# 对于给定仅由小写字母构成的字符串 s ，请你将其进行重新排列后得到 s' ，使其“完美长度”最大化 - 题解

### 比赛与标签
> **比赛**: undefined
> **标签**: Greedy, Implementation, Priority Queue
> **难度**: *2100

## 题目大意喵~
主人你好呀~！这道题是说，我们拿到一个只包含小写字母的字符串 `s`，需要我们像玩拼图一样，把它重新排列成一个新的字符串 `s'`。我们的目标是让这个新字符串 `s'` 的“完美长度”尽可能大，喵~

那什么是“完美长度” `m` 呢？听起来有点复杂，但让本喵来给你解释一下呐：

1.  首先，我们看新字符串 `s'` 所有长度为 `m` 的连续子串。
2.  如果对于其中 **每一个** 长度为 `m` 的子串，这个子串自身的所有 **非空子串** 都是独一无二、不重复的，那么 `m` 就是一个“完美长度”。

这个“子串的子串都独一无二”的条件其实是在暗示我们一件事哦！想一想，如果一个字符串里有重复的字符，比如 "aba"，那它长度为1的子串 "a" 就出现了两次，就不满足条件了对不对？所以，这个条件等价于：**`s'` 中所有长度为 `m` 的子串，都必须由 `m` 个完全不同的字符组成**。

再进一步思考，这个条件其实是对整个 `s'` 提出了一个要求：对于任意一个字符，比如 'a'，它在 `s'` 中每次出现的位置之间，至少要隔开 `m-1` 个其他的字符。也就是说，任意两个相同字符的下标之差的绝对值必须 `>= m`。

所以，我们的任务就是：找到最大的 `m`，使得我们可以将 `s` 重新排列，满足任意两个相同字符的距离都至少为 `m`，并输出这个 `m` 和排列后的字符串 `s'` 的说。

## 解题思路喵！
这道题要求我们找到最大的 `m`，这是一个很强的暗示哦！当一个问题要求最优解，并且解的范围是单调的时候（`m` 越大，满足条件越难），我们通常可以考虑二分答案或者从大到小枚举答案。

在这里，从大到小枚举 `m` 是一个非常直观和可爱的策略！`m` 的最大可能值是多少呢？一个长度为 `m` 的子串要有 `m` 个不同字符，那 `m` 最大也就是26啦（因为只有26个小写字母）。当然，如果字符串总长度 `n` 小于26，那 `m` 最大也只能是 `n`。所以我们可以从 `m = min(n, 26)` 开始，一个一个往下试。我们找到的第一个能成功构造出 `s'` 的 `m`，就一定是最大的 `m`！

那么，对于一个固定的 `m`，我们要怎么判断能不能构造出合法的 `s'`，并且如果可以的话，要怎么构造出来呢？

这就要用到我们最喜欢的**贪心**策略啦，喵~！

想象一下我们正在一个一个地填充 `s'` 的位置，从左到右。在每个位置上，我们应该放哪个字符呢？
一个很自然的想法是：**优先放置当前数量最多，并且可以放置的字符**。

为什么呢？因为数量越多的字符，就像是越烫手的山芋，它们对位置的要求最苛刻，需要被隔得远远的。我们尽早地把它们用掉一个，就能缓解后续的压力，为其他字符（包括它自己）的放置创造更多空间。

于是，我们的贪心策略就成型了：
1.  **统计频率**：首先，我们数一数原字符串 `s` 中每个字符（'a' 到 'z'）出现了多少次。
2.  **维护可用字符**：我们需要一个数据结构，能随时告诉我们当前“可用”的字符中，哪个数量最多。**优先队列（大顶堆）** 就是完美的选择！我们可以把 `(字符数量, 字符)` 这样的二元组放进去。
3.  **处理“冷却时间”**：我们放置了一个字符 `c` 在位置 `j` 之后，它就进入“冷却”了。在位置 `j+1, j+2, ..., j+m-1` 都不能再放 `c`。它要到位置 `j+m` 才能再次变为“可用”状态。
4.  **构造过程**：
    - 我们从 `j = 0` 到 `n-1` 遍历，填充 `s'` 的每一个位置。
    - 在第 `j` 步，我们先把所有“冷却”结束（即在 `j-m` 位置被使用）的字符重新放回优先队列。
    - 然后，从优先队列中取出堆顶元素，也就是当前数量最多的可用字符。
    - 如果优先队列是空的，说明在当前位置无字符可放，构造失败！这个 `m` 太大了，我们得试试更小的 `m`。
    - 如果成功取出字符 `c`，就把它放到 `s'` 的第 `j` 个位置。然后把它的数量减一。
    - 如果 `c` 的数量还没用完，就让它进入“冷却”，即安排它在 `j+m` 时刻重新变为可用。

代码里用了一个很巧妙的方式来实现“冷却”管理：用一个 `vector<vector<pii>> t`，`t[j]` 存的就是在第 `j` 步会“冷却”结束，可以重新加入优先队列的字符们。

只要这个过程能成功构造出一个长度为 `n` 的字符串，我们就找到了当前 `m` 的一个解。因为我们是从大到小枚举 `m` 的，所以这就是最终答案啦！立刻输出 `m` 和构造好的字符串，然后开心地结束程序，喵~

## 代码实现的说
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
#define int long long
#define all(x) x.begin(),x.end()
#define rall(x) x.rbegin(),x.rend()
#define pb push_back
#define pii pair<int,int>
using namespace std;
const int mod=998244353;
int gcd(int a,int b){return b?gcd(b,a%b):a;};
int qpw(int a,int b){int ans=1;while(b){if(b&1)ans=ans*a%mod;a=a*a%mod,b>>=1;}return ans;}
int inv(int x){return qpw(x,mod-2);}
void solve(){
    string s;cin>>s;
    int n=s.size();
    
    // 1. 统计每个字符的出现次数
    vector<int>cnt(26);
    for (int i=0;i<n;i++) {
        cnt[s[i]-'a']++;
    }

    // 2. 从大到小枚举可能的完美长度 m (在代码里是变量 i)
    // m 不会超过字符串长度 n，也不会超过 26
    for (int i=min(26ll,n);i>=1;i--) {
        // 每次尝试一个新的 m，都重置状态
        priority_queue<pii>q; // 优先队列，存储 (字符数量, 字符编号)，数量多的优先
        
        // t 是一个冷却管理器，t[j] 存储在第 j 步解除冷却的字符
        vector t(n+i+10,vector<pii>()); 
        
        // 初始时，所有字符在第 0 步都是可用的
        for (int j=0;j<26;j++) {
            if (cnt[j]) t[0].pb({cnt[j],j});
        }
        
        string ans; // 用来构造最终的字符串 s'
        
        // 3. 贪心构造字符串 s'
        for (int j=0;j<n;j++) {
            // 将在当前步骤 j 解除冷却的字符加入优先队列
            for (auto &son:t[j]) q.push(son);
            
            // 如果队列为空，说明没有可用的字符，当前 m 无法构造成功
            if (q.empty()) break;
            
            // 取出当前数量最多的可用字符
            auto top=q.top();
            q.pop();
            
            // 如果这个字符还有剩余 (数量 > 1)，则让它进入冷却
            // 它将在 j+i (即 j+m) 步之后才能再次使用
            if (top.first>1) t[j+i].pb({top.first-1,top.second});
            
            // 将选出的字符拼接到答案字符串中
            ans+=(char)('a'+top.second);
        }
        
        // 4. 检查是否构造成功
        // 如果构造出的字符串长度等于 n，说明我们成功了！
        if (ans.size()==n) {
            cout<<i<<'\n'; // i 就是我们找到的最大 m
            cout<<ans<<'\n';
            return; // 找到答案，直接结束程序
        }
    }
}
signed main(){
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    int _=1;
    while(_--)solve();
}
```

## 复杂度分析
- **时间复杂度**: O(C * n * log C) 的说。
  这里的 `C` 是字符集大小，也就是26。外层循环从 `m = min(n, 26)` 开始，最多执行 `C` 次。内层循环是构造字符串，执行 `n` 次。每次循环内部，最耗时的操作是优先队列的 `push` 和 `pop`，其复杂度为 `O(log C)`。所以总时间复杂度是 `O(C * n * log C)`。因为 `C` 是一个很小的常数（26），所以这个算法非常高效，近似于线性的 `O(n)` 呐。
- **空间复杂度**: O(n) 的说。
  我们用了一个 `cnt` 数组，大小为 `O(C)`。优先队列 `q` 的大小最多也是 `O(C)`。最占空间的是冷却管理器 `t`，它的总大小和字符串长度 `n` 相关，因为我们最多会向其中插入 `n` 个元素，所以它的空间复杂度是 `O(n)`。结果字符串 `ans` 也是 `O(n)`。所以总的空间复杂度是 `O(n)`。

## 知识点与总结喵~
这道题真是一次愉快的思维探险呢！让本喵来总结一下我们学到了什么吧：

1.  **问题转化**：解题的第一步，也是最关键的一步，是把题目中那个看起来很绕的“完美长度”定义，转化为一个清晰、可操作的数学约束——“任意两个相同字符的距离至少为 `m`”。学会简化和转化问题是成为算法高手的必备技能哦！

2.  **贪心与优先队列**：对于需要按“最优”顺序处理一系列元素的调度类问题，贪心 + 优先队列是一个非常经典的组合拳！我们总是优先处理“最紧急”或“最受限”的元素，这往往能导向全局最优解。

3.  **巧妙处理“冷却”**：本题的 `m` 距离限制，本质上是一种“冷却机制”。代码中使用 `vector<vector<pii>>` 来作为“事件调度表”，`t[j]` 存储在时间 `j` 发生的事件（字符变为可用），这是一个非常简洁且高效的实现方式，值得学习和借鉴！

4.  **枚举答案的策略**：当问题的答案具有单调性时，除了二分，从最优端开始枚举也是一种好方法。如果检查一个解的可行性（构造过程）与找到解是同一过程，那么从大到小（或从小到大）的枚举往往比二分更简单直接。

希望这篇题解能帮到主人哦！继续加油，享受每一道题带来的挑战和乐趣吧，喵~！