# 对于给定仅由小写字母构成的字符串 s ，请你将其进行重新排列后得到 s' ，使其“完美长度”最大化。 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供]

> **标签**: [标签未提供]

> **难度**: [难度未提供]

## 题目大意喵~

主人你好呀，喵~ ฅ(●´ω｀●)ฅ 这道题是要我们扮演一个厉害的字符串魔术师！

我们拿到一个只包含小写字母的字符串 `s`。我们的任务是把 `s` 里的字符重新排列，得到一个新的字符串 `s'`，目标是让这个 `s'` 的“完美长度” `m` 尽可能大。

那什么是“完美长度” `m` 呢？
定义是这样的：对于 `s'` 中所有长度为 `m` 的子串，比如 `t'_1, t'_2, ...`，我们要求每一个这样的子串 `t'_i` 自身的所有非空子串都是独一无二的。

这个定义听起来有点绕，对不对？别担心，猫娘帮你分析一下！一个字符串要让它所有的子串都独一无二，最关键的条件是什么呢？其实呀，只要这个字符串里的所有**字符**都是独一无二的，就一定能满足条件啦！比如 "abc"，它的子串 "a", "b", "c", "ab", "bc", "abc" 全都不一样。但如果是 "aba"，子串 "a" 就出现了两次，不满足条件。

所以，题目里那个复杂的定义，其实可以被我们简化成一个更可爱的要求，喵~：
**`s'` 的任意一个长度为 `m` 的子串，都必须由完全不同的字符组成。**

于是，我们的任务就变成：
找到一个最大的 `m`，使得我们可以重新排列 `s`，让新字符串 `s'` 中任意长度为 `m` 的连续字符段里都没有重复的字母。然后输出这个最大的 `m` 和构造出的 `s'`。

## 解题思路分析

好戏开场啦！让本猫娘带你一步步解开谜题，喵！

### 核心限制条件的转化

首先，我们来思考一下 "任意长度为 `m` 的子串都由不同字符组成" 这句话到底意味着什么。
假设我们已经构造好了字符串 `s'`。如果 `s'` 中有两个相同的字符，比如 `s'[i] == s'[j] == 'c'`，并且它们的距离 `j - i` (假设 `j > i`) 小于 `m`，那么我们肯定能找到一个长度为 `m` 的子串同时包含 `s'[i]` 和 `s'[j]`。比如从 `s'[j - m + 1]` 开始的子串，它的范围是 `[j - m + 1, j]`。因为 `j - i < m`，所以 `i > j - m`，这意味着 `i` 就在这个范围里！这样一来，这个子串就包含了两个 `'c'`，违反了我们的要求。

所以，为了满足条件，我们必须保证：**对于 `s'` 中任意一个字符，它的所有出现位置之间的距离都必须大于等于 `m`**。
这就是我们真正需要遵守的规则！

### 如何找到最大的 `m`？

我们想让 `m` 最大化。这个问题有一个非常棒的性质叫做**单调性**。如果一个 `m` 可以成功构造出 `s'`，那么任何比 `m` 小的 `m'` 肯定也可以呀（用为 `m` 构造的 `s'` 就行，距离都大于等于 `m` 了，自然也大于等于 `m'`）。

这种性质让我们想到了二分查找！但是，我们再想一想 `m` 的取值范围。一个长度为 `m` 的子串要有 `m` 个不同的字符，那 `m` 最大能是多少呢？最多也就是字母表的大小，26 嘛！而且 `m` 也不可能超过原字符串的长度 `n`。所以 `m` 的取值范围其实是 `[1, min(n, 26)]`。

这个范围非常小！我们完全不需要用二分查找这么高级的武器。直接从大到小暴力枚举 `m` 就好啦！我们从 `m = min(n, 26)` 开始尝试，一路递减到 1。第一个能成功构造出 `s'` 的 `m`，就是我们要找的最大值！

### 如何构造字符串 `s'`？（贪心大法好！）

现在的问题变成了：给定一个 `m`，我们如何判断能否构造出满足条件的 `s'` 呢？
这是一个构造性的问题，通常可以用**贪心**的思路来解决，喵~

我们要一个个地往新字符串 `s'` 里填字符。在每一步，我们应该填哪个字符呢？
想象一下，我们手里有一堆不同颜色的猫爪球（代表不同字符），数量也不同。我们要把它们排成一排，要求相同颜色的球之间至少要隔开 `m-1` 个其他球。

哪种颜色的球最“危险”，最难安排呢？当然是数量最多的那种！如果我们不优先使用数量最多的字符，它们可能会在后面堆积起来，导致我们没有足够的位置来分隔它们。

所以，我们的贪心策略是：**在每一步，优先选择当前可用的、并且剩余数量最多的字符进行放置。**

为了高效地实现这个“选择数量最多”的操作，**优先队列（大顶堆）** 就是我们的不二之选！

### 算法流程

结合上面的分析，我们的完整算法就出来啦：

1.  **外层循环**：从 `m = min(n, 26)` 递减到 1，对每个 `m` 进行尝试。
2.  **内层构造 (`check` 函数)**：
    a.  首先，统计原字符串 `s` 中每个字符的出现次数。
    b.  创建一个优先队列 `pq`，用来存放 `{字符数量, 字符}` 的二元组，并按数量从大到小排序。
    c.  为了处理 "冷却时间"（即一个字符放下去后，要等 `m` 步才能再放），我们用一个 "调度器"。这里可以用一个数组 `cooldown_schedule`，`cooldown_schedule[i]` 存放那些在第 `i` 步会“冷却”完毕、可以重新加入优先队列的字符。
    d.  初始化：在第 0 步，所有字符都是可用的。我们把所有 `(count, char)` 都放入 `cooldown_schedule[0]`。
    e.  开始构造 `s'`，循环 `i` 从 0 到 `n-1`：
        i.  将 `cooldown_schedule[i]` 中的所有字符重新加入优先队列 `pq`。
        ii. 如果 `pq` 空了，说明在当前位置无字符可放。构造失败，这个 `m` 不行，`break`。
        iii. 从 `pq` 队首取出一个数量最多的字符 `c`。
        iv. 将 `c` 追加到我们的答案字符串 `ans` 的末尾。
        v.  将 `c` 的数量减 1。如果数量还大于 0，就把它放入 `cooldown_schedule[i + m]`，表示它将在 `m` 步之后才能再次使用。
    f.  如果循环结束后，`ans` 的长度等于 `n`，说明我们成功为这个 `m` 找到了一个合法的排列！
3.  **找到答案**：由于我们是从大到小枚举 `m` 的，第一个成功的 `m` 就是最大值。此时，我们立刻打印 `m` 和构造出的字符串 `ans`，然后结束整个程序。

这个方法既能找到最大的 `m`，又能顺便把对应的 `s'` 构造出来，是不是很巧妙呀，喵~

## 代码实现

这是本猫娘根据上面的思路，精心为你重写的代码哦！注释超详细的，希望能帮到你，喵~

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>

// 定义一个结构体来存储字符和它的数量，方便放入优先队列
struct CharInfo {
    int count;
    char character;

    // 自定义比较运算符，让优先队列变成大顶堆
    bool operator<(const CharInfo& other) const {
        return count < other.count;
    }
};

void solve() {
    std::string s;
    std::cin >> s;
    int n = s.length();

    // 1. 统计原字符串中每个字符的频率
    std::vector<int> char_counts(26, 0);
    for (char c : s) {
        char_counts[c - 'a']++;
    }

    // 2. 从大到小枚举可能的完美长度 m
    for (int m = std::min(n, 26); m >= 1; --m) {
        std::priority_queue<CharInfo> pq;
        // 调度器，cooldown_schedule[i] 表示在第 i 步可以解禁的字符
        std::vector<std::vector<CharInfo>> cooldown_schedule(n + m);

        // 初始时，所有字符在第0步都可用
        for (int i = 0; i < 26; ++i) {
            if (char_counts[i] > 0) {
                cooldown_schedule[0].push_back({char_counts[i], (char)('a' + i)});
            }
        }

        std::string result_string = "";
        bool possible = true;

        // 3. 尝试构造长度为 n 的字符串
        for (int i = 0; i < n; ++i) {
            // 将当前步骤解禁的字符加入优先队列
            for (const auto& info : cooldown_schedule[i]) {
                pq.push(info);
            }

            // 如果优先队列为空，说明没有可用字符，构造失败
            if (pq.empty()) {
                possible = false;
                break;
            }

            // 贪心选择：取出频率最高的可用字符
            CharInfo current_char = pq.top();
            pq.pop();

            // 将该字符添加到结果字符串
            result_string += current_char.character;
            
            // 将用过的字符放入冷却调度器
            current_char.count--;
            if (current_char.count > 0) {
                // 它将在 i + m 步后解禁
                cooldown_schedule[i + m].push_back(current_char);
            }
        }

        // 4. 如果成功构造，则这就是最优解
        if (possible) {
            std::cout << m << std::endl;
            std::cout << result_string << std::endl;
            return; // 找到最大值，直接返回
        }
    }
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve();
    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(K \cdot N \log K)$
    这里的 `K` 是字符集的大小，也就是 26，`N` 是字符串的长度。
    外层循环最多执行 `K` 次（从 `min(N, 26)` 到 1）。在每次循环内部，我们要构造一个长度为 `N` 的字符串。构造过程中的每一步，都涉及到对优先队列的操作（`push` 和 `pop`），优先队列里最多有 `K` 个元素，所以操作的复杂度是 $O(\log K)$。因此，总的时间复杂度是 $O(K \cdot N \log K)$。

-   **空间复杂度**: $O(N + K)$
    我们需要一个大小为 26 的数组 `char_counts` 来计数的说，空间是 $O(K)$。优先队列 `pq` 最多也只存放 `K` 个元素。最占空间的是 `cooldown_schedule` 这个调度器，它的大小和 `N` 相关，是 $O(N+m)$，也就是 $O(N)$。所以总的空间复杂度是 $O(N + K)$。

## 知识点总结

这道题真有趣，让我们学会了好多东西呢，喵！

1.  **问题转化**: 这是解题的第一步，也是最重要的一步！把题目中复杂的定义（“所有非空子串两两不同”）转化为一个简单直观的约束（“任意相同字符间距至少为 `m`”），问题瞬间就清晰了。
2.  **贪心算法**: 面对构造类问题，贪心是一个非常强大的武器。本题的贪心策略是“优先处理最紧急的情况”，即优先放置数量最多的字符，这是一种很常见的贪心思路。
3.  **优先队列 (Priority Queue)**: 它是实现贪心策略的完美工具。当我们每次都需要从一堆动态变化的元素中找到“最值”（最大或最小）时，就应该想到它！
4.  **模拟与构造**: 整个解题过程其实是在模拟字符串的构造过程。通过一个巧妙的“冷却”机制，我们保证了构造出的字符串满足题目的所有条件。

希望这篇题解能帮到主人哦！如果还有问题，随时可以再来问猫娘，喵~ (づ｡◕‿‿◕｡)づ