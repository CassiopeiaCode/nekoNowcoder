# 题解 - $|\bigcap_{s \in T} F(s)|$

### 比赛与标签
> **比赛**: N/A (喵~ 主人给我的信息里没有包含比赛名称哦)

> **标签**: 字符串, 后缀自动机, KMP
 
> **难度**: N/A (难度评分也没有提供呢, 喵~)

## 题目大意喵~

一位名叫 Apollo 的小可爱和他的朋友 Avery 发现了一堆，也就是 `n` 个咒语！每个咒语都是由一个特定的字符串（我们叫它“循环节”）无限重复形成的。比如说，循环节是 `'abc'`，那么形成的咒语就是 `'abcabcabc...'` 这样一个无限长的字符串，是不是很神奇呀？

我们的任务是，计算出在这 `n` 个无限咒语中，所有咒语都共同拥有的、不重复的子串一共有多少个。题目给出的数学语言就是计算 $|\bigcap_{s \in T} F(s)|$ 的值，其中 $T$ 是所有咒语的集合，$F(s)$ 表示咒语 $s$ 的所有子串的集合。简单来说，就是求所有无限咒语的子串集合的交集的大小，喵~

**输入格式**:
第一行是一个整数 $n$，代表咒语的数量。
接下来 $n$ 行，每行一个字符串，代表生成无限咒语的循环节。

**输出格式**:
输出一个整数，表示所有咒语公共子串的数量。
有一个特殊情况哦：如果所有的咒语其实都是同一种（比如 `'ab'` 和 `'abab'` 都会生成 `'ababab...'`），那么公共子串有无限多个，这时需要输出 `-1`。

## 解题思路分析

这道题看起来好复杂呀，要处理无限长的字符串！但是不要怕，猫娘我来带你一步步拆解它，很快就能找到思路的，喵~

#### 第一步：从无限到有限

无限长的字符串我们是没法直接处理的。但仔细想想，任何一个子串，它的长度总是有限的吧？一个由循环节 `p` 生成的无限咒语 `ppp...`，它的任何子串，要么完全包含在 `p` 内部，要么会跨越两个 `p` 的边界。

举个例子，如果循环节是 `p = 'abac'`，无限咒语就是 `'abacabacabac...'`。
- 子串 `'bac'` 完全在 `p` 里面。
- 子串 `'acab'` 跨越了第一个 `p` 和第二个 `p` 的边界。

但是，任何跨越边界的子串，都一定能被 `p` 重复两次，也就是 `pp` (`'abacabac'`) 所包含！所以，一个无限咒语的所有子串集合，其实就等价于它的循环节 `p` 重复两次（`pp`）后形成的新字符串的子串集合。这样，我们就成功地把无限问题转化为了有限问题，耶！

#### 第二步：咒语的“身份证”——标准化处理

不同的循环节可能会生成同一个无限咒urry。
- 比如 `'ab'` 和 `'abab'` 都会生成 `'ababab...'`。
- 再比如 `'bca'` 和 `'acb'` 都会生成 `'bcabcabc...'`。

为了公平地比较它们，我们需要给每个咒语一个独一无二的“身份证”。这个过程分两步：

1.  **找到最小循环节**: 像 `'abab'`，它的最小循环节其实是 `'ab'`。我们可以用 KMP 算法的 `next` 数组（或叫 `pi` 数组）来找到它。对于一个长度为 $L$ 的字符串 $s$，如果 $L$ 能被 $L - \text{next}[L-1]$ 整除，那么最小循环节的长度就是 $L - \text{next}[L-1]$。
2.  **找到字典序最小的表示**: 对于一个循环节，比如 `'bca'`，它的循环同构串有 `'bca'`, `'cab'`, `'abc'`。为了统一，我们选择字典序最小的那个 `'abc'` 作为它的标准表示。这个可以通过“最小表示法”算法（比如 two-pointers 方法）找到。

经过这两步，每个无限咒语就有了一个唯一的、标准化的循环节。我们对所有输入的 $n$ 个字符串都进行这样的标准化处理，然后去重。如果去重后只剩下一种咒语，那就说明所有咒语都一样，答案是 `-1`。

#### 第三. 三步：广义后缀自动机 (GSA) 出场！

现在我们有了一堆（去重后有 $k$ 个）标准化的循环节 $p_1, p_2, \dots, p_k$。问题变成了：求字符串集合 $\{p_1p_1, p_2p_2, \dots, p_kp_k\}$ 的公共子串数量。

这可是后缀自动机（SAM）的拿手好戏！当处理多个字符串的子串问题时，我们通常会用到它的推广形式——广义后缀自动机（GSA）。

构建 GSA 的一个简单直观的方法是：
1.  创建一个空的 SAM。
2.  对于第一个字符串 $p_1p_1$，像平常一样把它所有字符依次插入 SAM。
3.  对于第二个字符串 $p_2p_2$，**将 SAM 的 `last` 指针重置回根节点**，然后依次插入 $p_2p_2$ 的所有字符。
4.  对所有 $k$ 个字符串重复此过程。

这样，我们就得到了一个包含了所有 $k$ 个字符串全部子串信息的 GSA。

#### 第四步：统计公共子串

GSA 建好了，怎么数公共子串呢？
一个状态（节点）`u` 在 SAM/GSA 中代表了一个或多个子串。这些子串的长度范围是 $(\text{len}[\text{link}[u]], \text{len}[u]]$。

我们需要找出哪些状态代表的子串是所有 $k$ 个源字符串都拥有的。
我们可以这样做：
1.  对每个源字符串 $p_i p_i$ ($i=1 \dots k$)，在 GSA 上走一遍。
2.  在行走过程中，所有经过的状态 `v`，以及从 `v` 沿着 `link` 指针（父指针）向上跳直到根节点路径上的所有状态，都说明它们代表的子串是存在于 $p_i p_i$ 中的。
3.  我们用一个计数器 `count[u]` 记录状态 `u` 被多少个不同的源字符串所“覆盖”。为了避免在同一个字符串中重复计数，每次处理一个新的源字符串时，可以用一个 `visited` 数组来标记。
4.  当所有字符串都处理完后，我们遍历 GSA 的所有状态。如果一个状态 `u` 的 `count[u]` 等于 $k$，就说明它代表的子串们是所有 $k$ 个咒语的公共子串！
5.  这个状态 `u` 贡献的公共子串数量就是它所代表的子串个数，即 $\text{len}[u] - \text{len}[\text{link}[u]]$。
6.  把所有满足 `count[u] == k` 的状态的贡献加起来，就是最终的答案啦！

总结一下流程，就是： **标准化 -> 建 GSA -> 标记计数 -> 汇总答案**。是不是清晰多啦？喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码哦~ 注释很详细，希望能帮到你，喵！

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include <algorithm>
#include <map>

using namespace std;

// KMP算法，计算next数组，用于找最小循环节
vector<int> calculate_pi(const string& s) {
    int n = s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        if (s[i] == s[j]) {
            j++;
        }
        pi[i] = j;
    }
    return pi;
}

// 找到字符串的最小循环节
string get_minimal_period(const string& s) {
    if (s.empty()) return "";
    vector<int> pi = calculate_pi(s);
    int len = s.length();
    int period_len = len - pi[len - 1];
    if (len % period_len == 0) {
        return s.substr(0, period_len);
    }
    return s;
}

// 找到一个字符串的字典序最小的循环表示
string get_min_lex_representation(const string& s) {
    int n = s.length();
    if (n == 0) return "";
    int i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n) {
        if (s[(i + k) % n] == s[(j + k) % n]) {
            k++;
        } else {
            if (s[(i + k) % n] > s[(j + k) % n]) {
                i = i + k + 1;
            } else {
                j = j + k + 1;
            }
            if (i == j) j++;
            k = 0;
        }
    }
    int start_pos = min(i, j);
    return s.substr(start_pos) + s.substr(0, start_pos);
}

// 后缀自动机 (SAM) 的状态节点
struct SAM_State {
    int len, link;
    map<char, int> next;
};

vector<SAM_State> sam;
int sam_last;
int sam_size;

void sam_init() {
    sam.clear();
    sam.resize(2); // Start with 2 to avoid resizing issues, index 0 is dummy, 1 is root
    sam_size = 2;
    sam[1].len = 0;
    sam[1].link = 0; // link to dummy node 0
    sam_last = 1;
}

void sam_extend(char c) {
    int cur = sam_size++;
    sam.resize(sam_size);
    sam[cur].len = sam[sam_last].len + 1;
    
    int p = sam_last;
    while (p != 0 && sam[p].next.find(c) == sam[p].next.end()) {
        sam[p].next[c] = cur;
        p = sam[p].link;
    }

    if (p == 0) {
        sam[cur].link = 1;
    } else {
        int q = sam[p].next[c];
        if (sam[q].len == sam[p].len + 1) {
            sam[cur].link = q;
        } else {
            int clone = sam_size++;
            sam.resize(sam_size);
            sam[clone].len = sam[p].len + 1;
            sam[clone].next = sam[q].next;
            sam[clone].link = sam[q].link;
            while (p != 0 && sam[p].next[c] == q) {
                sam[p].next[c] = clone;
                p = sam[p].link;
            }
            sam[q].link = clone;
            sam[cur].link = clone;
        }
    }
    sam_last = cur;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<string> normalized_strings;
    for (int i = 0; i < n; ++i) {
        string s;
        cin >> s;
        string period = get_minimal_period(s);
        normalized_strings.push_back(get_min_lex_representation(period));
    }

    sort(normalized_strings.begin(), normalized_strings.end());
    normalized_strings.erase(unique(normalized_strings.begin(), normalized_strings.end()), normalized_strings.end());

    if (normalized_strings.size() <= 1) {
        cout << -1 << endl;
        return 0;
    }

    // 构建广义后缀自动机
    sam_init();
    for (const string& s : normalized_strings) {
        sam_last = 1; // 每次处理新字符串都从根开始
        string doubled_s = s + s;
        for (char c : doubled_s) {
            sam_extend(c);
        }
    }

    // 统计出现在所有字符串中的状态
    vector<int> counts(sam_size, 0);
    vector<int> visited_by_string(sam_size, 0);

    int string_id = 0;
    for (const string& s : normalized_strings) {
        string_id++;
        int p = 1;
        string doubled_s = s + s;
        for (char c : doubled_s) {
            p = sam[p].next[c];
            int cur = p;
            while (cur != 0 && visited_by_string[cur] != string_id) {
                visited_by_string[cur] = string_id;
                counts[cur]++;
                cur = sam[cur].link;
            }
        }
    }

    // 计算最终答案
    long long total_common_substrings = 0;
    int num_unique_strings = normalized_strings.size();
    for (int i = 2; i < sam_size; ++i) { // 从2开始，跳过dummy和root
        if (counts[i] == num_unique_strings) {
            total_common_substrings += (long long)sam[i].len - sam[sam[i].link].len;
        }
    }

    cout << total_common_substrings << endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(\sum |s_i|)$
    喵~ 让我来分析一下。设所有输入字符串的总长度为 $L$。
    1.  **标准化**: 对每个字符串 $s_i$，计算KMP的`pi`数组和最小表示法都是线性的，即 $O(|s_i|)$。所以总的标准化时间是 $O(L)$。
    2.  **构建GSA**: 我们对每个标准化后的循环节 $p_i$ 的两倍长度（$p_i p_i$）进行构建。设所有标准化后字符串的总长为 $L_{norm}$，那么GSA的构建时间是 $O(\sum |p_i p_i|) = O(L_{norm})$。因为 $L_{norm} \le L$，所以这部分也是 $O(L)$。
    3.  **计数**: 我们遍历每个 $p_i p_i$，并在GSA上行走。每次行走后会沿着`link`链向上跳。整个过程的总复杂度也是和总长度成正比的，即 $O(L_{norm})$。
    所以，总的时间复杂度是 $O(L)$ 的说！

-   **空间复杂度**: $O(\sum |s_i|)$
    1.  **SAM**: 后缀自动机的状态数最多是总插入字符数的两倍，转移数也是线性的。所以SAM本身的空间是 $O(L_{norm})$。
    2.  **辅助数组**: `counts` 和 `visited_by_string` 数组的大小都和SAM的状态数相同。
    因此，总的空间复杂度也是 $O(L)$，喵~

## 知识点总结

这道题真是个字符串算法的绝佳练习！我们用到了：

1.  **KMP算法**: 不仅仅是用于字符串匹配，它强大的`next`/`pi`数组能帮我们分析字符串的周期性，找到最小循环节。
2.  **最小表示法**: 处理循环同构字符串问题的标准武器，能将一类问题简化为一种标准形式。
3.  **后缀自动机 (SAM)**: 处理各种子串问题的神器！它能在线性时间内表示一个字符串的所有子串。
4.  **广义后缀自动机 (GSA)**: SAM在多字符串问题上的自然延伸。通过巧妙的构建（每次重置`last`指针），我们可以把多个字符串的信息压缩到一个自动机里。
5.  **`link`树 (父指针树)**: SAM中 `link` 指针形成的树状结构非常重要。一个节点的`link`祖先们代表了它所表示子串的后缀。利用这个性质，我们可以高效地进行状态的标记和统计。

通过这道题，我们把好几个重要的字符串知识点串联了起来，解决了一个看似棘手的问题。是不是很有成就感呀？继续加油哦，你超棒的！喵~