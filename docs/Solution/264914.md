# Crying 正在学习爬山算法 - 题解

### 比赛与标签
> **比赛**: 未提供

> **标签**: 未提供

> **难度**: 未提供

## 题目大意喵~

主人你好呀，这道题是关于一个叫 Crying 的朋友学习爬山算法的故事，喵~

事情是这样哒：我们有一个定义在整数区间 $[1, n]$ 上的函数 $f(x)$。我们需要找到所有“极值点”的数量。

一个点 $x$ 被称为“极值点”，需要满足两个条件哦：
1.  $x$ 必须在 $[2, n-1]$ 这个区间里。也就是说，它不能是第一个点，也不能是最后一个点，得是个“中间点”才行呐。
2.  它的函数值 $f(x)$ 必须比它左边邻居 $f(x-1)$ 和右边邻居 $f(x+1)$ 的函数值都要小。用数学语言来说就是：$f(x-1) > f(x) < f(x+1)$。

这就像一个小山谷一样，两边高，中间低，猫娘最喜欢在这种地方打滚了，嘻嘻~

**输入**:
- 第一行是一个整数 $n$，表示函数的定义域有 $n$ 个点。
- 第二行有 $n$ 个整数，分别代表 $f(1), f(2), \dots, f(n)$ 的值。

**输出**:
- 一个整数，表示满足条件的“极值点”的总数。

## 解题思路分析

这道题其实非常直白可爱，就像一只伸懒腰的小猫咪，逻辑很顺畅的说！我们只需要按照题目给出的定义，去检查每一个可能的点就好啦。

#### 1. 谁有资格成为极值点？

题目明确告诉我们啦，只有在 $[2, n-1]$ 范围内的点 $x$ 才有资格成为候选者。为什么呢？
- 对于 $x=1$，它没有左边的邻居 $f(0)$，没法比较呀。
- 对于 $x=n$，它没有右边的邻居 $f(n+1)$，也没法比较呢。
所以，我们只需要关注那些有左右邻居的“中间”点就可以啦！

如果 $n$ 小于 3（比如 $n=1$ 或 $n=2$），那就连一个“中间”点都没有，极值点的数量肯定是 0 啦，喵~

#### 2. 如何判断一个点是不是极值点？

对于每一个候选点 $x$（从 $2$ 到 $n-1$），我们只要检查它是否满足 $f(x-1) > f(x) < f(x+1)$ 这个条件就好。
- 如果满足，恭喜！我们找到了一个可爱的“小山谷”，计数器加一！
- 如果不满足，那就继续去看下一个点咯。

#### 3. 数组下标的小陷阱

在写代码的时候，我们通常用数组或者 `vector` 来存储 $f(1), f(2), \dots, f(n)$ 的值。要注意，C++ 和很多语言的数组下标都是从 0 开始的。
- $f(1)$ 存储在 `f[0]`
- $f(2)$ 存储在 `f[1]`
- ...
- $f(x)$ 就存储在 `f[x-1]`

所以，我们要检查的条件 $f(x-1) > f(x) < f(x+1)$，在代码里就要转换成对数组元素的比较：
`f[x-2] > f[x-1] < f[x]`

我们的循环变量可以直接遍历 $x$ 从 $2$ 到 $n-1$。

#### 举个栗子！

假设我们拿到的函数值是 `[5, 2, 8, 4, 6]`，这里 $n=5$。
我们需要检查的 $x$ 的范围是 $[2, 4]$。

1.  **当 $x=2$ 时**:
    - 我们要比较 $f(1), f(2), f(3)$。它们的值分别是 5, 2, 8。
    - 检查条件：$5 > 2 < 8$。咦，成立！这是一个极值点！我们的计数器 `count` 变成 1。

2.  **当 $x=3$ 时**:
    - 我们要比较 $f(2), f(3), f(4)$。它们的值分别是 2, 8, 4。
    - 检查条件：$2 > 8 < 4$。哦哦，$2 > 8$ 是错的。所以 $x=3$ 不是极值点。

3.  **当 $x=4$ 时**:
    - 我们要比较 $f(3), f(4), f(5)$。它们的值分别是 8, 4, 6。
    - 检查条件：$8 > 4 < 6$。成立！又找到一个！我们的计数器 `count` 变成 2。

遍历结束，我们一共找到了 2 个极值点。所以答案就是 2，喵~

总结一下，我们的算法就是：
1.  读入 $n$ 和所有的函数值。
2.  创建一个计数器 `count`，初始化为 0。
3.  写一个循环，遍历所有可能的 $x$（从 $2$ 到 $n-1$）。
4.  在循环中，用数组下标检查 `f[x-2] > f[x-1] < f[x]` 是否成立。
5.  如果成立，`count` 加 1。
6.  循环结束后，输出 `count` 的值。

是不是很简单呢？下面就让本猫娘来把它变成代码吧！

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <numeric> // 虽然这个题目用不到，但包含常用头文件是个好习惯喵

// 为了让输入输出更快一点，喵~
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    fast_io();

    int n;
    std::cin >> n;

    // 如果 n 小于 3，不可能有符合条件的极值点，直接输出 0 跑路~
    if (n < 3) {
        std::cout << 0 << std::endl;
        return 0;
    }

    // 使用 vector 来存储函数 f(x) 的值，大小为 n
    std::vector<int> f_values(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> f_values[i];
    }

    int extreme_points_count = 0; // 用来计数的变量，爪子已经准备好啦

    // 题目定义极值点 x 的范围是 [2, n-1]
    // 我们直接遍历这个范围内的 x
    // 记住哦, f(x) 对应数组中的 f_values[x-1]
    for (int x = 2; x <= n - 1; ++x) {
        // 条件是 f(x-1) > f(x) < f(x+1)
        // 转换成0-based的数组下标就是:
        // f_values[x-2] > f_values[x-1] < f_values[x]
        if (f_values[x - 2] > f_values[x - 1] && f_values[x - 1] < f_values[x]) {
            extreme_points_count++; // 找到一个！计数器+1！
        }
    }

    std::cout << extreme_points_count << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(n)$
  我们只需要读取一遍输入数据，这需要 $O(n)$ 的时间。然后，我们用一个循环来检查每个可能的极值点。这个循环从 $x=2$ 运行到 $x=n-1$，总共运行了 $n-2$ 次。所以，总的时间复杂度是线性的，也就是 $O(n)$，非常高效的说！

- **空间复杂度**: $O(n)$
  我们需要一个 `vector` 或者数组来存储 $n$ 个函数值，所以占用了 $O(n)$ 的额外空间。除此之外，我们只用了几个简单的变量，它们的空间是常数级别的。所以总的空间复杂度就是 $O(n)$ 啦。

## 知识点总结

这道题虽然简单，但也能让我们巩固一些重要的基础知识呢，喵~

1.  **读懂题意**: 编程的第一步永远是准确理解题目要求！特别是对“极值点”的定义，包括它的取值范围和判断条件。
2.  **循环遍历**: 这是解决很多问题的基础。通过一个 `for` 循环，我们可以系统地检查所有可能性。
3.  **数组下标转换**: 很多题目描述是基于 1-based 索引的（像 $f(1), f(2)$），而代码实现通常是 0-based 索引（像 `array[0], array[1]`）。正确地进行转换是避免“off-by-one”错误的-关键，一定要小心哦！
4.  **边界条件处理**: 考虑像 $n<3$ 这样的特殊情况，可以让我们的代码更健壮、更可靠。

希望这篇题解能帮到你，如果还有其他问题，随时可以来找本猫娘哦！一起学习，一起进步，喵~！