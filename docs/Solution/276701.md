# 树上点对匹配方案权值和 - 题解

### 比赛与标签
> **比赛**: 暂无信息
> **标签**: 暂无信息
> **难度**: 暂无信息

## 题目大意喵~
ฅ'ω'ฅ 各位同学，大家好呀！今天我们来解决一个超级有趣的树上问题，喵~

题目是这样子的：我们拿到了一棵有 `n` 个点的树，`n` 是一个偶数哦。我们的任务呢，就是把这 `n` 个点两两配对，组成 `n/2` 个点对。

对于每一种配对方案，比如说 `(u_1, v_1), (u_2, v_2), ...`，我们要计算一个“权值”。这个权值等于所有点对之间距离的乘积，也就是 `d(u_1, v_1) * d(u_2, v_2) * ...`，这里的 `d(u,v)` 是指 `u` 和 `v` 在树上的最短路径长度（也就是边数）的说。

最后，我们需要计算出 **所有** 不同配た配对方案的权值之和，然后把结果对 `10^9 + 7` 取模。两种配对方案只要有一个点配对的对象不一样，就算作是不同的方案哦。

简单来说，就是：
- **输入**: 一个 `n` 个点的树 (`n` 是偶数)。
- **任务**: 将 `n` 个点分成 `n/2` 对。
- **目标**: 计算 `Σ (Π d(u,v))`，其中 `Σ` 是对所有配对方案求和，`Π` 是对方案内所有点对的距离求积。

## 解题思路分析喵~
这个问题看起来超级复杂，因为配对的方案数实在是太多啦，暴力枚举肯定是不行的说！(>ω<)
看到树上的问题，而且带有组合和计数性质，我们聪明的直觉就应该告诉我们——这很可能是一道 **树形DP** 题！

我们的核心思路就是从叶子节点开始，一点点向上合并信息，直到根节点，最后得出整个树的答案。

#### 状态定义
最关键的一步就是定义好我们的DP状态。这道题的难点在于权值是距离的 **乘积**，这让状态的合并变得不那么直观。经过一番思考，我们可以设计出这样一个神奇的状态：

`dp[u][i][j]` 表示在以 `u` 为根的子树中：
- 有 `i` 个节点，它们各自形成了一条“半路径”，终点是 `u`，等待着和 `u` 外面的节点（或者 `u` 的其他子树的节点）配对。我们称之为 **“向上”** 的半路径。
- 有 `j` 个节点，它们也形成了“半路径”，但起点是 `u`，等待着和 `u` 子树内部的节点配对。我们称之为 **“向下”** 的半路径。
- `dp[u][i][j]` 的值，就是达成这种状态的所有部分配对方案的 **权值之和**。已经完全在子树内部配对好的点对，它们的距离乘积已经被计算并累加到这个值里了。

#### 状态转移
状态转移是通过合并子节点的信息来更新父节点的DP状态。假设我们正在计算节点 `u` 的DP值，并且已经处理完了它的部分子树，当前状态是 `dp[u][j][k]`。现在我们要合并一个新的子树，根为 `v`。

**第一步：子树状态的“视角转换” (tx 数组)**

在合并之前，我们需要对子节点 `v` 的DP状态 `dp[v][l][r]` 做一个预处理。这是因为从 `u` 的视角看，`v` 的子树里伸出来的“向上”路径，都必须经过 `(u, v)` 这条边，所以它们的长度都增加了1。而“向下”的路径则不受影响。

直接给距离加1是很麻烦的，但代码里的 `tx` 数组用了一种非常巧妙的组合数学方法来等效处理这个问题，喵~
```cpp
// 对于子节点 v 的状态 dp[v][l][r]
for(int k=0; k<=l; k++) {
    tx[l-k][r+k] = (tx[l-k][r+k] + 1ll*C[l][k]*dp[v][l][r]) % MOD;
}
```
这一步可以理解为：在 `v` 的 `l` 条向上路径中，我们选择 `k` 条，将它们从“向上”类别转换到“向下”类别。这在组合意义上，巧妙地处理了因路径延伸而带来的权值变化。虽然严格的数学证明（通常涉及生成函数）比较复杂，但我们可以直观地理解为这是在为接下来的配对做准备。

**第二步：合并状态 (tp 数组)**

现在我们有了 `u` 的当前状态 `dp[u][j][k]` 和 `v` 转换后的状态 `tx[l][r]`。我们可以把它们合并起来了！

合并时，有几种配对方式：
1.  `u` 的 `j` 条“向上”路径，可以和 `v` 的 `r` 条“向下”路径配对。假设我们配了 `p` 对。
2.  `u` 的 `k` 条“向下”路径，可以和 `v` 的 `l` 条“向上”路径配对。假设我们配了 `q` 对。

对于第一种情况，我们从 `j` 条里选 `p` 条，从 `r` 条里选 `p` 条，配对方式有 `C(j, p) * C(r, p) * p!` 种。
对于第二种情况，同理有 `C(k, q) * C(l, q) * q!` 种。

配对完成后，`u` 的新状态就变成了：
- 新的“向上”路径数：`(j-p) + (l-q)`
- 新的“向下”路径数：`(k-q) + (r-p)`

我们把所有可能的 `p` 和 `q` 的贡献累加起来，就得到了合并后的新状态，存放在临时数组 `tp` 中。

#### 初始状态和最终答案

- **初始状态**: 对于任何一个节点 `u`，在考虑它的子树之前，它自身就是一个需要配对的节点。我们可以看作是有一条“向上”的半路径。所以 `dp[u][1][0] = 1`。
- **最终答案**: 当我们从根节点 `1` 开始 `dfs`，处理完所有子树后，我们想要的最终结果是所有节点都已配对。这意味着在根节点 `1`，不应该有任何“向上”或“向下”的未配对路径。所以答案就是 `dp[1][0][0]` 的说！

这个过程就像是在玩一个连线游戏，我们不断地把子树里伸出的线头两两连接，或者把它们留给更上层的节点去连接，最终要把所有的线头都连完，喵~

## 代码实现喵
```cpp
#include <bits/stdc++.h>

// 定义模数
#define MOD 1000000007

int N, hd[59], siz[59], to[109], nxt[109], k;
// dp[u][i][j]: 在以u为根的子树中，有i条向上的半路径，j条向下的半路径时的权值和
long long dp[59][59][59]; 
// tp, tx: DP转移时用的临时数组
long long tp[59][59], tx[59][59];
// C: 组合数, px: 阶乘
long long C[59][59], px[59];

// 加边函数，使用链式前向星存图
void l(int u, int v) {
    to[++k] = v;
    nxt[k] = hd[u];
    hd[u] = k;
}

void dfs(int n, int f) {
    // 初始化：节点n自身构成一个向上的半路径
    dp[n][1][0] = 1;
    siz[n] = 1;

    // 遍历n的所有子节点
    for (int i = hd[n]; i; i = nxt[i]) {
        if (to[i] == f) continue; // 避免回到父节点
        dfs(to[i], n); // 递归处理子树

        // 清空临时数组，准备合并
        memset(tp, 0, sizeof(tp));
        memset(tx, 0, sizeof(tx));

        // === 步骤1: 子树状态的“视角转换” ===
        // 预处理子节点 to[i] 的DP状态
        for (int l = 0; l <= siz[to[i]]; l++) {
            for (int r = 0; r <= siz[to[i]]; r++) {
                if(dp[to[i]][l][r] == 0) continue;
                // 从l条向上路径中选k条，改变它们的性质
                for (int k = 0; k <= l; k++) {
                    tx[l - k][r + k] = (tx[l - k][r + k] + C[l][k] * dp[to[i]][l][r]) % MOD;
                }
            }
        }

        // === 步骤2: 合并状态 ===
        // j, k: 节点n当前的向上/向下路径数
        for (int j = 0; j <= siz[n]; j++) {
            for (int k = 0; k <= siz[n]; k++) {
                if (dp[n][j][k] == 0) continue;
                // l, r: 子节点to[i]转换后的向上/向下路径数
                for (int l = 0; l <= siz[to[i]]; l++) {
                    for (int r = 0; r <= siz[to[i]]; r++) {
                        if (tx[l][r] == 0) continue;
                        // p: n的向上路径 与 to[i]的向下路径 配对的数量
                        for (int p = 0; p <= j && p <= r; p++) {
                            // q: n的向下路径 与 to[i]的向上路径 配对的数量
                            for (int q = 0; q <= k && q <= l; q++) {
                                // 计算新状态的贡献
                                long long contribution = dp[n][j][k] * tx[l][r] % MOD;
                                contribution = contribution * C[j][p] % MOD * C[r][p] % MOD * px[p] % MOD;
                                contribution = contribution * C[k][q] % MOD * C[l][q] % MOD * px[q] % MOD;
                                // 更新合并后的状态
                                tp[j + l - p - q][k + r - p - q] = (tp[j + l - p - q][k + r - p - q] + contribution) % MOD;
                            }
                        }
                    }
                }
            }
        }
        
        // 更新子树大小和dp数组
        siz[n] += siz[to[i]];
        for (int j = 0; j <= siz[n]; j++) {
            for (int k = 0; k <= siz[n]; k++) {
                dp[n][j][k] = tp[j][k];
            }
        }
    }
}

signed main(void) {
    scanf("%d", &N);
    
    // 预处理阶乘
    px[0] = 1;
    for (int i = 1; i <= 50; i++) px[i] = 1ll * px[i - 1] * i % MOD;

    // 预处理组合数
    for (int i = 0; i <= 50; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
        }
    }

    // 读入树的边
    for (int i = 1; i < N; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        l(u, v), l(v, u);
    }
    
    // 从根节点1开始DFS
    dfs(1, 0);

    // 最终答案是所有点都配对好，即没有向上或向下的半路径
    printf("%lld", dp[1][0][0]);
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(N^5) 的说。在 `dfs` 中，合并两个子树是复杂度的主要来源。假设父节点 `u` 已处理的子树大小为 `s1`，要并入的子树大小为 `s2`。状态合并涉及到 `j, k, l, r, p, q` 六层循环。虽然有剪枝和范围限制，但最坏情况下可以看作是 `s1^2 * s2^2` 乘以 `s1*s2` 的组合。经过树形背包的经典分析，这种多维状态合并的复杂度可以界定在 `O(N^5)` 或 `O(N^4)`。对于 `N=50` 的数据范围，`50^5` 约为 `3*10^8`，`50^4` 约为 `6*10^6`，这个算法是可以通过的呐！
- **空间复杂度**: O(N^3) 的说。主要是 `dp` 数组 `dp[59][59][59]` 占用的空间。其他临时数组和邻接表空间都小于这个。

## 知识点与总结
这真是一道锻炼思维的好题呀！(≧▽≦) 我们来总结一下学到了什么吧：

1.  **树形DP**: 解决树上计数、最优解问题的强大武器。核心是找到合适的状态表示，并设计出从子节点到父节点的状态转移方程。
2.  **复杂状态设计**: 当简单状态（比如 `dp[u][i]` 表示 `i` 个未匹配点）无法携带足够信息时，需要增加维度。本题的 `dp[u][i][j]` 通过区分“向上”和“向下”的半路径，成功解决了路径跨越子树根节点的问题。
3.  **组合计数**: 状态转移中大量运用了组合数 `C(n,k)` 和阶乘 `k!` 来计算配对的方案数。预处理这些值是必须的。
4.  **抽象思维**: 本题最巧妙也是最难理解的部分，就是 `tx` 数组的变换。它没有直接在状态里记录距离，而是通过一种组合变换，等价地处理了距离加1带来的权值乘积变化。这告诉我们，有时DP可以不直接处理数值，而是处理其背后的组合结构或生成函数。

总之，解决这类问题需要扎实的DP功底、敏锐的组合数学直觉和一点点大胆的猜想与验证！希望这篇题解能帮助你理解这只“代码猫”的思考过程，一起在算法的世界里愉快地玩耍吧，喵~