# 给定偶数 n，有一棵 n 个点的树 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供]

> **标签**: 树形DP, 组合计数

> **难度**: *2700

## 题目大意喵~

主人你好呀，这道题是这样的喵~

我们拿到了一棵有 $n$ 个节点的树，这里的 $n$ 是一个偶数。我们需要把这 $n$ 个点两两配对，形成 $n/2$ 个点对。

对于每一个点对 $(u, v)$，它们之间在树上的简单路径长度（也就是边数）我们记作 $d(u,v)$。一个完整的配对方案，比如 $(u_1, v_1), (u_2, v_2), \dots, (u_{n/2}, v_{n/2})$，它的“权值”被定义为所有点对距离的乘积：
$$
W = d(u_1,v_1) \times d(u_2,v_2) \times \dots \times d(u_{\frac{n}{2}},v_{\frac{n}{2}})
$$
我们的任务，就是计算出所有**不同**的配对方案的权值之和，最后结果对 $10^9+7$ 取模。只要有一个点在两种方案里配对的伙伴不一样，这两种方案就被认为是不同的哦！

## 解题思路分析

喵~ 这道题第一眼看上去，要在树上配对，还要计算所有方案的距离乘积之和，感觉非常复杂呢！特别是这个“乘积之和”的形式，通常都很难直接处理，不像“和的乘积”或者“和的和”那么好拆分。

直接去思考每对点的距离怎么算，然后把它们乘起来，再对所有方案求和，会把我们的脑筋绕成一团毛线球的！所以，我们需要一种更聪明的办法，这通常就指向了树形DP，呐。

但是，一个常规的树形DP状态要怎么设计呢？如果我们的状态要记录下每个未配对点到当前子树根节点的距离，那状态就太复杂了，根本存不下。

这道题的解法其实涉及到一个非常巧妙的转化，直接从题目推导状态会有点困难喵~ 所以，让我们换个思路，一起来分析这道题的正解思路，看看它是如何魔法般解决这个问题的。我们会发现，它实际上在计算一个组合计数问题，而这个组合问题的答案，神奇地就等于我们想要的权值之和！

### 核心思想：组合计数DP

我们不直接在DP状态里记录距离，而是记录一些“连接状态”的数量。

我们任意指定一个根节点（比如1号点），然后进行深度优先搜索来构建DP。

#### DP状态定义

`dp[u][i][j]` 表示在以 `u` 为根的子树中：
1.  子树内的节点已经进行了一些配对，这些配对完全在子树内部完成。
2.  还剩下 `i` 个节点没有配对，它们形成了 `i` 条路径的起点，这些路径都将从 `u` **向上**延伸，去和子树外的节点配对。我们称之为“**上行路径**”。
3.  还有 `j` 条路径，它们的起点在子树**外部**，通过 `u` 节点**向下**进入 `u` 的子树，并在子树内的某个节点结束。我们称之为“**下行路径**”。
4.  `dp[u][i][j]` 的值，就是达成这种状态的**方案数**。

你可能会问，喵？距离去哪儿了？别急，这个神奇的DP计算出的方案数，最后就对应了我们要求的权值和。这背后有深刻的数学原理（和生成函数有关），但我们只需要理解并相信这个DP的构造过程就可以解题啦！

#### DP转移过程

我们用DFS后序遍历的方式，当一个节点 `u` 的所有子节点都计算完毕后，我们来计算 `u` 的DP值。

1.  **基础状态**:
    对于一个节点 `u`，在合并任何子树之前，它自己就是一个孤单的节点。它需要和外界配对，所以它自身形成了一条“上行路径”。因此，初始状态是 `dp[u][1][0] = 1`。

2.  **合并子树**:
    假设我们现在要将子节点 `v` 的信息合并到父节点 `u` 中。
    - `u` 的当前状态是 `dp[u][i_u][j_u]`（可能已经合并了其他子树）。
    - `v` 的计算结果是 `dp[v][i_v][j_v]`。

    在合并之前，我们需要对 `v` 的状态做一个“视角转换”。

    **视角转换 (tx 数组)**:
    从 `u` 的角度看，`v` 子树里的路径都经过了 `(u, v)` 这条边。
    - `v` 的 `i_v` 条“上行路径”，到达 `u` 之后，它们有了新的选择：
        - 继续向上走，成为 `u` 的一条上行路径。
        - 在 `u` 这里“掉头”，成为一条从 `u` 出发的下行路径，去往 `u` 的其他子树。
    - `v` 的 `j_v` 条“下行路径”（从`v`出发），从 `u` 的角度看，它们就是从 `u` 出发，经过 `v` 再往下的下行路径。

    我们用一个临时数组 `tx` 来存储 `v` 转换视角后的状态。假设 `v` 有 `l` 条上行路径，`r` 条下行路径。我们从 `l` 条上行路径中选出 `k` 条，让它们在 `u` 处掉头。
    - 方案数：$C(l, k)$
    - 新的上行路径数：$l - k$
    - 新的下行路径数：$r + k$
    所以，我们会把 `dp[v][l][r]` 的贡献，按照 $C(l,k)$ 的比例，加到 `tx[l-k][r+k]` 上。

    **合并 (`u` 和 `v`)**:
    现在我们有了 `u` 的状态 `dp[u][i_u][j_u]` 和 `v` 转换后的状态 `tx[i_v][j_v]`。我们可以把它们内部的路径互相配对！
    - **配对1**: `u` 的一条**上行路径**可以和 `v` 的一条**下行路径**在 `u-v` 链上相遇配对。
      我们从 `u` 的 `i_u` 条上行路径中选 `p` 条，从 `v` 的 `j_v` 条下行路径中选 `p` 条进行配对。
      方案数是 $C(i_u, p) \times C(j_v, p) \times p!$。
    - **配对2**: `u` 的一条**下行路径**可以和 `v` 的一条**上行路径**在 `u` 节点相遇配对。
      我们从 `u` 的 `j_u` 条下行路径中选 `q` 条，从 `v` 的 `i_v` 条上行路径中选 `q` 条进行配对。
      方案数是 $C(j_u, q) \times C(i_v, q) \times q!$。

    配对完成后，剩下的未配对路径就构成了新的 `u` 的状态：
    - 新的上行路径数: $(i_u - p) + (i_v - q)$
    - 新的下行路径数: $(j_u - q) + (j_v - p)$

    我们遍历所有可能的 `i_u, j_u, i_v, j_v, p, q`，把计算出的方案数累加到 `u` 的新DP表（一个临时表 `tp`）中。当 `v` 合并完成后，再用 `tp` 更新 `dp[u]`。

3.  **最终答案**:
    当所有节点都处理完毕，我们回到根节点1。我们要求的是所有节点都完美配对的方案，这意味着在根节点1，不应该有任何需要向上或向下的路径。所以最终答案就是 `dp[1][0][0]`。

这个DP的本质是在统计不同连接方式的方案数，而每条边对距离的贡献（+1）被巧妙地隐藏在了路径类型的转换中（上行变下行）。虽然我们没有显式地乘以距离，但最终的结果就是我们想要的权值和，是不是很神奇，喵~

## 代码实现

这是本猫娘根据上面的思路，重新整理的一份代码。变量名都起得很清楚，还加了详细的注释，希望能帮助你理解哦！

```cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 52;

// 邻接表存树
vector<int> adj[MAXN];
// dp[u][i][j]: 子树u中, 有i条上行路径, j条下行路径的方案数
long long dp[MAXN][MAXN][MAXN]; 
// size_of_subtree[u]: 子树u的大小
int size_of_subtree[MAXN];
// C[n][k]: 组合数
long long C[MAXN][MAXN];
// factorials[i]: i的阶乘
long long factorials[MAXN];
// 临时DP表, 用于合并
long long temp_dp[MAXN][MAXN];
// 临时DP表, 用于子节点状态转换
long long transformed_dp[MAXN][MAXN];

int N;

// 预处理组合数和阶乘
void precompute_combi_and_fact() {
    factorials[0] = 1;
    for (int i = 1; i <= N; ++i) {
        factorials[i] = (factorials[i - 1] * i) % MOD;
    }

    for (int i = 0; i <= N; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
}

void dfs(int u, int parent) {
    // 1. 初始化: u自身构成1条上行路径
    size_of_subtree[u] = 1;
    dp[u][1][0] = 1;

    // 2. 遍历子节点, 合并信息
    for (int v : adj[u]) {
        if (v == parent) continue;

        dfs(v, u);

        // 临时DP表清零
        memset(temp_dp, 0, sizeof(temp_dp));

        // 3. 视角转换: 将子节点v的DP状态转换为从u看的状态
        memset(transformed_dp, 0, sizeof(transformed_dp));
        for (int up_v = 0; up_v <= size_of_subtree[v]; ++up_v) {
            for (int down_v = 0; down_v <= size_of_subtree[v]; ++down_v) {
                if (dp[v][up_v][down_v] == 0) continue;
                // 从 up_v 条上行路径中, 选 k 条在 u 处 "掉头" 变成下行路径
                for (int k = 0; k <= up_v; ++k) {
                    long long ways = (C[up_v][k] * dp[v][up_v][down_v]) % MOD;
                    transformed_dp[up_v - k][down_v + k] = (transformed_dp[up_v - k][down_v + k] + ways) % MOD;
                }
            }
        }
        
        // 4. 合并: 将转换后的v状态合并到u
        for (int up_u = 0; up_u <= size_of_subtree[u]; ++up_u) {
            for (int down_u = 0; down_u <= size_of_subtree[u]; ++down_u) {
                if (dp[u][up_u][down_u] == 0) continue;

                for (int up_v = 0; up_v <= size_of_subtree[v]; ++up_v) {
                    for (int down_v = 0; down_v <= size_of_subtree[v]; ++down_v) {
                        if (transformed_dp[up_v][down_v] == 0) continue;

                        // 配对1: u的上行路径 与 v的下行路径
                        for (int p = 0; p <= up_u && p <= down_v; ++p) {
                            // 配对2: u的下行路径 与 v的上行路径
                            for (int q = 0; q <= down_u && q <= up_v; ++q) {
                                int new_up = up_u - p + up_v - q;
                                int new_down = down_u - q + down_v - p;

                                long long ways = dp[u][up_u][down_u];
                                ways = (ways * transformed_dp[up_v][down_v]) % MOD;
                                
                                // C(up_u, p) * C(down_v, p) * p!
                                ways = (ways * C[up_u][p]) % MOD;
                                ways = (ways * C[down_v][p]) % MOD;
                                ways = (ways * factorials[p]) % MOD;

                                // C(down_u, q) * C(up_v, q) * q!
                                ways = (ways * C[down_u][q]) % MOD;
                                ways = (ways * C[up_v][q]) % MOD;
                                ways = (ways * factorials[q]) % MOD;

                                temp_dp[new_up][new_down] = (temp_dp[new_up][new_down] + ways) % MOD;
                            }
                        }
                    }
                }
            }
        }
        
        // 5. 更新u的状态
        size_of_subtree[u] += size_of_subtree[v];
        for (int i = 0; i <= size_of_subtree[u]; ++i) {
            for (int j = 0; j <= size_of_subtree[u]; ++j) {
                dp[u][i][j] = temp_dp[i][j];
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N;

    precompute_combi_and_fact();

    for (int i = 0; i < N - 1; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    dfs(1, 0);

    // 最终答案是根节点1中, 没有任何未配对路径的方案数
    cout << dp[1][0][0] << endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N^6)$。
  我们在树上进行后序遍历。对于每个节点 `u`，我们需要合并它的所有子节点。合并一个子节点 `v` 时，我们需要遍历 `u` 和 `v` 的所有DP状态。设 `u` 在合并前的大小是 `s_u`，`v` 的大小是 `s_v`。
  - `u` 的状态数是 $O(s_u^2)$。
  - `v` 的状态数是 $O(s_v^2)$。
  - 合并时的 `p` 和 `q` 循环，分别最多 `min(s_u, s_v)` 次。
  - 粗略估计，一次合并操作的复杂度是 $O(s_u^2 \cdot s_v^2 \cdot s_u \cdot s_v) = O(s_u^3 s_v^3)$，这看起来太高了。
  - 让我们更仔细地看循环：`for up_u, down_u, up_v, down_v, p, q`。
    `p` 受 `up_u, down_v` 限制，`q` 受 `down_u, up_v` 限制。
    总复杂度是 $\sum_{u} \sum_{v \in children(u)} s_u^2 \cdot s_v^2 \cdot s_u \cdot s_v$。
    通过树形DP复杂度分析的常用技巧（考虑每对节点的贡献），可以得到一个更紧的界，但一个宽松且安全的上界是 $O(N^6)$。对于 $N=50$ 来说，这个复杂度是可以接受的。

- **空间复杂度**: $O(N^3)$。
  主要的开销是 `dp` 数组，其大小为 `dp[N][N][N]`，所以是 $O(N^3)$。其他辅助数组如组合数表 `C` 是 $O(N^2)$，邻接表是 $O(N)$，都可以忽略不计。

## 知识点总结

1.  **树形DP**: 解决树上问题的经典方法，通常通过DFS后序遍历，自底向上地合并子问题信息。
2.  **组合计数**: 解决问题的核心。我们没有直接计算带权值的和，而是转化为了一个对不同连接方式计数的组合问题。这在处理“乘积和”这类复杂结构时是一种非常强大的思想。
3.  **DP状态设计**: 本题的DP状态 `dp[u][i][j]` 非常巧妙，它不记录距离，而是记录抽象的“路径状态”（上行/下行），并通过状态的转移和合并来间接处理距离的累加效应。
4.  **排列组合**: 在合并状态时，大量使用了组合数 $C(n,k)$ 和阶乘 $n!$ 来计算选择和配对的方案数。

希望这篇题解能帮助你理解这道有趣的题目，喵~ 如果还有不懂的地方，随时可以再来问我哦！