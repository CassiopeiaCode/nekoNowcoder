# PointsConstructionProblem - 题解

### 标签与难度
> **标签**: 构造, 思维题, 图论, 网格图, constructive algorithms, graph theory
> **难度**: 1900

## 题目大意喵~

主人你好呀，喵~ 这道题是这样的：在一个无限大的二维坐标平面上，所有的整点一开始都是白色的。现在，我们要把其中的 `n` 个点染成黑色，并且要求，恰好有 `m` 对相邻的黑白点对。

这里的“相邻”指的是两个点的曼哈顿距离为1，也就是 $|x_1 - x_2| + |y_1 - y_2| = 1$。

如果能找到这样一种染 `n` 个点的方法，就输出 "Yes" 和这 `n` 个点的坐标；如果找不到，就输出 "No"。坐标的范围很大，所以我们不用担心会超出边界，可以自由地选择位置哦，喵~

## 解题思路分析

这道题看起来是在一个无限大的平面上找点，但其实是一道非常有趣的构造题，喵！关键在于理解 `n` 个黑点和 `m` 对黑白边界之间的关系。让本猫娘带你一步步解开谜题吧！

### 关键洞察：边界与内部连接的关系

我们先来思考一下，`m` 到底代表什么。`m` 是所有黑色点与相邻白色点形成的“边界”的总长度。

每个黑点都有四个方向的邻居（上、下、左、右）。所以，如果我们有 `n` 个黑点，它们总共就有 $4n$ 个“邻居位”。

这些邻居位要么是另一个黑点，要么是一个白点。
*   如果邻居是**白点**，那就形成了一对我们想要的黑白点对，对 `m` 有 1 的贡献。
*   如果邻居是**黑点**，那就形成了一条“内部连接”。

让我们定义一个变量 $k$，表示所有黑点之间内部连接的总数。比如，两个黑点 `(0,0)` 和 `(0,1)` 相邻，它们之间就有一条内部连接，所以 $k$ 会加一。

现在，我们可以建立一个等式来描述这 $4n$ 个邻居位的去向：
$$
4n = m + 2k
$$

为什么是 $2k$ 呢？因为每一条内部连接（比如点 A 和点 B 之间的连接）都会被计算两次：一次是从点 A 的角度看点 B 是它的邻居，一次是从点 B 的角度看点 A 是它的邻居。所以，内部连接消耗掉了 $2k$ 个邻居位。剩下的 $4n - 2k$ 个邻居位就都朝向白色点了，这就是 `m` 的值！

从这个美妙的公式里，我们可以立刻得到两个重要的推论：
1.  $m = 4n - 2k$。因为 $4n$ 和 $2k$ 都是偶数，所以它们的差也必须是偶数。这意味着，如果给定的 **`m` 是奇数**，那绝对不可能构造出来，可以直接说 "No"，喵！
2.  $2k = 4n - m$。因为内部连接数 $k$ 肯定是非负的（$k \ge 0$），所以 $4n - m \ge 0$，也就是 **$m \le 4n$**。如果一个黑点周围全是白点，`m` 就最大，等于 $4n$。这也是一个无解的判断条件。

现在，问题被我们转化成了一个更具体的目标：
**给定 `n` 和 `m`，我们能否构造一个由 `n` 个点组成的图形，使得它们之间恰好有 $k = (4n - m) / 2$ 条内部连接？**

### 构造策略：分情况讨论大法！

一个由 `n` 个点组成的连通图，最少有 $n-1$ 条边（此时它是一棵树，比如一条直线）。最多的情况，是把它排列成尽可能紧凑的形状。
*   当 $k = n-1$ 时，对应的 $m = 4n - 2(n-1) = 2n+2$。
*   当 $k < n-1$ 时，图必然是不连通的（一个“森林”），$m > 2n+2$。
*   当 $k > n-1$ 时，图中必然有环，形状更紧凑，$m < 2n+2$。

这个 $m = 2n+2$ 就成了一个天然的分界线，我们可以据此分为两种情况来构造，喵~

#### 情况一：$m > 2n+2$ (需要较少的内部连接)

这个时候，$k = (4n-m)/2 < n-1$。为了让内部连接数少于 $n-1$，我们必须让这些点不全都连在一起，也就是构造一个不连通的图形。

最简单的构造方法就是：一部分点形成一条直线（一个连通分量），剩下的点全部作为孤立点（每个点都是一个连通分量）。

*   假设我们用 `c` 个点构成一条直线，那么它们内部有 $c-1$ 条连接。
*   剩下的 $n-c$ 个点都是孤立的，它们内部没有连接。
*   所以总的内部连接数 $k = c-1$。

我们需要的连接数是 $k = (4n-m)/2$，所以令 $c-1 = (4n-m)/2$，解得：
$$
c = \frac{4n-m}{2} + 1 = 2n - \frac{m}{2} + 1
$$
只要我们算出的这个 c 是一个合理的数值（即 $1 \le c \le n$），我们就可以这样构造！经过分析可以发现，在 $m > 2n+2$ 的前提下，c 总是在这个范围内。

**构造方法:**
1.  计算出需要连成线的点的数量 $c = 2n - m/2 + 1$。
2.  输出 "Yes"。
3.  输出 `c` 个点，让它们排成一条线，比如 `(1, 1), (1, 2), ..., (1, c)`。
4.  输出剩下的 $n-c$ 个点，让它们离得远远的，互相不挨着，也和那条线不挨着。比如 `(-100, -100), (-200, -200), ...`。

#### 情况二：$m \le 2n+2$ (需要较多的内部连接)

这个时候，$k \ge n-1$。我们需要构造一个连通的、甚至有环的紧凑图形。

这里有一个非常巧妙的构造方法：**L形填充法**！

1.  **基础框架**：我们先想办法构造一个有 `m` 条边界的“基础图形”。研究发现，一个由 $N_L$ 个点组成的L形（或直线），它的边界数恰好是 $2N_L+2$。我们想让这个边界数等于 `m`，所以 $m = 2N_L+2$，解得基础图形需要 $N_L = m/2 - 1$ 个点。
    *   如果我们的总点数 $n$ 连基础图形都凑不齐（即 $n < N_L$），那肯定是无解的，喵。

2.  **增加点数而不改变边界**：现在我们有了一个 $N_L$ 个点的L形，它已经满足了边界为 `m` 的要求。我们还有 $n - N_L$ 个点没用呢！怎么把它们加上去，同时不改变 `m` 的值？
    回到我们的公式 $m = 4n - 2k$。当我们增加一个点（$\Delta n = 1$），为了让 `m` 不变（$\Delta m = 0$），就需要满足 $0 = 4(1) - 2(\Delta k)$，解得 $\Delta k = 2$。
    也就是说，我们每新加一个点，必须让它恰好与已有的图形形成 2 条新的内部连接！

3.  **L形填充**：怎么做到这一点呢？把点放在L形的“拐角”里！
    我们先用 $N_L$ 个点搭一个L形。为了让它能容纳最多的点，我们让L的两臂长度尽可能相等。设 $S = m/2$，L的两臂总长应该是 $S$。我们可以让两臂长度分别为 `len_x = S/2` 和 `len_y = S - S/2`。
    这个L形框架就定义了一个 `len_x * len_y` 的矩形区域。我们把剩下的点，一个一个地填充到这个矩形的内部。每个被填充进去的点，都会和它上方和左侧（或右侧）的点相邻，恰好形成2条新的内部连接！

4.  **容量限制**：这个 `len_x * len_y` 的矩形就是我们这个方法能容纳的总点数上限。如果给定的 `n` 超过了这个容量，那就说明我们的方法也无能为力了，判定为无解。

**构造方法:**
1.  计算 L 形臂长之和 $S = m/2$。
2.  判断是否能搭出框架：如果 $n < S-1$，无解。
3.  计算两臂长度 `len_x = S / 2` 和 `len_y = S - (S / 2)`。
4.  判断是否超出容量：如果 $n > (long long)len_x \times len_y$，无解。
5.  如果都满足，输出 "Yes"。
6.  然后，像打印机一样，从上到下、从左到右，依次输出 `n` 个点的坐标来填充这个 `len_x * len_y` 的矩形区域。

这样，我们就完美地解决了所有情况，喵~

## 代码实现

这是本猫娘根据上面的思路，为你精心重构的一份代码，注释超详细的哦！

```cpp
#include <iostream>
#include <vector>
#include <numeric>

void solve() {
    long long n, m;
    std::cin >> n >> m;

    // --- 基本的无解判断 ---
    // 1. m 必须是偶数
    // 2. m 不能超过 4n (每个点最多4个白邻居)
    if (m % 2 != 0 || m > 4 * n) {
        std::cout << "No" << std::endl;
        return;
    }

    // --- 情况一: m > 2n + 2 ---
    // 此时需要的内部连接数 k < n-1, 必须构造不连通图
    if (m > 2 * n + 2) {
        // 计算需要连成一线的点的数量 c
        // k = c - 1
        // (4n - m) / 2 = c - 1  => c = 2n - m/2 + 1
        long long c = 2 * n - m / 2 + 1;

        // c 必须是有效的点数 (1 <= c <= n)
        // 在 m > 2n+2 和 m <= 4n 的前提下，c 总是合法的，这里为了代码稳健性可以加上检查
        if (c < 1) { // c > n 的情况不会发生
             std::cout << "No" << std::endl;
             return;
        }

        std::cout << "Yes" << std::endl;
        // 构造 c 个点的直线
        for (int i = 1; i <= c; ++i) {
            std::cout << 1 << " " << i << std::endl;
        }
        // 构造 n-c 个孤立点，用大的负坐标保证不相邻
        for (int i = 1; i <= n - c; ++i) {
            std::cout << -2 * i - 10 << " " << -2 * i - 10 << std::endl;
        }
        return;
    }

    // --- 情况二: m <= 2n + 2 ---
    // 此时需要的内部连接数 k >= n-1, 构造紧凑的连通图
    long long S = m / 2;

    // 基础L形框架需要 S-1 个点。如果总点数 n 还不够搭框架，则无解。
    // 特例: n=1, m=4, S=2, S-1=1, n >= S-1 成立。
    if (n < S - 1) {
        std::cout << "No" << std::endl;
        return;
    }
    
    // 如果 S < 2 (即 m < 4), L形臂长至少为1，无法构成
    if (S < 2 && n > 1) { // n=1,m=4时S=2, n=1,m=2时S=1
        std::cout << "No" << std::endl;
        return;
    }

    // 计算L形两臂长度，使其尽可能接近，以最大化填充区域
    long long len_x = S / 2;
    long long len_y = S - len_x;

    // 如果 L 形臂长为0，说明 m 过小，无法构造
    if (len_x == 0 || len_y == 0) {
        if (n == 1 && m == 4) { // 唯一特例 (len_x=1, len_y=1)
            std::cout << "Yes" << std::endl;
            std::cout << "1 1" << std::endl;
        } else {
            std::cout << "No" << std::endl;
        }
        return;
    }

    // 如果需要的总点数 n 超过了 L 形定义的矩形容量，则无解
    if (n > len_x * len_y) {
        std::cout << "No" << std::endl;
        return;
    }

    // 构造答案
    std::cout << "Yes" << std::endl;
    long long count = 0;
    for (int i = 1; i <= len_x; ++i) {
        for (int j = 1; j <= len_y; ++j) {
            if (count < n) {
                std::cout << i << " " << j << std::endl;
                count++;
            } else {
                break;
            }
        }
        if (count == n) {
            break;
        }
    }
}

int main() {
    // 加速输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int T;
    std::cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N)$
    整个算法的核心是几个数学计算，这都是 $O(1)$ 的。唯一消耗时间的部分是最后输出 `n` 个点的坐标，所以总的时间复杂度是 $O(n)$，非常高效，喵！

-   **空间复杂度**: $O(1)$
    我们没有使用任何随输入规模 `n` 变化的额外存储空间。我们是直接计算并输出坐标，所以空间复杂度是常数级别的，非常节省内存呢！

## 知识点总结

这道题真是一次愉快的思维探险，主人！我们从中可以学到：

1.  **核心关系建模**: 解决构造题的第一步往往是找到变量之间的数学关系。本题的 $4n = m + 2k$ 就是解题的钥匙。
2.  **分类讨论思想**: 找到一个关键的阈值（本题是 $m=2n+2$），以此为界限对问题进行拆分，是处理复杂构造问题的常用技巧。
3.  **构造的原子操作**: 理解增加一个元素（点）会对整体性质（边界 `m`）产生什么影响。在本题中，我们发现了“增加一个点，使其产生2个内部连接，则边界数不变”这一神奇的原子操作。
4.  **常用构造图形**: 直线、L形、矩形是网格图中非常基础且有用的构造单元。特别是L形+填充的策略，在处理需要特定边界和内部连接数的问题时非常强大。

希望这篇题解能帮到你，主人！如果还有其他问题，随时可以来找我玩哦，喵~