# 有两棵树 - 题解

### 比赛与标签
> **比赛**: The 17th Zhejiang Provincial Collegiate Programming Contest
> **标签**: `树形DP`, `换根DP`, `__int128
> **难度**: ****2000

## 题目大意喵~

主人你好呀，这道题是这样的喵~

我们有两棵树，一棵有 $n$ 个节点（编号 $1$ 到 $n$），另一棵有 $m$ 个节点（编号 $n+1$ 到 $n+m$）。

我们可以进行一次“联结”操作：在第一棵树里选一个节点 $u$，在第二棵树里选一个节点 $v$，然后用一条边把 $u$ 和 $v$ 连起来。这样，两棵小树就合成了一棵大树啦！

对于任意两个节点 $s$ 和 $t$，它们在新形成的大树里的距离，我们记作 $f(u, v, s, t)$。

现在，题目定义了一个“极限距离” $d(s, t)$，它是在所有可能的联结方式 $(u, v)$ 中，$s$ 和 $t$ 之间距离的最大值。也就是说：
$$
d(s, t) = \max_{1 \le u \le n, n+1 \le v \le n+m} f(u, v, s, t)
$$

我们的最终任务，就是要计算所有节点对 $(s, t)$（其中 $s < t$）的极限距离之和，也就是：
$$
\sum_{1 \le s < t \le n+m} d(s, t)
$$
这个数字可能会很大，要小心溢出哦，喵~

## 解题思路分析

这道题看起来有点复杂，要把所有可能的连接方式都考虑进去，还要找最大值，然后再求和... 但是别担心，跟着本喵的思路一步步来，问题就会变得清晰起来啦，喵！

首先，我们来分析一下这个“极限距离” $d(s, t)$ 到底是什么。这取决于节点 $s$ 和 $t$ 的位置关系，呐。

我们把第一棵树叫做 $T_1$，第二棵树叫做 $T_2$。节点 $u \in T_1, v \in T_2$。连接 $u,v$ 后，两棵树通过一条长度为 1 的“桥”连在了一起。

#### Case 1: $s$ 和 $t$ 在同一棵原始树里

比如说，$s, t$ 都在 $T_1$ 里。在新形成的大树里，从 $s$ 到 $t$ 的最短路径，还会是原来在 $T_1$ 里的那条路吗？是的喵！因为绕道去 $T_2$ 再回来，路程肯定会变长。所以，无论我们怎么选择连接点 $u$ 和 $v$，只要 $s, t$ 在同一棵树里，它们之间的距离是不会变的。

*   如果 $s, t \in T_1$，那么 $d(s, t) = \text{dist}_1(s, t)$，也就是它们在 $T_1$ 中的原始距离。
*   如果 $s, t \in T_2$，那么 $d(s, t) = \text{dist}_2(s, t)$，也就是它们在 $T_2$ 中的原始距离。

#### Case 2: $s$ 和 $t$ 在不同的树里

比如说，$s \in T_1$，$t \in T_2$。要从 $s$ 走到 $t$，必须经过我们新加的边 $(u,v)$。路径一定是这样的：$s \to \dots \to u \to v \to \dots \to t$。
这条路径的长度就是：
$$
\text{dist}_1(s, u) + 1 + \text{dist}_2(v, t)
$$
我们要找的是极限距离 $d(s, t)$，也就是让这个值最大。我们可以在 $T_1$ 中自由选择 $u$，在 $T_2$ 中自由选择 $v$。为了让总和最大，我们应该让两部分都取到最大值！
*   在 $T_1$ 中，选择离 $s$ 最远的节点作为 $u$。
*   在 $T_2$ 中，选择离 $t$ 最远的节点作为 $v$。

所以，当 $s \in T_1, t \in T_2$ 时，极限距离是：
$$
d(s, t) = (\max_{u \in T_1} \text{dist}_1(s, u)) + 1 + (\max_{v \in T_2} \text{dist}_2(v, t))
$$
我们把一个节点 $x$ 在它所属的树中离它最远的距离记为 $\text{max\_dist}(x)$。那么公式就变成了：
$$
d(s, t) = \text{max\_dist}_1(s) + 1 + \text{max\_dist}_2(t)
$$

#### 拆解总和

现在我们知道了 $d(s, t)$ 的计算方法，就可以把总的求和公式拆成三部分了：

**总和 = ( $s,t$ 都在 $T_1$ 的距离和 ) + ( $s,t$ 都在 $T_2$ 的距离和 ) + ( $s \in T_1, t \in T_2$ 的距离和 )**

1.  **$s,t \in T_1$ 的部分**: $\sum_{1 \le s < t \le n} \text{dist}_1(s, t)$。这是个经典问题：求树上所有点对的距离之和。
2.  **$s,t \in T_2$ 的部分**: $\sum_{n+1 \le s < t \le n+m} \text{dist}_2(s, t)$。和上面一样，只是换了一棵树。
3.  **$s \in T_1, t \in T_2$ 的部分**:
    $$
    \sum_{s=1}^{n} \sum_{t=n+1}^{n+m} (\text{max\_dist}_1(s) + 1 + \text{max\_dist}_2(t))
    $$
    这个和式可以展开：
    $$
    = \sum_{s=1}^{n} \sum_{t=n+1}^{n+m} \text{max\_dist}_1(s) + \sum_{s=1}^{n} \sum_{t=n+1}^{n+m} 1 + \sum_{s=1}^{n} \sum_{t=n+1}^{n+m} \text{max\_dist}_2(t)
    $$
    $$
    = m \cdot \sum_{s=1}^{n} \text{max\_dist}_1(s) + n \cdot m + n \cdot \sum_{t=n+1}^{n+m} \text{max\_dist}_2(t)
    $$

#### 如何高效计算？

现在问题转化成了，对于一棵给定的树，我们需要计算两样东西：
A. 所有点对的距离之和：$\sum_{s<t} \text{dist}(s, t)$
B. 每个点到最远点的距离之和：$\sum_{s} \text{max\_dist}(s)$

这两样东西都可以用一种叫做“**换根DP**”（或者叫二次扫描法）的树形DP技巧在 $O(N)$ 时间内解决，超级高效的喵！

**换根DP的基本思路**：
1.  **第一次DFS (自底向上)**：随便选个根（比如1号节点），从叶子节点开始向上递推信息。对于每个节点 u`，我们计算它**子树内**的相关信息。
    *   `subtree_size[u]`: `u` 的子树大小。
    *   `down_path_sum[u]`: `u` 到它子树内所有节点的距离之和。
    *   `down_max_len[u]`: 从 `u` 出发，在子树内能走到的最长路径长度。

2.  **第二次DFS (自顶向下)**：从根节点开始，向下传递信息。对于每个节点 `u`，我们利用父节点已经算好的“全局”信息，来计算 `u` 的**子树外**的信息。
    *   `up_path_sum[u]`: `u` 到它子树外所有节点的距离之和。
    *   `up_max_len[u]`: 从 `u` 出发，不进入其子树（即向上或进入兄弟子树）能走到的最长路径长度。

**计算 A 和 B**：
*   **A. 所有点对距离和**: 对于任意一个节点 `u，经过它的路径可以分为两类：一端在子树内，一端在子树外。其实有个更简单的公式：所有点对的距离和等于 $\frac{1}{2} \sum_{u=1}^{N} (\text{down\_path\_sum}[u] + \text{up\_path\_sum}[u])$。
*   **B. 每个点最远距离**: 对于节点 u`，离它最远的点，要么在它的子树里（路径长 `down_max_len[u]`），要么在子树外（路径长 `up_max_len[u]）。所以 $\text{max\_dist}(u) = \max(\text{down\_max\_len}[u], \text{up\_max\_len}[u])$。我们把所有 u 的这个值加起来就好啦。

具体的DP转移方程有点小复杂，本喵在代码注释里会详细解释哒！

**总结一下我们的计划**：
1.  把输入的边建成一个图。这个图包含两个不连通的树。
2.  找到这两棵树（例如，从节点1开始DFS/BFS找到第一棵树，再找一个没访问过的节点如 $n+1$ 开始找第二棵树）。
3.  对第一棵树，用换根DP算出 $\sum \text{dist}_1$ 和 $\sum \text{max\_dist}_1$。
4.  对第二棵树，用换根DP算出 $\sum \text{dist}_2$ 和 $\sum \text{max\_dist}_2$。
5.  把这四个值代入我们推导出的总和公式，算出最终答案。
6.  因为结果很大，要用 __int128` 来存，喵~

## 代码实现

这是本喵根据上面的思路，精心重构的代码哦！注释写得很详细，希望能帮助主人理解，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 __int128 来处理可能非常大的结果
using int128 = __int128;

// 总节点数
const int MAXN = 200005;
std::vector<int> adj[MAXN];
bool visited[MAXN];
int n, m;

// 存储每棵树的计算结果
struct TreeInfo {
    int128 all_pairs_dist_sum = 0; // 树内所有点对距离之和
    int128 max_dist_from_each_node_sum = 0; // 树内每个点到其最远点距离之和
};

// 换根DP的核心计算逻辑
namespace TreeDP {
    std::vector<int> nodes;
    long long subtree_size[MAXN];
    int128 down_path_sum[MAXN];
    int128 up_path_sum[MAXN];
    long long down_max_len1[MAXN], down_max_len2[MAXN]; // 向下的最长和次长路径
    long long up_max_len[MAXN]; // 向上的最长路径

    // 清理上次计算的数据
    void clear() {
        for (int u : nodes) {
            subtree_size[u] = 0;
            down_path_sum[u] = up_path_sum[u] = 0;
            down_max_len1[u] = down_max_len2[u] = 0;
            up_max_len[u] = 0;
        }
        nodes.clear();
    }

    // 第一次DFS：自底向上，计算子树信息
    void dfs1_down(int u, int p) {
        visited[u] = true;
        nodes.push_back(u);

        subtree_size[u] = 1;
        down_path_sum[u] = 0;
        down_max_len1[u] = 0;
        down_max_len2[u] = 0;

        for (int v : adj[u]) {
            if (v == p) continue;
            dfs1_down(v, u);
            subtree_size[u] += subtree_size[v];
            // u到v子树所有点的距离和 = v到v子树所有点的距离和 + v子树每个点到u的距离都多了1
            down_path_sum[u] += down_path_sum[v] + subtree_size[v];
            
            // 更新u向下的最长和次长路径
            long long child_path_len = down_max_len1[v] + 1;
            if (child_path_len > down_max_len1[u]) {
                down_max_len2[u] = down_max_len1[u];
                down_max_len1[u] = child_path_len;
            } else if (child_path_len > down_max_len2[u]) {
                down_max_len2[u] = child_path_len;
            }
        }
    }

    // 第二次DFS：自顶向下，计算子树外信息
    void dfs2_up(int u, int p) {
        for (int v : adj[u]) {
            if (v == p) continue;

            // 计算 v 的向上最长路径 up_max_len[v]
            // 它可以来自 u 的向上路径，或者 u 通往其他兄弟子树的向下路径
            long long u_up_path = up_max_len[u] + 1;
            long long u_down_path = 0;
            if (down_max_len1[v] + 1 == down_max_len1[u]) {
                // v 就在 u 的最长向下路径上，所以 u 只能用次长路径
                u_down_path = down_max_len2[u] + 1;
            } else {
                // v 不在 u 的最长向下路径上，u 可以用最长路径
                u_down_path = down_max_len1[u] + 1;
            }
            up_max_len[v] = std::max(u_up_path, u_down_path);

            // 计算 v 的向上路径和 up_path_sum[v]
            // u到子树外所有点的距离和 = u的向上路径和 + u到其他子树的向下路径和
            int128 u_external_sum = up_path_sum[u] + (down_path_sum[u] - (down_path_sum[v] + subtree_size[v]));
            long long num_external_nodes = (long long)nodes.size() - subtree_size[v];
            up_path_sum[v] = u_external_sum + num_external_nodes;
            
            dfs2_up(v, u);
        }
    }

    TreeInfo calculate(int start_node) {
        clear();
        dfs1_down(start_node, 0);
        dfs2_up(start_node, 0);

        TreeInfo result;
        int128 total_dist_sum = 0;
        for (int u : nodes) {
            // 每个点到其他所有点的距离和 = down_path_sum + up_path_sum
            // 所有点对距离和是这个值的一半（因为每条路被算了两次）
            total_dist_sum += down_path_sum[u] + up_path_sum[u];
            
            // 每个点到最远点的距离 = max(向下最长, 向上最长)
            result.max_dist_from_each_node_sum += std::max(down_max_len1[u], up_max_len[u]);
        }
        result.all_pairs_dist_sum = total_dist_sum / 2;
        
        return result;
    }
}

// 用来输出 __int128
void print_int128(int128 n) {
    if (n == 0) {
        std::cout << "0";
        return;
    }
    std::string s = "";
    while (n > 0) {
        s += (n % 10) + '0';
        n /= 10;
    }
    std::reverse(s.begin(), s.end());
    std::cout << s;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::cin >> n >> m;
    for (int i = 0; i < n + m - 2; ++i) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // 分别计算两棵树的信息
    TreeInfo info1 = TreeDP::calculate(1);
    // 找到第二棵树的起点（第一个没访问过的节点）
    int second_tree_start = -1;
    for(int i = 1; i <= n + m; ++i) {
        if (!visited[i]) {
            second_tree_start = i;
            break;
        }
    }
    TreeInfo info2 = TreeDP::calculate(second_tree_start);

    int128 ans = 0;
    // Part 1 & 2: 树内部点对的距离和
    ans += info1.all_pairs_dist_sum;
    ans += info2.all_pairs_dist_sum;

    // Part 3: 跨树点对的距离和
    int128 n_128 = n, m_128 = m;
    ans += n_128 * m_128; // 中间的 +1 部分
    ans += m_128 * info1.max_dist_from_each_node_sum; // T1的max_dist部分
    ans += n_128 * info2.max_dist_from_each_node_sum; // T2的max_dist部分

    print_int128(ans);
    std::cout << "\n";

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N+M)$
    *   我们对整个图（包含两棵树）进行了两次完整的深度优先搜索。每个节点和每条边都只会被访问常数次。所以，整个过程是线性的，喵~

*   **空间复杂度**: $O(N+M)$
    *   我们使用了邻接表来存图，以及一些数组来存储DP状态，它们的大小都和总节点数 $N+M$ 成正比。DFS的递归栈深度最多也是 $O(N+M)$。

## 知识点总结

这道题是树形DP的一个非常棒的练习，融合了多个经典模型，喵~

1.  **问题分解**: 能够把一个复杂的问题（求所有点对的极限距离和）分解成几个更简单、更熟悉的子问题，是解题的关键第一步！
2.  **树上所有点对距离和**: 这是一个经典的树形DP问题。通过计算每条边的贡献，或者使用换根DP（如本题解），都可以在线性时间内解决。
3.  **树上每个点到最远点的距离**: 另一个经典问题。可以用两次BFS/DFS找直径端点的方法，也可以像本题解一样，在换根DP的过程中一并算出。
4.  **换根DP (二次扫描法)**: 这是解决一类“需要从每个点视角看整棵树”的问题的强大武器。先自底向上收集子树信息，再自顶向下传递全局信息，思路非常优美。
5.  **`__int128` 的使用**: 对于可能超过 `long long` 范围的计算，`__int128` 是一个非常有用的工具。不过要注意，它不是标准C++的一部分，但在GCC/Clang等编译器中广泛支持。输入输出需要自己写函数处理，有点小麻烦呢。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问本喵哦！加油，喵~