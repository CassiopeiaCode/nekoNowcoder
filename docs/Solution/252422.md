# 好四边形 - 题解

### 比赛与标签
> **比赛**: 信息未提供

> **标签**: 信息未提供

> **难度**: 信息未提供

## 题目大意喵~

秋静叶和秋穰子姐妹俩有 `n` 根长度各不相同的木棍，她们想从中选出四根，搭成一个“好”的四边形笼子来装可爱的二维西瓜，喵~

一个四边形是“好”的，需要满足两个条件：
1.  它必须是一个**凸四边形**。
2.  它必须有一个**内切圆**，也就是说，要存在一个圆，能够同时与四边形的四条边都相切。

我们的任务就是判断，是否存在这样四根木棍，如果存在就输出 `YES`，否则输出 `NO` 呐。

简单来说，就是从 `n` 个不同的数里，能不能找出四个数 `a, b, c, d`，让它们可以组成一个带内切圆的凸四边形。

## 解题思路分析

喵哈哈，这个问题看起来和几何有关，但其实核心是一个非常有趣的数学性质哦！让本猫娘来给你一步步分析吧！

#### 关键的几何性质：皮托定理 (Pitot's Theorem)

首先，什么样的四边形才能有内切圆呢？这里有一个非常关键的定理，叫做**皮托定理**！

> **皮托定理**：一个凸四边形有内切圆的**充分必要条件**是，它的两组对边长度之和相等。

也就是说，如果我们选出的四根木棍长度为 `l_1, l_2, l_3, l_4`，只要我们能把它们分成两对，让每一对的和都相等，那么它们就一定能组成一个有内切圆的四边形！比如，如果我们能让 `l_1 + l_3 = l_2 + l_4`，我们就可以把 `l_1` 和 `l_3` 作为对边，`l_2` 和 `l_4` 作为另一组对边，来构成我们想要的笼子。

至于**凸四边形**的条件，只要最长的一根木棍的长度小于另外三根之和（`l_max < l_a + l_b + l_c`），就总能构成一个四边形。在大部分情况下，我们找到满足皮托定理的四根木棍时，这个条件也自然满足了，所以我们可以暂时把注意力集中在寻找满足对边和相等的木棍上，喵~

#### 把问题转换一下！

所以，这个几何问题现在就变成了一个纯粹的数字问题啦：

> 在给定的 `n` 根不同长度的木棍中，是否存在**四根**不同的木棍，它们的长度可以分为两组，使得两组的和相等？

用数学语言来说，就是我们能不能找到四个**不同**的下标 `i, j, k, l`，使得 `a[i] + a[j] = a[k] + a[l]` 呢？

#### 暴力破解？太慢啦！

最直接的想法就是枚举所有可能的四根木棍组合。我们可以用四层循环来挑选四个不同的下标 `i, j, k, l`，然后检查它们的长度 `a[i], a[j], a[k], a[l]` 是否满足 `a[i] + a[j] = a[k] + a[l]` 或者 `a[i] + a[k] = a[j] + a[l]` 等组合。

这种方法的时间复杂度是 $O(N^4)$，如果 `n` 稍微大一点（比如题目数据范围暗示的几千甚至上万），我们的电脑猫猫就会累趴下的，绝对会超时的说！所以我们需要更聪明的办法。

#### 聪明的猫娘选择哈希！$O(N^2)$ 的优雅解法

我们可以换个角度思考，喵~ 我们要找的是 `a[i] + a[j] = a[k] + a[l]`。等式两边都是**两根木棍长度的和**。

这启发了我们：我们可以先计算出所有可能的两根木棍的长度和，然后看看有没有哪个“和”出现了不止一次！

这就像我们在派对上找朋友，不是一个一个问“你是不是我的朋友”，而是把所有人的名字和爱好都记在一个小本本上，然后看看有没有人和你有相同的爱好，这样效率就高多啦！

这个“小本本”，在编程里就是**哈希集合**（`std::unordered_set`）或者**哈希映射**（`std::unordered_map`）。

算法步骤如下：
1.  创建一个哈希集合 `seen_sums`，用来存放我们已经遇到过的“两根木棍之和”。
2.  使用两层循环，遍历所有可能的木棍对 `(a[i], a[j])`，其中 `i < j` 以免重复。
3.  对于每一对，计算它们的和 `current_sum = a[i] + a[j]`。
4.  在哈希集合 `seen_sums` 中查找是否存在 `current_sum`。
    *   **如果存在**：太棒了！这说明我们之前已经找到了另一对木棍 `(a[k], a[l])`，它们的和也是 `current_sum`。所以 `a[i] + a[j] = a[k] + a[l]`。因为我们遍历时保证了 `(i, j)` 和 `(k, l)` 是不同的两对，并且所有木棍长度都独一无二，所以这四根木棍 `a[i], a[j], a[k], a[l]` 一定是不同的！我们找到了答案，可以直接输出 `YES` 然后结束程序啦！
    *   **如果不存在**：说明这是我们第一次遇到这个和。我们将 `current_sum` 加入到 `seen_sums` 中，方便后面的查找。
5.  如果所有木棍对都遍历完了，还没有找到重复的和，那就说明不存在这样的四根木棍。我们就在最后输出 `NO`。

这个方法只需要两层循环，时间复杂度是 $O(N^2)$，对于 `n` 在几千的范围内是完全可以接受的，喵~！

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的代码哦！注释写得很详细，希望能帮助你理解，呐~

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

// 为了让代码跑得更快，喵~
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    fast_io();

    int n;
    std::cin >> n;

    // 如果木棍数量少于4根，肯定搭不成四边形啦
    if (n < 4) {
        std::cout << "NO\n";
        return 0;
    }

    std::vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    // 用一个哈希集合来记录所有出现过的两根木棍的和
    // 它的查找和插入操作平均是 O(1) 的，非常快！
    std::unordered_set<int> seen_sums;

    // 遍历所有可能的木棍对 (a[i], a[j])
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int current_sum = a[i] + a[j];

            // 检查这个和之前是否出现过
            if (seen_sums.count(current_sum)) {
                // 如果出现过，说明我们找到了两对不同的木棍，它们的和相等
                // 这就满足了皮托定理的条件，可以构成一个好四边形！
                // a[i] + a[j] = a[k] + a[l]
                std::cout << "YES\n";
                return 0; // 找到一组就足够了，直接结束程序
            }

            // 如果这个和是第一次出现，就把它记录到集合里
            seen_sums.insert(current_sum);
        }
    }

    // 如果遍历完所有组合都没找到，那就是不行咯
    std::cout << "NO\n";

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N^2)$
    我们用了两层嵌套循环来遍历所有可能的木棍对。外层循环执行 `N` 次，内层循环平均执行约 `N/2` 次，总共的配对次数是 $N(N-1)/2$，也就是 $O(N^2)$ 级别。哈希集合的 `count` 和 `insert` 操作的平均时间复杂度是 $O(1)$，所以总的时间复杂度由循环决定，为 $O(N^2)$。

-   **空间复杂度**: $O(N^2)$
    在最坏的情况下，所有木棍对的和都是独一无二的，这时哈希集合 `seen_sums` 需要存储所有 $O(N^2)$ 个和。因此，空间复杂度是 $O(N^2)$。

## 知识点总结

1.  **皮托定理 (Pitot's Theorem)**: 这是解决本题的钥匙！它巧妙地将一个几何问题（判断是否存在内切圆）转化为了一个代数问题（判断对边和是否相等）。
2.  **问题转化**: 学会将复杂的、抽象的问题描述，转化为更具体、更易于用算法解决的模型，是成为解题高手的必经之路，喵~
3.  **哈希数据结构的应用**: 当你需要快速查找一个元素是否存在于一个大集合中时，哈希表（如 `std::unordered_set` 或 `std::unordered_map`）是你的绝佳帮手！它能将查找时间从 $O(N)$ 或 $O(\log N)$ 降低到平均 $O(1)$。
4.  **组合枚举**: `for i ... for j=i+1 ...` 是一种经典的枚举无序对的循环结构，可以有效避免重复计算和自我配对。

希望这篇题解能帮到你，如果还有其他问题，随时可以来问本猫娘哦！一起享受解题的乐趣吧，喵~！