# 如果世上只剩下一个女孩子，应该给她取名叫伊娜。 - 题解

### 比赛与标签
> **比赛**: 信息未提供

> **标签**: 信息未提供

> **难度**: 信息未提供

## 题目大意喵~

一位名叫伊娜的可爱女孩定义了一个神奇的魔法序列 $a$，它的规则是这样的呐：

1.  序列的第一项 $a_1$ 固定为 $1$。
2.  对于 $i > 1$，序列的第 $i$ 项 $a_i$ 的值，等于它的前一项 $a_{i-1}$ 在它自己（$a_i$）之前出现过的总次数。

用数学语言来表达就是：
$$
\begin{cases}
a_1=1 \\
a_i=\sum_{j<i}[a_j=a_{i-1}] & i>1
\end{cases}
$$
其中 $[P]$ 是艾佛森括号，如果条件 $P$ 成立，它的值为 $1$，否则为 $0$。

我们的任务是，给定一个正整数 $n$，计算这个魔法序列前 $n$ 项的总和，也就是 $\sum_{i=1}^n a_i$ 的说。

## 解题思路分析

喵哈~ 这个序列的定义看起来有点绕，是不是呀？别担心，本猫娘最喜欢的就是把复杂的问题变简单了！我们一起来看看这个序列到底长什么样吧，喵~

我们来手动生成几项看看：

-   **$a_1$**: 根据定义，就是 $1$。
    序列: `1

-   **$a_2$**: 它的值是 $a_1$ 在位置2之前出现的次数。$a_1=1$，在它之前（也就是在 $\{a_1\}$ 里），$1$ 出现了 $1$ 次。所以 $a_2 = 1$。
    序列: 1, 1

-   **$a_3$**: 它的值是 $a_2$ 在位置3之前出现的次数。$a_2=1$，在它之前（也就是在 $\{a_1, a_2\}$ 里），$1$ 出现了 $2$ 次。所以 $a_3 = 2$。
    序列: 1, 1, 2

-   **$a_4$**: 它的值是 $a_3$ 在位置4之前出现的次数。$a_3=2$，在它之前（也就是在 $\{a_1, a_2, a_3\}$ 里），$2$ 出现了 $1$ 次。所以 $a_4 = 1$。
    序列: 1, 1, 2, 1

-   **$a_5$**: 它的值是 $a_4$ 在位置5之前出现的次数。$a_4=1$，在它之前（也就是在 $\{a_1, a_2, a_3, a_4\}$ 里），$1$ 出现了 $3$ 次。所以 $a_5 = 3$。
    序列: 1, 1, 2, 1, 3

-   **$a_6$**: 它的值是 $a_5$ 在位置6之前出现的次数。$a_5=3$，在它之前（也就是在 $\{a_1, ..., a_5\}$ 里），$3$ 出现了 $1$ 次。所以 $a_6 = 1$。
    序列: 1, 1, 2, 1, 3, 1`

把它们连起来看看： `1, 1, 2, 1, 3, 1, 4, 1, 5, 1, ...

喵喵！本猫娘的胡须探测到了规律！你发现了吗？

-   从第二项开始，所有**偶数位置**的数 ($a_2, a_4, a_6, \dots$) 好像都是 $1$ 哎！
-   所有**奇数位置**的数 ($a_1, a_3, a_5, \dots$) 构成了 1, 2, 3, 4, 5, ... 这样一个序列！

我们可以大胆地猜想一下通项公式：
-   $a_1 = 1$
-   当 $i \ge 2$ 时：
    -   如果 $i$ 是偶数，那么 $a_i = 1$。
    -   如果 $i$ 是奇数，设 $i = 2k-1$，那么 $a_i = k$。也就是 $a_i = (i+1)/2$。

这个猜想对不对呢？我们可以用归纳法来简单验证一下，喵~
假设这个规律在第 $2k$ 项之前都成立 ($k \ge 2$)。序列的样子就是 1, 1, 2, 1, 3, 1, ..., k, 1。
1.  **求 $a_{2k+1}$**: 它的前一项是 $a_{2k}=1$。我们需要数一下在 $a_1, \dots, a_{2k}$ 中有多少个 $1$。这些 $1$ 分别是 $a_1, a_2, a_4, a_6, \dots, a_{2k}$。总共有 $1 + (k-1) + 1 = k+1$ 个。所以 $a_{2k+1} = k+1$。这正好符合我们的猜想，因为 $i=2k+1$ 是奇数，那么 $a_i = (i+1)/2 = (2k+2)/2 = k+1$。完美！
2.  **求 $a_{2k+2}$**: 它的前一项是 $a_{2k+1}=k+1$。我们需要数一下在 $a_1, \dots, a_{2k+1}$ 中有多少个 $k+1$。在我们刚算出来之前，序列里根本没有 $k+1$ 这个数，所以 $k+1$ 只在 $a_{2k+1}$ 出现过一次。所以 $a_{2k+2} = 1$。这也符合我们的猜想，因为 $i=2k+2$ 是偶数。

猜想成立！问题就变得非常简单啦！我们只需要对这个有规律的序列求和。

要求 $\sum_{i=1}^n a_i$，我们可以把它分成两部分：
1.  **偶数项的和**：从 $i=1$ 到 $n$ 有 $\lfloor n/2 \rfloor$ 个偶数。这些项的值都是 $1$。所以它们的和就是 $\lfloor n/2 \rfloor$。
2.  **奇数项的和**：从 $i=1$ 到 $n$ 有 $\lceil n/2 \rceil$ 个奇数。这些项的值分别是 $1, 2, 3, \dots, \lceil n/2 \rceil$。这是一个等差数列求和！它的和是 $\frac{\lceil n/2 \rceil \cdot (\lceil n/2 \rceil + 1)}{2}$。

所以，最终的答案就是：
$$
\text{总和} = \left( \frac{\lceil n/2 \rceil \cdot (\lceil n/2 \rceil + 1)}{2} \right) + \lfloor n/2 \rfloor
$$

在编程实现时，对于一个整数 n：
-   $\lfloor n/2 \rfloor$ 就是 n / 2。
-   $\lceil n/2 \rceil$ 可以用 (n + 1) / 2` 或者 `n - n / 2` 来计算。

这样，我们就能用一个简单的公式直接算出答案啦，是不是很高效呀，喵~

## 代码实现

这是本猫娘为你准备的一份 C++ 代码，注释超详细的哦！考虑到 $n$ 可能会非常大，我们用了 `__int128_t` 来确保计算不会溢出，这是一种可以存储更大数字的类型，非常安全！

```cpp
#include <iostream>
#include <string>
#include <algorithm> // 用于 std::reverse

// 这是一个用来打印 __int128 类型数字的函数，喵~
// 因为 iostream 不直接支持它，所以我们自己写一个！
void print_int128(__int128_t n) {
    if (n < 0) {
        std::cout << "-";
        n = -n;
    }
    if (n == 0) {
        std::cout << "0";
        return;
    }
    std::string s = "";
    while (n > 0) {
        s += (n % 10) + '0';
        n /= 10;
    }
    std::reverse(s.begin(), s.end());
    std::cout << s;
}

int main() {
    // 为了防止终端输入输出过慢，加一点小小的优化，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // 使用 long long 来读取 n，因为 n 可能很大
    long long n;
    std::cin >> n;

    // 为了防止计算过程中溢出，我们使用 __int128_t 来存储中间和最终结果
    // 这是一个128位的整数类型，比 long long 更大，更安全喵~
    __int128_t num_odd_terms;  // n 中奇数项的个数
    __int128_t num_even_terms; // n 中偶数项的个数

    // 计算奇数项和偶数项的数量
    // n / 2 是向下取整，得到偶数项的数量
    num_even_terms = n / 2;
    // n 减去偶数项的数量就是奇数项的数量，这相当于向上取整
    num_odd_terms = n - num_even_terms;

    // 奇数项的值构成了 1, 2, 3, ..., num_odd_terms 的等差数列
    // 它们的和是 (首项+末项)*项数/2，也就是 (1 + num_odd_terms) * num_odd_terms / 2
    __int128_t sum_odd = num_odd_terms * (num_odd_terms + 1) / 2;

    // 偶数项的值都是 1，所以它们的和就是偶数项的数量
    __int128_t sum_even = num_even_terms;

    // 总和就是奇数项的和加上偶数项的和
    __int128_t total_sum = sum_odd + sum_even;

    // 使用我们自己写的函数打印结果
    print_int128(total_sum);
    std::cout << std::endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(1)$
    我们的解法是基于一个数学公式的。无论输入的 $n$ 有多大，我们都只需要进行几次简单的算术运算（加、减、乘、除）。所以时间复杂度是常数级别的，超级快！

-   **空间复杂度**: $O(1)$
    我们只用了几个变量来存储输入的 `n` 和计算结果，没有使用任何随 `n 增长的额外空间（比如数组）。所以空间复杂度也是常数级别的，非常节省内存的说。

## 知识点总结

通过解决这道题，我们又变强了一点点，喵~

1.  **序列规律探索**: 解题的关键一步！面对复杂的递推关系，先手动算几项，观察规律，是屡试不爽的好方法。
2.  **数学归纳法**: 这是我们验证猜想正确性的有力武器。虽然在比赛中不一定要写出严格证明，但有这个思想能让我们对自己的结论更有信心。
3.  **等差数列求和**: $1+2+3+\dots+k = \frac{k(k+1)}{2}$，这个公式是算法竞赛中的常客，一定要牢记于心哦！
4.  **整型运算技巧**: 学会了如何用 n / 2` 和 `(n + 1) / 2`（或 `n - n/2）来快速计算 $\lfloor n/2 \rfloor$ 和 $\lceil n/2 \rceil$。
5.  **大数处理**: 认识到了 long long` 的局限性，并学会了使用 `__int128_t` 来处理可能超出 `long long` 范围的计算，避免溢出错误。这是成为一个细心程序员的重要一步呢！

希望这篇题解能帮助到你，加油哦，未来的算法大师！喵~