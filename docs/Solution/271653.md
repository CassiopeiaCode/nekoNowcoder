# 智乃的贸易站 - 题解

### 比赛与标签
> **比赛**: 牛客小白月赛91

> **标签**: 数论, 整除分块

> **难度**: *2543

## 题目大意喵~

nyaa~ 主人，这道题是关于智乃酱在罗德岛上经营贸易站的故事哦！

我们有 $M$ 个贸易站，编号从 $1$ 到 $M$。还有 $N$ 天的时间。

每个贸易站 $i$ 有两个属性：贸易等级 $L_i$ 和贸易点数 $P_i$。一开始，所有贸易站的 $L_i$ 和 $P_i$ 都是 $0$。

每天的生产和升级流程是这样的：
1.  **获得点数**：在第 $y$ 天，所有编号 $d$ 是 $y$ 的因子的贸易站（$d | y$ 且 $d \le M$），其贸易点数 $P_d$ 都会增加 1。
2.  **自动升级**：点数增加后，对于每个贸易站 $i$，如果它的点数 $P_i$ 大于等于 $L_i+1$，它就会消耗 $L_i+1$ 点数来升一级，即 $L_i$ 变成 $L_i+1$，$P_i$ 减去 $(L_i+1)$。这个过程会一直重复，直到 $P_i < L_i+1$ 为止。
3.  **生产龙门币**：升级完成后，每个贸易站 $i$ 会生产 $A \cdot L_i^2 + B \cdot P_i + C$ 个龙门币。

我们的任务就是计算从第 1 天到第 $N$ 天，所有贸易站生产的龙门币总和，结果需要对 $10^9+9$ 取模，喵~

## 解题思路分析

主人，这道题看起来有点复杂，涉及到每天的状态变化和累加求和。如果直接一天天、一个站一个站地模拟，当 $N$ 和 $M$ 很大的时候，肯定会超时啦！所以我们需要找到更聪明的办法，喵~

### 关键状态的简化

首先，我们来分析一下贸易站 $i$ 在第 $y$ 天的状态 $(L_{i,y}, P_{i,y})$ 是由什么决定的。

- **贸易点数**：贸易站 $i$ 在第 $y$ 天会获得点数，条件是 $i$ 是 $y$ 的因子。那么到第 $y$ 天结束时，贸易站 $i$ 总共获得的点数，就是 $1$ 到 $y$ 之间 $i$ 的倍数的数量。这个数量正好是 $\lfloor y/i \rfloor$ 呢！

- **贸易等级**：升级需要消耗点数。从 0 级升到 1 级需要 $1$ 点，从 1 级升到 2 级需要 $2$ 点，...，从 $(L-1)$ 级升到 $L$ 级需要 $L$ 点。所以，要升到 $L$ 级，总共需要消耗的点数是 $1+2+\dots+L = \frac{L(L+1)}{2}$。

所以，如果一个贸易站 $i$ 在第 $y$ 天总共获得了 $T_{i,y} = \lfloor y/i \rfloor$ 个点数，它的等级 $L_{i,y}$ 就会是满足 $\frac{L(L+1)}{2} \le T_{i,y}$ 的最大整数 $L$。

- **剩余点数**：升到 $L_{i,y}$ 级后，剩余的点数 $P_{i,y}$ 就是总点数减去升级消耗的点数：
$$
P_{i,y} = T_{i,y} - \frac{L_{i,y}(L_{i,y}+1)}{2} = \lfloor \frac{y}{i} \rfloor - \frac{L_{i,y}(L_{i,y}+1)}{2}
$$

这样一来，我们就可以在任意时刻 $y$ 直接计算出任意贸易站 $i$ 的状态啦！

### 重新组织求和公式

我们的目标是计算总产量：
$$
\text{Total} = \sum_{y=1}^{N} \sum_{i=1}^{M} (A \cdot L_{i,y}^2 + B \cdot P_{i,y} + C)
$$
把 $P_{i,y}$ 的表达式代入，可以得到一个只和 $L_{i,y}$ 与 $\lfloor y/i \rfloor$ 有关的式子。不过，直接计算这个双重求和还是太慢了。

我们可以交换求和的顺序，先对每个贸易站 $i$ 计算它在 $N$ 天内的总产量，然后再把所有贸易站的贡献加起来：
$$
\text{Total} = \sum_{i=1}^{M} \left( \sum_{y=1}^{N} \text{Production}(i, y) \right)
$$
其中 $\text{Production}(i, y)$ 是贸易站 $i$ 在第 $y$ 天的产量。

对于一个固定的贸易站 $i$，它的状态只取决于 $k = \lfloor y/i \rfloor$。我们可以定义一个函数 $f(k)$ 表示当总获得点数为 $k$ 时的日产量。
令 $L(k)$ 为满足 $\frac{L(L+1)}{2} \le k$ 的最大 $L$，则：
$$
f(k) = A \cdot L(k)^2 + B \cdot \left(k - \frac{L(k)(L(k)+1)}{2}\right) + C
$$
那么贸易站 $i$ 的总贡献就是 $\sum_{y=1}^{N} f(\lfloor y/i \rfloor)$。

### 整除分块大显神威！

现在问题变成了计算 $\sum_{i=1}^{M} \sum_{y=1}^{N} f(\lfloor y/i \rfloor)$。
对于内层的和 $\sum_{y=1}^{N} f(\lfloor y/i \rfloor)$，$\lfloor y/i \rfloor$ 的值是分段不变的。但这还不够快。

我们注意到，外层求和中的 $\sum_{y=1}^{N} f(\lfloor y/i \rfloor)$ 这一项，它的值会随着 $i$ 的变化而变化。但是，它的计算结构依赖于 $\lfloor N/i \rfloor$。这是一个强烈的信号，告诉我们可以使用**整除分块**（也叫数论分块）来优化外层的求和！

对于一个 $l$，我们可以找到一个最大的 $r \ge l$，使得对于所有 $i \in [l, r]$，$\lfloor N/i \rfloor$ 的值都等于一个常量 $V = \lfloor N/l \rfloor$。这个 $r$ 可以通过 $r = \min(M, \lfloor N/V \rfloor)$ 算出来。

现在，我们来分析在一个块 $[l, r]$ 内，所有贸易站的总贡献。
对于任意一个 $i \in [l, r]$，它在 $N$ 天内的总贡献是：
$$
\text{Contribution}(i) = \sum_{y=1}^{N} f(\lfloor y/i \rfloor)
$$
令 $K = \lfloor N/i \rfloor = V$。
当 $y$ 从 $1$ 遍历到 $N$ 时，$\lfloor y/i \rfloor$ 会取值为 $0, 1, \dots, V-1$, 最后是 $V$。
- 对于每个值 $k \in [0, V-1]$，$\lfloor y/i \rfloor = k$ 发生在 $y \in [ki, (k+1)i-1]$，这样的 $y$ 有 $i$ 个。
- 对于值 $V$，$\lfloor y/i \rfloor = V$ 发生在 $y \in [Vi, N]$，这样的 $y$ 有 $N - Vi + 1$ 个。

所以，$\text{Contribution}(i) = \sum_{k=0}^{V-1} i \cdot f(k) + (N - Vi + 1) \cdot f(V)$。
令 $S_f(V) = \sum_{k=0}^{V-1} f(k)$，那么上式可以写成：
$$
\text{Contribution}(i) = i \cdot S_f(V) + (N+1)f(V) - i \cdot V f(V) = i \cdot (S_f(V) - V f(V)) + (N+1)f(V)
$$
这是一个关于 $i$ 的一次函数！对于整个块 $[l, r]$ 的总贡献就是：
$$
\sum_{i=l}^{r} \text{Contribution}(i) = (S_f(V) - V f(V)) \sum_{i=l}^{r} i + (N+1)f(V) \sum_{i=l}^{r} 1
$$
$\sum i$ 是等差数列求和，$\sum 1$ 就是区间的长度。这两项我们都能快速计算。

### 如何快速计算 $f(k)$ 和 $S_f(k)$？

剩下的问题就是如何为给定的 $V$ 快速计算 $f(V)$ 和 $S_f(V) = \sum_{k=0}^{V-1} f(k)$。

- **计算 $f(k)$**:
  首先要找到 $L(k)$。$L(k) \approx \sqrt{2k}$。我们可以用 `sqrt` 估算一个值，再微调一下得到精确值。
  $L(k) = \lfloor \frac{\sqrt{8k+1}-1}{2} \rfloor$。用 `long double` 的 `sqrt` 保证精度就没问题啦。
  得到 $L(k)$ 后，代入公式即可计算 $f(k)$。

- **计算 $S_f(K) = \sum_{k=0}^{K-1} f(k)$**:
  这个是前缀和。$f(k)$ 的公式展开后是关于 $L(k)$ 和 $k$ 的多项式。对它求和，就是对 $L(k)^2, L(k), k, 1$ 这些项分别求和。
  $\sum k$ 和 $\sum 1$ 很简单。
  $\sum L(k)^p$ (其中 $p=1,2$) 的计算方法和我们上面分析 $\text{Contribution}(i)$ 类似。$L(k)$ 的值也是分段不变的。$L(k)$ 等于 $L_{val}$ 的 $k$ 的范围是 $[\frac{L_{val}(L_{val}+1)}{2}, \frac{(L_{val}+1)(L_{val}+2)}{2}-1]$，共有 $L_{val}+1$ 个。
  所以 $\sum_{k=0}^{K-1} L(k)^p$ 可以分解成对 $L_{val}$ 的求和。
  $$
  \sum_{k=0}^{K-1} L(k)^p = \sum_{L_{val}=0}^{L_{max}-1} (L_{val}+1) L_{val}^p + (K - \frac{L_{max}(L_{max}+1)}{2}) \cdot L_{max}^p
  $$
  其中 $L_{max} = L(K-1)$。
  $\sum (L+1)L^p = \sum L^{p+1} + \sum L^p$。这些都是自然数幂和，有现成的公式！
  $\sum_{i=1}^n i = \frac{n(n+1)}{2}$
  $\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$
  $\sum_{i=1}^n i^3 = (\frac{n(n+1)}{2})^2$
  
  所以，我们只要写好自然数幂和的函数，就能在 $O(1)$ 时间内算出 $S_f(K)$ 啦！

### 算法总览

1.  预处理模 $10^9+9$ 下的 2 和 6 的逆元。
2.  实现自然数幂和函数 `s1(n), s2(n), s3(n)`。
3.  实现 `calc_f(k)` 和 `calc_S_f(K)`。
4.  使用整除分块，对 $i$ 从 1 到 $M$ 进行分块处理。
5.  在每个块 $[l, r]$ 内，计算出 $V = \lfloor N/l \rfloor$，然后调用 `calc_f(V)` 和 `calc_S_f(V)`，套用我们推导出的公式计算块贡献，累加到总答案。
6.  最后输出总答案就大功告成啦，喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦~ 每个变量和函数都有清晰的注释，希望能帮到主人！

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

// 使用 long long 防止中间计算溢出
using i64 = long long;
// 使用 __int128 来处理可能超过 long long 的乘法
using i128 = __int128;

// 模数
const i64 MOD = 1000000009;

// 预计算的模逆元
i64 INV2, INV6;

// 模块化快速幂，用于计算逆元
i64 power(i64 base, i64 exp) {
    i64 res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (i128)res * base % MOD;
        base = (i128)base * base % MOD;
        exp /= 2;
    }
    return res;
}

// 计算 n 在模 MOD 下的逆元
i64 modInverse(i64 n) {
    return power(n, MOD - 2);
}

// --- 自然数幂和公式 ---
// sum of i from 1 to n
i64 s1(i64 n) {
    n %= MOD;
    i64 term1 = n;
    i64 term2 = (n + 1) % MOD;
    return (i128)term1 * term2 % MOD * INV2 % MOD;
}

// sum of i^2 from 1 to n
i64 s2(i64 n) {
    n %= MOD;
    i64 term1 = n;
    i64 term2 = (n + 1) % MOD;
    i64 term3 = (2 * n + 1) % MOD;
    return (i128)term1 * term2 % MOD * term3 % MOD * INV6 % MOD;
}

// sum of i^3 from 1 to n
i64 s3(i64 n) {
    i64 term = s1(n);
    return (i128)term * term % MOD;
}

// --- 核心计算函数 ---
i64 N, M, A, B, C;

// 根据总点数 k，计算对应的等级 L(k)
// L(L+1)/2 <= k, L^2+L-2k <= 0
// L <= (sqrt(8k+1)-1)/2
i64 find_level(i64 total_points) {
    if (total_points < 0) return 0;
    i64 l_approx = sqrtl(2.0L * total_points);
    // 向下调整，确保 T(l) <= k
    while ((i128)l_approx * (l_approx + 1) / 2 > total_points) {
        l_approx--;
    }
    // 向上调整，找到最大的 l
    while ((i128)(l_approx + 1) * (l_approx + 2) / 2 <= total_points) {
        l_approx++;
    }
    return l_approx;
}

// 计算当总点数为 k 时的日产量 f(k)
i64 calc_f(i64 k) {
    if (k < 0) return 0;
    i64 level = find_level(k);
    i64 level_sq = (i128)level * level % MOD;
    i64 points_cost = (i128)level * (level + 1) / 2;
    i64 remaining_points = (k - points_cost) % MOD;

    i64 production = ((i128)A * level_sq % MOD + (i128)B * remaining_points % MOD + C) % MOD;
    return (production + MOD) % MOD;
}

// 计算 f(k) 的前缀和 S_f(K) = sum_{k=0}^{K-1} f(k)
i64 calc_S_f(i64 K) {
    if (K <= 0) return 0;
    // f(k) = (A - B/2)L(k)^2 - (B/2)L(k) + B*k + C
    // 我们需要计算 sum(L(k)^2), sum(L(k)), sum(k), sum(1)
    
    i64 L_max = find_level(K - 1);
    i64 T_L_max = (i128)L_max * (L_max + 1) / 2;

    // 计算 sum_{k=0}^{K-1} L(k)
    i64 sum_L_full_levels = (s2(L_max - 1) + s1(L_max - 1)) % MOD;
    i64 sum_L_last_level = (i128)(K - T_L_max) % MOD * (L_max % MOD) % MOD;
    i64 total_sum_L = (sum_L_full_levels + sum_L_last_level) % MOD;

    // 计算 sum_{k=0}^{K-1} L(k)^2
    i64 sum_L2_full_levels = (s3(L_max - 1) + s2(L_max - 1)) % MOD;
    i64 L_max_sq = (i128)(L_max % MOD) * (L_max % MOD) % MOD;
    i64 sum_L2_last_level = (i128)(K - T_L_max) % MOD * L_max_sq % MOD;
    i64 total_sum_L2 = (sum_L2_full_levels + sum_L2_last_level) % MOD;

    // 计算 sum_{k=0}^{K-1} k
    i64 total_sum_k = s1(K - 1);

    // 计算 sum_{k=0}^{K-1} 1
    i64 total_sum_1 = K % MOD;

    // 组合各项
    i64 term_L2 = (i128)(A - (i128)B * INV2 % MOD + MOD) % MOD * total_sum_L2 % MOD;
    i64 term_L = (i128)(- (i128)B * INV2 % MOD + MOD) % MOD * total_sum_L % MOD;
    i64 term_k = (i128)B * total_sum_k % MOD;
    i64 term_1 = (i128)C * total_sum_1 % MOD;

    i64 total_S_f = (term_L2 + term_L + term_k + term_1) % MOD;
    return (total_S_f + MOD) % MOD;
}

int main() {
    // 加速输入输出
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 初始化逆元
    INV2 = modInverse(2);
    INV6 = modInverse(6);

    cin >> N >> M >> A >> B >> C;
    A %= MOD; B %= MOD; C %= MOD;
    if (A < 0) A += MOD;
    if (B < 0) B += MOD;
    if (C < 0) C += MOD;

    i64 total_production = 0;

    // 整除分块
    for (i64 l = 1; l <= M; ) {
        i64 V = N / l;
        if (V == 0) { // 对于 l > N, 产量总是 C
            i64 num_stations = M - l + 1;
            i64 days = N;
            total_production = (total_production + (i128)num_stations % MOD * (days % MOD) % MOD * C % MOD) % MOD;
            break;
        }
        i64 r = min(M, N / V);

        i64 f_V = calc_f(V);
        i64 S_f_V = calc_S_f(V);

        i64 term1_factor = (S_f_V - (i128) (V % MOD) * f_V % MOD + MOD) % MOD;
        i64 term2_factor = (i128) ((N + 1) % MOD) * f_V % MOD;

        i64 sum_i_in_block = (s1(r) - s1(l - 1) + MOD) % MOD;
        i64 count_i_in_block = (r - l + 1);

        i64 block_contribution = ((i128)term1_factor * sum_i_in_block % MOD + (i128)term2_factor * (count_i_in_block % MOD) % MOD) % MOD;
        
        total_production = (total_production + block_contribution) % MOD;

        l = r + 1;
    }

    cout << (total_production + MOD) % MOD << endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(\min(M, \sqrt{N}))$
  算法的核心是整除分块。我们对贸易站编号 $i$ 从 $1$ 到 $M$ 进行分块，分块的依据是 $\lfloor N/i \rfloor$ 的值。这样的块数是 $O(\sqrt{N})$。同时，由于 $i$ 最大只到 $M$，所以总的块数是 $O(\min(M, \sqrt{N}))$。在每个块内部，我们的计算（包括 `calc_f` 和 `calc_S_f`）都依赖于自然数幂和公式，其复杂度为 $O(1)$。因此，总时间复杂度由分块的块数决定。

- **空间复杂度**: $O(1)$
  我们只使用了几个变量来存储输入和中间计算结果，没有使用任何随输入规模增大的数据结构，所以空间复杂度是常数级别的，喵~

## 知识点总结

这道题真是一次有趣的冒险呢，主人！我们用到了不少好玩的工具：

1.  **问题转化**: 把复杂的每日状态演变问题，转化为一个可以用数学公式直接计算任意时刻状态的问题。这是解题的第一步，也是最关键的一步！
2.  **整除分块 (数论分块)**: 这是解决形如 $\sum_{i=1}^n f(\lfloor n/i \rfloor)$ 的求和问题的强大武器。通过把具有相同 $\lfloor n/i \rfloor$ 值的 $i$ 分成一块处理，大大降低了计算量。
3.  **自然数幂和**: 在计算前缀和 $S_f(K)$ 时，我们巧妙地把问题分解，最终归结为计算 $\sum i, \sum i^2, \sum i^3$。记住这些公式能在很多数论和组合问题中派上用场哦！
4.  **模块化算术**: 所有计算都在模 $10^9+9$ 下进行，要小心处理减法可能产生的负数，以及除法需要用模逆元来代替。

希望这篇题解能帮到主人哦！如果还有不明白的地方，随时可以再来问本猫娘，喵~ >w<