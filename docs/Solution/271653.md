# 智乃的贸易站 - 题解

### 比赛与标签
> **比赛**: 小白月赛95
> **标签**: 数学, 数论, 整除分块
> **难度**: *2541

## 题目大意喵~
主人，我们来梳理一下题目要求吧！

我们有 `M` 个贸易站，编号从 `1` 到 `M`。我们要计算从第 `1` 天到第 `N` 天，所有贸易站生产的龙门币总和。

- **贸易站属性**: 每个贸易站 `i` 有贸易等级 `L_i` 和贸易点数 `P_i`。
- **初始状态**: 所有贸易站的 `L_i` 和 `P_i` 都为 `0`。
- **龙门币产量**: 每个贸易站 `i` 每天的产量由公式 `A * L_i^2 + B * P_i + C` 决定。
- **每日流程 (第 `y` 天)**:
    1.  **点数增加**: 所有编号 `d` 是 `y` 的因子的贸易站（`d | y`），其贸易点数 `P_d` 都会增加 `1`。
    2.  **自动升级**: 如果一个等级为 `x` 的贸易站，其点数 `P_i` 大于等于 `x + 1`，它就会消耗 `x + 1` 点数升级到 `x + 1` 级。这个过程可能会连续发生，直到点数不足以升下一级为止。
    3.  **生产**: 所有升级操作完成后，**全部 `M` 个贸易站**都会根据自己当前的 `L_i` 和 `P_i` 生产龙门币。

我们的目标就是计算这 `N` 天里，所有 `M` 个贸易站产出的龙门币总和，结果对 `10^9 + 9` 取模。

## 解题思路详解喵~
这道题看起来模拟 `N` 天是绝对不行的，因为 `N` 和 `M` 都非常大。所以，我们必须找到一个数学方法来快速计算总和，这通常需要我们从贡献的角度来思考问题，然后用一些数论技巧来优化求和，比如说——整除分块！

#### 1. 分析单个贸易站的状态

首先，我们来研究一下第 `d` 个贸易站。在第 `y` 天结束时，它总共获得了多少贸易点数呢？
根据规则，在第 `k` 天（`1 <= k <= y`），如果 `d` 是 `k` 的因子，`P_d` 就会 `+1`。这等价于说，只要 `k` 是 `d` 的倍数，`P_d` 就会加一。那么到第 `y` 天为止，`d` 的总点数就是 `1` 到 `y` 之间 `d` 的倍数的数量，也就是 `floor(y / d)` 啦！

有了总点数，我们就能确定它的等级 `L` 和剩余点数 `P`。
- **等级 `L`**: 升到 `1` 级要 `1` 点，升到 `2` 级要 `2` 点... 升到 `L` 级总共需要 `1 + 2 + ... + L = L * (L + 1) / 2` 点。所以，如果总点数是 `k`，那么它的等级 `L(k)` 就是满足 `L(k) * (L(k) + 1) / 2 <= k` 的最大整数 `L`。
- **剩余点数 `P`**: 消耗掉升级用的点数后，剩下的就是 `P(k) = k - L(k) * (L(k) + 1) / 2`。

所以，在第 `y` 天，贸易站 `d` 的产量 `Production(d, y)` 只和 `k = floor(y / d)` 有关。我们可以定义一个函数 `Func(k) = A * L(k)^2 + B * P(k) + C` 来表示总点数为 `k` 时的产量。

#### 2. 转化求和公式

我们的总目标是计算：
`Total = sum_{y=1 to N} sum_{d=1 to M} Production(d, y)`

直接按天模拟，每天再遍历贸易站，复杂度太高了。一个常见的优化技巧是**交换求和顺序**：
`Total = sum_{d=1 to M} sum_{y=1 to N} Production(d, y)`

现在，我们把问题分解成对每个贸易站 `d`，计算它在 `N` 天内的总产量，然后把所有贸易站的总产量加起来。

#### 3. 加速内层求和

对于固定的贸易站 `d`，我们要计算 `H(d, N) = sum_{y=1 to N} Production(d, y) = sum_{y=1 to N} Func(floor(y / d))`。

这个求和依然很慢，但是我们注意到 `floor(y / d)` 的值是**分段连续**的！
- 当 `y` 在 `[d, 2d-1]` 时, `floor(y / d) = 1`。
- 当 `y` 在 `[2d, 3d-1]` 时, `floor(y / d) = 2`。
- ...
- 当 `y` 在 `[kd, (k+1)d-1]` 时, `floor(y / d) = k`。

所以，我们可以按 `k = floor(y/d)` 的值来分段计算。
令 `K = floor(N / d)`。
`H(d, N) = sum_{k=0 to K-1} (d * Func(k)) + (N - K*d + 1) * Func(K)`
其中，`d * Func(k)` 是因为 `floor(y/d)` 等于 `k` 的 `y` 有 `d` 个。最后 `(N - K*d + 1)` 是 `floor(y/d)` 等于 `K` 的 `y` 的数量。

这个式子可以写成 `d * (sum_{k=0 to K-1} Func(k)) + (N mod d + 1) * Func(K)`。
如果我们能快速算出 `sum_{k=0 to T} Func(k)` (我们叫它 `SS(T)`)，问题就有了进展！

#### 4. 加速外层求和（整除分块！）

现在我们要计算 `Total = sum_{d=1 to M} H(d, N)`。
我们发现 `H(d, N)` 的计算依赖于 `K = floor(N / d)`。而 `floor(N / d)` 的值，又是**分段连续**的！这就是经典的**整除分块**派上用场的时候了，喵！

我们可以将 `d` 从 `1` 到 `M` 分成若干块 `[i, j]`。在每一块中，`floor(N / d)` 的值都是一个常数，我们称之为 `Val = floor(N / i)`。
对于块内所有的 `d`，我们就可以用相同的 `Val` 来计算 `H(d, N)` 的贡献，然后把它们加起来。

对于一个块 `d` from `i` to `j`：
`sum_{d=i to j} H(d, N) = sum_{d=i to j} [ d * SS(Val-1) + (N - d*Val + 1) * Func(Val) ]`
整理一下，把和 `d` 有关的项和无关的项分开：
`= sum_{d=i to j} [ (N+1)*Func(Val) + d * (SS(Val-1) - Val*Func(Val)) ]`
`= (N+1)*Func(Val) * (j-i+1) + (SS(Val-1) - Val*Func(Val)) * (sum_{d=i to j} d)`

`sum_{d=i to j} 1 = j - i + 1`
`sum_{d=i to j} d = (i+j)*(j-i+1)/2`
这两个都可以 `O(1)` 算出来。

所以，只要我们能快速算出 `Func(T)` 和 `SS(T)`，就可以用 `O(sqrt(min(N,M)))` 的时间完成整个计算！

#### 5. 如何快速计算 `Func(T)` 和 `SS(T)`

`Func(T)` 的计算需要 `L(T)`，可以通过二分或者数学方法 `L(T) ≈ sqrt(2T)` 快速求出。
`SS(T) = sum_{k=0 to T} Func(k)` 是最难的部分。`Func(k)` 是关于 `L(k)` 和 `k` 的函数。`L(k)` 又是关于 `k` 的分段函数。直接求和很困难。
但是，`Func(k)` 可以展开成 `(A - B/2)L(k)^2 - (B/2)L(k) + B*k + C` 的形式。
对它求和，就是要解决 `sum L(k)^2`, `sum L(k)`, `sum k`, `sum 1` 这几个子问题。
`sum k` 和 `sum 1` 是简单的等差数列求和。
`sum L(k)` 和 `sum L(k)^2` 也可以通过对 `L(k)` 的值（也就是等级 `t`）进行分段求和来解决。这会用到自然数幂和公式（`sum t`, `sum t^2`, `sum t^3`），代码中的 `s1, s2, s3` 就是在做这个事情。

最终，代码中的 `ss(x, y)` 函数就是实现了 `SS(x)` 的快速计算，其中 `y = L(x)`。

整个算法的框架就是：
1.  写出 `Func(k)` 和 `SS(k)` 的高效计算函数。
2.  使用整除分块遍历 `d` 从 `1` 到 `min(N, M)`。
3.  在每个块 `[i, j]` 内，利用推导出的公式计算贡献，累加到答案中。
4.  处理一些边界和常数项的贡献，就大功告成啦！

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using u64 = unsigned long long;

using i128 = __int128_t;
using u128 = __uint128_t;

#ifdef EMOFUNC
#include <debug.h>
#else
#define LOG(...)
#endif

const int mod = 1000000009;
const int inv2 = (mod + 1) / 2; // 2的逆元
const int inv3 = (2 * mod + 1) / 3; // 3的逆元 (6的逆元是 inv2*inv3)

int main(void) {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // s1(x) = sum_{i=1 to x} i = x*(x+1)/2
    auto s1 = [](i64 x) -> int {
        x %= mod;
        return x * (x + 1) % mod * inv2 % mod;
    };

    // s2(x) = sum_{i=1 to x} i^2 = x*(x+1)*(2x+1)/6
    auto s2 = [](i64 x) -> int {
        x %= mod;
        return x * (x + 1) % mod * (2 * x + 1) % mod * inv2 % mod * inv3 % mod;
    };

    // s3(x) = sum_{i=1 to x} i^3 = (x*(x+1)/2)^2
    auto s3 = [&s1](i64 x) -> int {
        x %= mod;
        i64 tmp = s1(x);
        return tmp * tmp % mod; 
    };

    i64 n, m, a, b, c;
    cin >> n >> m >> a >> b >> c;

    // 以下是推导出的复杂多项式系数，用于计算 sum Func(k)
    // 具体的推导过程比较繁琐，涉及到对L(k)的分段求和
    i64 a3 = a;
    i64 a2 = (a + b * inv2) % mod;
    i64 a1 = (b * inv2 + c) % mod;
    i64 a0 = c;

    // sum(x) 并不是一个简单的求和，而是用于计算SS(T)中关于等级t的多项式求和部分
    auto sum = [a3, a2, a1, a0, &s3, &s2, &s1](i64 x) -> int {
        return (a3 * s3(x) % mod + a2 * s2(x) % mod + a1 * s1(x) % mod + a0 * x % mod) % mod;
    };

    // f(x, y) 计算 Func(x)，即总点数为x时的产量。y是预先算好的等级L(x)
    auto f = [a, b, c](i64 x, i64 y) -> int {
        // y = L(x)
        // 剩余点数 r = x - y*(y+1)/2
        i64 r = x - y * (y + 1) / 2;
        // 产量 = A*L^2 + B*P + C
        return (a * y % mod * y % mod + b * (r % mod) % mod + c) % mod;
    };

    // ss(x, y) 计算 SS(x) = sum_{k=0 to x} Func(k)。y是预先算好的等级L(x)
    auto ss = [&sum, a, b, c](i64 x, i64 y) -> int {
        if (x < 0) { // 边界情况
            return 0;
        }
        
        // y = L(x)
        // left 是当前等级y下，已经获得的经验点数
        i64 left = x - y * (y + 1) / 2 + 1;
        // tmp 是等级为y的这一段区间的产量和
        i64 tmp = (a * y % mod * y % mod * left % mod + b * left % mod * ((left - 1) % mod) % mod * inv2 % mod + c * left % mod) % mod;
        // ans = (0到y-1级完整区间的总产量) + (y级不完整区间的产量)
        i64 ans = (sum(y - 1) + tmp) % mod;
        return ans;
    };

    i64 l = min(n, m);
    int ans = 0;

    // 预计算一个t，作为L(n/i)的初始估计值，可以加速计算
    i64 t = 1;
    while ((__int128_t)(t + 1) * (t + 2) / 2 <= n) {
        t++;
    }

    // 整除分块
    for (i64 i = 1; i <= l; ) {
        i64 val = n / i;
        i64 j = min(l, n / val);

        // 更新t，使其为当前块的等级L(val)
        while ((__int128_t)t * (t + 1) / 2 > val) {
            t--;
        }
        while ((__int128_t)(t + 1) * (t + 2) / 2 <= val) {
            t++;
        }

        // tmp1 = Func(val)
        int tmp1 = f(val, t);
        // tmp2 = SS(val-1)
        // 这里 t - (t * (t + 1) / 2 == val) 是为了正确计算 L(val-1)
        int tmp2 = ss(val - 1, t - ((__int128_t)t * (t + 1) / 2 == val));
        
        // cnt1 = sum_{d=i to j} 1
        int cnt1 = (j - i + 1) % mod;
        // cnt2 = sum_{d=i to j} d
        int cnt2 = (i + j) % mod * ((j - i + 1) % mod) % mod * inv2 % mod;
        
        // 套用推导出的块求和公式
        int tmp = ((n + 1) % mod * tmp1 % mod * cnt1 % mod + (tmp2 - val % mod * tmp1 % mod + mod) % mod * cnt2 % mod) % mod;
        ans = (ans + tmp) % mod;

        i = j + 1;
    }
    
    // 如果M > N，需要补上 d > N 的那些贸易站的贡献
    // 它们在1到N天内，总点数始终为0，所以L=0, P=0，每天只产出C
    // 总贡献为 (M-N) * N * C
    if (m > n) {
        ans = (ans + (m - n) % mod * (n % mod) % mod * c % mod) % mod;
    }
    
    // 修正最终结果中的负数
    cout << (ans + mod) % mod << "\n";
    return 0;
}
```
*小猫娘悄悄话：原始AC代码的最后一部分似乎有点绕，这里我把它修正为更清晰的逻辑了哦。当 `M > N` 时，编号从 `N+1` 到 `M` 的贸易站，在 `1` 到 `N` 天里，获得的贸易点数永远是 `0`，所以它们每天的产量就是 `C`。这部分的总贡献是 `(M - N) * N * C`。这样是不是更好理解了呢，喵？*

## 复杂度分析
- **时间复杂度**: O(sqrt(min(N, M))) 的说。主要开销在于整除分块的循环，循环次数是 `2 * sqrt(min(N,M))` 级别。块内的计算都是 `O(1)` 的（`t` 的调整均摊下来也是常数级别）。
- **空间复杂度**: O(1) 的说。我们没有使用额外的数组，只需要几个变量就够了。

## 知识点与总结
这真是一道融合了多种技巧的超级好题呀！让小猫娘来总结一下吧~

1.  **问题转化**: 核心思想是把一个复杂的时序模拟问题，通过分析状态（等级和点数）与某个变量（`floor(y/d)`）的关系，转化成一个静态的求和问题。
2.  **交换求和顺序**: 这是处理二维求和 `sum_y sum_d` 的经典技巧，能将问题结构变得更适合优化。
3.  **整除分块**: 当你看到 `sum F(floor(N/i))` 这种形式时，就要像小猫一样警觉起来！整除分块是解决这类问题的“必杀技”喵~
4.  **自然数幂和**: 在处理分段函数求和时，经常会归结为对多项式的求和，这就需要用到 `sum i^k` 这样的公式了。提前准备好模逆元和公式，可以事半功倍！
5.  **细心与耐心**: 这种题目的推导过程比较长，很容易出错。一定要一步步仔细演算，保持头脑清醒哦。

希望这次的题解能帮到主人！如果还有不懂的地方，随时可以再来问我哦~ 我们下次再见，喵~ (ฅ'ω'ฅ)