# 给你 q 个数组 - 题解

### 比赛与标签
> **比赛**: NowCoder

> **标签**: 思维, 模拟

> **难度**: *1420

## 题目大意喵~

主人你好呀~ 这道题是这样哒：

我们收到了 `q` 个小数组。我们的任务是，像玩积木一样，把这 `q` 个数组里的所有数字，合并成一个长长的新数组 `A`。

在合并的时候，有两个非常重要的规则哦：

1.  **保持相对顺序**: 每个数字在它原来所在的小数组里的前后位置关系不能改变。比如说，如果原来有个数组是 `{10, 20}`，那么在最终的大数组 `A` 里，`10` 也必须出现在 `20` 的前面，喵~
2.  **最终是连续数组**: 合并成功后的新数组 `A` 必须是一个“连续数组”。所谓的“连续数组”，就是指数组里的数字是严格递增的，并且后一个数恰好比前一个数大 1。比如 `{2, 3, 4, 5}` 就是一个完美的连续数组，而 `{2, 3, 5}` 就不是，因为它跳过了 `4`，不可爱！

我们需要判断，是否存在一种合并方法，能够满足以上所有条件，造出一个“好数组”。如果可以，就告诉世界 "YES"，如果不可以，就只好遗憾地回答 "NO" 啦。

## 解题思路分析

这道题看起来像是在玩一个复杂的拼图游戏呢，喵~ 但别担心，只要我们抓住问题的核心，就能轻松解决！让本猫娘带你一步步分析吧！

首先，我们最终的目标是得到一个**连续数组**。一个连续数组长什么样呢？它一定是形如 `{x, x+1, x+2, ..., y}` 的样子。这给了我们两个重要的启示：

1.  **元素唯一且无间隙**: 如果我们把所有输入的小数组里的数字都倒进一个大袋子里，那么这个袋子里的所有数字，必须正好能组成从某个最小值 `min_val` 到某个最大值 `max_val` 的完整序列。这意味着：
    *   不能有重复的数字。比如，如果袋子里有两个 `5`，那就不可能排成连续数组了。
    *   在 `min_val` 和 `max_val` 之间不能缺少任何数字。比如，有 `3` 和 `5` 但没有 `4`，那也是不行的。

2.  **顺序严格递增**: 最终的数组 `A` 必须是严格递增的。

现在，我们再回头看看题目给的那个“保持相对顺序”的约束。这个约束是解题的关键哦！

如果某个小数组是 `{8, 6}`，题目要求在最终的数组 `A` 中，`8` 必须出现在 `6` 的前面。但是，一个连续数组必须是 `{..., 6, 7, 8, ...}` 这样严格递增的，`6` 应该在 `8` 的前面才对呀！这就产生了一个无法解决的矛盾，喵呜~

所以，我们立刻可以得到第一个**必要条件**:

**条件一：所有输入的小数组内部，必须本身就是严格递增的。**
如果在任何一个小数组中，出现了 `a[i] <= a[i-1]` 的情况，那么我们就可以直接判定无法构成最终的连续数组，直接输出 "NO" 就好啦！因为这个小数组内部的顺序要求，已经和最终连续数组的严格递增要求冲突了。

好了，如果我们检查了所有小数组，它们内部都是严格递增的，是不是就一定可以了呢？

还没那么简单哦，我们还要考虑刚才提到的“元素唯一且无间隙”的问题。

**条件二：将所有小数组的元素汇集起来，必须构成一个从全局最小值到全局最大值的无重复、无遗漏的完整序列。**

我们可以这样做：
1.  在读取所有数字的时候，顺便记录下所有数字中的全局最小值 `global_min` 和全局最大值 `global_max`。
2.  同时，我们用一个哈希表（在 C++ 中就是 `std::map`）来统计每个数字出现的次数。
3.  当所有数字都读取完毕后，我们来检查一下。从 `global_min` 到 `global_max` 的每一个整数，它在我们统计的哈希表里的出现次数是不是都**恰好为 1**？
    *   如果某个数字的出现次数是 `0`，说明这个数字缺失了，无法形成连续序列。
    *   如果某个数字的出现次数大于 `1`，说明这个数字重复了，也无法形成连续序列。

只要以上两个条件**同时满足**，我们就能拍着胸脯保证，一定可以合并成一个好数组！为什么呢？因为条件一保证了没有内部的顺序矛盾，条件二保证了我们有且仅有所有需要的“积木块”。我们可以用类似归并排序的“多路归并”思想，每次从所有小数组的当前首部中，选出最小的那个数字放到最终数组 `A` 中。由于条件一和条件二都满足，这个过程总能顺利地、不重不漏地按顺序取出 `global_min, global_min+1, ... global_max`。

总结一下我们的解题策略：
1.  遍历所有 `q` 个数组。
2.  在遍历时，检查每个数组内部是否严格递增（**条件一**）。
3.  同时，将所有数字存入一个 `map` 中进行计数，并找出全局的 `min` 和 `max`。
4.  所有输入读取完毕后，检查从 `min` 到 `max` 的所有整数，在 `map` 中的计数是否均为 `1`（**条件二**）。
5.  如果两个条件都通过，则输出 "YES"，否则输出 "NO"。

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的代码哦~ 注释超详细的，快来看看吧！

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

int main() {
    // 为了更快的输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int q; // q 个小数组
    std::cin >> q;

    // 用 map 来统计每个数字出现的次数
    std::map<int, int> frequency_map;
    
    // 初始化全局最小值和最大值
    int global_min = 2e9; // 一个足够大的数
    int global_max = -2e9; // 一个足够小的数
    
    bool is_possible = true; // 一个标志，判断是否可能构成好数组

    for (int i = 0; i < q; ++i) {
        int k; // 当前数组的元素个数
        std::cin >> k;

        int prev_val = -1; // 用来存储上一个读入的数字，用于检查单调性

        for (int j = 0; j < k; ++j) {
            int current_val;
            std::cin >> current_val;

            // 如果已经确定不可能了，后面的数字读进来就好，不用再判断了
            if (!is_possible) {
                continue;
            }

            // 1. 更新全局的最小值和最大值
            global_min = std::min(global_min, current_val);
            global_max = std::max(global_max, current_val);

            // 2. 更新该数字的出现次数
            frequency_map[current_val]++;

            // 3. 检查小数组内部是否严格递增 (条件一)
            // j > 0 表示这不是当前小数组的第一个元素
            if (j > 0 && current_val <= prev_val) {
                is_possible = false; // 出现了非严格递增，直接判定失败！
            }
            prev_val = current_val;
        }
    }

    // 如果在读取时就已经发现不满足条件一，直接输出 NO
    if (!is_possible) {
        std::cout << "NO\n";
        return 0;
    }
    
    // 如果所有小数组都是空的，特殊情况，也算可以吧？ (虽然题目数据范围不会出现)
    // 如果 frequency_map 为空，说明没有输入任何数字，此时 min 和 max 还是初始值，循环不会执行，会误判为 YES。
    // 但题目保证总元素个数 >= 1，所以这里不用特别处理。

    // 4. 检查所有元素是否构成一个无缝的连续序列 (条件二)
    for (int val = global_min; val <= global_max; ++val) {
        // 如果某个数没出现，或者出现了不止一次
        if (frequency_map[val] != 1) {
            is_possible = false;
            break; // 只要找到一个不满足的，就可以停下了
        }
    }

    if (is_possible) {
        std::cout << "YES\n";
    } else {
        std::cout << "NO\n";
    }

    return 0;
}
``

## 复杂度分析

- **时间复杂度**: $O(N \log N)$
  令 $N$ 为所有数组中元素的总个数。我们在读取输入时，对每个元素都执行了一次 map` 的插入/更新操作，`map 的单次操作复杂度是 $O(\log K)$，其中 $K$ 是 map 中不同元素的数量。因为最多有 $N$ 个元素，所以 $K \le N$。这部分的复杂度是 $O(N \log N)$。
  之后，我们从 global_min` 遍历到 `global_max。设这个范围的长度为 $R = \text{global\_max} - \text{global\_min} + 1$。在最坏的情况下，$R$ 的大小可能和 $N$ 是一个数量级的。在循环中，每次访问 map 也是 $O(\log N)$。所以这部分的复杂度是 $O(R \log N)$。
  总的时间复杂度就是 $O(N \log N + R \log N)$，因为 $R$ 不会超过 $N$ 的一个较大常数倍，所以可以简化为 $O(N \log N)$。

- **空间复杂度**: $O(N)$
  我们主要使用了 std::map` 来存储所有元素的频率。在最坏的情况下，所有 $N$ 个元素都不同，所以 `map` 需要存储 $N$ 个键值对。因此，空间复杂度是 $O(N)$。

## 知识点总结

这道题虽然伪装成了一道合并数组的模拟题，但它的核心其实是**逻辑推理**和**条件分析**，喵~

1.  **问题分解**: 解决复杂问题的有效方法是将其分解为几个更简单、可验证的子条件。我们将“能构成好数组”这个复杂目标，分解为了“子数组内部递增”和“全局元素集合连续”两个独立的条件。
2.  **必要条件**: 学会寻找问题的必要条件可以帮助我们快速筛掉无效情况。这里的“子数组内部递增”就是一个非常强的必要条件，能让我们提前结束判断。
3.  **数据结构的选择**: `std::map` 是处理这种需要对可能范围很大或不连续的整数进行计数或标记的绝佳工具。它的对数时间复杂度在大多数情况下都足够快。
4.  **思维严谨**: 不要想当然！找到了几个必要条件后，要思考一下它们组合起来是否就是充分条件。在本题中，这两个条件恰好是充分必要的，这让问题变得很简洁。

希望这篇题解能帮到你，喵~ 如果还有不懂的地方，随时可以来问本猫娘哦！一起加油，攻克更多算法难题吧！>w<