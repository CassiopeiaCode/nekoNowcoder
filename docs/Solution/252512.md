# 圆 - 题解

### 比赛与标签
> **比赛**: [牛客练习赛58](https://ac.nowcoder.com/acm/contest/58833/C)

> **标签**: 二分, 计算几何

> **难度**: *2100

## 题目大意喵~

主人你好呀~！这道题是这样的喵：

我们有一个 $n \times m$ 的大~大~的矩形地毯，它的左下角在坐标 $(0,0)$，右上角在 $(n,m)$。地毯上还有 $k$ 个特殊的小点点。题目保证这 $k$ 个点都在同一条直线上哦！

我们的任务是，要在这个地毯里画一个尽可能大的圆圈。但是这个圆圈有两个规矩要遵守，喵~：
1.  圆圈不能“吃掉”地毯的边界。也就是说，圆圈必须完全在矩形内部，或者和边界相切。
2.  圆圈也不能“吃掉”任何一个特殊的小点点。点点可以在圆圈的边上，但是不能在圆圈的内部。

最后，我们需要告诉裁判，这个最大的圆圈的半径是多少，的说。

## 解题思路分析

喵哈哈，看到“求最大值”这种字眼，本猫娘的DNA就动了！这通常是在暗示我们可以用二分答案来解决问题哦！

我们可以二分来猜这个最大半径 $R$。如果一个半径为 $R$ 的圆可以被成功放置，那么任何比 $R$ 小的圆肯定也能找到地方放，对吧？反之，如果连半径 $R$ 的圆都放不下，那更大的圆就更不可能了。这个单调性是二分答案的完美舞台，喵~

那么，二分的关键就在于写一个 `check(R) 函数：给定一个半径 $R$，我们能在这个矩形里找到一个合法的位置来安放它吗？

#### 简化问题：圆会和谁贴贴？

一个被放到极限大的圆，肯定是被什么东西给“卡住”了，动弹不得。它要么是和矩形的某条边相切，要么是和某些特殊点点相切。

一个最直接的想法是，这个最大的圆，很有可能至少会和矩形的某一条边相切。我们可以大胆猜测，最大圆一定与上、下、左、右四条边中的至少一条相切。为什么可以这么猜呢？如果一个圆没有和任何边或点相切，我们总能稍微把它变大一点点，直到它碰到什么为止，对吧？而点都在一条直线上，这个特殊条件使得点构成的约束不会太复杂，被边卡住的情况更有可能成为最终的限制。

所以，我们可以把问题分解成四个独立的子问题：
1.  找到一个与 **下边界** 相切的最大合法圆。
2.  找到一个与 **上边界** 相切的最大合法圆。
3.  找到一个与 **左边界** 相切的最大合法圆。
4.  找到一个与 **右边界** 相切的最大合法圆。

最后，这四个子问题中能得到的最大半径，就是我们全局的答案啦！

#### 坐标变换的魔法！

这四个子问题看起来好像要写四遍代码，好麻烦的说... 但是！本猫娘有聪明的办法！我们可以用坐标变换的魔法，把四个问题都变成同一个标准问题，喵~

我们选择“与 **下边界** 相切”作为我们的标准问题。
*   **Case 1: 与下边界相切 (标准模型)**
    *   点坐标为 $(x, y)$，矩形大小为 $n \times m$。
*   **Case 2: 与上边界相切**
    *   我们可以把整个坐标系上下翻转一下！令新的 $y'$ 坐标为 $m - y$。这样，原来的上边界 $y=m$ 就变成了新的下边界 $y'=0$。点 $(x, y)$ 就变成了 $(x, m-y)$。问题就转化成了在 $n \times m$ 矩形里找一个与下边界相切的圆。
*   **Case 3: 与左边界相切**
    *   我们可以把坐标系旋转90度！令 $x' = y, y' = x$。这样，左边界 $x=0$ 就变成了新的下边界 $y'=0$。点 $(x, y)$ 变成了 $(y, x)$，矩形大小也变成了 $m \times n$。
*   **Case 4: 与右边界相切**
    *   结合翻转和旋转！先对 $x$ 坐标翻转得到 $x' = n-x$，再交换 $x,y$ 坐标。点 $(x, y)$ 变成 $(y, n-x)$，矩形是 $m \times n$。

看吧！通过这些简单的变换，我们只需要解决标准模型，然后调用四次就行啦！

#### 标准模型：圆心在哪儿？

现在我们来专心解决标准问题：在一个宽为 limit_w`，高为 `limit_h 的矩形中，找一个与下边界相切的半径为 $R$ 的圆。

如果一个圆和下边界 $y=0$ 相切，它的圆心纵坐标一定是 $R$，对吧？所以圆心可以写成 $(c_x, R)$。

这个圆心 $(c_x, R)$ 需要满足哪些条件呢？
1.  **矩形边界约束**：圆必须在矩形内。
    *   左边界：$c_x - R \ge 0 \implies c_x \ge R$
    *   右边界：$c_x + R \le \text{limit\_w} \implies c_x \le \text{limit\_w} - R$
    *   所以，圆心的横坐标 $c_x$ 必须在 $[R, \text{limit\_w} - R]$ 这个区间内。

2.  **特殊点约束**：对于每一个特殊点 $p_i = (p_{ix}, p_{iy})$，它不能被严格包含在圆内。
    *   圆心 $(c_x, R)$ 到点 $p_i$ 的距离平方要大于等于半径的平方。
    $$
    (c_x - p_{ix})^2 + (R - p_{iy})^2 \ge R^2
    $$
    *   整理一下这个式子，喵~
    $$
    (c_x - p_{ix})^2 \ge R^2 - (R - p_{iy})^2 = 2Rp_{iy} - p_{iy}^2
    $$
    *   如果右边 $2Rp_{iy} - p_{iy}^2 < 0$ (也就是 $p_{iy} > 2R$)，这个不等式恒成立，说明这个点太高了，根本不会影响到我们贴着底边的圆。
    *   如果右边 $\ge 0$，我们可以开方得到：
    $$
    |c_x - p_{ix}| \ge \sqrt{2Rp_{iy} - p_{iy}^2}
    $$
    *   令 $d_i = \sqrt{2Rp_{iy} - p_{iy}^2}$。这个式子告诉我们，$c_x$ 不能落在以 $p_{ix}$ 为中心，半径为 $d_i$ 的开区间里，也就是 $c_x \notin (p_{ix} - d_i, p_{ix} + d_i)$。这是一个 $c_x$ 的“**禁区**”！

#### 寻找可用空间：一维区间的游戏

现在问题变成了：在允许的区间 $[R, \text{limit\_w} - R]$ 中，是否存在一个 $c_x$，它不属于任何一个由特殊点产生的禁区 $(p_{ix} - d_i, p_{ix} + d_i)$？

这是一个经典的一维区间问题！我们可以把所有禁区都找出来，然后看看它们是否把整个允许区间 $[R, \text{limit\_w} - R]$ 都覆盖掉了。如果没完全覆盖，就说明有空隙，也就是有合法的位置放圆心，check(R)` 就返回 `true。

这里有一个更巧妙的实现方法，喵~
我们可以把问题反过来想：我们不是要找一个**合法**的 $c_x$ 吗？
一个合法的 $c_x$ 必须满足：
1.  $c_x > R$
2.  $c_x < \text{limit\_w} - R$
3.  对于所有相关的点 $p_i$，$c_x$ 不在禁区 $(p_{ix} - d_i, p_{ix} + d_i)$ 内。

我们可以把这些条件对应的**反面**，也就是“不合法”的区域，看成是一些区间。
1.  $c_x \le R$ 对应区间 $(-\infty, R]$
2.  $c_x \ge \text{limit\_w} - R$ 对应区间 $[\text{limit\_w} - R, \infty)$
3.  $c_x \in (p_{ix} - d_i, p_{ix} + d_i)$

我们把所有这些“不合法”的区间收集起来，包括来自边界的 $[0, R]$ 和 $[\text{limit\_w} - R, \text{limit\_w}]$ (我们只关心 $[0, \text{limit\_w}]$ 范围)，以及所有点产生的禁区 $[p_{ix} - d_i, p_{ix} + d_i]$。

然后，我们检查这些区间的并集是否覆盖了整个 $[0, \text{limit\_w}]$。
*   如果**没有**完全覆盖，说明存在一个x`，它不在任何一个禁区里。这个`x`就是一个合法的圆心横坐标 $c_x$！于是 `check(R)` 成功！
*   如果**完全**覆盖了，说明找不到任何一个合法位置，`check(R)` 失败。

检查区间覆盖的方法也很经典：把所有区间按左端点排序，然后贪心地合并。维护一个当前已覆盖到的最右端点 `max_reach`。遍历区间 `[l, r]`，如果 `l > max_reach`，就说明出现了空隙！

这样，我们的 `check(R)` 函数就完成了！整个算法的框架就是：
1.  二分半径 $R$。
2.  在 `check(R)` 中：
    a. 对四个对称情况，分别建立坐标转换后的点集。
    b. 对每种情况，调用一次标准模型的检查函数。
    c. 标准模型检查函数：收集所有禁区（包括边界和点），判断它们的并集是否留有空隙。
    d. 只要四种情况有一种成功，`check(R)` 就返回 `true`。
3.  根据 `check(R)` 的结果，调整二分范围，直到找到答案。

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦！希望能帮到主人，喵~

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <iomanip>

// 为了精度，我们使用 long double，喵~
using ld = long double;

// 定义点的结构体
struct Point {
    ld x, y;
};

// 检查函数，对应我们的“标准模型”
// p: 转换后的点集
// r: 当前二分的半径
// limit_w: 当前坐标系下的宽度
bool check_placement(const std::vector<Point>& p, ld r, ld limit_w) {
    // 如果半径太大，圆心都没有活动空间了，直接返回 false
    if (2.0 * r > limit_w) {
        return false;
    }

    // 收集所有“禁区”的区间
    std::vector<std::pair<ld, ld>> forbidden_intervals;

    // 1. 来自边界的禁区
    // 圆心 c_x 必须在 [r, limit_w - r] 之间。
    // 我们可以用一个聪明的技巧，把 [0, r] 和 [limit_w - r, limit_w] 当成是 c_x 的禁区
    // 如果我们能找到一个 x 不在任何禁区里，那这个 x 就是一个合法的 c_x
    forbidden_intervals.push_back({0.0, r});
    forbidden_intervals.push_back({limit_w - r, limit_w});

    // 2. 来自特殊点的禁区
    for (const auto& point : p) {
        // 如果点的高度大于 2r，它不会对贴着底边的圆产生影响
        if (point.y >= 2.0 * r) {
            continue;
        }
        
        // 计算禁区半宽 d，即 |c_x - p_x| >= d
        ld d_squared = 2.0 * r * point.y - point.y * point.y;
        // 正常情况下 d_squared >= 0，但以防万一
        if (d_squared < 0) continue;
        ld d = sqrt(d_squared);

        forbidden_intervals.push_back({point.x - d, point.x + d});
    }

    // 检查这些禁区是否覆盖了整个 [0, limit_w]
    std::sort(forbidden_intervals.begin(), forbidden_intervals.end());

    ld max_reach = 0.0;
    for (const auto& interval : forbidden_intervals) {
        // 如果区间的左端点 > 当前覆盖的最右端，说明出现了空隙！
        // 找到了一个合法的位置！
        if (interval.first > max_reach) {
            return true;
        }
        // 否则，延伸我们的覆盖范围
        max_reach = std::max(max_reach, interval.second);
    }

    // 如果循环结束，max_reach 还没能覆盖到 limit_w，说明最后也存在空隙
    return max_reach < limit_w;
}

void solve() {
    ld n, m;
    int k;
    std::cin >> n >> m >> k;

    std::vector<Point> original_points(k);
    for (int i = 0; i < k; ++i) {
        std::cin >> original_points[i].x >> original_points[i].y;
    }

    // 四种对称情况的点集
    std::vector<Point> points_down = original_points;
    std::vector<Point> points_up(k);
    std::vector<Point> points_left(k);
    std::vector<Point> points_right(k);

    for (int i = 0; i < k; ++i) {
        // Case 2: 向上翻转
        points_up[i] = {original_points[i].x, m - original_points[i].y};
        // Case 3: 旋转 (x,y) -> (y,x)
        points_left[i] = {original_points[i].y, original_points[i].x};
        // Case 4: 向右翻转再旋转 (x,y) -> (y, n-x)
        points_right[i] = {original_points[i].y, n - original_points[i].x};
    }

    // 二分答案
    ld low = 0.0, high = std::min(n, m) / 2.0;
    // 二分100次，精度足够了喵~
    for(int iter = 0; iter < 100; ++iter) {
        ld mid = low + (high - low) / 2.0;
        bool possible = false;
        // 检查四种情况，只要有一种可能，就说明这个半径 mid 是可行的
        if (check_placement(points_down, mid, n) ||
            check_placement(points_up, mid, n) ||
            check_placement(points_left, mid, m) ||
            check_placement(points_right, mid, m)) {
            possible = true;
        }

        if (possible) {
            low = mid; // 半径可能更大
        } else {
            high = mid; // 半径必须更小
        }
    }

    std::cout << std::fixed << std::setprecision(10) << low << std::endl;
}

int main() {
    // 加速输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    solve();
    return 0;
}
``

## 复杂度分析

*   **时间复杂度**: $O(C \cdot K \log K)$，其中 $C$ 是二分的次数（通常是一个常数，比如100），$K$ 是特殊点的数量。
    每次二分的 check 函数中，我们需要对四种情况进行判断。每种情况都需要对 $O(K)$ 个区间进行排序，这需要 $O(K \log K)$ 的时间。然后遍历一次排序后的区间，需要 $O(K)$ 的时间。所以 check 函数的总时间复杂度是 $O(K \log K)$。因此，总时间复杂度就是 $O(C \cdot K \log K)$。

*   **空间复杂度**: $O(K)$。
    我们需要存储原始点集和四种变换后的点集，以及在 check` 函数中临时存储 $O(K)$ 个区间。所以空间开销是与点的数量 $K$ 成正比的。

## 知识点总结

这道题真是一次愉快的冒险，我们用到了好几种有趣的工具呢，喵~

1.  **二分答案**: 这是解决“最大化最小值”或“最小化最大值”问题的经典思想。当问题答案具有单调性时，就可以用二分来快速锁定解的范围。
2.  **坐标变换/对称性**: 面对看似重复的多种情况（比如这里的四个边界），可以尝试通过坐标变换（如翻转、旋转）将它们统一为一种标准模型来处理，大大简化代码逻辑。
3.  **降维思想**: 巧妙地将二维的圆的放置问题，通过固定一个坐标（圆心与边界相切），转化成了一维的区间问题。这是解决计算几何问题常用的策略。
4.  **区间覆盖/合并**: 这是一个基础但非常有用的算法。通过排序和贪心，可以高效地处理一系列区间，比如求并集、找空隙等。

希望这篇题解能帮助主人更好地理解这道题！如果还有问题，随时可以再来找我玩哦，喵~