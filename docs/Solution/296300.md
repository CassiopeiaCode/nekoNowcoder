# 由于撤云读错了 2025 ICPC 武汉邀请赛的 J 题，因此提出了另一个问题。 - 题解

### 比赛与标签
> **比赛**: 2025 ICPC 武汉邀请赛
> **标签**: 思维, 贪心
> **难度**: *1200

## 题目大意喵~
主人你好呀~ 这道题是这样的喵：

我们有一个长度为 `n` 的字符串 `s`，还有 `q` 次操作的说。

每一次操作，都会给我们一个区间 `[l, r]`。然后我们需要做一件有趣的事情：把所有以 `l` 为起点，并且以子串 `s[l..r]` 为前缀的子串都“标记”起来。

举个栗子呐：如果字符串是 "ababa"，`n=5`。对于一次操作 `l=2, r=4`，子串 `s[2..4]` 就是 "bab"。那么，所有以第 2 个位置 'b' 开头，并且包含 "bab" 作为前缀的子串都要被标记。这些子串就是 "bab" (即 `s[2..4]`) 和 "baba" (即 `s[2..5]`)。

每次操作之后，我们都要告诉撤云同学，到目前为止，总共有多少个 **不同** 的子串被标记了呢？注意哦，标记是会累积的，一个子串被标记过一次，就永远是标记状态啦！

输入就是 `n`, `q` 和字符串 `s`，接着是 `q` 行，每行是 `l` 和 `r`。输出就是每次操作后，被标记的不同子串的总数。

## 解题思路喵！
这道题看起来好像要我们处理好多好多子串的集合，然后求并集的大小，感觉好复杂的样子，对不对？但其实，只要我们换个角度思考，问题就会变得超级简单喵！

首先，我们来分析一下标记规则。一次操作 `(l, r)` 会标记所有 `s[l..k]` 形式的子串，其中 `k` 的范围是 `r` 到 `n`。也就是说，它把从 `l` 开始，长度不小于 `r-l+1` 的所有子串都给标记了。

关键点来啦！对于一个 **固定的起始位置 `l`**，所有被标记的子串都来自这个位置。
*   假设第一次对 `l` 的操作是 `(l, r1)`。我们会标记 `s[l..r1], s[l..r1+1], ..., s[l..n]`。总共 `n - r1 + 1` 个。
*   如果又来了一次对 `l` 的操作 `(l, r2)`，其中 `r2 > r1`。这次操作要标记的子串集合是 `s[l..r2], ..., s[l..n]`。但是喵，这些子串在第一次操作时已经被标记过啦！所以总的标记数量不会增加。
*   如果又来了一次对 `l` 的操作 `(l, r3)`，其中 `r3 < r1`。这次要标记的子串是 `s[l..r3], ..., s[l..n]`。这个集合比第一次标记的集合要大！新增加的被标记子串就是 `s[l..r3], s[l..r3+1], ..., s[l..r1-1]`。数量是 `r1 - r3` 个。

发现了吗？对于每一个起始位置 `l`，真正决定标记范围的，其实是所有关于 `l` 的操作中，那个 **最小的 `r`**！只要我们知道了这个最小的 `r`，我们就能确定所有从 `l` 开始的被标记子串。

所以，我们的喵喵妙计是这样的~
1.  我们用一个数组 `minR`，`minR[l]` 记录对于起始位置 `l`，到目前为止我们遇到的所有查询中最小的那个 `r`。
2.  因为一开始没有任何子串被标记，我们可以把 `minR[l]` 初始化为一个比任何可能的 `r` 都大的值，比如 `n + 1`。这样，初始时，对于每个 `l`，被标记的子串数量是 `n - (n+1) + 1 = 0`，很合理对吧！
3.  我们再用一个变量 `ans` 来记录当前被标记的子串总数，初始为 `0`。
4.  当来了一个新的查询 `(l, r)` 时，我们只关心 `l`：
    *   我们看看新的 `r` 是不是比我们记录的 `minR[l]` 还要小。
    *   如果是，`r < minR[l]`，说明我们拓展了标记范围！新增加的标记子串数量就是 `minR[l] - r` 个。我们就把 `ans` 加上这个差值，然后更新 `minR[l] = r`。
    *   如果不是，`r >= minR[l]`，说明这次要标记的范围已经被更小的 `r` 覆盖了，没有新的子串被标记，`ans` 不变。
5.  每次查询后，输出当前的 `ans` 就好啦！

你看，我们根本不需要真的去操作字符串 `s`，它只是个可爱的背景板喵~ 整个问题就变成了一个简单的更新和累加问题了！

## 代码实现喵~
```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;

int main() {
    // 提高cin/cout效率，让程序跑得更快喵~
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    string s;
    cin >> n >> q >> s;

    // minR[i] 记录对于起始位置 i，所有查询中最小的 r
    // 初始化为 n + 1，表示一个不可能达到的r值，代表初始未标记
    vector<int> minR(n + 1, n + 1); 
    ll ans = 0; // 用 long long 防止答案溢出，是个好习惯的说

    while (q--) {
        int l, r;
        cin >> l >> r;
        
        // 如果当前查询的 r 比我们记录的最小 r 还要小
        if (r < minR[l]) {
            // 这意味着我们标记了新的子串！
            // 新标记的子串是从 s[l..r] 到 s[l..minR[l]-1]
            // 数量就是 minR[l] - r
            ans += minR[l] - r;
            
            // 更新对于起始位置 l 的最小 r
            minR[l] = r;
        }
        
        // 每次查询后输出当前的累计答案
        cout << ans << '\n';
    }

    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(n + q) 的说。
  初始化 `minR` 数组需要 O(n) 的时间。之后有 `q` 次查询，每次查询我们都只进行一次常数时间的比较、加法和赋值操作。所以总的时间复杂度就是 O(n + q) 啦，非常高效！

- **空间复杂度**: O(n) 的说。
  我们主要用了一个 `minR` 数组来存储每个起始位置的最小 `r` 值，它的大小和字符串长度 `n` 是一个数量级的。所以空间复杂度是 O(n) 呢。

## 知识点与总结喵
这道题虽然伪装成了一道复杂的字符串问题，但它的核心其实是一个非常巧妙的 **思维转换** 和 **贪心** 思想！

1.  **问题简化**: 核心技巧是把对“子串集合求并集”的复杂问题，分解成对每个“起始位置”的独立子问题。
2.  **状态压缩**: 对于每个起始位置 `l`，影响标记范围的多个 `r` 值可以被压缩成一个信息——即 `minR[l]`。这大大降低了我们需要维护的状态的复杂度。
3.  **抓住本质**: 很多题目（就像这道！）会给出一些看似重要但实际无关的信息（比如字符串 `s` 的具体内容），学会识别并忽略这些“烟雾弹”是成为解题高手的重要一步哦！

所以，下次遇到看起来很吓人的问题，不妨先静下心来，像小猫咪一样，从最简单的部分开始分析，说不定就能找到问题的“毛线球”，一拉就解开啦！加油喵~！