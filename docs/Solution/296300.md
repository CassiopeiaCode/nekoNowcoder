# 由于撤云读错了 2025 ICPC 武汉邀请赛的 J 题，因此提出了另一个问题。 - 题解

### 比赛与标签
> **比赛**: The 2024 ICPC Henan Provincial Collegiate Programming Contest

> **标签**: 思维, 模拟

> **难度**: *1200

## 题目大意喵~

你好呀，未来的算法大师！本喵今天带来一道有趣的字符串问题，一起来看看吧，喵~

题目是这样子的：
我们有一个长度为 $n$ 的字符串 $s$ 和 $q$ 次操作。
每一次操作，会给我们两个数字 $l$ 和 $r$。这代表了一个子串 $s[l..r]$。

我们的任务是，对于这次操作，要找出所有以 $s[l..r]$ 为前缀，并且同样从位置 $l$ 开始的子串，然后把它们全部“标记”起来。

每次操作结束后，我们需要告诉裁判，到目前为止，总共有多少个**不同**的子串被我们标记过了。这个计数是累积的哦，也就是说，一旦一个子串被标记，它就永远是标记状态啦！

举个例子，如果字符串是 "ababa"，$n=5$。
一次操作是 $(l=2, r=3)$，对应的子串是 $s[2..3]$，也就是 "ba"。
那么，从位置 2 开始，以 "ba" 为前缀的子串有：
- "ba" ($s[2..3]$)
- "bab" ($s[2..4]$)
- "baba" ($s[2..5]$)
这 3 个子串都会被标记。如果我们之前没有标记过任何子串，那么这次操作后，总的被标记子串数量就是 3。

## 解题思路分析

喵呜~ 这个问题看起来好像要处理很多子串的集合，可能会很复杂的样子。但是不要怕，让本喵带你一步步解开它的神秘面纱！

首先，我们来仔细分析一下 "标记" 这个动作。
当给定一个查询 $(l, r)$ 时，我们要标记所有以 $s[l..r]$ 为前缀且起始于 $l$ 的子串。
一个从 $l$ 开始的子串可以写成 $s[l..k]$，其中 $k$ 是它的结束位置。
要让 $s[l..k]$ 以 $s[l..r]$ 为前缀，需要满足什么条件呢？很明显，它的长度必须不小于 $s[l..r]$ 的长度，也就是说，结束位置 $k$ 必须大于等于 $r$。
所以，一次 $(l, r)$ 的查询，实际上标记的是这样一个子串集合：
$\{ s[l..r], s[l..r+1], s[l..r+2], \dots, s[l..n] \}$

问题的关键在于，总数是**累积**的，而且我们只计算**不同**的子串。

我们注意到，一个子串由它的起始位置和结束位置唯一确定。不同起始位置的子串（比如 $s[1..2]$ 和 $s[2..3]$）不可能是同一个子串。这意味着，我们可以独立地考虑每一个起始位置 $l$ 的贡献！

让我们只关注所有从同一个位置 $l$ 开始的子串。
假设第一次关于 $l$ 的查询是 $(l, r_1)$。我们会标记 $s[l..r_1], s[l..r_1+1], \dots, s[l..n]$ 这些子串。数量是 $n - r_1 + 1$ 个。
现在，又来了一个关于 $l$ 的查询 $(l, r_2)$。
- 如果 $r_2 \ge r_1$，那么要标记的子串集合 $\{s[l..k] \mid k \ge r_2\}$ 是之前标记过的集合 $\{s[l..k] \mid k \ge r_1\}$ 的一个子集。所以，没有新的子串被标记，总数不变。
- 如果 $r_2 < r_1$，那么要标记的子串集合 $\{s[l..k] \mid k \ge r_2\}$ 比之前的集合更大。新增加的被标记子串是 $\{s[l..k] \mid r_2 \le k < r_1\}$。这些新子串的数量是 $r_1 - r_2$ 个。

发现了喵？对于每一个起始位置 $l$，我们实际上只关心一个东西：**到目前为止，所有关于 $l$ 的查询中，那个最小的 $r$ 是多少**。
只要我们记录下这个最小的 $r$（我们叫它 `min_r[l]`），我们就能算出从 $l$ 开始的子串总共被标记了多少个。

所以，我们的策略就非常清晰啦：
1.  我们创建一个数组，叫做 `min_right_boundary`，大小为 $n+1$。`min_right_boundary[l]` 用来记录对于起始位置 $l$，我们遇到过的最小的右端点 $r$。
2.  一开始，对于任何一个 $l$，我们都还没有进行过任何标记。我们可以认为 `min_right_boundary[l]` 的初始值是一个比 $n$ 大的数，比如 $n+1$。这表示标记的“边界”在字符串之外，所以还没有任何子串被标记。
3.  我们用一个变量 `total_marked_count` 来记录总的标记数量，初始为 0。
4.  当来了一个查询 $(l, r)$ 时：
    - 我们取出之前记录的 `min_right_boundary[l]`。
    - 如果新的 $r$ 比 `min_right_boundary[l]` 更小，说明我们的标记范围向左扩大了！
    - 扩大的范围是从新的 $r$ 到旧的 `min_right_boundary[l] - 1`。新增加的标记数量就是 `min_right_boundary[l] - r`。
    - 我们把这个增量加到 `total_marked_count` 上。
    - 然后，更新 `min_right_boundary[l] = r`。
    - 如果新的 $r$ 不比 `min_right_boundary[l]` 小，说明这次操作没有引入任何新的被标记子串，我们什么都不用做。
5.  每次查询后，输出 `total_marked_count` 就好啦！

这个方法是不是很巧妙呢？我们把一个关于子串集合的问题，转化成了一个维护每个起始位置最小右端点的问题，大大简化了计算，喵~

## 代码实现

下面是本喵根据上面的思路，精心为你准备的代码哦~ 加了很多注释，希望能帮助你理解呐！

```cpp
#include <iostream>
#include <vector>
#include <string>

// 使用 long long 来存储答案，防止溢出喵~
using ll = long long;

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::string s;
    std::cin >> n >> q >> s;

    // min_right_boundary[i] 存储对于起始位置 i，我们遇到过的最小的右端点 r。
    // 初始值设为 n + 1，表示对于任何起始位置，都还没有子串被标记。
    // 数组大小为 n + 1，因为字符串下标从 1 到 n。
    std::vector<int> min_right_boundary(n + 1, n + 1);
    
    // 用于记录到目前为止总共标记了多少个不同的子串。
    ll total_marked_count = 0;

    for (int i = 0; i < q; ++i) {
        int l, r;
        std::cin >> l >> r;

        // 获取当前起始位置 l 已经记录的最小右端点。
        int current_min_r = min_right_boundary[l];

        // 如果新的右端点 r 比我们记录过的最小右端点还要小，
        // 说明我们标记的范围扩大了，需要增加计数。
        if (r < current_min_r) {
            // 新增的被标记子串数量，就是旧的最小右端点和新的最小右端点之差。
            ll newly_marked_count = current_min_r - r;
            total_marked_count += newly_marked_count;
            
            // 更新这个起始位置的最小右端点。
            min_right_boundary[l] = r;
        }
        
        // 每次操作后都输出当前的累计总数。
        std::cout << total_marked_count << '\n';
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N + Q)$
  - 初始化 `min_right_boundary` 数组需要 $O(N)$ 的时间。
  - 接下来有一个循环处理 $Q$ 次查询。在循环内部，我们只进行几次简单的数组访问、比较和算术运算，这些都是 $O(1)$ 的常数时间操作。
  - 所以，总的时间复杂度就是 $O(N)$ 的初始化加上 $Q$ 次 $O(1)$ 的操作，合起来就是 $O(N + Q)$，非常高效的说！

- **空间复杂度**: $O(N)$
  - 我们主要使用了 `min_right_boundary` 这个向量来存储每个起始位置的状态。它的大小与字符串长度 $N$ 成正比。因此，我们占用的额外空间是 $O(N)$。

## 知识点总结

这道题虽然披着字符串的外衣，但核心却是一个思维转换和模拟计数的题目，喵~

1.  **问题分解**: 最关键的一步是将问题分解。我们发现不同起始点的子串互不影响，因此可以独立计算每个起始点 $l$ 的贡献，最后累加起来。这是解决复杂问题时一个非常有用的思想！
2.  **状态压缩/简化**: 我们不需要真的去存储所有被标记的子串。对于每个起始点 $l$，所有相关信息都可以被压缩成一个单一的数值——即 `min_right_boundary[l]`。这极大地降低了问题的复杂度。
3.  **差分思想**: 每次更新答案时，我们计算的是增量（`min_right_boundary[l] - r）。这种通过计算变化量来更新总和的方法，可以看作是差分思想的一种简单应用。
4.  **注意数据范围**: 总的标记数可能会很大（最大可达 $N \times Q$ 级别），所以要记得使用 long long` 来存储答案，不然会因为溢出而得到错误的结果哦！

希望这篇题解能帮到你！继续努力，你一定能成为超厉害的算法大师的，喵~！