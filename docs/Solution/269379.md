# 作为树的大师，S 老师又给你了一个数学题： - 题解

### 比赛与标签
> **比赛**: Codeforces - Codeforces Round #674 (Div. 3)
> **标签**: 树论, 期望, 生成函数, NTT, 组合计数
> **难度**: *2800

## 题目大意喵~

S老师给了一棵有 $n$ 个节点的大树，树上的每条边都有一个颜色，喵~

我们需要考虑这棵树的所有大小为 $i$ 的顶点子集 $S$（其中 $i$ 从 1 到 $n$ 变化）。对于每个子集 $S$，我们要构建一棵**虚树**。虚树是包含 $S$ 中所有顶点的、在原树上的最小连通子图。

一个子集 $S$ 的**权值** $w(S)$ 定义为它对应的虚树中，包含了多少种**不同**的边颜色。

我们的任务是，对于每一个 $i \in \{1, 2, \ldots, n\}$，计算出所有大小为 $i$ 的顶点子集 $S$ 的权值 $w(S)$ 的**期望值**。也就是说，我们要从所有大小为 $i$ 的子集中随机抽取一个，它的权值期望是多少呢？最后结果要对 $998244353$ 取模哦！

**输入**:
第一行一个整数 $n$，表示树的节点数。
接下来 $n-1$ 行，每行三个整数 $u, v, c$，表示节点 $u$ 和 $v$ 之间有一条颜色为 $c$ 的边。

**输出**:
一行 $n$ 个数，第 $i$ 个数表示大小为 $i$ 的顶点子集权值的期望值。

## 解题思路分析

这道题看起来好复杂呀，又是虚树又是期望的，但别怕，跟着本猫娘的思路，一步步拆解它，就会发现它其实是只纸老虎，喵呜~

### 期望？交给线性性！

题目要求的是期望值。对付期望问题，我们有一个超级好用的工具，那就是**期望的线性性**！$E(X+Y) = E(X) + E(Y)$，这个性质不管 $X$ 和 $Y$ 是否独立都成立，是不是很神奇？

一个子集 $S$ 的权值 $w(S)$ 是其虚树中不同颜色的数量。我们可以把它看成是所有颜色对权值的贡献之和。
$$w(S) = \sum_{\text{颜色 } c} I_c(S)$$
其中 $I_c(S)$ 是一个指示函数：如果颜色 $c$ 出现在 $S$ 的虚树中，则 $I_c(S)=1$，否则为 $0$。

根据期望的线性性，我们要求的期望值就是：
$$E[w(S)] = E\left[\sum_c I_c(S)\right] = \sum_c E[I_c(S)]$$
$E[I_c(S)]$ 是什么呢？它就是颜色 $c$ 出现在一个随机大小为 $i$ 的子集 $S$ 的虚树中的**概率**。
所以，我们只需要对每一种颜色 $c$，求出它出现的概率，然后把所有颜色的概率加起来，就是我们想要的期望值啦！

### 什么时候颜色会出现在虚树里？

一个颜色 $c$ 会出现在虚树里，当且仅当虚树包含了至少一条颜色为 $c$ 的边。
而一条边 $(u,v)$ 会出现在虚树里，当且仅当子集 $S$ 中，既有在 $u$ 这侧的点，也有在 $v$ 这侧的点（把边 $(u,v)$ 断开，树会分成两个连通块）。

这个“当且仅当”听起来有点绕，我们不如换个角度思考：什么时候颜色 $c$ **不会**出现在虚树里呢？

如果把所有颜色为 $c$ 的边都从树上拿走，树就会碎成好几个连通块。颜色 $c$ **不**出现在虚树中，当且仅当子集 $S$ 的所有顶点都落在这些连通块中的**同一个**里面！

这下思路就清晰多啦！对于一个固定的颜色 $c$，我们：
1.  把所有颜色为 $c$ 的边都删除。
2.  树被分成了 $m$ 个连通块，大小分别为 $s_1, s_2, \ldots, s_m$。
3.  要让颜色 $c$ 不出现，我们选择的 $i$ 个点必须全部来自某个 $s_j$。
4.  从大小为 $s_j$ 的块中选 $i$ 个点，有 $\binom{s_j}{i}$ 种方法。
5.  所以，使得颜色 $c$ 不出现的、大小为 $i$ 的子集总数是 $\sum_{j=1}^m \binom{s_j}{i}$。

总的大小为 $i$ 的子集有 $\binom{n}{i}$ 个。所以，颜色 $c$ **出现**的子集数量就是：
$$ \text{Count}_c(i) = \binom{n}{i} - \sum_{j=1}^m \binom{s_j}{i} $$

### 汇总所有颜色

把所有颜色的贡献加起来，大小为 $i$ 的子集的权值总和就是：
$$ \sum_{|S|=i} w(S) = \sum_{\text{颜色 } c} \text{Count}_c(i) = \sum_c \left(\binom{n}{i} - \sum_{j=1}^{m_c} \binom{s_{c,j}}{i}\right) $$
其中 $m_c$ 和 $s_{c,j}$ 是颜色 $c$ 对应的连通块数量和大小。

设总共有 $|C|$ 种不同的颜色出现在树上。上式可以整理为：
$$ \sum_{|S|=i} w(S) = |C| \cdot \binom{n}{i} - \sum_c \sum_j \binom{s_{c,j}}{i} $$
我们要求的期望值就是用这个总和除以 $\binom{n}{i}$：
$$ E_i = |C| - \frac{\sum_c \sum_j \binom{s_{c,j}}{i}}{\binom{n}{i}} $$
现在，我们的核心任务变成了计算后面那个看起来很可怕的减项。

### 用生成函数和NTT加速！

我们把所有颜色拆分出的所有连通块大小收集起来。定义 $N_k$ 为：在对**所有**颜色分别进行拆分后，大小为 $k$ 的连通块一共出现了多少次。
$$ N_k = \sum_{\text{颜色 } c} (\text{大小为 } k \text{ 的连通块 } s_{c,j} \text{ 的数量}) $$
那么上面那个大大的和式就可以写成：
$$ \sum_c \sum_j \binom{s_{c,j}}{i} = \sum_{k=i}^n N_k \binom{k}{i} $$
我们令 $T_i = \sum_{k=i}^n N_k \binom{k}{i}$。只要我们能求出所有 $N_k$，再快速计算出所有 $T_i$，问题就解决啦！

**第一步：计算 $N_k$**

对于每种颜色，暴力地删边、找连通块太慢了。我们可以用更聪明的树上技巧！
1.  先对整棵树做一次 DFS，预处理出每个节点的父节点 `parent`，深度 `depth`，以及子树大小 `subtree_size`，还有 DFS 序 `dfn`。
2.  我们用一个数据结构，比如**树状数组（BIT）**，来维护当前有效的节点集合。BIT 的下标对应 DFS 序。初始时，每个节点都有效，我们在 BIT 的 `dfn[v]` 位置上加 1。查询一个子树中有效节点的数量，就等于查询 BIT 中 `dfn` 区间 `[dfn[v], dfn[v] + subtree_size[v] - 1]` 的和。
3.  遍历每一种颜色 $c$：
    a. 找出所有连接父子节点、颜色为 $c$ 的边 $(p, v)$。
    b. 为了处理嵌套子树的情况，我们按 `dfn` 降序（即从深到浅）处理这些节点 $v$。
    c. 对于每个 $v$，它所代表的连通块大小就是当前它子树中有效节点的数量。用 BIT 查询一下就能得到，记为 `size_v`。
    d. 记录下来：我们找到了一个大小为 `size_v` 的连通块，所以 `N[size_v]` 加一。
    e. 为了避免重复计算，我们把这个大小为 `size_v` 的连通块从树中“暂时移除”。具体操作是在 BIT 的 `dfn[v]` 位置减去 `size_v`。
    f. 处理完所有颜色为 $c$ 的边后，BIT 中剩下的有效节点数就是最后一个连通块的大小（包含根节点的那个）。把它也加到 $N_k$ 中。
    g. **恢复现场！** 把刚才减去的 `size_v` 都加回去，这样才能正确处理下一种颜色。

这个过程对每条边只处理常数次，所以计算所有 $N_k$ 的总时间复杂度是 $O(N \log N)$ 的说！

**第二步：计算 $T_i$**

我们现在有了所有的 $N_k$，需要计算 $T_i = \sum_{k=i}^n N_k \binom{k}{i}$。如果对每个 $i$ 都暴力求和，总共是 $O(N^2)$，不行呀！
这里就要请出我们的魔法棒——**生成函数**和**NTT**了！

$T_i$ 的表达式是一个典型的可以被卷积解决的形式。我们来变形一下：
$$ T_i = \sum_{k=i}^n N_k \frac{k!}{i!(k-i)!} = \frac{1}{i!} \sum_{k=i}^n (k! \cdot N_k) \cdot \frac{1}{(k-i)!} $$
这个形式 $\sum A_k B_{k-i}$ 就是卷积！
我们构造两个多项式：
- $F(x) = \sum_{k=0}^n (k! \cdot N_k) x^k$
- $G(x) = \sum_{j=0}^n \frac{1}{j!} x^j$

如果我们计算 $F(x)$ 和 $G_{rev}(x) = \sum_{j=0}^n \frac{1}{(n-j)!}x^j$ 的卷积 $H(x) = F(x)G_{rev}(x)$，那么 $H(x)$ 的第 $n+i$ 项系数 $[x^{n+i}]H(x)$ 恰好就是：
$$ h_{n+i} = \sum_{k=i}^n (k! \cdot N_k) \cdot \frac{1}{(k-i)!} $$
这正是 $i! \cdot T_i$！

所以，我们用 NTT 快速计算出 $H(x)$，然后就能得到所有 $T_i = h_{n+i} / i!$。

**第三步：算出最终答案**

万事俱备，只欠东风！对于每个 $i \in \{1, \ldots, n\}$，期望值是：
$$ E_i = |C| - \frac{T_i}{\binom{n}{i}} = |C| - \frac{h_{n+i}/i!}{n!/(i!(n-i)!)} = |C| - h_{n+i} \cdot \frac{(n-i)!}{n!} $$
预处理阶乘和阶乘逆元，我们就可以 $O(1)$ 算出每一项啦！

总结一下我们的冒险路线：
1.  DFS 预处理树的信息。
2.  用 DFS + 树状数组 $O(N \log N)$ 计算出所有 $N_k$。
3.  构造多项式，用 NTT 在 $O(N \log N)$ 时间内计算卷积，得到所有 $T_i$。
4.  $O(N)$ 计算并输出每个 $i$ 的最终期望值。

好耶！我们成功把问题解决了，喵~

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

using ll = long long;

const int MOD = 998244353;
const int NTT_G = 3;

// 快速幂，喵~
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 求逆元，除法就靠你啦！
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// NTT 模板，多项式乘法的魔法！
namespace NTT {
    vector<ll> rev;
    void ntt(vector<ll>& a, bool invert) {
        int n = a.size();
        if (rev.size() != n) {
            rev.resize(n);
            int log_n = 0;
            while ((1 << log_n) < n) log_n++;
            for (int i = 0; i < n; i++) {
                rev[i] = 0;
                for (int j = 0; j < log_n; j++) {
                    if ((i >> j) & 1) {
                        rev[i] |= 1 << (log_n - 1 - j);
                    }
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (i < rev[i]) swap(a[i], a[rev[i]]);
        }

        for (int len = 2; len <= n; len <<= 1) {
            ll wlen = power(NTT_G, (MOD - 1) / len);
            if (invert) wlen = modInverse(wlen);
            for (int i = 0; i < n; i += len) {
                ll w = 1;
                for (int j = 0; j < len / 2; j++) {
                    ll u = a[i + j], v = (a[i + j + len / 2] * w) % MOD;
                    a[i + j] = (u + v) % MOD;
                    a[i + j + len / 2] = (u - v + MOD) % MOD;
                    w = (w * wlen) % MOD;
                }
            }
        }

        if (invert) {
            ll n_inv = modInverse(n);
            for (ll& x : a) x = (x * n_inv) % MOD;
        }
    }

    vector<ll> multiply(vector<ll> a, vector<ll> b) {
        int sz = 1;
        while (sz < a.size() + b.size()) sz <<= 1;
        a.resize(sz);
        b.resize(sz);

        ntt(a, false);
        ntt(b, false);

        for (int i = 0; i < sz; i++) a[i] = (a[i] * b[i]) % MOD;
        ntt(a, true);

        return a;
    }
}

const int MAXN = 200005;

// 树的数据结构
vector<pair<int, int>> adj[MAXN];
vector<int> edges_by_color[MAXN];
int parent[MAXN], depth[MAXN], subtree_size[MAXN], dfn[MAXN];
int timer;

// 树状数组
ll bit[MAXN];
int N;

void bit_update(int idx, int delta) {
    for (; idx <= N; idx += idx & -idx) {
        bit[idx] += delta;
    }
}

ll bit_query(int idx) {
    ll sum = 0;
    for (; idx > 0; idx -= idx & -idx) {
        sum += bit[idx];
    }
    return sum;
}

ll query_range(int l, int r) {
    if (l > r) return 0;
    return bit_query(r) - bit_query(l - 1);
}

// 预处理 DFS
void dfs_precompute(int u, int p, int d) {
    parent[u] = p;
    depth[u] = d;
    subtree_size[u] = 1;
    dfn[u] = ++timer;
    for (auto& edge : adj[u]) {
        int v = edge.first;
        if (v == p) continue;
        dfs_precompute(v, u, d + 1);
        subtree_size[u] += subtree_size[v];
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N;
    vector<bool> is_color_used(N + 1, false);
    for (int i = 0; i < N - 1; ++i) {
        int u, v, c;
        cin >> u >> v >> c;
        adj[u].push_back({v, c});
        adj[v].push_back({u, c});
        is_color_used[c] = true;
    }

    dfs_precompute(1, 0, 0);

    for (int u = 1; u <= N; ++u) {
        for (auto& edge : adj[u]) {
            int v = edge.first;
            int c = edge.second;
            if (parent[v] == u) { // 确保是父子边
                edges_by_color[c].push_back(v);
            }
        }
    }

    vector<ll> component_size_counts(N + 1, 0);
    int used_colors_count = 0;

    for (int i = 1; i <= N; ++i) bit_update(i, 1);

    for (int c = 1; c <= N; ++c) {
        if (edges_by_color[c].empty()) continue;
        used_colors_count++;

        // 按dfn降序排，从深到浅处理
        sort(edges_by_color[c].begin(), edges_by_color[c].end(), [&](int u, int v) {
            return dfn[u] > dfn[v];
        });

        vector<pair<int, int>> temp_comps;
        for (int v : edges_by_color[c]) {
            ll comp_size = query_range(dfn[v], dfn[v] + subtree_size[v] - 1);
            temp_comps.push_back({v, (int)comp_size});
            component_size_counts[comp_size]++;
            bit_update(dfn[v], -comp_size);
        }

        component_size_counts[bit_query(N)]++;

        // 恢复BIT
        for (auto& p : temp_comps) {
            bit_update(dfn[p.first], p.second);
        }
    }

    vector<ll> fact(N + 1), invFact(N + 1);
    fact[0] = 1;
    invFact[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
        invFact[i] = modInverse(fact[i]);
    }

    vector<ll> F(N + 1, 0), G_rev(N + 1, 0);
    for (int k = 0; k <= N; ++k) {
        if (component_size_counts[k] > 0) {
            F[k] = (component_size_counts[k] * fact[k]) % MOD;
        }
    }
    for (int j = 0; j <= N; ++j) {
        G_rev[j] = invFact[j];
    }
    reverse(G_rev.begin(), G_rev.end());

    vector<ll> H = NTT::multiply(F, G_rev);

    vector<ll> T(N + 1);
    for (int i = 1; i <= N; ++i) {
        if (H.size() > N + i) {
            T[i] = (H[N + i] * invFact[i]) % MOD;
        } else {
            T[i] = 0;
        }
    }

    auto nCr = [&](int n, int r) {
        if (r < 0 || r > n) return 0LL;
        return (((fact[n] * invFact[r]) % MOD) * invFact[n - r]) % MOD;
    };

    for (int i = 1; i <= N; ++i) {
        ll total_sum = (used_colors_count * nCr(N, i)) % MOD;
        total_sum = (total_sum - T[i] + MOD) % MOD;
        ll ans = (total_sum * modInverse(nCr(N, i))) % MOD;
        cout << ans << (i == N ? "" : " ");
    }
    cout << endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**:
    - `dfs_precompute`: 遍历整棵树，时间复杂度为 $O(N)$。
    - 计算 $N_k$ (component_size_counts): 我们遍历每种颜色，对于每种颜色，我们处理其对应的所有边。每条边在整个过程中只会被处理一次。对每个颜色内的边排序，总的排序复杂度为 $\sum |E_c| \log |E_c| \le N \log N$。树状数组的操作是 $O(\log N)$。所以这部分总复杂度是 $O(N \log N)$。
    - NTT: 两个大小为 $N$ 的多项式相乘，复杂度为 $O(N \log N)$。
    - 计算最终答案：$O(N)$。
    - 综上，总时间复杂度为 $O(N \log N)$，瓶颈在于排序和NTT，完全可以通过，喵~

- **空间复杂度**:
    - 邻接表、各种预处理数组（parent, depth, etc.）、树状数组都需要 $O(N)$ 的空间。
    - NTT中用于存储多项式的 `vector` 也需要 $O(N)$ 的空间。
    - 所以，总空间复杂度为 $O(N)$。

## 知识点总结

这道题是一道非常棒的综合题，像一盘丰盛的猫饭，融合了多种算法和思想，吃下去回味无穷！

1.  **期望的线性性**: 解决期望问题的万能钥匙！将复杂的总体期望分解为简单的个体期望（或概率）之和。
2.  **组合计数与容斥原理**: 通过计算补集（颜色不出现的情况）来简化问题，是组合数学中常用的技巧。
3.  **树上算法**: DFS、DFS序、子树大小等是解决树问题的基本功，必须熟练掌握。
4.  **数据结构**: 树状数组（Fenwick Tree）在这里被巧妙地用来动态维护子树信息，实现了高效计算。
5.  **生成函数与多项式**: 将组合计数问题转化为多项式运算，是处理复杂求和式的强大工具。
6.  **NTT (快速数论变换)**: 实现多项式乘法的核心算法，是算法竞赛中处理卷积问题的标准解法。

通过这道题，我们可以深刻体会到，将不同领域的知识点融会贯通，才能解决更具挑战性的问题。希望大家都能从中学到东西，变得更强，喵~！