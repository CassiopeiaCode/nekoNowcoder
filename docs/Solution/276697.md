# D. 0011 - 题解

### 比赛与标签
> **比赛**: The 2nd Universal Cup. Stage 10: Dolgoprudny
> **标签**: combinatorics, data structures, dfs and similar, dp, trees
> **难度**: *2500

## 题目大意喵~
主人你好呀~ 这道题是这样的喵：

我们有一个长度为 `4n` 的 01 字符串 `s`。我们需要进行 `n` 次操作，直到把整个字符串消除干净为止。

每次操作，我们要在当前的字符串里找到一个子串 "0011"，然后把它删掉。如果我们是第 `j` 次操作，并且删掉的 "0011" 在当前字符串的起始位置是 `i` (从1开始计数哦)，我们就记下 `x_j = i`。

我们的任务是，计算有多少种不同的操作序列 `(x_1, x_2, ..., x_n)`，能够最终把整个字符串删空。因为答案可能很大，所以要对 `10^9 + 7` 取模哦！

两种方案被认为是不同的，只要它们操作序列 `x` 中有任何一个位置的值不一样，就算不同啦。

## 解题思路大揭秘！
喵哈哈，看到这种“消除”、“配对”、“嵌套”感觉的题目，本猫娘的DNA就动起来了！这不就是栈和树的绝佳舞台嘛！让本喵带你一步步拆解这个问题！

### Step 1: 括号匹配？不，是 "0011" 匹配！

首先，我们要判断给定的字符串 `s` 是否能被完全消除。一个 "0011" 子串可以被看作一对可以消除的括号。比如 "0011" 就像 `()`。那一个字符串比如 "00001111"，就可以看成是 `( ( ) )` 这样的嵌套结构。

这种匹配问题，用**栈**来解决最合适不过了！我们可以遍历整个字符串 `s`：
1.  把每个字符和它的原始下标（从0到 `4n-1`）作为一个组合，压入栈中。
2.  每当压入一个新字符后，就检查栈顶的四个元素是不是恰好构成了 "0011" 的模式。
3.  如果是的话，说明我们找到了一个可以消除的最小单位！就像匹配了一对括号一样，把这四个元素从栈顶弹出。

如果在遍历完整个字符串 `s` 之后，栈正好变空了，那就说明这个字符串是合法的，可以被完全消除！如果栈里还有剩下的字符，那就说明无法完全消除，方案数自然就是 0 啦，可以直接输出 "0" 跑路，喵~

在弹栈的时候，我们顺便记录一下每个字符是被哪个 "0011" 块消除的。我们可以用 `lpos[i]` 和 `rpos[i]` 数组记录下标为 `i` 的字符所属的 "0011" 块的左右端点原始下标。

### Step 2: 从序列到树的华丽变身！

既然我们已经知道了所有 "0011" 的匹配关系，我们就能发现这些匹配关系存在着**嵌套**。比如在 `00001111` 中，内层的 "0011"（原始下标 1,2,3,4）被外层的 "0011"（原始下标 0,1,2,3,4,5,6,7...不对，是0,1...6,7）包裹着。

这种层层包裹的结构，用一棵**树**来表示再形象不过了！
- 每一个可以被消除的 "0011" 块，我们都把它看作树上的一个**节点**。
- 如果一个块 `A` 完全包含另一个块 `B`，并且 `A` 中除了 `B` 之外没有其他块包裹 `B`，那么 `B` 对应的节点就是 `A` 对应节点的**子节点**。

举个栗子：`s = 00001111`
1.  内层的 `s[2..5]` 是 "0011"，它是一个节点，我们称之为 `u`。
2.  外层的 `s[0..7]` 在消除 `u` 之后会变成 "0011"，它也是一个节点，我们称之为 `v`。
3.  `v` 包裹了 `u`，所以 `u` 是 `v` 的孩子。

我们可以创建一个虚拟的“超级根节点”，所有最外层的 "0011" 块都作为它的子节点。这样，所有的删除操作就构成了一棵井然有序的树！

### Step 3: 在树上快乐地DP！

问题转化成了：在一棵代表操作依赖关系的树上，有多少种合法的操作顺序？这就可以用**树形DP**来解决了！

我们定义 `dfs(u)` 来计算以 `u` 为根的子树所代表的消除方案数。
- `sz[u]`: 以 `u` 为根的子树中，包含了多少次 "0011" 消除操作（也就是子树的节点数）。
- `f[u]`: 将以 `u` 为根的子树所代表的子问题（即消除 `u` 块内部的所有小块，最后再消除 `u` 块本身）全部完成的方案数。

`dfs(u)` 的过程如下：
1.  初始化 `f[u] = 1`（代表最后消除 `u` 本身这一步操作），`sz[u] = 0`。
2.  遍历 `u` 的所有子节点 `v`：
    -   递归调用 `dfs(v)` 计算出 `f[v]` 和 `sz[v]`。
    -   现在，我们有了 `sz[u]` 个已经合并的操作（来自 `u` 的其他已处理过的孩子），和 `sz[v]` 个来自子树 `v` 的新操作。我们需要将这 `sz[v]` 个操作插入到 `sz[u]` 个操作的序列中。
    -   这相当于把 `sz[v]` 个球（来自`v`的操作）放进 `sz[u] + 1` 个盒子（`sz[u]`个操作形成的`sz[u]+1`个空隙）。这是一个经典的组合问题（隔板法/插空法）！方案数是 `C(sz[u] + sz[v], sz[u])`。
    -   所以，我们将 `f[u]` 更新为 `f[u] * f[v] * C(sz[u] + sz[v], sz[u])`。
    -   然后，把 `v` 子树的操作数加进来：`sz[u] += sz[v]`。
3.  遍历完所有子节点后，`sz[u]` 是 `u` 所有孩子的操作数之和。别忘了 `u` 本身也是一次操作！所以 `sz[u]` 最后要加 1。

最终，调用 `dfs(超级根节点)`，得到的 `f[超级根节点]` 就是我们想要的答案啦！

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

#ifdef LOCAL
    #define debug(...) cout << "[" << #__VA_ARGS__ << "]: ", print_args(__VA_ARGS__)
    template <class... T>
    void print_args(T... args) { ((cout << args << ' '), ...) << '\n'; }
#else
    #define debug(...) void()
#endif

const ll N = 2e5 + 10, mod = 1e9 + 7;
ll fact[N];

// 快速幂，用来求逆元
ll qpow(ll a, ll n) {
    ll res = 1;
    a %= mod;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}
ll inv(ll x) { return qpow(x, mod - 2); }

// 预处理阶乘
void init_fact() {
    fact[0] = 1;
    for (int i = 1; i < N; ++ i) fact[i] = fact[i - 1] * i % mod;
}
// 计算组合数 C(n, m)
ll c(ll n, ll m) {
    if (n < m || m < 0) return 0; // 别忘了边界检查喵
    return fact[n] * inv(fact[m]) % mod * inv(fact[n - m]) % mod;
}
// n 个相同的球，m 个不同的盒子，盒子可为空
// 相当于 C(n + m - 1, m - 1)
ll calc(ll n, ll m) { return c(n + m - 1, m - 1); }

void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    assert(s.size() == n * 4);

    // 用栈来匹配 "0011"
    vector<array<int, 2>> stk; // 存储 {字符类型 '0'或'1', 原始下标}
    vector<int> lpos(n * 4), rpos(n * 4); // 记录每个字符所属块的左右端点
    
    // 检查栈顶4个元素是否为 "0011"
    auto valid = [&]() {
        int sz = stk.size();
        return stk[sz - 4][0] == 0 && stk[sz - 3][0] == 0 &&
            stk[sz - 2][0] == 1 && stk[sz - 1][0] == 1;
    };
    // 弹出栈顶的 "0011" 块，并记录信息
    auto pop = [&]() {
        int l = stk[stk.size() - 4][1];
        int r = stk[stk.size() - 1][1];
        for (int i = 0; i < 4; ++ i) {
            lpos[stk.back()[1]] = l;
            rpos[stk.back()[1]] = r;
            stk.pop_back();
        }
    };
    
    for (int i = 0; i < 4 * n; ++ i) {
        stk.push_back({s[i] == '1', i});
        if (stk.size() >= 4 && valid()) pop();
    }
    
    // 如果栈非空，说明无法完全消除，方案为0
    if (stk.size()) return cout << "0\n", void();

    // 构建操作树
    int root = n * 4; // 虚拟超级根节点
    vector<vector<int>> e(n * 4 + 1);
    vector<int> fa = {root}; // 用一个栈来辅助建树，存储当前节点的父节点链
    for (int i = 0; i < 4 * n; ++ i) {
        if (lpos[i] == i) { // i 是一个 "0011" 块的起始
            e[fa.back()].push_back(i); // 成为当前父节点的子节点
            fa.push_back(i); // 进入这个新块，i 成为新的父节点
        } else if (fa.back() != root && rpos[fa.back()] == i) { // i 是当前块的结尾
            fa.pop_back(); // 返回上一层父节点
        }
    }

    // 树形DP
    vector<ll> f(4 * n + 1), sz(4 * n + 1); // f[u]: u子树方案数, sz[u]: u子树操作数
    function<void(int u)> dfs = [&](int u) {
        f[u] = 1;
        sz[u] = 0;
        for (auto v : e[u]) {
            dfs(v);
            // 组合：将v子树的sz[v]个操作与当前已合并的sz[u]个操作进行混合
            // f[v]是v子树内部的方案数，calc是混合的方案数
            f[u] = f[u] * f[v] % mod * calc(sz[v], sz[u] + 1) % mod;
            sz[u] += sz[v];
        }
        ++ sz[u]; // 加上u本身的一次操作
    };
    dfs(root);
    cout << f[root] << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    init_fact(); // 初始化阶乘表

    int t;
    cin >> t;
    while (t -- ) {
        solve();
    }

    return 0;
}
```

## 复杂度分析
- **时间复杂度**: O(N) 的说，其中 N 是字符串的长度 `4n`。
  - 预处理阶乘是 O(N)。
  - 栈操作和建树都只遍历了一遍字符串，是 O(N)。
  - 树形DP中每个节点和每条边也只访问一次，还是 O(N)。
  - 所以总的来说非常快喵~
- **空间复杂度**: O(N) 的说。
  - 阶乘表、栈、`lpos`、`rpos`、树的邻接表以及DP数组都需要 O(N) 的空间。

## 知识点与总结
这道题真是一次有趣的冒险呢，喵~ 它完美地融合了多种算法思想：

1.  **栈的应用**：使用栈来解析和匹配嵌套结构，是处理这类问题的经典模式。
2.  **问题转化**：最关键的一步，是将线性的、动态的删除过程，抽象成一个静态的、层次分明的**树结构**。这种转化思维在很多难题中都至关重要！
3.  **树形DP**：在构建好的树上，利用DP自底向上地统计方案数。
4.  **组合数学**：DP的状态转移方程涉及到了组合计数，具体来说是如何将两组有序的操作序列合并成一个，同时保持它们各自内部的相对顺序。这里用到的“插空法”或“隔板法”是组合数学中的基本工具。

所以，主人下次再遇到这种看起来很复杂、一步步操作改变状态的计数问题时，不妨想一想：
- 能不能用栈来简化过程？
- 操作之间有没有嵌套或依赖关系？
- 能不能把这些关系建成一棵树，然后在树上解决问题呢？

希望本猫娘的题解能帮到你哦！加油，你一定可以的，喵~ >ω<