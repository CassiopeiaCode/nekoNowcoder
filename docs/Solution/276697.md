# 0011 序列消除 - 题解

### 比赛与标签
> **比赛**: （未提供）

> **标签**: `dp`, `树形dp`, `组合数学`, `栈`, `思维`

> **难度**: `*2500`

## 题目大意喵~

主人你好呀，喵~ 这是一道关于字符串操作的计数问题哦！

我们有一个长度为 $4n$ 的 `01` 字符串。我们需要进行 $n$ 次操作，直到把整个字符串都消除掉。

每次操作是这样的：
1.  在当前字符串中，找到一个连续的子串，它恰好是 "0011"。
2.  把这个 "0011" 子串从字符串中删掉。剩下的部分会拼接在一起，形成一个新的、更短的字符串。
3.  记下这次操作删除的 "0011" 在 *当前* 字符串中的起始位置（从1开始数哦）。

我们要做的，就是计算一共有多少种不同的操作序列，可以最终把整个字符串删空。两种操作序列不同，当且仅当它们在某一步选择删除的 "0011" 的起始位置不同。

最后的结果要对 $10^9+7$ 取模，可别忘了哦，喵~

## 解题思路分析

这道题看起来像是在玩一种消除游戏，每次消除一个 "0011" 小方块，喵~ 看到这种嵌套消除的结构，我的猫猫直觉告诉我，这背后一定藏着一棵树！

#### 第一步：识别 "0011" 的匹配结构

一个字符串能被完全消除，意味着它必须能被完美地分解成若干个 "0011" 块。这很像括号匹配问题，不是吗？"00" 就像左括号 `(`, "11" 就像右括号 `)`. 一个合法的字符串，比如 `00001111`，可以看作是 `00(0011)11`，一个 `0011` 嵌套在另一个里面。而 `00110011` 则是两个 `0011` 并列。

怎么找出这种结构呢？用栈！这可是处理匹配问题的万能工具，喵~

我们可以遍历整个字符串，用一个栈来帮助我们识别出这些可以被消除的 "0011" 块。
1.  我们创建一个栈，里面存放字符和它们在原始字符串中的位置。
2.  从左到右扫描字符串 `s`。
3.  每遇到一个字符，就把它和它的索引一起压入栈中。
4.  在压入后，我们检查栈顶的四个元素。如果它们恰好组成了 `0, 0, 1, 1` 的序列，就说明我们找到了一个最内层的、可以立即消除的 "0011" 块！
5.  找到后，就把这四个元素从栈顶弹出。这个过程就模拟了一次消除操作。

如果遍历完整个字符串后，栈变空了，那就说明这个字符串是合法的，可以被完全消除。如果栈里还有剩下的字符，那说明匹配失败，无论如何也无法删空，方案数就是 0 啦。

#### 第二步：构建消除关系树

通过上面的栈操作，我们其实已经揭示了 "0011" 块之间的嵌套关系。一个块 `B` 在另一个块 `A` 内部（比如 `00...B...11`），意味着要消除 `A`，必须先消除 `B`。这不就是树上的父子关系嘛！

我们可以把每个 "0011" 块看作一个节点。
-   如果块 `B` 被块 `A` 直接包含，那么 `B` 就是 `A` 的一个孩子节点。
-   如果块 `A` 和 `B` 是并列的（比如 `...A...B...`），它们就是兄弟节点。

为了方便处理所有并列的顶级块，我们可以想象一个虚拟的“宇宙根”节点，所有最外层的 "0011" 块都是它的孩子。这样，我们就得到了一片森林，或者说一棵以虚拟根为根的树。

举个例子，喵~
-   对于 `s = 00110011`，我们有两个并列的块。树的结构是：`虚拟根 -> {块1, 块2}`。
-   对于 `s = 00001111`，我们有一个块嵌套在另一个里面。树的结构是：`虚拟根 -> 块1(外) -> 块2(内)`。

#### 第三步：树形 DP 计数

现在问题转化成了：在一棵代表消除顺序依赖的树上，计算合法的操作序列数。一个父节点代表的块，必须在它所有子节点代表的块都被消除后才能被消除。

这正是树形动态规划（Tree DP）大显身手的时候！我们用 `dfs` 来遍历这棵树，从叶子节点往上计算。

对于树中的每个节点 `u`（代表一个 "0011" 块），我们需要计算两个值：
1.  `size[u]`: 以 `u` 为根的子树中，总共有多少个 "0011" 块（包括 `u` 自己）。这代表要完全消除 `u` 这整个大家族，需要多少次操作。
2.  `dp[u]`: 将以 `u` 为根的子树完全消除的方案数。

`dfs(u)` 的计算过程如下：
-   **基本情况**：如果 `u` 是一个叶子节点，它没有孩子。消除它只需要一步操作。所以 `size[u] = 1`，`dp[u] = 1`。
-   **递归计算**：对于一个非叶子节点 `u`，它有孩子 `v_1, v_2, ..., v_k`。
    -   我们首先递归调用 `dfs` 计算出所有子节点 `v_j` 的 `size[v_j]` 和 `dp[v_j]`。
    -   要消除 `u`，我们必须先消除它所有孩子代表的子树。这些子树的消除是独立的，但它们的操作序列需要被合并（或者说，交错排列）。
    -   假设我们已经处理了前 `i-1` 个孩子，得到了一个包含 `S_{i-1} = \sum_{j=1}^{i-1} size[v_j]` 次操作的合并序列，方案数为 `F_{i-1}`。现在要并入第 `i` 个孩子 `v_i` 的操作序列（长度为 `size[v_i]`，方案数为 `dp[v_i]`）。
    -   我们需要将一个长度为 `S_{i-1}` 的序列和一个长度为 `size[v_i]` 的序列交错合并。总操作数是 `S_{i-1} + size[v_i]`。我们可以从这 `S_{i-1} + size[v_i]` 个总位置中，选出 `size[v_i]` 个位置给 `v_i` 的操作。方案数是组合数 $C(S_{i-1} + size[v_i], size[v_i])$。
    -   所以，合并后的总方案数 `F_i = F_{i-1} \times dp[v_i] \times C(S_{i-1} + size[v_i], size[v_i])$。
    -   我们对所有孩子依次进行这个合并过程。
    -   最终，`dp[u]` 就是所有孩子合并后的总方案数。`size[u]` 则是 `1 + \sum size[v_j]`。

这里有一个很巧妙的组合数学视角，喵~ 将 `size[v_i]` 个操作（看作相同的球）放入由 `S_{i-1}` 个操作产生的 `S_{i-1} + 1` 个间隙（看作不同的盒子）中，方案数是 $C(size[v_i] + (S_{i-1}+1) - 1, (S_{i-1}+1)-1) = C(size[v_i] + S_{i-1}, S_{i-1})$。这和我们上面的推导是一样的！

最终的答案就是 `dp[虚拟根]`。

总结一下步骤：
1.  预处理阶乘和逆元，用于快速计算组合数。
2.  用栈方法解析字符串，判断合法性并找出所有 "0011" 块的范围。
3.  根据块的嵌套关系建树。
4.  在树上进行一次 DFS，用动态规划计算出方案数。

这样一步步下来，问题就迎刃而解啦！是不是很有趣，呐？

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦！希望能帮助到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include <algorithm>

using namespace std;

const int MOD = 1e9 + 7;
const int MAX_LEN = 200005; // 4n <= 200000

long long fact[MAX_LEN];
long long invFact[MAX_LEN];

// 快速幂计算 a^b % MOD
long long power(long long base, long long exp) {
    long long res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 计算模逆元
long long modInverse(long long n) {
    return power(n, MOD - 2);
}

// 预计算阶乘和阶乘的逆元
void precompute_factorials(int n) {
    fact[0] = 1;
    invFact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
        invFact[i] = modInverse(fact[i]);
    }
}

// 计算组合数 C(n, k)
long long nCr_mod_p(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    return (((fact[n] * invFact[k]) % MOD) * invFact[n - k]) % MOD;
}

// dp_ways[u] 存储消除子树u的方案数
// subtree_size[u] 存储子树u的节点数
vector<long long> dp_ways;
vector<int> subtree_size;
vector<vector<int>> adj;

void dfs(int u) {
    // 初始化当前节点的DP值
    dp_ways[u] = 1;
    subtree_size[u] = 0;

    for (int v : adj[u]) {
        dfs(v);
        
        // 合并子问题 v 到当前节点 u
        // 1. 方案数相乘
        dp_ways[u] = (dp_ways[u] * dp_ways[v]) % MOD;
        
        // 2. 乘以交错排列的方案数
        // 我们有 subtree_size[u] 个操作和 subtree_size[v] 个操作
        // 总共有 subtree_size[u] + subtree_size[v] 个操作
        // 从中选 subtree_size[v] 个位置给v的操作序列
        long long interleave_ways = nCr_mod_p(subtree_size[u] + subtree_size[v], subtree_size[v]);
        dp_ways[u] = (dp_ways[u] * interleave_ways) % MOD;
        
        // 3. 累加子树大小
        subtree_size[u] += subtree_size[v];
    }
    
    // 加上节点 u 本身
    subtree_size[u]++;
}


void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;

    int len = 4 * n;
    vector<pair<char, int>> stk;
    vector<int> block_start(len, -1), block_end(len, -1);
    vector<int> block_nodes; // 存储每个块的起始位置，即树节点

    for (int i = 0; i < len; ++i) {
        stk.push_back({s[i], i});
        if (stk.size() >= 4) {
            int sz = stk.size();
            if (stk[sz-4].first == '0' && stk[sz-3].first == '0' &&
                stk[sz-2].first == '1' && stk[sz-1].first == '1') {
                
                int start_idx = stk[sz-4].second;
                int end_idx = stk[sz-1].second;
                
                block_nodes.push_back(start_idx);
                
                for (int k = 0; k < 4; ++k) {
                    int original_idx = stk.back().second;
                    block_start[original_idx] = start_idx;
                    block_end[original_idx] = end_idx;
                    stk.pop_back();
                }
            }
        }
    }

    if (!stk.empty()) {
        cout << 0 << "\n";
        return;
    }

    // 构建消除树
    int VIRTUAL_ROOT = len;
    adj.assign(len + 1, vector<int>());
    
    vector<int> parent_stack;
    parent_stack.push_back(VIRTUAL_ROOT);

    for (int i = 0; i < len; ++i) {
        if (block_start[i] == i) { // 一个新块的开始
            adj[parent_stack.back()].push_back(i);
            parent_stack.push_back(i);
        }
        if (block_end[i] == i) { // 一个块的结束
            // 确保我们不是在处理一个不存在于栈顶的块的结尾
            // （正常情况下，block_end[parent_stack.back()] 应该等于 i）
            if (parent_stack.back() != VIRTUAL_ROOT && block_end[parent_stack.back()] == i) {
                parent_stack.pop_back();
            }
        }
    }
    
    // 树形DP
    dp_ways.assign(len + 1, 0);
    subtree_size.assign(len + 1, 0);
    
    dfs(VIRTUAL_ROOT);
    
    // 最终答案是虚拟根节点的方案数。
    // 虚拟根自己不代表一次操作，所以它的size是n+1, dp值是最终答案。
    cout << dp_ways[VIRTUAL_ROOT] << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    precompute_factorials(MAX_LEN - 1);

    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N)$，其中 $N = 4n$ 是字符串的长度。
    -   预计算阶乘和逆元需要 $O(N \log MOD)$ 或者线性预处理逆元 $O(N)$。这里我们用了快速幂，所以是 $O(N \log MOD)$，但由于只做一次，均摊下来很快。
    -   用栈解析字符串的过程是线性的，每个字符入栈出栈最多一次，所以是 $O(N)$。
    -   建树的过程也是线性扫描一次字符串，所以是 $O(N)$。
    -   树形 DP 的 `dfs` 过程访问每个节点和每条边一次，节点数最多为 $n+1$，所以是 $O(n)$。
    -   总的来说，整个算法的瓶颈在于对字符串的处理，所以时间复杂度是 $O(N)$ 的说。

-   **空间复杂度**: $O(N)$。
    -   我们需要存储阶乘、逆元、邻接表、DP数组等，它们的大小都和 $N$ 或 $n$ 线性相关。
    -   栈和 `parent_stack` 的深度最大也是 $O(N)$。
    -   所以空间复杂度是 $O(N)$，喵~

## 知识点总结

这道题真是一场美妙的思维旅行，融合了多种算法思想呢！
1.  **栈的应用**: 栈是解决匹配和嵌套结构的利器。通过模拟消除过程，我们可以有效地识别出基本单元及其层次关系。
2.  **问题转化**: 将一个看似复杂的字符串操作计数问题，转化为一个清晰的树上组合计数问题，是解题的关键一步。这种抽象和建模的能力非常重要哦！
3.  **树形动态规划 (Tree DP)**: 在树形结构上进行动态规划是解决这类问题的经典范式。通过 DFS 从子节点向父节点传递信息，最终求解整个问题。
4.  **组合数学**: DP 的转移方程涉及到了组合计数。理解如何将多个有序序列交错排列（即多项式系数或其迭代形式），并用组合数 $C(n,k)$ 来计算，是本题的数学核心。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，变得更强吧，喵~！