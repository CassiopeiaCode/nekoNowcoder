# 本题 easy version 的唯一区别是，本题需要求解一个序列中任两个不同的数的 k 进制异或和的和。 - 题解

### 比赛与标签
> **比赛**: (比赛信息未提供喵~)
> **标签**: 数学, 位运算, 贡献法
> **难度**: *2000

## 喵喵的题目解读
喵哈喽，各位算法大师们！今天本喵要带大家攻略一道关于 k 进制异或的有趣题目哦~

题目是这样哒：我们有一个包含 `n` 个数字的序列 `a`，还有一个整数 `k`。我们需要计算一个“总权重”。这个总权重是序列中任意两个**不同**的数字 `a_i` 和 `a_j` 的 “k进制异或和” 的总和。

那什么是“k进制异或”呢？其实就是 k 进制下的不进位加法啦。举个例子，如果 `k=10`，两个数字在某一位上分别是 `3` 和 `8`，那么它们在这一位的 k 进制异或结果就是 `(3 + 8) % 10 = 1`。整个数字的 k 进制异或就是把每一位都这么算一遍，然后加权求和。

我们的任务就是，计算出所有 `a_i` 和 `a_j` (`i < j`) 的 k 进制异或值，然后把它们全部加起来，最后对 `10^9 + 7` 取个模。数据范围还挺大的，`n` 可以到 `2*10^6`，`a_i` 更是达到了 `10^18`，所以暴力枚举所有数对肯定是不行的说！

## 解题思路喵~
直接计算 `n(n-1)/2` 对数字的和太慢了，肯定会超时的说。当遇到这种和“位运算”或者“进制”相关的求和问题时，一个非常强大的思想就闪亮登场啦——**按位贡献法**！

简单来说，就是我们不一个一个地计算每对 `(a_i, a_j)` 的异或和，而是考虑每一位（digit）对最终总答案的贡献。

### 1. 拆解问题
一个十进制数 `A` 可以表示成 `A = ... + A_d * 10^d + ... + A_0 * 10^0`。同理，一个 k 进制数也可以这么表示。
`k` 进制异或 `a_i \oplus_k a_j` 的值，可以看成是每一位的异或结果再乘以其对应的权重（`k^d`）得到的。
也就是说：
`a_i \oplus_k a_j = \sum_{d=0}^{\infty} ((a_{i,d} + a_{j,d}) \pmod k) \cdot k^d`
其中 `a_{i,d}` 是 `a_i` 在 `k` 进制下第 `d` 位的值。

我们要计算的总和 `ANS` 就是：
`ANS = \sum_{1 \le i < j \le n} (a_i \oplus_k a_j)`
`ANS = \sum_{1 \le i < j \le n} \sum_{d=0}^{\infty} ((a_{i,d} + a_{j,d}) \pmod k) \cdot k^d`

根据加法的交换律和结合律，我们可以把求和顺序换一下：
`ANS = \sum_{d=0}^{\infty} k^d \cdot \left[ \sum_{1 \le i < j \le n} ((a_{i,d} + a_{j,d}) \pmod k) \right]`

看呐！问题被我们分解成了对每一位 `d`，计算所有数对在这一位的贡献，然后乘以 `k^d`，最后全部加起来。这样就好处理多啦！

### 2. 计算每一位的贡献
现在，我们专注于第 `d` 位。我们需要计算 `Contribution_d = \sum_{1 \le i < j \le n} ((a_{i,d} + a_{j,d}) \pmod k)`。

` (x + y) \pmod k ` 这个式子有点讨厌。我们可以把它拆开：
- 如果 `x + y < k`，则 `(x + y) \pmod k = x + y`。
- 如果 `x + y \ge k`，则 `(x + y) \pmod k = x + y - k`。

所以，`Contribution_d` 可以写成：
`Contribution_d = \sum_{1 \le i < j \le n} (a_{i,d} + a_{j,d}) - k \cdot (\text{满足 } a_{i,d} + a_{j,d} \ge k \text{ 的数对 } \{i, j\} \text{ 的数量})`

我们把这个式子分成两部分来计算：

#### 第一部分：`\sum_{1 \le i < j \le n} (a_{i,d} + a_{j,d})`
这是一个经典的组合计数问题。我们考虑每个 `a_{i,d}` 会被加多少次。在所有的数对中，`a_{i,d}` 会和 `n-1` 个其他的 `a_{j,d}` (`j \neq i`) 配对。所以，每个 `a_{i,d}` 在这个总和里都出现了 `n-1` 次。
因此，`\sum_{1 \le i < j \le n} (a_{i,d} + a_{j,d}) = (n-1) \cdot \sum_{i=1}^{n} a_{i,d}`。
`\sum a_{i,d}` 也很容易算。我们先遍历一遍所有 `n` 个数，统计出第 `d` 位数字是 `0, 1, ..., k-1` 的分别有多少个，记在 `cnt[0], cnt[1], ..., cnt[k-1]` 数组里。那么 `\sum a_{i,d} = \sum_{x=0}^{k-1} x \cdot cnt[x]`。

#### 第二部分：计算“进位”的数对数量
我们需要计算有多少对 `{i, j}` (`i < j`) 满足 `a_{i,d} + a_{j,d} \ge k`。
直接计算无序数对 `{i, j}` 有点麻烦，我们可以先计算**有序**数对 `(i, j)`（允许 `i=j`）的数量，然后再转换。

令 `T_{total}` 为满足 `a_{i,d} + a_{j,d} \ge k` 的**有序**数对 `(i, j)` 的数量。
`T_{total} = \sum_{x=0}^{k-1} \sum_{y=0}^{k-1} [x+y \ge k] \cdot cnt[x] \cdot cnt[y]`
这个可以通过两层循环 `O(k^2)` 算出。

`T_{total}` 包含了三种情况：
1. `(i, j)` 其中 `i < j`
2. `(j, i)` 其中 `i < j` (和上面是对称的)
3. `(i, i)` (对角线上的元素)

我们想要的只是第一种情况的数量。
- 对于 `i \neq j` 的情况，如果 `(i, j)` 满足条件，那么 `(j, i)` 也一定满足，它们在 `T_{total}` 中被算了两次。
- 对于 `i = j` 的情况，`a_{i,d} + a_{i,d} \ge k`，即 `2 \cdot a_{i,d} \ge k`。这种对角线上的数对 `(i, i)` 只被算了一次。

所以，我们需要从 `T_{total}` 中减去对角线上满足条件的元素，然后除以2，就能得到 `{i, j}` (`i < j`) 的数量。
令 `same_part` 为满足 `2 \cdot a_{i,d} \ge k` 的 `i` 的数量。
`same_part = \sum_{x=0}^{k-1} [2x \ge k] \cdot cnt[x]`。
那么，我们要求的“进位”数对数量就是 `(T_{total} - same_part) / 2`。

### 3. 算法总览
好啦，现在我们可以总结出完整的算法流程了：
1. 初始化总答案 `ans = 0`，`k` 的幂 `current_power = 1`，以及用于计算位值的 `kd = 1`。
2. 进入一个循环，处理 `k` 进制的每一位 `d=0, 1, 2, ...`，直到 `kd` 超过所有 `a_i` 的最大值。
3. 在循环中（处理第 `d` 位）：
    a. 创建一个大小为 `k` 的 `cnt` 数组，清零。
    b. 遍历 `n` 个数，计算每个数 `a_i` 的第 `d` 位 `v = (a_i / kd) % k`，并更新 `cnt[v]++`。
    c. 计算 `sum_v = \sum_{x=0}^{k-1} x \cdot cnt[x]`。
    d. 计算有序对“进位”总数 `T_total = \sum_{x=0}^{k-1} \sum_{y=0}^{k-1} [x+y \ge k] \cdot cnt[x] \cdot cnt[y]`。
    e. 计算对角线“进位”数 `same_part = \sum_{x=0}^{k-1} [2x \ge k] \cdot cnt[x]`。
    f. 计算无序对“进位”数 `cnt_total = (T_total - same_part) / 2`。
    g. 计算第 `d` 位对总和的贡献值（不含 `k^d`）: `contribution = (n-1) * sum_v - k * cnt_total`。
    h. 将这一位的最终贡献加到总答案上：`ans = (ans + contribution * current_power) % MOD`。
    i. 更新 `k` 的幂：`current_power = (current_power * k) % MOD`，`kd = kd * k`。
4. 循环结束后，`ans` 就是我们要求的答案啦！别忘了处理可能的负数哦。

## 代码实现喵~
好啦，思路理清了，就让我们把想法变成可爱的代码吧！喵~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<ll> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    ll ans = 0;
    ll current_power = 1; // k^d mod MOD，当前位的权重
    ll kd = 1;            // k^d，用于从数字中提取当前位

    // 循环处理 k 进制的每一位
    while (true) {
        // cnt[v] 存储当前位是 v 的数字有多少个
        vector<int> cnt(k, 0);
        for (ll num : a) {
            ll v = (num / kd) % k; // 提取第 d 位
            cnt[v]++;
        }

        // sum_v = sum(a_{i,d})
        ll sum_v = 0;
        for (int x = 0; x < k; ++x) {
            sum_v += (ll)x * cnt[x];
        }

        // 计算 T_total：满足 a_{i,d} + a_{j,d} >= k 的有序对 (i, j) 的数量
        ll T_total = 0;
        for (int x = 0; x < k; ++x) {
            for (int y = 0; y < k; ++y) {
                if (x + y >= k) {
                    T_total += (ll)cnt[x] * cnt[y];
                }
            }
        }

        // 计算 same_part：满足 2*a_{i,d} >= k 的 i 的数量
        ll same_part = 0;
        for (int x = 0; x < k; ++x) {
            if (x + x >= k) {
                same_part += cnt[x];
            }
        }
        
        // 我们需要的是 i < j 的数对，所以要从 T_total 中去掉 i=j 的情况，然后除以2
        // cnt_total 就是满足 a_{i,d} + a_{j,d} >= k 的无序对 {i, j} (i!=j) 的数量
        T_total -= same_part;
        ll cnt_total = T_total / 2;

        // 计算当前位的总贡献
        // sum_ij 是 (n-1) * sum(a_{i,d})
        ll sum_ij = (sum_v % MOD) * ((n - 1) % MOD) % MOD;
        // subtract 是需要减去的 k * (进位数)
        ll subtract = (k % MOD) * (cnt_total % MOD) % MOD;
        // contribution 是这一位对最终答案的贡献（还未乘以 k^d）
        ll contribution = (sum_ij - subtract) % MOD;
        contribution = contribution * current_power % MOD;
        ans = (ans + contribution) % MOD;

        // 更新下一位的权重和除数
        // 为了防止 kd 溢出 long long
        if (kd > 1000000000000000000LL / k) {
            break;
        } else {
            kd *= k;
        }
        current_power = (current_power * k) % MOD;

        // 如果 kd 已经超过了 a_i 的最大值，更高位就都是0了，可以提前结束
        if (kd > 1000000000000000000LL) {
            break;
        }
    }

    // 处理负数取模的情况
    ans = (ans % MOD + MOD) % MOD;
    cout << ans << "\n";

    return 0;
}
```

## 复杂度分析
- **时间复杂度**: O(log_k(A_max) * (n + k^2)) 的说。
  - 外层的 `while` 循环执行的次数是 `a_i` 最大值的 `k` 进制下的位数，大约是 `log_k(10^18)`，这是一个不大的常数。
  - 循环内部，填充 `cnt` 数组需要 `O(n)` 的时间。
  - 计算 `T_total` 需要 `O(k^2)` 的时间。
  - 所以总时间是 `O(log_k(A_max) * (n + k^2))`。对于本题的数据范围，这个效率是完全足够的！
- **空间复杂度**: O(n) 的说。
  - 主要的空间开销是存储输入的数组 `a`，需要 `O(n)`。`cnt` 数组只需要 `O(k)` 的空间。

## 知识点与总结喵~
这道题真是太棒了，巧妙地融合了数学和位运算的思想，喵~

1.  **核心思想 - 按位贡献法**: 这是解决这类问题的一把利刃！当整体计算非常复杂时，尝试将问题分解到每一“位”上，分别计算贡献再汇总。无论是二进制还是 `k` 进制，这个思想都非常有用。

2.  **k进制运算的推广**: 本题将我们熟悉的二进制异或（模2不进位加法）推广到了 `k` 进制。理解其本质是 `(x+y)%k` 是解题的关键。

3.  **组合计数技巧**: 在计算 `\sum_{i<j}` 这种形式的和或计数时，先计算更对称、更容易的 `\sum_{i,j}`（所有有序对），然后减去 `i=j` 的情况再除以2，是一个非常常见的转换技巧。

4.  **实现细节**:
    *   一定要用 `long long` 来处理 `a_i` 和 `kd` 这种大数，以及中间的乘法结果，防止溢出。
    *   取模运算 `MOD` 要及时进行，避免中间结果超出 `long long` 的范围。
    *   ` (ans % MOD + MOD) % MOD ` 是处理负数取模的标准写法，非常保险。
    *   用 `kd > 1e18 / k` 来判断 `kd * k` 是否会溢出，是一个比直接乘了再判断更安全的好习惯。

希望这篇题解能帮到你哦！继续加油，在算法的世界里探索更多乐趣吧，喵！