# 本题 easy version 的唯一区别是，本题需要求解一个序列中任两个不同的数的 k 进制异或和的和。 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供]

> **标签**: [题目标签未提供]

> **难度**: [难度评分未提供]

## 题目大意喵~

主人们好喵~！这道题是这样的：我们有一个长度为 $n$ 的序列 $a$，还有一个整数 $k$。我们需要从这个序列里，挑出任意两个**不同**的数 $a_i$ 和 $a_j$。

这两个数可以组成一个“组合”，这个组合的“权重”被定义为它们在 $k$ 进制下的“异或”值。这里的 $k$ 进制异或，其实就是 $k$ 进制下的不进位加法啦，喵~ 也就是说，把两个数都写成 $k$ 进制，然后对每一位分别相加，再对 $k$ 取模，最后得到的结果就是它们的 $k$ 进制异或值。

我们的任务，就是计算所有可能的、由不同数组成的组合的权重之和，最后把这个巨大的总和对 $10^9 + 7$ 取模。

简单来说，就是要计算这个式子：
$$
\text{总权重} = \left( \sum_{1 \le i < j \le n} (a_i \oplus_k a_j) \right) \pmod{10^9 + 7}
$$
其中 $\oplus_k$ 就代表 $k$ 进制异或哦！

## 解题思路分析

看到要计算所有数对的和，最直接的想法就是暴力枚举，对吧？我们可以写两层循环，遍历所有的数对 $(a_i, a_j)$，计算它们的 $k$ 进制异或，然后加起来。但是看看数据范围，$n$ 最大有 $2 \times 10^6$ 呢！$O(n^2)$ 的复杂度肯定会超时的，就像猫娘追不上激光笔的光点一样，会累趴的啦~ 所以，我们得想个更聪明的办法，喵！

这种和位运算（或者说，和数位有关的运算）相关的求和问题，有一个非常经典的思路，叫做**按位贡献法**。它的核心思想是，我们不一个一个地计算 $a_i \oplus_k a_j$ 的完整值，而是把它们的 $k$ 进制表示拆开，分别计算**每一位**对总答案的贡献。

一个数 $X$ 的值可以表示成它在 $k$ 进制下每一位的值的总和：
$$
X = \sum_{p=0}^{\infty} d_p \cdot k^p
$$
其中 $d_p$ 是 $X$ 在 $k$ 进制下第 $p$ 位（从右往左数，从第0位开始）的数字。

那么，两个数的 $k$ 进制异或 $a_i \oplus_k a_j$ 也可以这样表示。设 $a_i$ 的第 $p$ 位是 $d_{i,p}$，$a_j$ 的第 $p$ 位是 $d_{j,p}$。根据定义，$a_i \oplus_k a_j$ 的第 $p$ 位就是 $(d_{i,p} + d_{j,p}) \pmod k$。所以：
$$
a_i \oplus_k a_j = \sum_{p=0}^{\infty} \left( (d_{i,p} + d_{j,p}) \pmod k \right) \cdot k^p
$$
我们要计算的总和 $S$ 就可以写成：
$$
S = \sum_{1 \le i < j \le n} \left( \sum_{p=0}^{\infty} \left( (d_{i,p} + d_{j,p}) \pmod k \right) \cdot k^p \right)
$$
交换一下求和顺序，这个操作就像猫娘把毛线球拆开再重新绕起来一样，虽然看起来复杂，但能让问题变清晰哦！
$$
S = \sum_{p=0}^{\infty} k^p \cdot \left( \sum_{1 \le i < j \le n} (d_{i,p} + d_{j,p}) \pmod k \right)
$$
看！现在我们只需要对每一个数位 $p$，计算出所有数对在这一位的数字之和（模 $k$ 之后的结果），再乘以对应的权重 $k^p$，最后把所有数位的贡献加起来就是答案啦！

接下来，我们专注于如何计算某一个数位 $p$ 的贡献，也就是这个部分：
$$
C_p = \sum_{1 \le i < j \le n} (d_{i,p} + d_{j,p}) \pmod k
$$
我们知道 $(a+b) \pmod k$ 可以写成 $a+b$ 或者 $a+b-k$ 的形式。具体来说：
$$
(d_{i,p} + d_{j,p}) \pmod k = d_{i,p} + d_{j,p} - k \cdot [d_{i,p} + d_{j,p} \ge k]
$$
这里的 $[...]$ 是艾佛森括号，如果里面的条件成立，值为1，否则为0。

代入 $C_p$ 的表达式中，得到：
$$
C_p = \sum_{1 \le i < j \le n} (d_{i,p} + d_{j,p}) - k \cdot \sum_{1 \le i < j \le n} [d_{i,p} + d_{j,p} \ge k]
$$
问题被拆解成了两个小问题，喵~

**小问题1：计算 $\sum_{1 \le i < j \le n} (d_{i,p} + d_{j,p})$**

这个和式里，每个 $d_{i,p}$ 会和多少个其他的 $d_{j,p}$ 相加呢？对于一个固定的 $i$，它会和所有 $j \ne i$ 的数配对，总共有 $n-1$ 对。所以，每个 $d_{i,p}$ 在这个总和里都出现了 $n-1$ 次。
$$
\sum_{1 \le i < j \le n} (d_{i,p} + d_{j,p}) = (n-1) \sum_{i=1}^n d_{i,p}
$$
我们只需要遍历一次所有数字，计算出它们在第 $p$ 位的数字之和 $\sum_{i=1}^n d_{i,p}$，就可以算出这部分啦！

**小问题2：计算 $\sum_{1 \le i < j \le n} [d_{i,p} + d_{j,p} \ge k]$**

这部分是计算有多少对不同的 $(i, j)$，它们在第 $p$ 位的数字之和大于等于 $k$（也就是会产生“进位”的数对数量）。

为了计算这个，我们可以先统计在第 $p$ 位，数字为 $0, 1, \dots, k-1$ 的数各有多少个。我们用一个数组 `counts` 来记录，`counts[v]` 表示第 $p$ 位数字是 $v$ 的数的个数。

然后，我们可以用两层循环来枚举两个数字的第 $p$ 位的值 $v_1$ 和 $v_2$。
- 如果 $v_1 + v_2 \ge k$，那么从第 $p$ 位是 $v_1$ 的数中任选一个，再从第 $p$ 位是 $v_2$ 的数中任选一个，它们组成的数对就满足条件。
    - 如果 $v_1 \ne v_2$，这样的数对有 `counts[v1] * counts[v2]` 个。
    - 如果 $v_1 = v_2$，这样的数对有 `counts[v1] * (counts[v1] - 1) / 2` 个。

把所有满足 $v_1+v_2 \ge k$ 的情况加起来，就是我们想要的数对数量了。这个计算是 $O(k^2)$ 的，因为 $k \le 500$，所以完全可以接受。

**整合一下，我们的完整算法步骤就是：**

1.  初始化总答案 `total_xor_sum = 0`。
2.  初始化一个变量 `power_of_k = 1`，它代表当前处理的数位的权重 $k^p$。
3.  循环处理每一个数位 $p=0, 1, 2, \dots$。当 $k^p$ 超过了所有 $a_i$ 的最大值时，就可以停止了。
4.  在每次循环（处理第 $p$ 位）中：
    a. 创建一个大小为 $k$ 的 `digit_counts` 数组，清零。
    b. 遍历所有输入数字 $a_i$，计算它在第 $p$ 位的数字 `d = (a_i / k^p) % k`，然后 `digit_counts[d]++`。
    c. 计算第 $p$ 位所有数字的总和 `sum_of_digits_p = \sum_{v=0}^{k-1} v \cdot \text{digit\_counts}[v]`。
    d. 计算会产生“进位”的数对数量 `carry_pairs_count`。用 $O(k^2)$ 的方法，枚举所有 $v_1, v_2$ 的组合。
    e. 计算第 $p$ 位对总答案的贡献值：
       `contribution_p = (n-1) * sum_of_digits_p - k * carry_pairs_count`。
    f. 将这份贡献加到总答案中：
       `total_xor_sum = (total_xor_sum + contribution_p * power_of_k) % MOD`。
    g. 更新权重：`power_of_k = (power_of_k * k) % MOD`。
5.  所有数位处理完毕后，`total_xor_sum` 就是最终答案啦！记得处理好取模，特别是负数的情况哦。

这样，我们就把一个 $O(n^2)$ 的问题，变成了一个 $O(\log_k(A_{max}) \cdot (n + k^2))$ 的问题，效率大大提升，可以顺利通过啦，喵~

## 代码实现

这是本猫娘根据上面的思路，精心编写的代码哦！注释很详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>

using namespace std;

// 使用 long long 防止计算过程中溢出
using ll = long long;

const int MOD = 1e9 + 7;

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    ll k;
    cin >> n >> k;

    vector<ll> a(n);
    ll max_a = 0;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        if (a[i] > max_a) {
            max_a = a[i];
        }
    }

    ll total_xor_sum = 0;
    ll power_of_k_val = 1;      // k^p 的实际值，用于提取数位
    ll power_of_k_mod = 1;      // k^p 对 MOD 取模后的值，用于计算贡献

    // 循环处理每一位，直到处理的位数超过了最大数的范围
    while (power_of_k_val <= max_a) {
        
        // 1. 统计当前位上，数字 0, 1, ..., k-1 的出现次数
        vector<ll> digit_counts(k, 0);
        for (ll val : a) {
            ll digit = (val / power_of_k_val) % k;
            digit_counts[digit]++;
        }

        // 2. 计算小问题1：当前位所有数字的和
        ll sum_of_digits_p = 0;
        for (ll v = 0; v < k; ++v) {
            sum_of_digits_p = (sum_of_digits_p + v * digit_counts[v]) % MOD;
        }
        ll part1 = ((ll)(n - 1) * sum_of_digits_p) % MOD;

        // 3. 计算小问题2：会产生进位的数对数量
        ll carry_pairs_count = 0;
        // 使用 O(k^2) 的方法计算
        // 这里的 T_total 是有序对(i,j)的数量，包括 i=j 的情况
        ll T_total = 0;
        for (ll v1 = 0; v1 < k; ++v1) {
            for (ll v2 = 0; v2 < k; ++v2) {
                if (v1 + v2 >= k) {
                    T_total = (T_total + digit_counts[v1] * digit_counts[v2]);
                }
            }
        }

        // T_total 包含了 (i,i) 这样的对自己产生进位的组合，我们需要减去
        // 题目要求是两个不同的数，所以 (i,i) 不算
        // T_total 也包含了 (i,j) 和 (j,i) 两种顺序，我们需要的是无序对
        ll self_carry_count = 0;
        for (ll v = 0; v < k; ++v) {
            if (v + v >= k) {
                self_carry_count = (self_carry_count + digit_counts[v]);
            }
        }
        
        // (T_total - self_carry_count) 得到的是有序且不同元素的进位对数
        // 除以 2 得到无序且不同元素的进位对数
        // 注意：这里 T_total 和 self_carry_count 都没有取模，因为它们是计数，不是最终值
        carry_pairs_count = (T_total - self_carry_count) / 2;
        
        ll part2 = (k % MOD * (carry_pairs_count % MOD)) % MOD;

        // 4. 计算当前位的总贡献
        ll current_digit_contribution = (part1 - part2 + MOD) % MOD;
        
        // 5. 计入总和
        total_xor_sum = (total_xor_sum + current_digit_contribution * power_of_k_mod) % MOD;

        // 6. 更新下一位的权重
        // 检查 power_of_k_val 乘以 k 是否会溢出 long long
        if (max_a / k < power_of_k_val) {
             break;
        }
        power_of_k_val *= k;
        power_of_k_mod = (power_of_k_mod * k) % MOD;
    }

    cout << total_xor_sum << endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(\log_k(A_{max}) \cdot (N + K^2))$
    -   外层循环的次数由数 $a_i$ 的最大值 $A_{max}$ 和基数 $k$ 决定，大约是 $\log_k(A_{max})$ 次。对于本题，$10^{18}$ 在不同 $k$ 下的位数最多也就 60 位左右。
    -   在循环内部，我们需要遍历一次长度为 $N$ 的数组来统计数位，这是 $O(N)$。
    -   接着，我们用一个 $O(K^2)$ 的双重循环来计算产生进位的数对数量。
    -   所以总的时间复杂度是 $O(\log_k(A_{max}) \cdot (N + K^2))$。考虑到 $N$ 远大于 $K^2$，也可以近似看作 $O(N \cdot \log_k(A_{max}))$。

-   **空间复杂度**: $O(N)$
    -   我们用了一个 `vector<ll> a` 来存储输入的 $N$ 个数，占用了 $O(N)$ 的空间。
    -   在循环中，我们用了一个 `digit_counts` 数组，大小为 $k$，占用了 $O(K)$ 的空间。
    -   总的空间复杂度由较大的部分决定，即 $O(N)$。

## 知识点总结

这道题真是一道非常棒的教学题呢，喵~ 从中学到的技巧可以用在很多地方哦！

1.  **按位贡献法**: 这是解决位运算或数位相关求和问题的万能钥匙！当直接计算非常困难时，尝试将问题分解到每一个独立的二进制位或 $k$ 进制位上，分别计算贡献再汇总，往往能奇迹般地简化问题。

2.  **$k$ 进制思想**: 不要局限于二进制！很多二进制下的技巧（比如异或、与、或）可以推广到更一般的 $k$ 进制。这道题的“$k$ 进制异或”就是对二进制异或的一个漂亮推广。

3.  **组合计数与统计**: 在计算“有多少对满足某某条件”时，先用一个数组统计各类元素的频率，再根据频率进行组合计数，是一种非常高效的策略。

4.  **模运算的细节**: 在处理大数求和时，每一步计算后都要及时取模，防止溢出。对于减法，要先加上模数再取模 `(a - b + MOD) % MOD`，以防结果是负数，这可是猫娘的小秘密武器，屡试不爽！

希望这篇题解能帮助你更好地理解这道题，如果还有疑问，随时可以再来找我玩哦，喵~！