# 求 gcd(∑(i=1 to n) i , ∏(i=1 to n) i) - 题解

### 比赛与标签
> **比赛**: S老师的数学小课堂

> **标签**: 数学, GCD, 模运算

> **难度**: ⭐⭐

## 题目大意喵~

各位算法大师，你们好呀，喵~ S老师给我们出了一道看起来有点吓人的数学题哦！

题目要求我们计算两个数的最大公约数（GCD）。这两个数分别是：
1.  从 1 到 $n$ 所有整数的和，也就是 $\sum_{i=1}^{n} i$。
2.  从 1 到 $n$ 所有整数的积，也就是 $\prod_{i=1}^{n} i$。

简单来说，就是求 $\gcd(1+2+\dots+n, 1 \times 2 \times \dots \times n)$ 的值。这里的 $n$ 会给到我们。

比如当 $n=3$ 的时候：
- 和是 $1+2+3 = 6$
- 积是 $1 \times 2 \times 3 = 6$
- 我们就需要求 $\gcd(6, 6)$，答案就是 6 啦！

当 $n=4$ 的时候：
- 和是 $1+2+3+4 = 10$
- 积是 $1 \times 2 \times 3 \times 4 = 24$
- 我们就需要求 $\gcd(10, 24)$，答案就是 2 啦！

看起来很简单，对吧？但是要小心哦，当 $n$ 很大的时候，那个乘积会变得超级超级大，直接算出来可不行呢，喵~

## 解题思路分析

这道题的核心难点在于，当 $n$ 稍微大一点（比如 $n=100$），$n$ 的阶乘（$n!$）就会变成一个天文数字，我们电脑的普通变量是存不下的。所以，我们必须找到一种方法，在不直接计算出 $n!$ 的情况下，求出这个最大公约数。

这就要请出我们数论中的好朋友——最大公约数（GCD）和模运算（Modulo）啦！

#### 第一步：简化求和公式

首先，我们来看看第一个数：从 1 到 $n$ 的和。这是一个经典的等差数列求和，我们小学（或者初中？）就学过它的公式，对吧？
$$
S_n = \sum_{i=1}^{n} i = \frac{n(n+1)}{2}
$$
这个值用 `long long` 类型就可以轻松存下，即使 $n$ 达到 $10^6$ 也没问题。我们就叫它 `sum_val 好了。

#### 第二步：处理巨大的阶乘

现在，我们的问题变成了求 $\gcd(\text{sum\_val}, n!)$。

面对这个巨大的 $n!$，我们该怎么办呢？本猫娘的爪子在键盘上敲出了一个神奇的GCD性质：
$$
\gcd(a, b) = \gcd(a, b \pmod a)
$$
这个性质是什么意思呢？它告诉我们，求 $a$ 和 $b$ 的最大公约数，等价于求 $a$ 和 $b$ 除以 $a$ 的余数的最大公约数。这简直是我们的救星！

我们可以把 sum_val 看作是 $a$，把 $n!$ 看作是 $b$。那么：
$$
\gcd(\text{sum\_val}, n!) = \gcd(\text{sum\_val}, n! \pmod{\text{sum\_val}})
$$
这样一来，我们就只需要计算 $n! \pmod{\text{sum\_val}}$ 的值了。这个余数肯定比 sum_val 小，所以它一定可以被存下来！

#### 第三步：计算 $n! \pmod{\text{sum\_val}}$

那么，如何计算一个巨大数的阶乘对另一个数的取余结果呢？我们不能先算出 $n!$ 再取余，但我们可以利用模运算的另一个性质：
$$
(x \times y) \pmod m = ((x \pmod m) \times (y \pmod m)) \pmod m
$$
这意味着我们可以在乘法的每一步都进行取余操作，结果和最后一次性取余是一样的，而且可以保证中间结果不会溢出！

我们可以设置一个变量 product_mod_sum`，初始值为 1。然后用一个循环，从 1 乘到 $n$：
```
product_mod_sum = 1;
for i from 1 to n:
  product_mod_sum = (product_mod_sum * i) % sum_val;
```
循环结束后，`product_mod_sum 的值就是 $n! \pmod{\text{sum\_val}}$ 啦！

#### 最终的算法~

把所有步骤串起来，我们的解题思路就非常清晰了，喵~
1.  读入 $n$。
2.  计算 $S_n = \frac{n(n+1)}{2}$，记为 sum_val`。
3.  初始化 `product_mod_sum = 1`。
4.  循环 $i$ 从 1 到 $n$，在循环中不断更新 `product_mod_sum = (product_mod_sum * i) % sum_val。
5.  最后，计算 $\gcd(\text{sum\_val}, \text{product\_mod\_sum})$，这就是我们的答案！

举个例子，$n=4$：
1.  sum_val = $4 \times 5 / 2 = 10$。
2.  product_mod_sum` 初始化为 1。
3.  循环开始：
    - $i=1$: `product_mod_sum = $(1 \times 1) \pmod{10} = 1$。
    - $i=2$: product_mod_sum = $(1 \times 2) \pmod{10} = 2$。
    - $i=3$: product_mod_sum = $(2 \times 3) \pmod{10} = 6$。
    - $i=4$: product_mod_sum = $(6 \times 4) \pmod{10} = 24 \pmod{10} = 4$。
4.  循环结束，product_mod_sum 是 4。
5.  计算 $\gcd(10, 4)$，得到 2。就是正确答案，太棒啦！

## 代码实现

下面就是本猫娘根据这个思路精心编写的代码啦，注释写得很详细，希望能帮到你，喵~

``cpp
#include <iostream>

// 一个标准的欧几里得算法（辗转相除法）来求最大公约数
// a 和 b 都是 long long 类型，以防数值过大
long long gcd(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL)
    // 可以让 C++ 的输入输出变得更快，对付大数据量时很有用哦！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 步骤1：计算从1到n的和
    // 为了防止 n * (n + 1) 在计算过程中溢出 int，我们先将 n 转为 long long
    long long sum_val = static_cast<long long>(n) * (n + 1) / 2;

    // 如果 sum_val 是 1，那么和任何数的 GCD 都是 1
    // 提前处理可以避免下面 % 1 的情况，虽然不处理也没问题
    if (sum_val == 1) {
        std::cout << 1 << std::endl;
        return 0;
    }

    // 步骤2：计算 n! % sum_val
    // 我们用一个循环来计算连乘的模，防止 n! 本身溢出
    long long product_mod_sum = 1;
    for (int i = 1; i <= n; ++i) {
        // 在每一步乘法后都取模，这是关键！
        product_mod_sum = (product_mod_sum * i) % sum_val;
    }

    // 步骤3：计算最终的 GCD
    // 根据性质 gcd(a, b) = gcd(a, b % a)，我们求 gcd(sum_val, n! % sum_val)
    // 注意一种特殊情况：如果 n! 能够整除 sum_val，那么 product_mod_sum 会是 0。
    // 此时 gcd(sum_val, 0) 按照定义就是 sum_val 本身。
    long long final_gcd = gcd(sum_val, product_mod_sum);

    std::cout << final_gcd << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(n)$
    我们的主要计算量在于那个从 1 到 $n$ 的循环，循环内部的操作（乘法和取模）都是常数时间的。最后的 `gcd 函数，其时间复杂度大约是 $O(\log(\text{sum\_val}))$，远小于 $O(n)$。所以总的时间复杂度由循环决定，是 $O(n)$，对于 $n \le 10^6$ 的数据范围来说是完全可以接受的，喵~

- **空间复杂度**: $O(1)$
    我们只用了几个变量（n`, `sum_val`, `product_mod_sum`, `final_gcd）来存储计算过程中的值，没有使用任何随 $n$ 增大的数组或者数据结构。所以，我们占用的额外空间是常数级别的，空间复杂度是 $O(1)$。

## 知识点总结

这道题虽然是数学题，但更像是一次巧妙的思维体操呢！通过它，我们可以复习和学到：

1.  **等差数列求和公式**: 快速计算 $\sum_{i=1}^{n} i = \frac{n(n+1)}{2}$。
2.  **最大公约数（GCD）的核心性质**: $\gcd(a, b) = \gcd(a, b \pmod a)$ 是解决无法直接计算大数的关键。
3.  **模运算（Modular Arithmetic）**: 在处理大数乘法时，通过在每一步取模来防止中间结果溢出，是一个非常重要的技巧。
4.  **数据类型选择**: 预估计算结果的范围，并选择合适的变量类型（如 long long`）是避免溢出错误的基础。

希望这篇题解能让你有所收获，以后遇到类似的难题也能像小猫一样，灵活地找到解决办法！加油哦，喵~