# ã€ŒNhk R2ã€é“¾ä¸Šä¹‹é“¾ - é¢˜è§£

### æ ‡ç­¾ä¸éš¾åº¦
> **æ ‡ç­¾**: æ•°æ®ç»“æ„, å¹³è¡¡æ ‘, Treap, FHQ-Treap, åŠ¨æ€DP, åºåˆ—ç»´æŠ¤, æ ‘ä¸Šé—®é¢˜, åµŒå¥—æ•°æ®ç»“æ„
> **éš¾åº¦**: 2900

## é¢˜ç›®å¤§æ„å–µ~

ä¸»äººä½ å¥½å‘€ï¼Œè¿™é“é¢˜æ˜¯å…³äºä¸€ä¸ªå¥‡ç‰¹çš„â€œé“¾ä¸Šä¹‹é“¾â€ç»“æ„çš„åŠ¨æ€ç»´æŠ¤é—®é¢˜ï¼Œå–µ~

æˆ‘ä»¬æœ‰ä¸€ä¸ªåºåˆ—ï¼Œåºåˆ—é‡Œçš„æ¯ä¸ªå…ƒç´ æœ¬èº«å°±æ˜¯ä¸€æ¡å¸¦æƒå€¼çš„â€œå°é“¾â€ã€‚æˆ‘ä»¬éœ€è¦æ”¯æŒå››ç§æ“ä½œï¼š
1.  **åˆ é™¤**: `0 x`ï¼ŒæŠŠåºåˆ—ä¸­ç¬¬ `x` ä¸ªå°é“¾åˆ æ‰ã€‚
2.  **æ’å…¥**: `1 x k v1 ... vk`ï¼Œåœ¨ç¬¬ `x` ä¸ªå°é“¾åé¢ï¼Œæ’å…¥ä¸€æ¡æ–°çš„ã€é•¿åº¦ä¸º `k` çš„å°é“¾ã€‚
3.  **åŒºé—´ä¿®æ”¹**: `2 x l r v`ï¼ŒæŠŠç¬¬ `x` ä¸ªå°é“¾ä¸Šï¼Œä»ç¬¬ `l` ä¸ªèŠ‚ç‚¹åˆ°ç¬¬ `r` ä¸ªèŠ‚ç‚¹çš„æƒå€¼éƒ½æ”¹æˆ `v`ã€‚
4.  **é•¿åº¦å‡åŠ**: `3 l r`ï¼Œå¯¹äºåºåˆ—ä¸­ä»ç¬¬ `l` ä¸ªåˆ°ç¬¬ `r` ä¸ªçš„æ¯ä¸€æ¡å°é“¾ï¼Œå¦‚æœå®ƒçš„é•¿åº¦ `len` å¤§äº1ï¼Œå°±æŠŠå®ƒå˜çŸ­ï¼Œåªä¿ç•™å‰ `ceil(len / 2)` ä¸ªèŠ‚ç‚¹ã€‚

æ¯æ¬¡æ“ä½œç»“æŸåï¼Œæˆ‘ä»¬éœ€è¦å›ç­”ä¸€ä¸ªè¯¢é—®ï¼šæŠŠæ‰€æœ‰å°é“¾æŒ‰ç…§å®ƒä»¬åœ¨åºåˆ—ä¸­çš„é¡ºåºï¼Œå°†ç›¸é‚»å°é“¾çš„ç¬¬1ä¸ªèŠ‚ç‚¹ç”¨è¾¹è¿èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªå¤§å›¾ã€‚è¯·é—®ï¼Œè¿™ä¸ªå¤§å›¾ä¸­çš„**æœ€é•¿é“¾**ï¼ˆè·¯å¾„ä¸ŠèŠ‚ç‚¹æƒå€¼å’Œæœ€å¤§ï¼‰æ˜¯å¤šå°‘å‘¢ï¼Ÿæ³¨æ„ï¼Œè·¯å¾„å¯ä»¥ä¸ºç©ºï¼Œæ­¤æ—¶æƒå€¼å’Œä¸º0ï¼Œå–µ~

## è§£é¢˜æ€è·¯åˆ†æ

è¿™é“é¢˜çœ‹èµ·æ¥å¥½å¤æ‚å‘€ï¼Œåˆæ˜¯åºåˆ—æ“ä½œï¼Œåˆæ˜¯å›¾è®ºçš„æœ€é•¿é“¾ï¼Œè¿˜è¦ç»´æŠ¤é“¾ä¸­é“¾... ä½†åˆ«æ€•ï¼Œè®©æˆ‘æ¥ä¸€æ­¥æ­¥æ‹†è§£å®ƒï¼Œå–µ~

### å…³é”®è½¬æ¢ï¼šä»å›¾è®ºåˆ°åºåˆ—DP

é¦–å…ˆï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹æ¯æ¬¡è¯¢é—®çš„è¿™ä¸ªâ€œå¤§å›¾â€åˆ°åº•é•¿ä»€ä¹ˆæ ·ã€‚å®ƒæ˜¯ç”±ä¸€æ’å°é“¾ $C_1, C_2, \dots, C_N$ ç»„æˆçš„ã€‚
-   åœ¨æ¯æ¡å°é“¾ $C_i$ å†…éƒ¨ï¼ŒèŠ‚ç‚¹ $v_{i,j}$ å’Œ $v_{i,j+1}$ æ˜¯ç›¸è¿çš„ã€‚
-   åœ¨å°é“¾ä¹‹é—´ï¼Œ$C_i$ çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ $v_{i,1}$ å’Œ $C_{i+1}$ çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ $v_{i+1,1}$ æ˜¯ç›¸è¿çš„ã€‚

å¦‚æœæˆ‘ä»¬å°†è¿™äº›è¾¹çœ‹ä½œæ˜¯**æ— å‘**çš„ï¼ˆå› ä¸ºâ€œæœ€é•¿é“¾â€é€šå¸¸åœ¨æ— å‘å›¾ä¸Šè®¨è®ºï¼‰ï¼Œè¿™ä¸ªå¤§å›¾çš„ç»“æ„å°±åƒä¸€åªæ¯›æ¯›è™«ï¼ğŸ› $v_{1,1}, v_{2,1}, \dots, v_{N,1}$ æ„æˆäº†æ¯›æ¯›è™«çš„èº«ä½“ï¼ˆä¸»å¹²ï¼‰ï¼Œè€Œæ¯ä¸ªå°é“¾å‰©ä¸‹çš„éƒ¨åˆ† $(v_{i,2}, v_{i,3}, \dots)$ å°±åƒæ˜¯æŒ‚åœ¨èº«ä½“ä¸Šçš„è„šã€‚

åœ¨è¿™æ ·çš„æ ‘å½¢ï¼ˆæ¯›æ¯›è™«ä¹Ÿæ˜¯ä¸€ç§æ ‘ï¼‰ç»“æ„ä¸Šæ±‚æœ€é•¿é“¾ï¼Œæ˜¯ä¸€ä¸ªç»å…¸çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬çš„â€œæ¯›æ¯›è™«â€æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼æ’å…¥ã€åˆ é™¤ã€ä¿®æ”¹... è¿™å°±éœ€è¦ä¸€ç§èƒ½å¤Ÿæ”¯æŒåŠ¨æ€ä¿®æ”¹çš„DPï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„â€œåŠ¨æ€DPâ€ã€‚

å¤„ç†åŠ¨æ€åºåˆ—é—®é¢˜ï¼Œæœ€å¼ºå¤§çš„æ­¦å™¨ä¹‹ä¸€å°±æ˜¯**å¹³è¡¡äºŒå‰æœç´¢æ ‘ (BBST)**ï¼Œæ¯”å¦‚Splayæˆ–è€…Treapã€‚è€ƒè™‘åˆ°æ“ä½œçš„å¤æ‚æ€§ï¼Œä½¿ç”¨Treapï¼ˆç‰¹åˆ«æ˜¯æ— éœ€æ—‹è½¬çš„FHQ-Treapï¼‰ä¼šè®©ä»£ç å®ç°æ›´æ¸…æ™°ï¼Œå–µ~

### åµŒå¥—Treapï¼šæˆ‘çš„é­”æ³•ç›’å­

æˆ‘ä»¬é¢å¯¹çš„æ˜¯ä¸¤ä¸ªå±‚çº§çš„åŠ¨æ€åºåˆ—ï¼š
1.  **å¤–å±‚åºåˆ—**: å°é“¾ç»„æˆçš„åºåˆ—ã€‚
2.  **å†…å±‚åºåˆ—**: æ¯ä¸ªå°é“¾å†…éƒ¨çš„èŠ‚ç‚¹åºåˆ—ã€‚

ä¸€ä¸ªéå¸¸è‡ªç„¶çš„æƒ³æ³•å°±æ˜¯ç”¨ä¸€ä¸ªæ•°æ®ç»“æ„å»å¥—å¦ä¸€ä¸ªã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª**å¤–å±‚Treap**æ¥ç»´æŠ¤å°é“¾çš„åºåˆ—ï¼Œå¤–å±‚Treapçš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€æ¡å°é“¾ã€‚è€Œè¿™æ¡å°é“¾æœ¬èº«ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ª**å†…å±‚Treap**æ¥ç»´æŠ¤å®ƒå†…éƒ¨çš„èŠ‚ç‚¹åºåˆ—ã€‚å°±åƒä¸€ä¸ªå¤§é­”æ³•ç›’ï¼ˆå¤–å±‚Treapï¼‰é‡Œè£…ç€è®¸å¤šå°é­”æ³•ç›’ï¼ˆå†…å±‚Treapï¼‰ä¸€æ ·ï¼Œå¯çˆ±å§~

### å†…å±‚Treapï¼šç»´æŠ¤å°é“¾ä¿¡æ¯

å†…å±‚Treapç›¸å¯¹ç®€å•ã€‚å¯¹äºä¸€æ¡å°é“¾ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å“ªäº›ä¿¡æ¯æ¥å¸®åŠ©å¤–å±‚è®¡ç®—å‘¢ï¼Ÿ
-   **æœ€å¤§å­æ®µå’Œ**: è¿™å¯¹åº”ç€å®Œå…¨åœ¨ä¸€æ¡å°é“¾å†…éƒ¨çš„æœ€é•¿è·¯å¾„ã€‚
-   **æœ€å¤§å‰ç¼€å’Œ**: åœ¨æ— å‘å›¾ä¸­ï¼Œä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ $v_{i,1}$ å‡ºå‘èƒ½èµ°åˆ°çš„æœ€é•¿è·¯å¾„ï¼ˆä¸ç¦»å¼€æœ¬é“¾ï¼‰ï¼Œå°±æ˜¯è¿™æ¡é“¾çš„æœ€å¤§å‰ç¼€å’Œã€‚
-   **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼**: è¿™æ˜¯è¿æ¥ç›¸é‚»å°é“¾çš„â€œå…³èŠ‚â€ç‚¹ã€‚

æ‰€ä»¥ï¼Œæˆ‘ä»¬çš„å†…å±‚Treapæ˜¯ä¸€ä¸ªæ ‡å‡†çš„ã€ç”¨äºç»´æŠ¤åºåˆ—æœ€å¤§å­æ®µå’Œçš„Treapã€‚æ¯ä¸ªèŠ‚ç‚¹éœ€è¦ç»´æŠ¤åŒºé—´å’Œ `sum`ã€æœ€å¤§å‰ç¼€å’Œ `lmax`ã€æœ€å¤§åç¼€å’Œ `rmax`ã€æœ€å¤§å­æ®µå’Œ `ans`ã€‚å½“ç„¶ï¼Œä¸ºäº†æ”¯æŒåŒºé—´ä¿®æ”¹ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åŠ ä¸Šæ‡’æ ‡è®° `tag`ã€‚

### å¤–å±‚Treapï¼šDPçŠ¶æ€çš„å®šä¹‰ä¸åˆå¹¶

è¿™æ˜¯æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼å¤–å±‚Treapçš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªæˆ–å¤šä¸ªè¿ç»­çš„å°é“¾ç»„æˆçš„â€œé“¾æ®µâ€ã€‚æˆ‘ä»¬éœ€è¦ä¸ºå®ƒè®¾è®¡ä¸€å¥—DPçŠ¶æ€å’Œåˆå¹¶è§„åˆ™ã€‚

å‡è®¾ä¸€ä¸ªå¤–å±‚TreapèŠ‚ç‚¹ä»£è¡¨äº†å°é“¾ $C_i, \dots, C_j$ ç»„æˆçš„é“¾æ®µã€‚æˆ‘ä»¬éœ€è¦ç»´æŠ¤ä»¥ä¸‹ä¿¡æ¯ï¼š
1.  `chain_head_sum`: é“¾æ®µä¸­æ‰€æœ‰å°é“¾çš„**ç¬¬ä¸€ä¸ªèŠ‚ç‚¹**çš„æƒå€¼ä¹‹å’Œï¼Œå³ $\sum_{k=i}^{j} v_{k,1}$ã€‚
2.  `max_l_path`: ä»é“¾æ®µçš„â€œå¤´â€ï¼ˆå³ $C_i$ çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ $v_{i,1}$ï¼‰å‡ºå‘ï¼Œèƒ½èµ°åˆ°çš„æœ€é•¿è·¯å¾„çš„æƒå€¼å’Œã€‚
3.  `max_r_path`: ä»é“¾æ®µçš„â€œå°¾â€ï¼ˆå³ $C_j$ çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ $v_{j,1}$ï¼‰å‡ºå‘ï¼Œèƒ½èµ°åˆ°çš„æœ€é•¿è·¯å¾„çš„æƒå€¼å’Œã€‚
4.  `max_internal_path`: å®Œå…¨åŒ…å«åœ¨è¯¥é“¾æ®µå†…éƒ¨çš„æœ€é•¿è·¯å¾„çš„æƒå€¼å’Œã€‚

å¯¹äºåªåŒ…å«ä¸€æ¡å°é“¾ $C_k$ çš„â€œå¶å­â€èŠ‚ç‚¹ï¼Œå®ƒçš„åˆå§‹DPçŠ¶æ€æ˜¯ï¼š
-   `chain_head_sum` = $v_{k,1}$ (ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼)
-   `max_l_path` = $P_k$ (å°é“¾ $C_k$ çš„æœ€å¤§å‰ç¼€å’Œ)
-   `max_r_path` = $P_k$ (å› ä¸ºåªæœ‰ä¸€ä¸ªè¿æ¥ç‚¹ï¼Œå·¦å³å¯¹ç§°)
-   `max_internal_path` = $X_k$ (å°é“¾ $C_k$ çš„æœ€å¤§å­æ®µå’Œ)

è¿™äº›å€¼ ($v_{k,1}, P_k, X_k$) éƒ½å¯ä»¥ä»å¯¹åº”çš„å†…å±‚Treapä¸­æŸ¥è¯¢å¾—åˆ°ã€‚

**åˆå¹¶è§„åˆ™ (æœ€é‡è¦çš„é­”æ³•ï¼)**
å‡è®¾æˆ‘ä»¬è¦åˆå¹¶å·¦è¾¹çš„é“¾æ®µ `A` å’Œå³è¾¹çš„é“¾æ®µ `B`ï¼Œå¾—åˆ°æ–°çš„é“¾æ®µ `New`ï¼š
-   `New.max_internal_path` = $\max($
    `A.max_internal_path`,
    `B.max_internal_path`,
    `A.max_r_path` + `B.max_l_path`  // å…³é”®ï¼è¿æ¥ä¸¤ä¸ªé“¾æ®µçš„æœ€é•¿è·¯å¾„
  $)$
-   `New.chain_head_sum` = `A.chain_head_sum` + `B.chain_head_sum`
-   `New.max_l_path` = $\max($
    `A.max_l_path`,
    `A.chain_head_sum` + `B.max_l_path` // ç©¿è¿‡æ•´ä¸ªAï¼Œå†èµ°Bçš„å·¦è·¯å¾„
  $)$
-   `New.max_r_path` = $\max($
    `B.max_r_path`,
    `B.chain_head_sum` + `A.max_r_path` // ç©¿è¿‡æ•´ä¸ªBï¼Œå†èµ°Açš„å³è·¯å¾„
  $)$

æœ‰äº†è¿™äº›ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨O(1)æ—¶é—´å†…åˆå¹¶ä¸¤ä¸ªå¤–å±‚TreapèŠ‚ç‚¹çš„ä¿¡æ¯å•¦ã€‚æœ€ç»ˆï¼Œæ•´ä¸ªåºåˆ—çš„æœ€é•¿é“¾å°±æ˜¯å¤–å±‚Treapæ ¹èŠ‚ç‚¹çš„ `max_internal_path`ï¼

### å¤„ç†å„ç§æ“ä½œ

-   **åˆ é™¤/æ’å…¥**: å¯¹å¤–å±‚Treapè¿›è¡Œ `split` å’Œ `merge` æ“ä½œï¼Œéå¸¸æ ‡å‡†ã€‚
-   **åŒºé—´ä¿®æ”¹**: `split` å¤–å±‚Treapæ‰¾åˆ°å¯¹åº”çš„å°é“¾èŠ‚ç‚¹ï¼Œç„¶åè¿›å…¥å…¶å†…å±‚Treapï¼Œæ‰§è¡Œæ ‡å‡†çš„åŒºé—´ä¿®æ”¹ï¼ˆ`split` -> `apply_tag` -> `merge`ï¼‰ã€‚ä¿®æ”¹åï¼Œåˆ«å¿˜äº†æ›´æ–°è¯¥å¤–å±‚èŠ‚ç‚¹çš„DPä¿¡æ¯ã€‚
-   **é•¿åº¦å‡åŠ**: è¿™æ˜¯æœ€éº»çƒ¦çš„æ“ä½œã€‚æˆ‘ä»¬éœ€è¦ `split` å¤–å±‚Treapå¾—åˆ°å¯¹åº”åŒºé—´çš„å­æ ‘ï¼Œç„¶åå¯¹è¿™ä¸ªå­æ ‘é‡Œçš„**æ¯ä¸€ä¸ª**èŠ‚ç‚¹ï¼Œæ‰¾åˆ°å®ƒçš„å†…å±‚Treapï¼Œ`split`æ‰ååŠéƒ¨åˆ†ï¼Œå†æ›´æ–°å¤–å±‚èŠ‚ç‚¹çš„DPä¿¡æ¯ã€‚æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªé€’å½’å‡½æ•°æ¥éå†è¿™ä¸ªå­æ ‘å¹¶æ‰§è¡Œä¿®æ”¹ã€‚ä¸ºäº†ä¼˜åŒ–ï¼Œå¯ä»¥åŠ ä¸€ä¸ªå‰ªæï¼šå¦‚æœä¸€ä¸ªå­æ ‘ä¸­æ‰€æœ‰å°é“¾çš„é•¿åº¦éƒ½å·²ç»æ˜¯1äº†ï¼Œå°±ä¸ç”¨å†é€’å½’è¿›å»äº†ï¼Œå–µ~

æ€»è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç²¾å·§çš„â€œTreapå¥—Treapâ€ç»“æ„ï¼ŒæŠŠå¤æ‚çš„å›¾é—®é¢˜è½¬åŒ–ä¸ºäº†åºåˆ—ä¸Šçš„åŠ¨æ€DPé—®é¢˜ï¼Œç„¶åç”¨å¹³è¡¡æ ‘é«˜æ•ˆè§£å†³ï¼æ˜¯ä¸æ˜¯å¾ˆæœ‰è¶£å‘¢ï¼Ÿ

## ä»£ç å®ç°

è¿™æ˜¯æˆ‘æ ¹æ®ä¸Šé¢çš„æ€è·¯ï¼Œç²¾å¿ƒé‡æ„çš„ä¸€ä»½ä»£ç ï¼ŒåŠ äº†è¯¦ç»†çš„æ³¨é‡Šï¼Œå¸Œæœ›èƒ½å¸®åŠ©ä¸»äººç†è§£ï¼Œå–µ~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

typedef long long ll;

// ä½¿ç”¨mt19937ç”Ÿæˆéšæœºä¼˜å…ˆçº§ï¼Œè®©Treapæ›´ç¨³å®š
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// -------------------- å†…å±‚Treap: ç»´æŠ¤å°é“¾èŠ‚ç‚¹ --------------------
namespace InnerTreap {
    struct Node {
        int priority, size;
        ll value;
        ll sum, lmax, rmax, ans; // æ ‡å‡†æœ€å¤§å­æ®µå’ŒDPä¿¡æ¯
        ll tag;
        bool has_tag;
        int ch[2]; // å·¦å³å­©å­
    };

    Node tree[1000005];
    int node_count = 0;

    int new_node(ll val) {
        int p = ++node_count;
        tree[p].priority = uniform_int_distribution<int>()(rng);
        tree[p].size = 1;
        tree[p].value = val;
        tree[p].sum = val;
        tree[p].lmax = max(0LL, val);
        tree[p].rmax = max(0LL, val);
        tree[p].ans = max(0LL, val);
        tree[p].tag = 0;
        tree[p].has_tag = false;
        tree[p].ch[0] = tree[p].ch[1] = 0;
        return p;
    }

    void push_up(int p) {
        if (!p) return;
        int l = tree[p].ch[0], r = tree[p].ch[1];
        tree[p].size = tree[l].size + tree[r].size + 1;
        tree[p].sum = tree[l].sum + tree[r].sum + tree[p].value;
        tree[p].lmax = max(tree[l].lmax, tree[l].sum + tree[p].value + tree[r].lmax);
        tree[p].rmax = max(tree[r].rmax, tree[r].sum + tree[p].value + tree[l].rmax);
        tree[p].ans = max({tree[l].ans, tree[r].ans, tree[l].rmax + tree[p].value + tree[r].lmax});
    }

    void apply_tag(int p, ll tag_val) {
        if (!p) return;
        tree[p].value = tag_val;
        tree[p].sum = (ll)tree[p].size * tag_val;
        tree[p].lmax = tree[p].rmax = tree[p].ans = max(0LL, tree[p].sum);
        tree[p].tag = tag_val;
        tree[p].has_tag = true;
    }

    void push_down(int p) {
        if (!p || !tree[p].has_tag) return;
        int l = tree[p].ch[0], r = tree[p].ch[1];
        if (l) apply_tag(l, tree[p].tag);
        if (r) apply_tag(r, tree[p].tag);
        tree[p].has_tag = false;
    }

    // æŒ‰å¤§å°åˆ†è£‚ï¼Œkä¸ªèŠ‚ç‚¹ç»™x, å‰©ä¸‹çš„ç»™y
    void split(int p, int k, int& x, int& y) {
        if (!p) {
            x = y = 0;
            return;
        }
        push_down(p);
        if (tree[tree[p].ch[0]].size < k) {
            x = p;
            split(tree[p].ch[1], k - tree[tree[p].ch[0]].size - 1, tree[x].ch[1], y);
        } else {
            y = p;
            split(tree[p].ch[0], k, x, tree[y].ch[0]);
        }
        push_up(p);
    }

    int merge(int x, int y) {
        if (!x || !y) return x | y;
        push_down(x);
        push_down(y);
        if (tree[x].priority > tree[y].priority) {
            tree[x].ch[1] = merge(tree[x].ch[1], y);
            push_up(x);
            return x;
        } else {
            tree[y].ch[0] = merge(x, tree[y].ch[0]);
            push_up(y);
            return y;
        }
    }
    
    // åˆå§‹åŒ–æ—¶ï¼ŒèŠ‚ç‚¹å€¼æ˜¯0ï¼Œå ä½ç”¨
    void init() { tree[0].sum = 0; tree[0].lmax = tree[0].rmax = tree[0].ans = 0;}
}

// -------------------- å¤–å±‚Treap: ç»´æŠ¤å°é“¾åºåˆ— --------------------
namespace OuterTreap {
    struct Node {
        int priority, size;
        int inner_root; // æŒ‡å‘å†…å±‚Treapçš„æ ¹
        bool needs_halving; // ä¼˜åŒ–op3: æ ‡è®°å­æ ‘ä¸­æ˜¯å¦æœ‰é•¿åº¦>1çš„é“¾
        // DPçŠ¶æ€
        ll chain_head_sum;
        ll max_l_path, max_r_path;
        ll max_internal_path;
        int ch[2];
    };

    Node tree[200005];
    int node_count = 0;

    void update_from_inner(int p) {
        if (!p) return;
        int inner_p = tree[p].inner_root;
        if (!inner_p) { // ç©ºé“¾
            tree[p].chain_head_sum = 0;
            tree[p].max_l_path = tree[p].max_r_path = tree[p].max_internal_path = 0;
            tree[p].needs_halving = false;
            return;
        }
        
        int first_node_root, rest;
        InnerTreap::split(inner_p, 1, first_node_root, rest);
        
        tree[p].chain_head_sum = InnerTreap::tree[first_node_root].value;
        tree[p].max_l_path = tree[p].max_r_path = InnerTreap::tree[inner_p].lmax;
        tree[p].max_internal_path = InnerTreap::tree[inner_p].ans;
        tree[p].needs_halving = (InnerTreap::tree[inner_p].size > 1);
        
        // åˆ«å¿˜äº†åˆå¹¶å›å»
        InnerTreap::merge(first_node_root, rest);
    }

    int new_node(int inner_root) {
        int p = ++node_count;
        tree[p].priority = uniform_int_distribution<int>()(rng);
        tree[p].size = 1;
        tree[p].inner_root = inner_root;
        tree[p].ch[0] = tree[p].ch[1] = 0;
        update_from_inner(p);
        return p;
    }
    
    void push_up(int p) {
        if (!p) return;
        int l = tree[p].ch[0], r = tree[p].ch[1];
        tree[p].size = tree[l].size + tree[r].size + 1;

        // åˆå¹¶DPçŠ¶æ€
        const auto& node_l = tree[l];
        const auto& node_r = tree[r];
        const auto& node_self = tree[p];

        tree[p].chain_head_sum = node_l.chain_head_sum + node_self.chain_head_sum + node_r.chain_head_sum;
        
        ll l_part_l_path = node_l.max_l_path;
        ll l_part_r_path = node_l.max_r_path;
        ll l_part_sum = node_l.chain_head_sum;
        ll l_part_ans = node_l.max_internal_path;

        ll self_part_l_path = node_self.max_l_path;
        ll self_part_r_path = node_self.max_r_path;
        ll self_part_sum = node_self.chain_head_sum;
        ll self_part_ans = node_self.max_internal_path;
        
        ll r_part_l_path = node_r.max_l_path;
        ll r_part_r_path = node_r.max_r_path;
        ll r_part_sum = node_r.chain_head_sum;
        ll r_part_ans = node_r.max_internal_path;
        
        // A = l, B = self
        ll mid_l_path = max(l_part_l_path, l_part_sum + self_part_l_path);
        ll mid_r_path = max(self_part_r_path, self_part_sum + l_part_r_path);
        ll mid_sum = l_part_sum + self_part_sum;
        ll mid_ans = max({l_part_ans, self_part_ans, l_part_r_path + self_part_l_path});
        
        // A = mid, B = r
        tree[p].max_l_path = max(mid_l_path, mid_sum + r_part_l_path);
        tree[p].max_r_path = max(r_part_r_path, r_part_sum + mid_r_path);
        tree[p].max_internal_path = max({mid_ans, r_part_ans, mid_r_path + r_part_l_path});
        
        tree[p].needs_halving = node_l.needs_halving || node_r.needs_halving || node_self.needs_halving;
    }

    void split(int p, int k, int& x, int& y) {
        if (!p) {
            x = y = 0;
            return;
        }
        if (tree[tree[p].ch[0]].size < k) {
            x = p;
            split(tree[p].ch[1], k - tree[tree[p].ch[0]].size - 1, tree[x].ch[1], y);
        } else {
            y = p;
            split(tree[p].ch[0], k, x, tree[y].ch[0]);
        }
        push_up(p);
    }

    int merge(int x, int y) {
        if (!x || !y) return x | y;
        if (tree[x].priority > tree[y].priority) {
            tree[x].ch[1] = merge(tree[x].ch[1], y);
            push_up(x);
            return x;
        } else {
            tree[y].ch[0] = merge(x, tree[y].ch[0]);
            push_up(y);
            return y;
        }
    }
    
    // é€’å½’åœ°å¯¹å­æ ‘ä¸­æ‰€æœ‰éœ€è¦å‡åŠçš„é“¾è¿›è¡Œæ“ä½œ
    void halve_chains(int p) {
        if (!p || !tree[p].needs_halving) return;
        
        // å…ˆå¤„ç†å­©å­ï¼Œå†å¤„ç†è‡ªå·±
        halve_chains(tree[p].ch[0]);
        halve_chains(tree[p].ch[1]);

        if (tree[p].needs_halving) { // å†æ¬¡æ£€æŸ¥ï¼Œå› ä¸ºå­©å­å¯èƒ½å·²ç»è¢«å¤„ç†
            int inner_p = tree[p].inner_root;
            int current_len = InnerTreap::tree[inner_p].size;
            if (current_len > 1) {
                int new_len = (current_len + 1) / 2;
                int kept_part, discarded_part;
                InnerTreap::split(inner_p, new_len, kept_part, discarded_part);
                tree[p].inner_root = kept_part;
            }
        }
        update_from_inner(p); // æ›´æ–°è‡ªå·±çš„DPä¿¡æ¯
        push_up(p); // é‡æ–°èšåˆä¿¡æ¯
    }
    
    void init() { tree[0].max_internal_path = 0; }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    InnerTreap::init();
    OuterTreap::init();

    int n, m;
    cin >> n >> m;

    int outer_root = 0;
    for (int i = 0; i < n; ++i) {
        int k;
        cin >> k;
        int inner_root = 0;
        for (int j = 0; j < k; ++j) {
            ll val;
            cin >> val;
            inner_root = InnerTreap::merge(inner_root, InnerTreap::new_node(val));
        }
        outer_root = OuterTreap::merge(outer_root, OuterTreap::new_node(inner_root));
    }

    cout << OuterTreap::tree[outer_root].max_internal_path << "\n";

    for (int q = 0; q < m; ++q) {
        int type;
        cin >> type;
        if (type == 0) {
            int x;
            cin >> x;
            int left, mid, right;
            OuterTreap::split(outer_root, x, mid, right);
            OuterTreap::split(mid, x - 1, left, mid);
            outer_root = OuterTreap::merge(left, right);
        } else if (type == 1) {
            int x, k;
            cin >> x;
            int inner_root = 0;
            cin >> k;
            for (int j = 0; j < k; ++j) {
                ll val;
                cin >> val;
                inner_root = InnerTreap::merge(inner_root, InnerTreap::new_node(val));
            }
            int new_outer_node = OuterTreap::new_node(inner_root);
            int left, right;
            OuterTreap::split(outer_root, x, left, right);
            outer_root = OuterTreap::merge(OuterTreap::merge(left, new_outer_node), right);
        } else if (type == 2) {
            int x, l, r;
            ll v;
            cin >> x >> l >> r >> v;
            int left, mid, right;
            OuterTreap::split(outer_root, x, mid, right);
            OuterTreap::split(mid, x - 1, left, mid);
            
            int inner_root = OuterTreap::tree[mid].inner_root;
            int inner_l, inner_m, inner_r;
            InnerTreap::split(inner_root, r, inner_m, inner_r);
            InnerTreap::split(inner_m, l - 1, inner_l, inner_m);
            InnerTreap::apply_tag(inner_m, v);
            inner_root = InnerTreap::merge(InnerTreap::merge(inner_l, inner_m), inner_r);
            OuterTreap::tree[mid].inner_root = inner_root;
            OuterTreap::update_from_inner(mid);
            
            outer_root = OuterTreap::merge(OuterTreap::merge(left, mid), right);
        } else { // type == 3
            int l, r;
            cin >> l >> r;
            int left, mid, right;
            OuterTreap::split(outer_root, r, mid, right);
            OuterTreap::split(mid, l - 1, left, mid);
            
            OuterTreap::halve_chains(mid);
            
            outer_root = OuterTreap::merge(OuterTreap::merge(left, mid), right);
        }
        cout << OuterTreap::tree[outer_root].max_internal_path << "\n";
    }

    return 0;
}
```

## å¤æ‚åº¦åˆ†æ

-   **æ—¶é—´å¤æ‚åº¦**: è®¾ `N` æ˜¯å°é“¾çš„æ•°é‡ï¼Œ`M` æ˜¯æ“ä½œæ¬¡æ•°ï¼Œ`L` æ˜¯å°é“¾çš„æœ€å¤§é•¿åº¦ã€‚
    -   æ“ä½œ0 (åˆ é™¤), 1 (æ’å…¥), 2 (ä¿®æ”¹): æ¯æ¬¡æ“ä½œæ¶‰åŠå¯¹å¤–å±‚Treapå’Œï¼ˆå¯èƒ½çš„ï¼‰å†…å±‚Treapçš„ `split` å’Œ `merge`ã€‚å¤–å±‚Treapæ“ä½œæ˜¯ $O(\log N)$ï¼Œå†…å±‚æ˜¯ $O(\log L)$ã€‚æ‰€ä»¥è¿™äº›æ“ä½œçš„å¤æ‚åº¦æ˜¯ $O(\log N + \log L)$ã€‚
    -   æ“ä½œ3 (é•¿åº¦å‡åŠ): è¿™ä¸ªæ“ä½œæœ€ç‰¹åˆ«ã€‚æˆ‘ä»¬éœ€è¦å¯¹ $[l, r]$ åŒºé—´çš„æ‰€æœ‰å°é“¾è¿›è¡Œä¿®æ”¹ã€‚æˆ‘ä»¬å…ˆç”¨ $O(\log N)$ çš„æ—¶é—´ split å‡ºä»£è¡¨è¿™ä¸ªåŒºé—´çš„å¤–å±‚å­Treapã€‚ç„¶åï¼Œæˆ‘ä»¬é€’å½’éå†è¿™ä¸ªå­Treapã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è®¿é—® $r-l+1$ ä¸ªèŠ‚ç‚¹ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹çš„å†…å±‚Treapåš $O(\log L)$ çš„ split æ“ä½œã€‚æ‰€ä»¥ä¸€æ¬¡æ“ä½œ3çš„å¤æ‚åº¦æ˜¯ $O((r-l+1)\log L + \log N)$ã€‚
-   **ç©ºé—´å¤æ‚åº¦**: æˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªèŠ‚ç‚¹ï¼ˆæ— è®ºæ˜¯å¤–å±‚è¿˜æ˜¯å†…å±‚ï¼‰éƒ½åˆ†é…ç©ºé—´ã€‚æ€»èŠ‚ç‚¹æ•°æ˜¯æ‰€æœ‰å°é“¾é•¿åº¦ä¹‹å’ŒåŠ ä¸Šå°é“¾çš„æ•°é‡ã€‚è®¾æ€»èŠ‚ç‚¹æ•°ä¸º `S`ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ $O(S)$ã€‚

## çŸ¥è¯†ç‚¹æ€»ç»“

è¿™é“é¢˜æ˜¯æ•°æ®ç»“æ„èƒ½åŠ›çš„ç»ˆæè€ƒéªŒä¹‹ä¸€ï¼Œå–µ~ å®ƒèåˆäº†å¤šç§æ€æƒ³ï¼š

1.  **é—®é¢˜å»ºæ¨¡**: å°†ä¸€ä¸ªçœ‹ä¼¼å¤æ‚çš„å›¾è®ºé—®é¢˜ï¼Œé€šè¿‡åˆ†æå…¶ç»“æ„ï¼ˆæ¯›æ¯›è™«å›¾ï¼‰ï¼Œè½¬åŒ–ä¸ºä¸€ä¸ªå¯ä»¥åœ¨åºåˆ—ä¸Šè§£å†³çš„åŠ¨æ€DPé—®é¢˜ã€‚è¿™æ˜¯è§£é¢˜çš„ç¬¬ä¸€æ­¥ï¼Œä¹Ÿæ˜¯æœ€é‡è¦çš„ä¸€æ­¥ï¼
2.  **åµŒå¥—æ•°æ®ç»“æ„**: ä½¿ç”¨â€œTreapå¥—Treapâ€çš„ç»“æ„æ¥ç®¡ç†ä¸¤ä¸ªå±‚çº§çš„åŠ¨æ€åºåˆ—ï¼Œæ˜¯è§£å†³æ­¤ç±»é—®é¢˜çš„ç»å…¸æ¨¡å¼ã€‚
3.  **åŠ¨æ€DPä¸å¹³è¡¡æ ‘**: å¹³è¡¡æ ‘ï¼ˆè¿™é‡Œæ˜¯FHQ-Treapï¼‰æ˜¯å®ç°åŠ¨æ€DPçš„æœ‰åŠ›å·¥å…·ã€‚é€šè¿‡åœ¨æ ‘çš„èŠ‚ç‚¹ä¸Šç»´æŠ¤DPçŠ¶æ€ï¼Œå¹¶å®šä¹‰å¥½çŠ¶æ€åˆå¹¶çš„è§„åˆ™ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨å¯¹æ•°æ—¶é—´å†…å®ŒæˆæŸ¥è¯¢å’Œå¤§éƒ¨åˆ†ä¿®æ”¹ã€‚
4.  **æ‡’æ ‡è®°æ€æƒ³**: åœ¨å†…å±‚Treapä¸­ä½¿ç”¨æ‡’æ ‡è®°æ¥æ”¯æŒåŒºé—´ä¿®æ”¹ï¼Œè¿™æ˜¯å¹³è¡¡æ ‘å¤„ç†åŒºé—´æ“ä½œçš„æ ‡å‡†æŠ€å·§ã€‚
5.  **å¤æ‚æ“ä½œçš„å¤„ç†**: æ“ä½œ3ï¼ˆé•¿åº¦å‡åŠï¼‰éœ€è¦å¯¹ä¸€ä¸ªå­æ ‘è¿›è¡Œæ•´ä½“æ“ä½œï¼Œé€šè¿‡é€’å½’éå†å¹¶ä¿®æ”¹ï¼Œå±•ç¤ºäº†å¹³è¡¡æ ‘å¼ºå¤§çš„çµæ´»æ€§ã€‚åŒæ—¶ï¼Œé€šè¿‡ `needs_halving` æ ‡å¿—è¿›è¡Œå‰ªæï¼Œæ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„ä¼˜åŒ–æŠ€å·§ã€‚

å¸Œæœ›è¿™ç¯‡é¢˜è§£èƒ½å¸®åˆ°ä½ ï¼Œä¸»äººï¼å¦‚æœè¿˜æœ‰ä¸æ‡‚çš„åœ°æ–¹ï¼Œéšæ—¶å¯ä»¥å†æ¥é—®æˆ‘å“¦ï¼Œå–µ~ â¤ï¸