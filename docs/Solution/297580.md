# C - Computational Geometry Problem - 题解

### 标签与难度
> **标签**: 组合数学, 数论, 模运算, 二项式系数, 生成函数
> **难度**: 2600

## 题目大意喵~

主人你好呀，咱是我 Dori，最喜欢挑战难题啦！这道题要我们解决一个计数问题，喵~

题目给了我们三个整数 $N, M, K$，要求我们找到满足下面三个条件的整数序列 $A$ 的数量，序列 $A$ 的总长度是 $NM$ 哦。

1.  **元素构成**: 序列里的每个数 $A_i$ 都在 $1$ 到 $M$ 之间。并且，从 $1$ 到 $M$ 的每个数，都恰好在序列 $A$ 中出现了 $N$ 次。
2.  **不交叉条件**: 不存在四个下标 $1 \le i < j < k < \ell \le NM$ 使得 $A_i = A_k$ 且 $A_j = A_\ell$ 同时 $A_i \neq A_j$。这个条件看起来有点像几何里的不交叉呢，所以题目才叫这个名字吧！简单来说，就是不同颜色的数字区间不能"交叉"着放，比如 `1...2...1...2` 这样的模式是不允许的。但 `1...2...2...1` 这样 `2` 完全被 `1` 包裹的模式是允许的~
3.  **相邻对计数**: 序列中满足 $A_i = A_{i+1}$ 的下标 $i$ 的数量正好是 $K$。

因为答案可能会非常大，所以要对 $998244353$ 取模，喵。

## 解题思路分析

这道题虽然名字里有“计算几何”，但实际上是一道非常有趣的组合计数问题，喵！我们要像解开一个线团一样，一步一步分析这些条件。

### 第一步：把 $K$ 变成更好懂的东西！

条件 3 是关于相邻且相同的元素对数 $K$ 的。直接处理 $K$ 不太方便，我们把它转化一下。
我们可以把整个序列看成由许多**纯色块**组成的。比如序列 `1, 1, 2, 2, 2, 1, 3, 3` 可以看成 `[1,1]`, `[2,2,2]`, `[1]`, `[3,3]` 这四个纯色块。

*   对于一个颜色 $c$，它在序列里出现了 $N$ 次。如果这 $N$ 个 $c$ 被分成了 $p_c$ 个纯色块，那么它会产生 $N - p_c$ 对相邻的相同元素。比如说，`c,c,c,c,c` ($N=5$) 被分成 `[c,c,c]` 和 `[c,c]` 两个块 ($p_c=2$)，那么 `c,c` `c,c` `c,c` `c,c` 这四对里，只有块内的三对是相邻的，即 $N-p_c = 5-2=3$ 对。
*   所以，总的相邻相同对数 $K$ 就是所有颜色贡献的总和：
    $$
    K = \sum_{c=1}^{M} (N - p_c) = NM - \sum_{c=1}^{M} p_c
    $$
*   令 $P = \sum_{c=1}^{M} p_c$ 为序列中纯色块的总数量。那么我们得到一个非常重要的关系：
    $$
    P = NM - K
    $$
现在，问题就转化成了：计算满足条件的、由 $P$ 个纯色块构成的序列数量。

### 第二步：把问题拆成两半！

一个序列的构成可以分为两个主要部分：
1.  **块的构成**：对于每种颜色，它的 $N$ 个元素是如何被划分成若干个块的？总共有 $P$ 个块，那每种颜色各有多少块呢？
2.  **块的排列**：这 $P$ 个块要如何排列，才能满足那个奇妙的“不交叉”条件呢？

幸运的是，这两个部分是相对独立的，我们可以分开计算然后把结果乘起来，喵！

#### 1. 计算块的构成方案数

我们有 $M$ 种颜色，总共要形成 $P$ 个块。
假设颜色 $c$ 被分成了 $p_c$ 个块，我们知道 $\sum p_c = P$ 且 $p_c \ge 1$。
将 $N$ 个相同的物品分成 $p_c$ 个非空的组，方法数是经典的“插板法”，方案数是 $\binom{N-1}{p_c-1}$。

所以，总的构成方案数就是对所有满足 $\sum p_c = P$ 的 $\{p_c\}$，求和 $\prod_{c=1}^{M} \binom{N-1}{p_c-1}$。
$$
\text{Ways}_{\text{form}} = \sum_{p_1+\dots+p_M=P, p_c \ge 1} \prod_{c=1}^{M} \binom{N-1}{p_c-1}
$$
这个式子看起来好复杂！但是，我们可以用生成函数来简化它，喵~
令 $j_c = p_c - 1 \ge 0$，则 $\sum j_c = P - M$。
上式就变成了 $\sum_{j_1+\dots+j_M=P-M, j_c \ge 0} \prod_{c=1}^{M} \binom{N-1}{j_c}$。
这正是下面这个多项式乘积中 $x^{P-M}$ 项的系数：
$$
\left( \sum_{j=0}^{N-1} \binom{N-1}{j} x^j \right)^M
$$
根据二项式定理，$\sum_{j=0}^{N-1} \binom{N-1}{j} x^j = (1+x)^{N-1}$。
所以，我们要找的是 $( (1+x)^{N-1} )^M = (1+x)^{M(N-1)}$ 中 $x^{P-M}$ 项的系数。
这个系数就是 $\binom{M(N-1)}{P-M}$！

所以，**块的构成方案数**就是 $\binom{M(N-1)}{P-M}$。

#### 2. 计算块的排列方案数

这是最棘手的部分了，喵~ 那个“不交叉”条件非常强力。
`不存在 i < j < k < l 使得 A_i=A_k, A_j=A_l, A_i != A_j`
这个条件意味着，由 $P$ 个块组成的序列，其颜色序列必须是“平面可画”的，就像一个合法的括号序列。例如，`红, 蓝, 蓝, 红, 绿, 绿` 是合法的，但 `红, 蓝, 红, 蓝, ...` 是不合法的。

推导这个排列数的公式需要用到高等组合学中的知识，比如广义Dyck路径或者平面树计数，非常复杂呢！对于我们解题来说，可以把它当成一个已知的组合结论来使用，喵~
一个关键的、不那么直观的推论是：**要满足不交叉条件，总块数 $P$ 必须在 $[M, 2M-1]$ 的范围内**。
也就是说，$M \le P \le 2M-1$。
如果 $P$ 在这个范围之外，方案数就是 0。

在 $P$ 满足这个条件时，将这 $P$ 个块（其中颜色 $c$ 有 $p_c$ 个块，$\sum p_c = P$）排成一个不交叉序列的方案数是：
$$
\text{Ways}_{\text{arrange}} = \binom{M}{P-M+1} (M-1)!
$$
这个公式真的好神奇！Dori第一次看到也觉得很惊讶呢！

### 第三步：把它们拼起来！

好啦，现在我们把两部分的答案相乘，就得到最终的答案了！
总方案数 = (块的构成方案数) $\times$ (块的排列方案数)
$$
\text{Answer} = \binom{M(N-1)}{P-M} \times \binom{M}{P-M+1} (M-1)!
$$
其中 $P = NM - K$。

我们来整理一下计算步骤：
1.  根据输入的 $N, M, K$，计算总块数 $P = NM - K$。
2.  计算一个重要的中间值 $K' = P - M$。
3.  检查 $K'$ 是否在 $[0, M-1]$ 范围内。如果不是，说明 $P$ 不在 $[M, 2M-1]$ 范围内，答案就是 0。
4.  如果满足条件，计算三个部分的乘积：
    *   $C_1 = \binom{M(N-1)}{K'}$
    *   $C_2 = \binom{M}{K'+1}$
    *   $C_3 = (M-1)!$
5.  最终答案就是 $(C_1 \times C_2 \times C_3) \pmod{998244353}$。

因为 $N, M$ 很大，计算组合数 $\binom{n}{k}$ 时不能直接用阶乘表。但注意到 $K'$ 的值不会超过 $M-1$，所以我们可以用 $O(K')$ 的时间来计算 $\binom{n}{k} = \frac{n(n-1)\dots(n-k+1)}{k!}$。

举个例子：$N=3, M=3, K=6$
1.  $P = 3 \times 3 - 6 = 3$。
2.  $K' = P - M = 3 - 3 = 0$。
3.  $K'=0$ 在 $[0, 2]$ 范围内，合法。
4.  计算：
    *   $C_1 = \binom{3(3-1)}{0} = \binom{6}{0} = 1$。
    *   $C_2 = \binom{3}{0+1} = \binom{3}{1} = 3$。
    *   $C_3 = (3-1)! = 2! = 2$。
5.  答案是 $1 \times 3 \times 2 = 6$。和样例一样耶！

## 代码实现

下面是 Dori 根据上面的思路，精心重构的代码。每个变量名都很好懂，注释也很详细哦，希望能帮到主人，喵~

```cpp
#include <iostream>
#include <vector>

// 使用 long long 防止整数溢出，喵~
using int64 = long long;

// 快速幂，用于计算模逆元
int64 power(int64 base, int64 exp) {
    int64 res = 1;
    base %= 998244353;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % 998244353;
        base = (base * base) % 998244353;
        exp /= 2;
    }
    return res;
}

// 费马小定理求模逆元
int64 modInverse(int64 n) {
    return power(n, 998244353 - 2);
}

// 组合数计算 C(n, k) % mod
// 因为 n 可能很大，但 k 比较小 (<= M-1)，所以用这个方法最合适
int64 combinations(int64 n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    if (k == 0 || k == n) {
        return 1;
    }
    // C(n,k) = C(n, n-k)，我们选 k 小的那一边来算，更快！
    if (k > n / 2) {
        k = n - k;
    }

    // 计算分子: n * (n-1) * ... * (n-k+1)
    int64 numerator = 1;
    for (int i = 0; i < k; ++i) {
        numerator = (numerator * (n - i)) % 998244353;
    }

    // 计算分母的逆元: (k!)^(-1)
    int64 denominator_inv = 1;
    for (int i = 1; i <= k; ++i) {
        denominator_inv = (denominator_inv * modInverse(i)) % 998244353;
    }

    return (numerator * denominator_inv) % 998244353;
}

// 阶乘计算
int64 factorial(int n) {
    int64 res = 1;
    for (int i = 2; i <= n; i++) {
        res = (res * i) % 998244353;
    }
    return res;
}

int main() {
    // 加速输入输出，让程序跑得更快，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int64 N, M, K_old;
    std::cin >> N >> M >> K_old;

    // 如果 M=1，只有一个数字，序列是唯一的。
    // K 必须是 N-1，否则无解。
    if (M == 1) {
        if (K_old == N - 1) {
            std::cout << 1 << std::endl;
        } else {
            std::cout << 0 << std::endl;
        }
        return 0;
    }

    // P = NM - K_old, P 是总块数
    // K_prime = P - M, 是“额外”的块数
    int64 K_prime = N * M - K_old - M;

    // 根据组合学推论，K_prime 必须在 [0, M-1] 范围内
    if (K_prime < 0 || K_prime > M - 1) {
        std::cout << 0 << std::endl;
        return 0;
    }

    // 计算公式的三个部分
    // 1. 块构成方案数: C(M*(N-1), K')
    int64 ways_form_blocks = combinations(M * (N - 1), K_prime);

    // 2. 块排列方案数 Part A: C(M, K'+1)
    int64 ways_arrange_part_A = combinations(M, K_prime + 1);

    // 3. 块排列方案数 Part B: (M-1)!
    int64 ways_arrange_part_B = factorial(M - 1);

    // 最终答案是三者相乘
    int64 ans = (ways_form_blocks * ways_arrange_part_A) % 998244353;
    ans = (ans * ways_arrange_part_B) % 998244353;

    std::cout << ans << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(M)$。
  我们的计算瓶颈在于计算组合数和阶乘。`factorial(M-1)` 的计算需要 $O(M)$ 的时间。`combinations(n, k)` 中，$k$ 的值是 `K_prime` 或 `K_prime+1`，最大是 $M$。所以计算组合数也需要 $O(M)$ 的时间。因此总的时间复杂度是 $O(M)$，对于 $M \le 10^7$ 来说是完全可以接受的，喵~

- **空间复杂度**: $O(1)$。
  我们没有使用任何与输入大小成比例的额外存储空间，只需要几个变量来存中间结果。所以空间复杂度是常数级别的，非常优秀！

## 知识点总结

这道题是“喵喵计数”大学问的绝佳案例！它教会了我们：

1.  **问题转化**: 将一个看似复杂的问题（计数相邻对）转化为一个更结构化的问题（计数纯色块）是解题的关键一步。
2.  **分步计数**: 看到“计数...的方案数”，可以尝试将对象的构造过程分解为几个独立的步骤，然后使用乘法原理。这里我们分成了“块的构成”和“块的排列”。
3.  **生成函数思想**: 面对形如 $\sum \prod \binom{n}{k}$ 的式子，可以联想到多项式乘法和生成函数，这能将复杂的求和问题变成简单的系数提取问题。
4.  **组合模型**: “不交叉”这个条件在组合数学中非常常见，它通常对应于 Dyck 路径、平面树、不交叉分区等模型。虽然直接推导这些模型的计数公式很难，但了解这些模型有助于我们在遇到类似问题时，能快速地联想到可能的解法方向和公式。
5.  **高效计算组合数**: 当 $n$ 很大而 $k$ 很小时，计算 $\binom{n}{k}$ 的最佳方式是使用定义式 $\frac{n \times (n-1) \times \dots \times (n-k+1)}{k!}$，而不是预处理所有阶乘。

希望 Dori 的这篇题解能帮助主人更好地理解这道题，喵！继续加油，算法的世界还有好多有趣的宝藏等着我们去发现呢！