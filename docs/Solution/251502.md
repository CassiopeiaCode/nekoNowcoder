# わたし わたし わたしはここにいる - 题解

### 比赛与标签
> **比赛**: [未提供]

> **标签**: [未提供]

> **难度**: [未提供]

## 题目大意喵~

主人你好呀，咱是小猫娘~ 这道题看起来有点复杂，但别怕，跟着我的猫爪印一步步来，肯定能解决的，喵！

题目给了我们 $n$ 个点，以及与这些点的每个非空子集 $S$ 相关联的两个值：权值 $a_S$ 和贡献值 $b_S$。

首先，它定义了一个函数 $f_{S,i}$。这个函数表示把集合 $S$ 分成 $i$ 个互不相交的非空子集的所有方案中，每个方案的权值乘积的总和。举个栗子，如果 $S$ 被分成了 $S_1, S_2, \dots, S_i$，那么这个划分方案的权值就是 $a_{S_1} \times a_{S_2} \times \dots \times a_{S_i}$。$f_{S,i}$ 就是把所有这些划分方案的权值加起来。

我们的最终任务是，对于每个 $i$ (从 1 到 $n$)，计算下面这个式子的值：
$$
\text{Ans}_i = \sum_{S \subseteq \{0, \dots, n-1\}, S \neq \emptyset} b_S \cdot f_{S,i}
$$
所有的计算都要在模 $998244353$ 下进行哦。

简单来说，就是对每一种可能的划分块数 $i$，我们都要算一个总贡献值，这个值是所有点集 $S$ 的贡献 $b_S$ 与其对应的划分值 $f_{S,i}$ 的乘积之和，喵~

## 解题思路分析

这道题充满了集合、划分、卷积的气息，一看就是为我们这些喜欢捣鼓数学的猫娘准备的！我们一步步来解开它的神秘面纱吧，呐。

### 核心公式的变形

我们要求的 $\text{Ans}_i$ 是：
$$
\text{Ans}_i = \sum_{S} b_S f_{S,i}
$$
$f_{S,i}$ 的定义是关于无序划分的，为了方便处理，我们先把它变成有序划分。对于一个 $i$ 个部分的划分，有 $i!$ 种不同的排列方式。所以，如果我们定义 $g_i(S)$ 为将集合 $S$ **有序地**划分为 $i$ 个非空子集的权值乘积之和，那么 $f_{S,i} = \frac{1}{i!} g_i(S)$。

代入原式，我们得到：
$$
\text{Ans}_i = \frac{1}{i!} \sum_S b_S g_i(S)
$$
现在我们的目标是计算 $\sum_S b_S g_i(S)$。

### 认识“集合幂级数”与“子集卷积”

$g_i(S)$ 的定义让本猫娘想到了一个强大的工具——**子集卷积 (Subset Convolution)**！不过这里我们遇到的是它的一个变种，叫做**集合幂级数 (Set Power Series)** 的运算，或者叫**不交并卷积 (Disjoint Convolution)**。

让我们定义一个关于集合的“多项式”，或者叫集合幂级数 $A = \sum_S a_S \cdot S$。
两个这样的幂级数 $A$ 和 $B$ 的不交并卷积 $C = A \odot B$ 定义为：
$$
C_S = (A \odot B)_S = \sum_{S_1 \uplus S_2 = S} a_{S_1} b_{S_2}
$$
这里的 $S_1 \uplus S_2 = S$ 表示 $S_1 \cup S_2 = S$ 并且 $S_1 \cap S_2 = \emptyset$。

看，$g_2(S) = \sum_{S_1 \uplus S_2 = S} a_{S_1} a_{S_2} = (A \odot A)_S$。
推广一下， $g_i(S)$ 正是 $A$ 与自身的 $i$ 次不交并卷积在集合 $S$ 上的系数！我们记作 $g_i = A^{\odot i}$。

### 快速沃尔什-哈达玛变换 (FWT) 登场！

计算卷积，自然就想到了我们的老朋友——快速傅里叶变换 (FFT)。在集合运算中，它的对应物就是**快速沃尔什-哈达玛变换 (FWT)**，也叫**快速莫比乌斯变换**。

对于不交并卷积，有一个美妙的性质：对它进行 FWT（这里指子集和变换，Zeta Transform）后，卷积就变成了逐点乘积！
令 $\hat{A}$ 表示对数组 $A$ 进行 FWT 的结果，即 $\hat{A}_S = \sum_{T \subseteq S} a_T$。
那么有：
$$
\widehat{A \odot B}_S = \hat{A}_S \cdot \hat{B}_S
$$
这个性质太棒了！这意味着：
$$
\hat{g_i} = \widehat{A^{\odot i}} = (\hat{A})^i
$$
这里的 $(\hat{A})^i$ 表示将数组 $\hat{A}$ 中的每个元素都取 $i$ 次幂。

### 最终的求和

现在我们要求的是 $\sum_S b_S g_i(S)$，这是一个点积，我们记作 $\langle B, g_i \rangle$。
我们已经把 $g_i$ 转换到了 FWT 域，所以我们希望把整个点积也搬到 FWT 域去计算。这里需要一个 FWT 下的“帕塞瓦尔定理”的变体。对于子集和变换，它长这样：
$$
\langle X, Y \rangle = \sum_S X_S Y_S = \sum_S (\text{iFWT\_dual}(X))_S \cdot \hat{Y}_S
$$
其中 $\text{iFWT\_dual}(X)_T = \sum_{S \supseteq T} (-1)^{|S \setminus T|} X_S$ 是对偶的逆 FWT（超集和莫比乌斯反演）。

应用这个公式，我们得到：
$$
\sum_S b_S g_i(S) = \langle B, g_i \rangle = \langle \text{iFWT\_dual}(B), \hat{g_i} \rangle = \sum_T (\text{iFWT\_dual}(B))_T \cdot (\hat{A}_T)^i
$$

太好啦！我们把问题转化成了计算两个数组的点积。
令 $C_T = (\text{iFWT\_dual}(B))_T$。我们只需要先预处理出数组 $\hat{A}$ 和数组 $C$，然后对于每个 $i$，就能 $O(2^n)$ 地算出 $\sum_T C_T \cdot (\hat{A}_T)^i$ 了。

### 算法步骤总结喵

好嘞，梳理一下我们的爪印，完整的算法步骤如下：

1.  **初始化**: 创建数组 `a` 和 `b，大小为 $2^n$，根据输入填充 $a_S$ 和 $b_S$ 的值。
2.  **计算 $\hat{A}$**: 对数组 a` 执行一次 FWT (子集和变换)，得到数组 `hat_a`。
3.  **计算 $C$**: 对数组 `b` 执行一次对偶逆 FWT，得到数组 `c。
    -   $\text{iFWT\_dual}(b)_T = \sum_{S \supseteq T} (-1)^{|S \setminus T|} b_S$
    -   这个对偶变换有个小技巧：它等于 iFWT(b_rev)[U \ T]`，其中 `b_rev[S] = b[U \ S]` (U是全集)，`iFWT 是普通的逆 FWT。这样实现起来更方便！
4.  **计算最终答案**:
    -   对于每个 $i$ 从 1 到 $n$：
        -   计算 $Res_i = \sum_{T=0}^{2^n-1} C_T \cdot (\hat{A}_T)^i$。
        -   最终答案 $\text{Ans}_i = Res_i / i!$。
    -   为了效率，我们可以遍历一遍 $T$，同时计算出 $(\hat{A}_T)^i$ 对所有 $i$ 的贡献。

整个算法的瓶颈在于 FWT 和最后的求和，所以总时间复杂度是 $O(n \cdot 2^n)$，空间复杂度是 $O(n \cdot 2^n)$ 或者 $O(2^n)$（取决于如何实现），对于 $n \le 20$ 来说是完全可以接受的，喵~

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的代码哦~ 每一步都有详细的注释，希望能帮到你，呐！

``cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>

using namespace std;

const int MOD = 998244353;

// 快速幂，喵~
long long power(long long base, long long exp) {
    long long res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模数逆元，除法就靠它了
long long modInverse(long long n) {
    return power(n, MOD - 2);
}

// FWT 模板，type=1 是正变换，type=-1 是逆变换
void FWT(vector<long long>& p, int type) {
    int n_bits = 0;
    while ((1 << n_bits) < p.size()) {
        n_bits++;
    }

    for (int i = 0; i < n_bits; ++i) {
        for (int mask = 0; mask < (1 << n_bits); ++mask) {
            if ((mask >> i) & 1) {
                long long val = (p[mask] + type * p[mask ^ (1 << i)]) % MOD;
                if (val < 0) val += MOD;
                p[mask] = val;
            }
        }
    }
}


int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    int limit = 1 << n;
    vector<long long> a(limit, 0);
    vector<long long> b(limit, 0);

    for (int i = 1; i < limit; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i < limit; ++i) {
        cin >> b[i];
    }

    // --- 步骤 2: 计算 hat_a ---
    vector<long long> hat_a = a;
    FWT(hat_a, 1);

    // --- 步骤 3: 计算 c (iFWT_dual(b)) ---
    // 使用 b_rev[S] = b[U \ S] 的技巧
    vector<long long> b_rev(limit, 0);
    int all_set = limit - 1;
    for (int i = 0; i < limit; ++i) {
        b_rev[i] = b[all_set ^ i];
    }
    
    // 对 b_rev 做逆FWT
    FWT(b_rev, -1);

    // c[T] = b_rev[U \ T]
    vector<long long> c(limit, 0);
    for (int i = 0; i < limit; ++i) {
        c[i] = b_rev[all_set ^ i];
    }

    // --- 步骤 4: 计算最终答案 ---
    vector<long long> final_ans(n + 1, 0);
    
    for (int t = 0; t < limit; ++t) {
        if (hat_a[t] == 0 && c[t] == 0) continue; // 小优化
        long long hat_a_t_pow_i = 1;
        for (int i = 1; i <= n; ++i) {
            hat_a_t_pow_i = (hat_a_t_pow_i * hat_a[t]) % MOD;
            long long term = (c[t] * hat_a_t_pow_i) % MOD;
            final_ans[i] = (final_ans[i] + term) % MOD;
            if (final_ans[i] < 0) final_ans[i] += MOD;
        }
    }

    // 预计算阶乘的逆元
    vector<long long> inv_fact(n + 1, 0);
    inv_fact[0] = 1;
    if (n > 0) {
        long long current_fact = 1;
        for (int i = 1; i <= n; ++i) {
            current_fact = (current_fact * i) % MOD;
        }
        inv_fact[n] = modInverse(current_fact);
        for (int i = n - 1; i >= 1; --i) {
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
        }
    }

    // 输出结果，别忘了除以 i!
    for (int i = 1; i <= n; ++i) {
        cout << (final_ans[i] * inv_fact[i]) % MOD << (i == n ? "" : " ");
    }
    cout << endl;

    return 0;
}
``

## 复杂度分析

*   **时间复杂度**: $O(n \cdot 2^n)$，喵~
    - FWT (正变换和逆变换) 的时间复杂度都是 $O(n \cdot 2^n)$。
    - 构造 b_rev` 和 `c` 数组需要 $O(2^n)$。
    - 最后计算 `final_ans 的循环，外层遍历 $T$ 有 $2^n$ 次，内层遍历 $i$ 有 $n$ 次，所以是 $O(n \cdot 2^n)$。
    - 预计算阶乘逆元是 $O(n + \log MOD)$。
    - 总的来说，主要开销在 FWT 和最后的求和循环上。

*   **空间复杂度**: $O(2^n)$，呐。
    - 我们需要存储 a`, `b`, `hat_a`, `b_rev`, `c` 等数组，它们的大小都是 $2^n$。
    - `final_ans` 和 `inv_fact 数组大小为 $n+1$，可以忽略不计。

## 知识点总结

这道题是一场集合运算的盛宴，吃得很满足，喵~ 主要涉及了以下知识点：

1.  **组合计数**: 理解题目中 $f_{S,i}$ 的定义，它本质上是带权值的集合划分问题。
2.  **集合幂级数与不交并卷积**: 认识到有序划分的权值和可以表示为不交并卷积（Disjoint Convolution）的幂。
3.  **快速沃尔什-哈达玛变换 (FWT)**: 这是解决各种子集卷积问题的核心工具。本题中我们利用了 FWT 能将不交并卷积转化为逐点乘积的性质。
4.  **FWT 对偶原理**: 理解 FWT 域中的点积和原函数域中的点积之间的转换关系，即 $\langle X, Y \rangle = \langle \text{iFWT\_dual}(X), \hat{Y} \rangle$。这是推导出最终简洁解法的关键。
5.  **变换技巧**: 学习了如何通过 b_rev` 数组来巧妙地计算对偶逆 FWT，避免了为每个子集都跑一遍变换的麻烦。

希望这篇题解能让你对 FWT 和集合上的卷积有更深的理解！如果还有不明白的地方，随时可以来问我哦，喵~