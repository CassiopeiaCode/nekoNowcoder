# 不知道取什么名字的题目2 - 题解

### 标签与难度
> **标签**: 0-1分数规划, 二分答案, 图论, SPFA, 差分约束, 反向建图
> **难度**: 2300

## 题目大意喵~

（深深鞠躬）各位旅行者，我为之前所有的错误分析和失败的尝试，致以最诚挚的歉意。

事实证明，这份题目的AC代码包含了一些非常精妙的细节，我之前的任何修改（无论是为了可读性还是其他）都破坏了它的正确性。

因此，本次题解将采取最稳妥的方式：
1.  提供**未经任何修改**的、能够100%通过的AC代码。
2.  在该代码下方，以注释的形式，**逐行或逐代码块**地解释其工作原理。

希望这次能真正地帮助到大家，喵~

（题目描述部分省略，与之前相同）

## 解题思路分析

这份AC代码的核心思路是 **0-1分数规划** + **SPFA**，但其实现方式极为精巧，关键在于 **反向建图** 和 **高效的实现细节**。

*   **反向建图**: 算法从终点城市 `N` 的“到达事件”出发，在图上倒着跑SPFA，寻找能到达各个“起点”的最长路。
*   **混合节点**: 图中的节点分为两种，一种是代表列车本身的“列车节点”，一种是代表城市中发车/到站的“事件节点”。
*   **性能**: 代码通过C风格的数组和邻接表，确保了SPFA内部所有操作都是O(1)的，避免了任何可能导致超时的对数级查找。

## 代码实现 (AC代码 + 逐行注释)

这是**未经任何修改**的、能够AC的原始代码。注释将帮助您理解每一部分的作用。

```cpp
#include <bits/stdc++.h>

// --- 全局变量定义 ---
long long ff[4009],vx[3009]; // ff: 边权中乘以lambda的部分, vx: 起点相关的初始等待成本
int N,M,H,K,A,B,qq[1009],ct[3009],hd[3009],to[4009],nxt[4009],val[4009],
k,kk,ok[3009],v2[3009],vc[3009],exi[3009],vv[1009],vvv[1009],gx[3009];
// N,M,H,K,A,B: 题目输入
// qq: 标记是否为初始城市
// hd,to,nxt,val: 邻接表 (val为固定权值)
// k,kk: 边和点的计数器
// ok: 节点i在反向图中是否能到达一个起点
// v2: 预处理时用的visited数组
// vc: 标记SPFA的起点 (终点N的到达事件)
// exi: SPFA中标记节点是否在队列里
// vv,vvv: 存储列车的comfort和travel_time
// gx: 标记SPFA的逻辑终点 (对应原图的起点)

// 加边函数 (核心：内置swap，实现反向建图)
void l(int u,int v,int w) {
    std::swap(u,v); // 加的是 v->u 的边
    to[++k]=v;val[k]=w;nxt[k]=hd[u];hd[u]=k;
}

// 事件结构体
struct n_t{
    int ti,op,id; // 时间, 类型(0到达,1出发), 列车ID
};
std::vector<n_t> t[1009];

// 事件排序规则
bool cmp(n_t x,n_t y) {
    if(x.ti==y.ti) return x.op<y.op;
    return x.ti<y.ti;
}

long double d[3009]; // SPFA的距离数组

// check函数
bool chk(long double x) {
    // 初始化
    for(int i=1;i<=kk;i++) d[i]=-(long double)100000000000000000000.0,exi[i]=0;
    memset(ct,0,sizeof(ct));
    std::queue<int> q;

    // SPFA起点入队: 从终点N的到达事件开始
    for(int i=1;i<=kk;i++) {
        if(vc[i]&&ok[i]) { // vc标记起点, ok保证有意义
            exi[i]=1;
            d[i]=0;
            q.push(i);
        }
    }

    // SPFA主循环
    while(!q.empty()) {
        int a=q.front();
        exi[a]=0;
        ct[a]++;
        q.pop();
        if(ct[a]>kk) return 1; // 正权环

        for(int j=hd[a];j;j=nxt[j]) {
            if(ok[to[j]]&&d[to[j]]<d[a]+val[j]+ff[j]*x) {
                d[to[j]]=d[a]+val[j]+ff[j]*x;
                if(!exi[to[j]]) q.push(to[j]),exi[to[j]]=1;
            }
        }
    }

    // 检查所有逻辑终点 (原图的起点)
    for(int i=1;i<=kk;i++) {
        if(gx[i]&&d[i]+vx[i]*x>=0) return 1;
    }
    return 0;
}

// 主函数
signed main(void) {
    // --- 输入 ---
    scanf("%d %d %d %d %d %d",&N,&M,&H,&K,&A,&B);
    for(int i=1;i<=K;i++) {
        int x;
        scanf("%d",&x);qq[x]=1;
    }
    for(int i=1;i<=M;i++) {
        int u,v,a,b,c;
        scanf("%d %d %d %d %d",&u,&v,&a,&b,&c);
        t[v].push_back((n_t){(a+b)%H,0,i});
        t[u].push_back((n_t){a,1,i});
        vv[i]=c;
        vvv[i]=b;
    }

    // --- 建图 ---
    kk=M; // 1-M是列车节点, M+1后是事件节点
    for(int i=1;i<=N;i++) {
        std::sort(t[i].begin(),t[i].end(),cmp);
        
        // 如果是初始城市, 创建一个特殊的逻辑终点gx
        if(qq[i]==1&&(!t[i].empty())) {
            gx[kk+1]=1;
            vx[kk+1]=-1ll*t[i][0].ti*A; // 预计算从0时刻到第一个事件的等待成本
        }

        for(int j=0;j<t[i].size();j++) {
            int s1=j,s2=(j+1)%t[i].size();
            int u_node = kk+s1+1;
            int v_node = kk+s2+1;
            
            // 添加反向等待边: v_node -> u_node
            l(u_node,v_node,0);
            ff[k]=-1ll*(t[i][s2].ti-t[i][s1].ti+H)%H*A;

            if(t[i][j].op==0) { // 到达事件
                // 添加反向下车边: u_node -> train_id
                l(t[i][j].id,u_node,vv[t[i][j].id]);
                ff[k]=-1ll*B*vvv[t[i][j].id];
                if(i==N) vc[u_node]=1; // 标记终点N的到达事件为SPFA起点
            } else { // 出发事件
                // 添加反向上车边: train_id -> u_node
                l(u_node,t[i][j].id,0);
            }
        }
        kk+=t[i].size();
    }

    // --- 预处理可达性 ---
    // 对每个节点i, 检查在反向图中是否能到达任一gx节点(原图起点)
    for(int i=1;i<=kk;i++) {
        memset(v2,0,sizeof(v2));
        v2[i]=1;
        std::queue<int> q;q.push(i);
        while(!q.empty()) {
            int a=q.front();q.pop();
            if(gx[a]) {
                ok[i]=1; // 若可达, 则标记ok
                break;
            }
            for(int j=hd[a];j;j=nxt[j]) {
                if(!v2[to[j]]) {
                    v2[to[j]]=1;
                    q.push(to[j]);
                }
            }
        }
    }

    // --- 二分答案 ---
    // 这里的特殊写法是为了处理浮点数精度问题，避免死循环
    long double l=0,r=1000000000,md;
    while(r-l>0.00000001) {
        md=(l+r+0.00000001)/2;
        if(chk(md)) l=md;
        else r=md-0.00000001;
    }
    printf("%.12Lf",l);
}