# 歪歪星球的快乐旅行 - 题解

哈喵~！各位热爱算法的旅行者们，欢迎来到本猫娘的题解小屋！今天我们要一起探索的是一个关于在歪歪星球进行快乐旅行的有趣问题，它涉及到路径规划和价值最大化，是不是听起来就很有趣捏？别担心，跟着本喵的思路，再复杂的算法也会变得像小鱼干一样美味可口！那么，我们开始吧~！

### 比赛与标签
> **比赛**: 比赛信息未提供喵~
> **标签**: 图论, 最短路, 0-1分数规划, SPFA
> **难度**: *2600

## 题目大意喵~
在一个神奇的歪歪星球上，一天有 `h` 个小时。我们有 `n` 座城市和 `m` 条单向的列车线路。

每条列车线路 `(u, v, t1, t2, val)` 的意思是：
- 每天都会在 `t1` 时刻（对 `h` 取模）从城市 `u` 出发。
- 经过 `t2` 小时到达城市 `v`。
- 乘坐这趟车可以获得 `val` 的舒适度。

我们可以在任何城市等待任意天，直到想坐的列车发车。

现在有 `k` 位乘客，他们各自从不同的城市 `s_i` 出发，都想去终点城市 `n`。对于一段旅程，我们需要计算两个值：
- **等待时间**: 在每个中转站等待列车的总时间。
- **乘车时间**: 乘坐列车在路上的总时间。

总的 **时间成本** 定义为：`等待时间 * a + 乘车时间 * b`。

我们的目标是，为这些乘客规划路径，在保证**至少有一名乘客**能到达终点 `n` 的前提下，最大化一个特别的比率：

**`所有成功到达乘客的总舒适度之和 / 所有成功到达乘客的总时间成本之和`**

我们需要求出这个最大的比率是多少，呐。

## 解题思路详解喵！
这个问题看起来好复杂哦，又要算时间又要算舒适度，还要最大化一个分数！但是不要怕，本喵来把它拆解成一小步一小步，你就会发现它的核心思想其实很优雅的喵~

### 第一步：看穿问题的本质——0/1分数规划
首先，我们看到目标是最大化一个分式 `总舒适度 / 总成本`，这种形式的问题通常都可以指向一个强大的算法模型——**0/1分数规划**！

假设我们想求的最大比率是 `ans`。那么，对于任何一个可行的旅行方案，都应该满足：
`总舒适度 / 总成本 ≤ ans`

我们可以把这个式子变一下形：
`总舒适度 ≤ ans * 总成本`
`总舒适度 - ans * 总成本 ≤ 0`

这给了我们一个超棒的思路！我们可以去**二分答案** `ans`！
对于一个二分猜出来的答案 `R`，我们来判断是否存在一个旅行方案，使得 `总舒适度 - R * 总成本 > 0`。
- 如果存在，说明我们选择的路径组合的实际比率比 `R` 更大，那么真正的 `ans` 肯定不小于 `R`，所以我们可以尝试更大的 `R`，即 `l = R`。
- 如果不存在，说明对于所有方案，这个值都小于等于0，意味着 `R` 太大了，真正的 `ans` 应该比 `R` 小，所以我们缩小范围，`r = R`。

通过不断二分，我们就能无限逼近那个最完美的 `ans` 啦！

### 第二步：重新定义“价值”
现在，问题转化成了：对于一个给定的 `R`，我们如何找到一个能让 `总舒适度 - R * 总成本` 最大的方案呢？

让我们把这个式子分配到每一次乘车上。假设一次乘车是从 `u` 到 `v`，列车信息为 `(u, v, a_p, c_p, w_p)`（出发时间、行驶时间、舒适度），并且我们在 `u` 点的等待时间是 `wait_u`。那么这次旅途的“新价值”就是：
`w_p - R * (a * wait_u + b * c_p)`

我们的目标就是找到一条或多条从起点到终点的路径，使得路径上所有“新价值”的总和最大！这是一个**最长路问题**！

### 第三步：构建最长路模型
最长路？那不是用 SPFA 或者 Bellman-Ford 就能解决嘛！但是，这里的“点”是什么呢？

一个旅客的状态，不仅取决于他所在的城市，还取决于他到达这个城市的时间（`mod h`），因为这决定了他下趟车的等待时间。如果把 `(城市, 时间)` 作为图的节点，那节点数量会是 `n * h`，太多了，会超时的说！

所以，我们需要更聪明的建图方式。注意到，一段旅程是由连续的列车线路（也就是原图的边）组成的。我们何不把**状态定义在边上**呢？

我们定义 `dp[i]` 为：**以乘坐第 `i` 条列车线路结束的某段旅程，所能获得的最大“新价值”**。

假设我们想计算乘坐线路 `p`（从 `x` 出发）的 `dp[p]`。它肯定是从某条到达城市 `x` 的线路 `y` 转移过来的。转移的增量就是乘坐线路 `p` 带来的“新价值”：
`dp[p] = max(dp[y] + w_p - R * (b*c_p + a*wait_at_x))`
其中 `wait_at_x` 是乘坐完 `y` 后在 `x` 等待 `p` 的时间。

### 第四步：时空穿梭的SPFA！
这个 `wait_at_x` 依赖于线路 `y` 的到达时间和线路 `p` 的出发时间，这让 `max` 的计算变得棘手。但是，观察代码，会发现一个绝妙的优化！

1.  **预处理**：我们把所有线路按出发点和到达点分组。对于每个城市 `x`，`h1[x]` 存所有从 `x` 出发的车次，`h2[x]` 存所有到达 `x` 的车次。并把它们都按时间排序。
2.  **SPFA/Bellman-Ford 核心**：我们用一个类似 Bellman-Ford 的结构来迭代更新所有 `dp[i]` 值。总共迭代 `n+m` 次左右，足以让最长路的值传播开，并且可以检测出是否存在**正环**。
    - **正环**：如果存在一个环，使得环上所有“新价值”之和为正，我们就可以在这个环上无限转圈，获得无限大的价值。这意味着我们猜的 `R` 肯定是可以达成的（甚至可以远超）。
3.  **高效转移**：在 `check` 函数中，对于每个城市 `x`，我们用一个类似双指针的方法来处理。
    - 遍历从 `x` 出发的每条线路 `p`（来自 `h1[x]`）。
    - 同时，用一个指针 `it` 维护所有在 `p` 出发前就已到达 `x` 的线路 `y`（来自 `h2[x]`）。
    - 我们维护一个 `rc` 变量，它记录了对于当前所有已到达的线路 `y`，`dp[y]` 经过某种变换后的最大值。这个变换是为了将等待时间巧妙地分离出来，使得 `max` 的计算变得高效。
    - 这样，对于每个 `p`，我们都可以 `O(1)` 地利用 `rc` 来更新 `dp[p]`。

整个 `check` 函数的逻辑就是：
1.  初始化：对于乘客的初始城市，计算他们乘坐第一趟车能获得的 `dp` 值。
2.  循环松弛：进行 `n+m` 次迭代，在所有城市之间传播 `dp` 值。
3.  判断结果：
    - 如果在松弛过程中发现了正环，说明 `R` 可行。
    - 如果没有正环，就检查所有能到达终点 `n` 的路径，看它们最终的 `dp` 值是否有大于0的。如果有，`R` 也可行。
    - 否则，`R` 不可行。

这样，通过二分和这个巧妙的类 Bellman-Ford 算法，我们就能找到答案啦，喵~

## 代码实现喵！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
#define cln cerr<<"Line:   "<<__LINE__<<"    "
#define pct __builtin_popcountll
#define ctz __builtin_ctzll
#define mkp make_pair
#define MST(x) memset(x,0,sizeof(x))
#define all(x) x.begin(),x.end()
using namespace std;
constexpr int N=(1<<21)+100,_g=3,M1=1e9+7,M2=1e9+9,M=998244353;
using ll=long long;
#define pli pair<ll,int>
#define pii pair<int,int>
using ul=unsigned long long;
template<typename tp1,typename tp2>
    void ckmx(tp1 &x,const tp2 &y){if(x<y)x=y;}
template<typename tp1,typename tp2>
    void ckmn(tp1 &x,const tp2 &y){if(x>y)x=y;}
void add(int &x,int y){(x+=y)>=M?x-=M:0;}
void del(int &x,int y){(x-=y)<0?x+=M:0;}
void add(int &x,ul y,int z){x=(y*z+x)%M;}
void del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}
int qp(ll a,ll x=M-2){
    int res=1;for(;x;x>>=1,a=a*a%M)
        (x&1)&&(res=a*res%M);return res;
}
int qp(ll a,ll x,int M){
    int res=1;for(;x;x>>=1,a=a*a%M)
        (x&1)&&(res=a*res%M);return res;
}
struct NTP{};
template<typename tp1,typename tp2,int N>
struct Htb{
    static constexpr int M=1e7+19;
    int hd[M+3],to[N],ct;
    tp1 ed[N];tp2 w[N];
    static int hc(ul v){
        v^=v<<13,v^=v>>7;
        return (v^(v<<17))%M;
    }
    void ins(tp1 x,tp2 y){
        int &p=hd[hc(x)];
        ed[++ct]=x,to[ct]=p;
        w[p=ct]=y;
    }
    int count(tp1 x){
        for(int i=hd[hc(x)];i;i=to[i])
            if(ed[i]==x)return 1;
        return 0;
    }
    pair<tp2,bool>find(tp1 x){
        for(int i=hd[hc(x)];i;i=to[i])
            if(ed[i]==x)return mkp(w[i],true);
        return mkp(tp2(),false);
    }
    int operator[](tp1 x){
        int &p=hd[hc(x)];
        for(int i=p;i;i=to[i])
            if(ed[i]==x)return i;
        ed[++ct]=x,to[ct]=p;
        return p=ct;
    }
    void clear(){while(ct)hd[hc(ed[ct--])]=0;}
};
namespace MATH{
    vector<int>jc,nv,_nv;
    int dv2(int x){return x&1?x+M>>1:x>>1;}
    int C(int n,int m){
        assert(m<=n);
        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;
    }
    int P(int n,int m){
        return 1ll*jc[n]*nv[n-m]%M;
    }
    int D(int n,int m){
        if(n<0||m<0)return 0;
        if(!n)return 1;
        if(!m)return 0;
        return C(n+m-1,m-1);
    }
    void init(int n){
        int x;
        jc.resize(n+2);
        jc[0]=jc[1]=1;
        nv=_nv=jc;
        for(x=2;x<=n;++x){
            jc[x]=1ll*x*jc[x-1]%M;
            _nv[x]=ll(M-M/x)*_nv[M%x]%M;
            nv[x]=1ll*nv[x-1]*_nv[x]%M;
        }
    }
}
struct DET{
    int a[3005][3005],n;
    int run(){
        if(!n)return 1;
        int x,y,z,k,res=1;
        for(x=1;x<=n;++x){
            for(y=x;y<=n&&!a[y][x];++y);
            if(y>n)return 0;
            if(y>x){
                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);
                res&&(res=M-res);
            }
            k=qp(a[x][x]);
            res=1ll*res*a[x][x]%M;
            for(z=1;z<=n;++z)
                a[x][z]=1ll*a[x][z]*k%M;
            for(y=1;y<=n;++y)
                if(x!=y){
                    k=a[y][x];
                    for(z=1;z<=n;++z)
                        del(a[y][z],a[x][z],k);
                }
        }
        for(x=1;x<=n;++x)
            res=1ll*res*a[x][x]%M;
        return res;
    }
};
ll Gcd(ll x,ll y){
    if(!x||!y)return x|y;
    int k=min(ctz(x),ctz(y));
    ll d;y>>=ctz(y);
    while(x){
        x>>=ctz(x),d=x-y;
        if(x<y)y=x;
        if(d<0)x=-d;
        else x=d;
    }return y<<k;
}
using ll=long long;
using ul=unsigned long long;
constexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}
template<int mod>struct NTT{
    constexpr int dil(int x){return x>>31?x+mod:x;}
    constexpr int mul(ul x,int y){return x*y%mod;}
    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}
    int w[N>>1],wI[N>>1];
    void init(int n){
        int l=bceil(n)>>1;w[0]=wI[0]=1;
        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}
        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}
    }
    void dif(int *f,int lim){
        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)
            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)
                for(int*k=j,x,y;k!=j+l;++k)
                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;
    }
    void dit(int *f,int lim){
        for(int l=1,r=2;l<lim;l<<=1,r<<=1)
            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)
                for(int*k=j,x,y;k!=j+l;++k)
                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);
        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%M;
    }
    void mul(int *f,int *g,int n){
        dif(f,n),dif(g,n);
        for(int i=0;i<n;++i)f[i]=1ll*f[i]*g[i]%M;
        dit(f,n);
    }
    void mul_(int *f,int *g,int n){
        static int g_[N];
        for(int i=0;i<n;++i)g_[i]=g[i];
        dif(f,n),dif(g_,n);
        for(int i=0;i<n;++i)f[i]=1ll*f[i]*g_[i]%M;
        dit(f,n);
    }
    void mul(int *f,int n){
        dif(f,n);int i;
        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;
        dit(f,n);
    }
};
using namespace MATH;
mt19937_64 rg(random_device{}());
using LL=__int128_t;
using vt=vector<int>;
using vl=vector<ll>;
using ld=double;
const ll INF=1e18;
int T,n,m,Q,K,A,B,q[N];
bitset<N>vs,vc;
struct dat{
    int a,b,c,w; // a:出发时间, b:到达时间, c:乘车时长, w:舒适度
}d[N];
vector<pii>h1[N],h2[N]; // h1[u]:从u出发的(时间,线路id), h2[v]:到达v的(时间,线路id)
vt lk[N]; // 反向图，用于判断可达性
ld d1[N],rp; // d1[i]是dp数组, rp是二分的答案R

// check函数，判断猜的答案rp是否可行
int ck(){
    int i,j,k,l,r,x,y,z;
    // 初始化dp数组，d1[i]表示以线路i结束的路径的最大“新价值”
    for(x=1;x<=m;++x)d1[x]=-1e40;
    
    // 初始化：对于所有起始城市的乘客
    for(x=1;x<=n;++x)
        if(vs[x]) // 如果x是起始城市
            for(auto p:h1[x]) // 遍历从x出发的所有线路
                // 乘客从0时刻开始等，等待时间为p.first (即t1)，乘车时间为d.c
                // 新价值 = w - R * (A*wait + B*travel)
                ckmx(d1[p.second], (ld)d[p.second].w - rp*(1ll*B*d[p.second].c + 1ll*A*p.first));

    int tg; // 标记本轮迭代是否有更新，用于检测正环
    // Bellman-Ford/SPFA核心过程，迭代足够多次以传播最长路信息
    for(int tt=max(n,m)+2;tt--;){
        tg=0;
        // 遍历每个城市作为中转站
        for(x=1;x<=n;++x){
            auto it=h2[x].begin(); // 指向到达线路的指针
            ld rc=-1e40; // 记录到达x的线路能提供的最大“价值潜力”
            
            // 遍历从x出发的每条线路p
            for(auto p:h1[x]){
                // 处理所有在p出发前到达的线路y
                while(it!=h2[x].end() && it->first <= p.first){
                    y = it->second; // 线路y的id
                    if(d1[y]>-1e38) // 如果线路y是可达的
                        // 这是一个聪明的变换，把等待时间巧妙地拆分计算
                        ckmx(rc, d1[y] + rp * A * it->first);
                    ++it;
                }
                
                if(rc > -1e38){ // 如果存在可以转移来的前驱路径
                    // 计算出到达线路p的新价值
                    ld _rc = rc + d[p.second].w - rp * (1ll * A * p.first + 1ll * B * d[p.second].c);
                    if(_rc > d1[p.second]){
                        tg = 1; // 发生了更新
                        d1[p.second] = _rc;
                    }
                }
            }
        }
    }
    
    if(tg) return 1; // 如果最后一次迭代还有更新，说明存在正价值环，rp可行
    
    // 检查所有能到达终点n的线路，看其价值是否>0
    for(auto p:h2[n]) if(d1[p.second] > 1e-38) return 1;
    
    return 0; // 否则rp不可行
}

int main(){
    ios::sync_with_stdio(false),cin.tie(0);
    int i,j,k,l,r,x,y,z;
    cin>>n>>m>>K>>T>>A>>B; // K是h
    while(T--)cin>>k,vs[k]=1; // 标记起始城市
    
    for(i=1;i<=m;++i){
        cin>>x>>y>>l>>r>>k; // u, v, t1, t2, val
        d[i]={l, (l+r)%K, r, k};
        h1[x].emplace_back(l, i); // 当天出发
        h1[x].emplace_back(l+K, i); // 第二天出发(处理跨天等待)
        h2[y].emplace_back((l+r)%K, i);
        lk[y].push_back(x); // 构建反图
    }
    
    // 预处理：用反向BFS/DFS找到所有能到达终点n的城市
    vc[q[l=r=1]=n]=1;
    while(l<=r){
        x=q[l++];
        for(int y:lk[x])
            if(!vc[y])vc[q[++r]=y]=1;
    }
    // 剪枝：清除从不可达城市出发/到达不可达城市的线路
    for(x=1;x<=n;++x)
        if(!vc[x])h1[x].clear(),h2[x].clear();
    
    // 对所有城市的出发和到达线路按时间排序
    for(x=1;x<=n;++x){
        sort(all(h1[x]));
        sort(all(h2[x]));
    }
    
    // 二分答案
    ld _l=0, _r=1e9+7, ac=0;
    for(k=1;k<=90;++k){ // 迭代90次，精度足够
        rp=(_l+_r)/2;
        if(ck()) ac=rp, _l=rp; // 如果rp可行，尝试更大的答案
        else _r=rp; // 否则缩小答案
    }
    
    printf("%.12lf\n",ac);
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(log(V) * (N+M) * M) 的说。
  - 外层是二分答案，`log(V)` 是二分的次数，`V` 是答案的取值范围，一般迭代90-100次精度就足够了。
  - `check` 函数内部是 Bellman-Ford 过程。我们迭代了 `max(n,m)+2` 次。
  - 每次迭代中，我们遍历所有城市，对每个城市 `x`，我们用双指针的方式处理了 `h1[x]` 和 `h2[x]`。总的来说，对所有 `x` 的 `h1` 和 `h2` 的访问总次数是 `O(M)`。
  - 所以 `check` 函数的复杂度是 `O((N+M) * M)`。
  - 总复杂度就是 `O(log(V) * (N+M) * M)`。
- **空间复杂度**: O(N + M) 的说。
  - 我们需要存储图的信息、线路信息、DP数组等，这些都是线性的空间。

## 知识点与总结喵~
这次的旅行真是收获满满呀！我们来总结一下学到了哪些强大的魔法吧：

1.  **0/1分数规划**: 这是解决 `最大化 A/B` 这类问题的标准武器！核心就是**二分答案**，将问题转化为判定性问题。
2.  **SPFA/Bellman-Ford for Longest Path**: 当边权可正可负，并且需要检测正环时，这个算法就是我们的不二之选。这道题里，`新价值`可正可负，正环的存在直接意味着答案可行，完美契合！
3.  **DP状态设计与转移优化**: 面对 `(城市, 时间)` 这种复杂状态，一个非常重要的思想是**将DP状态定义在边上**。同时，通过**排序+双指针**的技巧，将复杂的转移优化到了线性时间，这是解题的关键！
4.  **剪枝思想**: 在算法主体开始前，通过反向图BFS判断节点是否能到达终点，并剔除无用信息。这个小小的预处理可以减少后续计算量，是个非常好的习惯哦！

希望本猫娘的讲解能帮助你更好地理解这个问题！下次遇到类似的挑战，也要像这样充满信心地去分析和解决哦！我们下次题解再见，喵~！