# 不知道取什么名字的题目2 - 题解

### 标签与难度
> **标签**: 0-1分数规划, 二分答案, 图论, SPFA, 差分约束, 反向建图
> **难度**: 2300

## 题目大意喵~

各位旅行者，欢迎来到歪歪星球，喵~！这个星球上的一天有 $h$ 个小时，有 $n$ 座城市和 $m$ 条单向的列车线路。

每条列车线路 `i` 从城市 $u$ 到城市 $v$，在每天的 $t_1$ 时刻发车，经过 $t_2$ 小时的旅行后，在 $(t_1+t_2) \pmod h$ 时刻到达城市 $v$。乘坐这趟列车还能获得 $val$ 的舒适度呢！

我们有 $k$ 位乘客，他们一开始在不同的城市，都想去终点城市 $n$。在旅途中，会有两种时间消耗：
1.  **等待时间**：在一个城市里等火车的时间。
2.  **乘车时间**：坐在火车上旅行的时间。

这两种时间都有一个代价系数，分别是 $a$ 和 $b$。所以，一次旅行的 **总时间成本** 就是 $(\text{等待时间}) \times a + (\text{乘车时间}) \times b$。

我们的目标是设计一个旅行策略，让所有成功到达终点的乘客们，他们获得的 $\frac{\sum (\text{成功到达乘客的舒适度})}{\sum (\text{成功到达乘客的总时间成本})}$ 这个比值达到最大！我们要输出的就是这个最大的比值，呐。

## 解题思路分析

这道题的核心是 **0-1分数规划**，我们可以二分答案 $\lambda$，然后检查是否存在一个旅行方案，使得 $\sum (\text{Comfort} - \lambda \times \text{Cost}) \ge 0$。

判定 `check(λ)` 的过程，是一个最长路问题。标准的 `(城市, 时刻)` 建图模型虽然逻辑清晰，但实现不当容易超时。下面这份AC代码采用了一种非常精巧（虽然初看有些晦涩）的 **反向建图** 策略，成功地优化了性能，让我们来一探究竟吧，喵~

### 反向建图的巧妙之处

正向思考（从起点到终点）时，我们知道出发时间，但需要计算到达每个中间状态的时刻。而反向思考，则是从终点 $n$ **倒着往回走**。我们可以问：要想在某个时刻到达终点 $n$，我们最晚需要从起点城市的0时刻出发？

这种思路将一个“发散”的多起点问题，转化为了一个“收敛”的、从终点出发的问题，更容易处理。

### AC代码的混合图模型（反向）

这份代码建立了一个混合了两种节点的图：

1.  **列车节点**：`1` 到 `M` 号节点，代表 $M$ 条列车线路。
2.  **事件节点**：从 `M+1` 号开始，代表每个城市中，所有列车的**出发**和**到达**事件。我们将每个城市的所有事件按时间排序，就构成了一系列按时间流逝的事件节点。

**建图过程（全程反向！）**

AC代码中的 `l(u, v, w)` 函数里有一个 `std::swap(u, v)`，这意味着它加的边都是 `v -> u`。

1.  **等待边**：在城市 `u` 中，从事件 `j+1` 向前一个事件 `j` 连边。这代表在正向世界里，从时刻 `j` 等待到时刻 `j+1`。边的权值是等待的成本：`-λ * a * wait_time`。
2.  **下车边**：对于一趟从 $u$ 到 $v$ 的列车 `i，它在 $s$ 时刻出发，$(s+t)\pmod h$ 时刻到达。在反向图中，我们从**到达事件**（在城市 $v$）向**列车节点 i`** 连边。这代表“下车”这个动作的反向。边的权值是乘坐列车的净收益：`val - λ * b * travel_time`。
3.  **上车边**：我们再从**列车节点 `i`** 向**出发事件**（在城市 $u$）连边。这代表“上车”动作的反向，是无成本的。

### SPFA 在反向图上的舞蹈

*   **SPFA起点 (`vc`数组)**：我们从终点城市 $n$ 的所有**到达事件**开始跑SPFA。因为我们想最大化收益，所以这些节点的初始距离（净收益）都是0。`vc` 数组就是用来标记这些起点的。
*   **SPFA终点 (`gx`, `vx`数组)**：反向图的终点，就是正向图的起点。对于每个有乘客的初始城市 `s`，代码创建了一个特殊的“汇点” `gx`，并把从0时刻到该城市第一个事件的等待成本用 `vx` 预计算出来。
*   **可达性 (`ok`数组)**：在SPFA开始前，代码做了一个预处理，计算出从图上任意一个节点 `i` 出发，在反向图中是否能最终走到一个 `gx` 节点（即原图的某个起点）。这是为了在SPFA中剪枝，只走有意义的路径。
*   **最终检查**：SPFA跑完后，检查所有被 `gx` 标记的汇点，看它们的最长路 `d[i]` 加上预计算的初始等待成本 `vx[i]*λ` 是否大于等于0。如果是，说明 `check(λ)` 成功。

## 代码实现 (AC Version)

这份代码虽然使用了C风格的数组和全局变量，但它对图的构建和SPFA的运用非常高效且正确，成功地规避了TLE。

```cpp
#include <bits/stdc++.h>

// 使用 long long 避免 ff 和 vx 数组在计算中溢出
long long ff[4009],vx[3009];
int N,M,H,K,A,B,qq[1009],ct[3009],hd[3009],to[4009],nxt[4009],val[4009],
k,kk,ok[3009],v2[3009],vc[3009],exi[3009],vv[1009],vvv[1009],gx[3009];

// 邻接表加边 (注意：内置了swap，实现反向建图)
void l(int u,int v,int w) {
    std::swap(u,v); // 核心！加的是 v->u 的边
    to[++k]=v;val[k]=w;nxt[k]=hd[u];hd[u]=k;
}

struct n_t{
    int ti,op,id; // 时间, 操作(0:到达, 1:出发), 列车ID
};
std::vector<n_t> t[1009];

bool cmp(n_t x,n_t y) {
    if(x.ti==y.ti) return x.op<y.op;
    return x.ti<y.ti;
}

long double d[3009];

// check 函数，判断是否存在一个比值 x 可行
bool chk(long double x) {
    for(int i=1;i<=kk;i++) d[i]=-(long double)100000000000000000000.0,exi[i]=0;
    memset(ct,0,sizeof(ct));
    std::queue<int> q;

    // 初始化SPFA队列，从终点城市N的到达事件开始
    for(int i=1;i<=kk;i++) {
        if(vc[i]&&ok[i]) { // vc[i] 标记了终点N的到达事件, ok[i]保证此路径有意义
            exi[i]=1;
            d[i]=0;
            q.push(i);
        }
    }

    while(!q.empty()) {
        int a=q.front();
        exi[a]=0;
        ct[a]++;
        q.pop();
        if(ct[a]>kk) { // SPFA 判断正环
            return 1;
        }
        for(int j=hd[a];j;j=nxt[j]) {
            if(ok[to[j]]&&d[to[j]]<d[a]+val[j]+ff[j]*x) {
                d[to[j]]=d[a]+val[j]+ff[j]*x;
                if(!exi[to[j]]) q.push(to[j]),exi[to[j]]=1;
            }
        }
    }

    // 检查所有终点状态（即原图的起点）
    for(int i=1;i<=kk;i++) {
        if(gx[i]&&d[i]+vx[i]*x>=0) return 1;
    }
    return 0;
}

signed main(void) {
    scanf("%d %d %d %d %d %d",&N,&M,&H,&K,&A,&B);
    for(int i=1;i<=K;i++) {
        int x;
        scanf("%d",&x);qq[x]=1; // 标记初始城市
    }

    for(int i=1;i<=M;i++) {
        int u,v,a,b,c;
        scanf("%d %d %d %d %d",&u,&v,&a,&b,&c);
        t[v].push_back((n_t){(a+b)%H,0,i}); // 到达事件
        t[u].push_back((n_t){a,1,i});       // 出发事件
        vv[i]=c;   // comfort
        vvv[i]=b;  // travel_time
    }

    kk=M; // 节点编号从 M+1 开始
    for(int i=1;i<=N;i++) {
        std::sort(t[i].begin(),t[i].end(),cmp);
        if(qq[i]==1&&(!t[i].empty())) {
            // gx标记反向图的终点（原图的起点）
            // vx存储了从0时刻到第一个事件的等待成本
            gx[kk+1]=1;
            vx[kk+1]=-1ll*t[i][0].ti*A;
        }
        for(int j=0;j<t[i].size();j++) {
            int s1=j,s2=(j+1)%t[i].size();
            int u_node = kk+s1+1;
            int v_node = kk+s2+1;
            
            // 添加反向等待边: v_node -> u_node
            l(v_node, u_node, 0);
            ff[k]=-1ll*(t[i][s2].ti-t[i][s1].ti+H)%H*A;

            if(t[i][j].op==0) { // 到达事件
                // 添加反向下车边: u_node -> train_id
                l(u_node, t[i][j].id, vv[t[i][j].id]);
                ff[k]=-1ll*B*vvv[t[i][j].id];
                if(i==N) vc[u_node]=1; // 标记终点N的到达事件为SPFA起点
            } else { // 出发事件
                // 添加反向上车边: train_id -> u_node
                l(t[i][j].id, u_node, 0);
            }
        }
        kk+=t[i].size();
    }

    // 预处理：从每个节点i出发，在反向图中是否能到达gx节点（原图起点）
    for(int i=1;i<=kk;i++) {
        memset(v2,0,sizeof(v2));
        v2[i]=1;
        std::queue<int> q;q.push(i);
        while(!q.empty()) {
            int a=q.front();q.pop();
            if(gx[a]) {
                ok[i]=1;
                break;
            }
            // 注意这里的hd,nxt,to是反向图的邻接表
            for(int j=hd[a];j;j=nxt[j]) {
                if(!v2[to[j]]) {
                    v2[to[j]]=1;
                    q.push(to[j]);
                }
            }
        }
    }

    // 二分答案
    long double l=0,r=1000000000,md;
    // 循环次数或精度要求较高
    while(r-l>1e-8) {
        md=(l+r)/2;
        if(chk(md)) l=md;
        else r=md;
    }
    printf("%.12Lf",l);
}
```

## 复杂度与性能分析

- **时间复杂度**: $O(kk^2 + \log(\text{Precision}) \times V' \times E')$
    - **预处理**：计算`ok`数组的循环，看起来是 $O(kk \times (V'+E'))$，近似为 $O(kk^2)$ 或 $O(M^2)$。这是一个较大的开销，但只执行一次。
    - **二分 + SPFA**：二分进行约100次。`check`函数中，SPFA的节点数 $V'$ 和边数 $E'$ 都是 $O(M)$ 级别。AC代码将所有节点都映射为整数ID，用邻接表存储，每次查找都是 $O(1)$ 的。所以SPFA的复杂度是纯粹的 $O(V' \times E')$，也就是 $O(M^2)$。
    - **总复杂度**：$O(M^2 + \log(\text{Precision}) \times M^2)$。
    - **为什么能AC**：初始题解的TLE代码，虽然没有 $O(M^2)$ 的预处理，但它把查找开销（`logM）带入到了二分的每一次迭代中，总复杂度是 $O(\log(\text{Precision}) \times M^2 \times \log M)$。当 $M$ 较大时，这个 logM` 因子影响巨大。AC代码通过一次性的、在数据范围内可接受的预处理，换取了每次 `check` 函数的高效率，最终成功压线通过。

- **空间复杂度**: $O(N+M)$
    - 存储图、事件、以及SPFA的辅助数组都需要 $O(N+M)$ 的空间。

## 知识点总结

1.  **0-1分数规划**: 解决形如 $\max \frac{\sum A_i}{\sum B_i}$ 问题的经典模型。
2.  **二分答案**: 将最优化问题转化为判定性问题 `check(x)` 的强大工具。
3.  **反向建图**: 解决“多起点单终点”问题、或者终点状态比起点状态更明确的问题时的神来之笔！
4.  **性能优化**: 权衡一次性预处理开销和迭代内计算开销，是解决复杂问题的关键。有时，一个看起来很慢的预处理，可以为核心算法争取到宝贵的时间。