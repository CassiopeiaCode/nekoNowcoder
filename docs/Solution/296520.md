# 不知道取什么名字的题目2 - 题解

### 标签与难度
> **标签**: 0-1分数规划, 二分答案, 图论, 最长路, SPFA, 差分约束
> **难度**: 2300

## 题目大意喵~

各位旅行者，欢迎来到歪歪星球，喵~！这个星球上的一天有 $K$ 个小时，有 $N$ 座城市和 $M$ 条单向的列车线路。

每条列车线路 `i` 从城市 $u$ 到城市 $v$，在每天的 $s$ 时刻发车，经过 $t$ 小时的旅行后，在 $(s+t) \pmod K$ 时刻到达城市 $v$。乘坐这趟列车还能获得 $w$ 的舒适度呢！

我们有 $Q$ 位乘客，他们一开始在不同的城市，但都想去终点城市 $N$。在旅途中，会有两种时间消耗：
1.  **等待时间**：在一个城市里等火车的时间。
2.  **乘车时间**：坐在火车上旅行的时间。

这两种时间都有一个代价系数，分别是 $A$ 和 $B$。所以，一次旅行的 **总时间成本** 就是 $A \times (\text{总等待时间}) + B \times (\text{总乘车时间})$。

我们的目标是设计一个旅行策略，让所有成功到达终点的乘客们，他们获得的 **(总舒适度之和) / (总时间成本之和)** 这个比值达到最大！当然，前提是至少要有一个人能成功到达终点哦。我们要输出的就是这个最大的比值，呐。

## 解题思路分析

这道题看起来好复杂呀，又是时间又是舒适度又是成本的，但别怕，让本猫娘来一步步拆解它，喵~

### 核心问题：分数规划！

我们要求最大化一个分式：
$$
\lambda = \frac{\sum \text{Comfort}}{\sum \text{Cost}}
$$
这种形式的问题，是一个经典的模型，叫做 **0-1分数规划**。对于这种问题，我们通常使用 **二分答案** 的方法来解决。

假设我们想知道，这个比值最大能不能达到 $\lambda_0$ 呢？也就是说，是否存在一个旅行策略，使得：
$$
\frac{\sum \text{Comfort}}{\sum \text{Cost}} \ge \lambda_0
$$
我们可以把这个式子变形一下：
$$
\sum \text{Comfort} \ge \lambda_0 \times \sum \text{Cost}
$$
$$
\sum \text{Comfort} - \lambda_0 \times \sum \text{Cost} \ge 0
$$
$$
\sum (\text{Comfort} - \lambda_0 \times \text{Cost}) \ge 0
$$
这个式子告诉我们，如果我们可以找到一个旅行策略，使得所有乘客的“净收益”（$\text{Comfort} - \lambda_0 \times \text{Cost}$）之和大于等于0，那么 $\lambda_0$ 就是一个可行的比值。

这就把问题转化成了一个判定问题：给定一个比值 $\lambda_{check}$，我们能否找到一个路径方案，使得 $\sum (\text{Comfort} - \lambda_{check} \times \text{Cost})$ 的最大值大于等于 0？

如果可以，说明真实的最大比值 $\lambda$ 可能比 $\lambda_{check}$ 更大，我们尝试更大的值（l = mid）；如果不可以，说明 $\lambda_{check}$ 太大了，我们需要减小一点（r = mid）。这样就可以愉快地二分答案啦！

### 如何解决判定问题 `check(λ)`？

现在我们的目标是，对于一个固定的 $\lambda$，最大化 $\sum (\text{Comfort} - \lambda \times \text{Cost})$。

因为我们想让这个总和最大，所以对于每个乘客，我们都应该独立地为他规划一条能最大化他个人 `Comfort - λ * Cost` 的路径。如果这个最大值是正的，我们就让他去旅行，贡献这个正值；如果是负的，就让他待在原地，贡献为0。最后，只要所有乘客中，至少有一个人的最大净收益大于等于0，那么 `check(λ)` 就返回真。

所以，问题被进一步简化为：**对于一个从城市 $u$ 出发的乘客，找到一条到终点 $N$ 的路径，使得 `PathComfort - λ * PathCost` 最大化**。

`PathCost` 包含等待时间和乘车时间，即 $A \times \text{WaitTime} + B \times \text{TravelTime}$。
所以我们要最大化的值是：
$$
\text{Value} = \sum w_i - \lambda \left( A \sum \text{wait}_i + B \sum \text{travel}_i \right)
$$
$$
\text{Value} = \sum \left( w_i - \lambda B \cdot \text{travel}_i \right) - \lambda A \sum \text{wait}_i
$$
这看起来像一个最长路问题！每条边的权值都和 $\lambda$ 有关。但是，`wait_i` 的值取决于我们到达一个城市的时刻，这让问题变得棘手。

### 建立一个带时间的图！

一个城市的物理位置并不能完全描述我们的状态，因为“什么时间”到达这里至关重要。所以，我们的图节点不能只是城市，而应该是 `(城市, 时刻)` 这样的状态对。

可是，一天有 $K$ 个小时，时刻是连续的，这状态也太多了吧！
冷静下来想一想，我们真的关心每一分每一秒吗？并不是哦。我们只关心那些**有事件发生**的时刻，也就是各个列车的**出发时刻**和**到达时刻**。

所以，我们可以对时间进行离散化！对于每个城市 $u$，我们只关心所有从 $u$ 出发的列车的出发时间，和所有到达 $u$ 的列车的到达时间。把这些时间点收集起来，排序去重，就构成了这个城市的“关键时刻”集合。

现在，我们可以建立一个全新的“超级图”：
*   **超级图的节点**：每个节点代表一个 `(城市, 关键时刻)` 的状态。
*   **超级图的边**：
    1.  **等待边**：在同一个城市 $u$ 内，从一个关键时刻 $t_1$等到下一个关键时刻 $t_2$，这也算是一段“旅程”。这条边的“舒适度”为 0，成本是 $A \times (t_2 - t_1)$（如果 $t_2 < t_1$，需要跨天，时间差是 $t_2 - t_1 + K$）。所以这条边的权值为 $0 - \lambda \times A \times \text{wait_time}$。
    2.  **列车边**：对于一条从 $u$ 到 $v$ 的列车，它在 $s$ 时刻出发，旅行 $t$ 小时。这对应于从超级节点 `(u, s)` 到 `(v, (s+t)%K)` 的一条边。这条边的“舒适度”是 $w$，成本是 $B \times t$。所以这条边的权值为 $w - \lambda \times B \times t$。

### 使用 SPFA 寻找最长路

建好这个超级图之后，我们的问题就变成了在这个图上寻找最长路！因为图中可能存在正权边，所以不能用 Dijkstra。SPFA (或者 Bellman-Ford) 是我们的好伙伴！

我们从所有乘客的初始状态 `(start_city, 0)` 出发（因为他们都是0时刻出发），计算到所有其他节点的最长路。

**特别注意：正权环！**
在最长路问题中，如果图里存在一个从起点可达，且可以到达终点的正权环，那我们就可以在这个环上不停地绕圈圈，刷出无限大的路径长度！
对于我们的 `check(λ) 问题，这意味着 Comfort - λ * Cost 可以无限大。这说明我们给定的 $\lambda$ 太小了，肯定可以找到一个比它更好的比值。所以，一旦 SPFA 检测到正权环，check(λ) 就可以直接返回 true` 啦。

**SPFA 判定正权环的方法**：如果一个图有 $V$ 个点，任何不含环的最短/最长路最多包含 $V-1$ 条边。如果在进行了 $V-1$ 轮松弛后，在第 $V$ 轮仍然可以松弛某条边，那就说明图中存在正权环。

### 算法流程总结

好啦，把所有部分串起来，我们的完整攻略就出炉了，喵~
1.  **二分答案**：设定答案 `λ` 的左右边界，比如 `[0, 1e9]`，进行二分。
2.  **`check(λ)` 函数**：
    a. **预处理**：用反向BFS/DFS从终点开始，标记所有能到达终点的城市。所有和这些城市无关的列车和乘客都可以被忽略，这是一个很棒的优化！
    b. **建立超级图**：
        i.  对每个能到达终点的城市，收集所有相关的出发和到达时间点作为“关键时刻”。
        ii. 创建超级节点 `(城市, 关键时刻)`。
        iii. 添加“等待边”和“列车边”，其权值为 `Comfort - λ * Cost`。
    c. **运行 SPFA**：
        i.  初始化所有节点的距离为负无穷，所有初始状态 `(start_city, 0)` 的距离为 0。
        ii. 运行 SPFA 算法松弛 $V$ 轮（$V$ 是超级图的节点数）。
        iii. 如果在第 $V$ 轮仍然有更新，说明存在正权环，`check(λ)` 返回 `true`。
    d. **检查结果**：如果 SPFA 正常结束（没有正权环），检查所有终点城市 $N$ 对应的超级节点，如果它们的最长路距离有任何一个大于等于0，说明存在一条净收益不为负的路径，`check(λ)` 返回 `true`。
    e. 否则，返回 `false`。
3.  根据 `check(λ)` 的结果调整二分边界，直到精度足够。
4.  输出最终的答案！

是不是清晰多啦？那么，让我们动手实现吧！

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <iomanip>
#include <tuple>

using namespace std;

const long double INF_LD = 1e18; // 使用一个足够大的数表示无穷

struct Train {
    int u, v, departure_time, travel_time, comfort;
    int id;
};

int N, M, K, T, A, B;
vector<int> initial_cities;
vector<Train> trains;

// Caches for graph construction to avoid re-computation
vector<bool> can_reach_dest;
vector<vector<int>> event_times;
vector<int> node_offsets;
int total_super_nodes = 0;

// Pre-computation to optimize check function
void precompute_reachability_and_events() {
    vector<vector<int>> reversed_adj(N + 1);
    for (const auto& train : trains) {
        reversed_adj[train.v].push_back(train.u);
    }

    can_reach_dest.assign(N + 1, false);
    queue<int> q;

    can_reach_dest[N] = true;
    q.push(N);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : reversed_adj[u]) {
            if (!can_reach_dest[v]) {
                can_reach_dest[v] = true;
                q.push(v);
            }
        }
    }

    event_times.assign(N + 1, vector<int>());
    for (int i = 1; i <= N; ++i) {
        if (can_reach_dest[i]) {
            event_times[i].push_back(0); // Time 0 is always a key event point for starting
        }
    }

    for (const auto& train : trains) {
        if (can_reach_dest[train.u] && can_reach_dest[train.v]) {
            event_times[train.u].push_back(train.departure_time);
            event_times[train.v].push_back((train.departure_time + train.travel_time) % K);
        }
    }

    node_offsets.assign(N + 2, 0);
    total_super_nodes = 0;
    for (int i = 1; i <= N; ++i) {
        if (can_reach_dest[i]) {
            sort(event_times[i].begin(), event_times[i].end());
            event_times[i].erase(unique(event_times[i].begin(), event_times[i].end()), event_times[i].end());
        }
        node_offsets[i + 1] = node_offsets[i] + event_times[i].size();
    }
    total_super_nodes = node_offsets[N + 1];
}

bool check(long double lambda) {
    if (total_super_nodes == 0) return false;

    vector<long double> dist(total_super_nodes, -INF_LD);
    vector<bool> in_queue(total_super_nodes, false);
    vector<int> update_count(total_super_nodes, 0);
    queue<int> q;

    // Initialize distances for starting passengers
    for (int start_city : initial_cities) {
        if (!can_reach_dest[start_city]) continue;
        // Find the node for (start_city, time 0)
        auto it = lower_bound(event_times[start_city].begin(), event_times[start_city].end(), 0);
        int time_idx = distance(event_times[start_city].begin(), it);
        int start_node_id = node_offsets[start_city] + time_idx;
        
        if (dist[start_node_id] < 0) {
            dist[start_node_id] = 0;
            q.push(start_node_id);
            in_queue[start_node_id] = true;
        }
    }

    while (!q.empty()) {
        int u_id = q.front();
        q.pop();
        in_queue[u_id] = false;

        update_count[u_id]++;
        if (update_count[u_id] > total_super_nodes) {
            return true; // Positive cycle detected!
        }

        // Find which city and time_idx this u_id corresponds to
        int city = upper_bound(node_offsets.begin(), node_offsets.end(), u_id) - node_offsets.begin() - 1;
        int time_idx = u_id - node_offsets[city];
        int current_time = event_times[city][time_idx];

        // 1. Relax waiting edges
        if (!event_times[city].empty()) {
            int next_time_idx = (time_idx + 1) % event_times[city].size();
            int next_time = event_times[city][next_time_idx];
            int wait_duration = (next_time - current_time + K) % K;
            long double edge_weight = -lambda * A * wait_duration;
            
            int v_id = node_offsets[city] + next_time_idx;
            if (dist[v_id] < dist[u_id] + edge_weight) {
                dist[v_id] = dist[u_id] + edge_weight;
                if (!in_queue[v_id]) {
                    q.push(v_id);
                    in_queue[v_id] = true;
                }
            }
        }
        
        // 2. Relax train edges that depart from this city
        for (const auto& train : trains) {
            if (train.u == city && train.departure_time == current_time) {
                if (!can_reach_dest[train.v]) continue;

                int arrival_time = (train.departure_time + train.travel_time) % K;
                long double edge_weight = (long double)train.comfort - lambda * B * train.travel_time;

                auto it = lower_bound(event_times[train.v].begin(), event_times[train.v].end(), arrival_time);
                int arrival_time_idx = distance(event_times[train.v].begin(), it);
                int v_id = node_offsets[train.v] + arrival_time_idx;

                if (dist[v_id] < dist[u_id] + edge_weight) {
                    dist[v_id] = dist[u_id] + edge_weight;
                    if (!in_queue[v_id]) {
                        q.push(v_id);
                        in_queue[v_id] = true;
                    }
                }
            }
        }
    }
    
    // Check if any path to the destination has non-negative value
    for (size_t i = 0; i < event_times[N].size(); ++i) {
        if (dist[node_offsets[N] + i] >= 0) {
            return true;
        }
    }

    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> M >> K >> T >> A >> B;

    initial_cities.resize(T);
    for (int i = 0; i < T; ++i) {
        cin >> initial_cities[i];
    }

    trains.resize(M);
    for (int i = 0; i < M; ++i) {
        trains[i].id = i;
        cin >> trains[i].u >> trains[i].v >> trains[i].departure_time >> trains[i].travel_time >> trains[i].comfort;
    }
    
    precompute_reachability_and_events();

    long double low = 0, high = 2e9; // A sufficiently large upper bound
    for(int i = 0; i < 100; ++i) { // Binary search for 100 iterations for high precision
        long double mid = low + (high - low) / 2;
        if (check(mid)) {
            low = mid;
        } else {
            high = mid;
        }
    }

    cout << fixed << setprecision(12) << low << endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(\log(\text{Precision}) \times V' \times E')$
    - 我们的二分答案需要进行约 100 次迭代，这是一个常数。
    - 在 `check` 函数中，我们主要的时间开销是 SPFA。
    - 超级图的节点数 $V'$ 是所有城市关键时刻的总和。每个城市最多有 $O(M)$ 个关键时刻，但总和是 $\sum \text{deg}(u) \le 2M$。所以 $V' = O(M)$。
    - 超级图的边数 $E'$ 包括等待边和列车边。等待边数量等于节点数 $V'$，列车边数量是 $M$。所以 $E' = O(M)$。
    - SPFA 在最坏情况下的复杂度是 $O(V' \times E')$，也就是 $O(M^2)$。
    - 因此，总时间复杂度是 $O(\log(\text{Precision}) \times M^2)$。对于 $M=4000$ 来说，这是可以通过的。

- **空间复杂度**: $O(N+M)$
    - 存储原始的图信息需要 $O(N+M)$。
    - 预计算的可达性 `can_reach_dest` 需要 $O(N)$。
    - 关键时刻 `event_times` 和超级节点偏移量 `node_offsets` 总共需要 $O(M)$ 的空间。
    - SPFA 中的 `dist` 数组、队列等辅助空间也都是 $O(V') = O(M)$。
    - 所以总的空间复杂度是 $O(N+M)$。

## 知识点总结

这道题是多种算法思想的美妙结合，喵~
1.  **0-1分数规划**: 解决形如 $\max \frac{\sum A_i}{\sum B_i}$ 问题的经典模型，通常用二分答案转化为判定性问题。
2.  **二分答案**: 将最优化问题转化为判定性问题 `check(x)` 的强大工具。
3.  **图论建模**: 问题的核心在于如何将一个复杂、带时间约束的场景抽象成一个图论模型。这里的关键是认识到状态不仅是位置，还包括时间。
4.  **状态空间离散化**: 当状态空间（如此处的时刻）太大时，可以只保留关键的状态点，从而大大减小图的规模。
5.  **SPFA 算法**: 用于在带正权边的图中求解单源最长路（或带负权边的最短路），并且能够有效地检测出正权环（或负权环）。
6.  **差分约束思想**: `check(λ)` 的过程本质上是在解一个差分约束系统，每条边的松弛操作 `dist[v] = dist[u] + weight` 都可以看作一个约束条件。

希望这篇题解能帮助你理解这道有趣的题目，喵~ 如果你还有其他问题，随时可以来问我哦！