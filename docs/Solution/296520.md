# 在歪歪星球的旅行 - 题解

### 比赛与标签
> **比赛**: (喵~ 题目信息里没有提供比赛名称呢)

> **标签**: 0/1分数规划, SPFA, 最长路, 二分

> **难度**: *2700

## 题目大意喵~

哈喵~ 各位旅行家！欢迎来到歪歪星球，这里的一天有 $h$ 个小时哦。

在这个星球上，有 $n$ 座城市和 $m$ 条单向的列车线路。每条线路都由 `(u, v, t1, t2, val)` 描述，意思是：
*   每天的 $t_1$ 时刻，有一班车从城市 $u$ 出发。
*   经过 $t_2$ 小时的旅行，列车会到达城市 $v$。
*   乘坐这趟车可以获得 `val` 的舒适度。

我们的小伙伴们非常耐心，可以在任何一座城市里等上任意长的时间，哪怕是好几天，只为搭上心仪的列车，喵~

现在，有 $k$ 位旅行者，他们各自从不同的城市 $s_i$ 出发，共同的目标是终点城市 $n$。对于一段旅程，我们需要计算两个值：
1.  **等待时间**: 在每个中转站等待下一班列车的总时间。
2.  **乘车时间**: 乘坐列车在路上的总时间。

旅途的总成本是 `等待时间 * a + 乘车时间 * b`。

我们的任务是，为这些旅行者规划路线，可以只选择一部分人去完成旅行，但必须保证**至少有一人**成功到达终点 $n$。在满足这个前提下，我们要最大化一个神奇的比值：

$$
\frac{\sum \text{（所有成功到达乘客的总舒适度）}}{\sum \text{（所有成功到达乘客的总时间成本）}}
$$

请你算出这个最大的比值是多少吧，拜托啦~！

## 解题思路分析

这道题看起来好复杂呀，又是时间又是舒适度，还要最大化一个分数，真是让人头大呢，喵~ 不过别怕，跟着我的猫爪印一步步来，我们就能解开它的秘密！

### 核心思想：0/1 分数规划

首先，我们要最大化的目标是一个分数形式：$\frac{\sum C}{\sum D}$，其中 $C$ 是总舒适度， $D$ 是总成本。这种问题有一个非常经典的名字，叫做 **0/1 分数规划**。

我们可以二分这个最终答案，也就是那个最大的比值。我们假设这个最大比值是 $\lambda$。
那么，对于一个我们猜的答案 $\lambda_{guess}$，我们需要判断是否存在一种旅行方案，使得：
$$
\frac{\sum C}{\sum D} \ge \lambda_{guess}
$$
这个式子可以变形一下：
$$
\sum C \ge \lambda_{guess} \cdot \sum D
$$
$$
\sum C - \lambda_{guess} \cdot \sum D \ge 0
$$
$$
\sum (C - \lambda_{guess} \cdot D) \ge 0
$$
这个式子告诉我们，对于每一段旅程，我们可以赋予它一个新的“价值”，这个价值就是 `舒适度 - λ * 成本`。我们的目标就变成了：**是否存在一种方案，使得所有成功旅客的新价值之和大于等于 0？**

为了让总的新价值最大，我们应该让每个想去终点的旅客，都走一条从他的起点 $s_i$ 到终点 $n$ 的、新价值最大的路径。如果这条路径的最大新价值是正的，我们就让他去旅行，并把这个正价值加入总和；如果是负的，那就不划算了，让他待在原地就好啦，喵~

所以，我们的 `check(\lambda)` 函数就变成了：
1.  对于每一个旅客，计算出他从起点到终点的“新价值”最大的路径。
2.  把所有算出来的正的最大新价值加起来。
3.  如果总和大于 0，说明我们猜的 $\lambda$ 是可能达到的（甚至可能还有提升空间），我们可以尝试更大的 $\lambda$。
4.  如果总和小于等于 0，说明我们猜的 $\lambda$ 太大了，需要减小一点。

这样，我们就可以通过二分法来逼近最终的答案 $\lambda$ 啦！

### 关键挑战：寻找新价值最大的路径

现在问题转化成了：对于一个固定的 $\lambda$，如何找到一条从起点 $s$ 到终点 $n$ 的路径，使得 $\sum(\text{val} - \lambda \cdot \text{cost})$ 最大？

这是一个最长路问题！我们把每段旅程的 `val - λ * cost` 当作边权，然后找最长路。

一段旅程的成本是 `a * 等待时间 + b * 乘车时间`。
所以一条边的“新价值”就是 `val - λ * (a * wait + b * travel)`。

麻烦的是，`等待时间` 依赖于我们到达一个站点的时刻，这让边权变得不固定，传统的 Dijkstra 或 SPFA 没法直接用在城市图上。

### 巧妙的建图与状态定义

为了解决动态边权的问题，我们需要更聪明的状态定义。直接对 `(城市, 时间)` 建图状态太多了，会超时的说。

让我们来施展一个魔法，对路径的价值公式进行变形！
一条完整的路径由若干段列车旅程 $e_1, e_2, \dots, e_p$ 组成。
总价值 = $\sum_{i=1}^p (\text{val}_i) - \lambda \cdot (\sum_{i=1}^p (b \cdot t_{2,i}) + a \cdot (\text{wait}_0 + \sum_{i=1}^{p-1} \text{wait}_i))$
其中 `wait_0` 是在起点的等待时间，`wait_i` 是在第 `i` 段旅程和第 `i+1` 段旅程之间的等待时间。

我们知道，`wait_i = t_depart_{i+1} - t_arrive_i`。
`wait_0 = t_depart_1` (因为我们从 0 时刻开始)。

把这个代入，经过一番化简（小猫咪的数学魔法，얍!）可以得到：
总价值 = $\sum_{i=1}^p (\text{val}_i - \lambda b \cdot t_{2,i} - \lambda a \cdot t_{depart,i}) + \sum_{i=1}^{p-1} (\lambda a \cdot t_{arrive,i})$

这个公式太棒了！它把每一段旅程的贡献拆分成了三部分：
1.  只和本段列车属性相关的部分：`val_i - λ*b*t2_i`
2.  只和本段列车出发时间相关的部分：`-λ*a*t_depart,i`
3.  只和上一段列车到达时间相关的部分：`λ*a*t_arrive,i-1`

这启发我们把**列车线路**本身作为图的节点！
我们定义 `dp[i]` 为：从某个起点出发，最后乘坐第 `i` 号列车结束的一条路径，所能获得的最大“价值”。

假设我们现在要计算 `dp[i]`，第 `i` 号列车从 `u` 开往 `v`。它之前的一段路程是乘坐第 `j` 号列车，到达了城市 `u`。
那么 `dp[i]` 就可以从 `dp[j]` 转移过来！
`dp[i] = dp[j] + (新价值贡献)`
`dp[i] = max_{所有能到达u的列车j} (dp[j] + val_i - \lambda \cdot \text{cost}_{j \to i})`

根据我们推导的公式，`dp[i]` 的更新规则可以写成：
`dp[i] = max(dp[i], (val_i - λ*b*t2_i - λ*a*t_depart,i) + (dp[j] + λ*a*t_arrive,j))`

这个形式非常适合用 Bellman-Ford 或 SPFA 算法来求解。
*   **状态**: `dp[i]` 表示以乘坐第 `i` 趟列车结束的路径的最大价值。
*   **节点**: $m$ 条列车线路。
*   **转移**: 从一条线路 `j` 到下一条线路 `i`。
*   **初始化**: 对于从起点 `s` 出发的第一趟车 `i`，`dp[i]` 的初始值就是 `val_i - λ*b*t2_i - λ*a*t_depart,i`。

### 算法实现细节

1.  **预处理**：首先，从终点 `n` 开始在反向图上做一次 BFS/DFS，标记所有能够到达终点 `n` 的城市。不在这些城市出发或到达的线路都是无用的，可以无视，喵~
2.  **处理跨天等待**：乘客可以等任意天。如果我到达时间是 `t_arrive`，车是 `t_depart` 开，如果 `t_arrive > t_depart`，我就得等到第二天的 `t_depart`。这相当于等待了 `t_depart + h - t_arrive` 小时。
    我们可以把每条线路 `(u,v,t1,t2,val)` 的出发时间看作有两个：`t1` 和 `t1+h`。这样就能优雅地处理跨天等待了。
3.  **高效转移**: 在 `check(\lambda)` 中，对每个城市 `u`，我们需要找到所有到达 `u` 的列车 `j` 中，`dp[j] + λ*a*t_arrive,j` 的最大值，来更新从 `u` 出发的所有列车 `i`。
    我们可以把所有到达 `u` 的列车按到达时间排序，把所有从 `u` 出发的列车按出发时间排序。然后用类似双指针的方法，对于每个出发的列车 `i`，我们只考虑那些在它出发前到达的列车 `j`，并维护一个 `dp[j] + λ*a*t_arrive,j` 的前缀最大值。这样一次松弛操作的复杂度就很低啦。
4.  **SPFA/Bellman-Ford**: 我们用 Bellman-Ford 的思想进行松弛。整个松弛过程迭代 `n` (或 `m`) 轮。如果 `n` 轮之后还能松弛，说明图中有正环！
5.  **正环处理**: 出现正环意味着我们可以通过在环里不停地转圈来获得无限大的新价值。只要这个环能从某个起点到达，并且能到达终点，那么 `check(\lambda)` 就应该返回 `true`。
6.  **最终检查**: 松弛结束后，我们检查所有终点为 `n` 的列车 `i`，如果它们的 `dp[i]` 有任何一个大于 0，说明存在一条正价值的路径，`check(\lambda)` 返回 `true`。

好啦，思路就是这样！结合二分和这个基于 SPFA 思想的最长路解法，我们就能找到答案啦！

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦~ 加满了注释，希望能帮助你理解！

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>
#include <queue>

using namespace std;

const long double INF = 1e18; // 使用 long double 保证精度
const long double EPS = 1e-9;   // 浮点数比较的精度

int N, M, K, H; // 城市数, 线路数, 旅客数, 每天小时数
double A, B;    // 等待和乘车代价系数

struct TrainRoute {
    int id;
    int from, to;
    int depart_time, travel_time, arrival_time;
    int comfort;
};

vector<TrainRoute> routes;
vector<bool> is_start_node;
vector<bool> can_reach_dest;

// check(lambda) 函数：判断是否存在一种方案使得总价值 > 0
bool check(double lambda) {
    // dp[i] 表示以乘坐第 i 趟车结束的路径的最大价值
    vector<long double> dp(M, -INF);

    // h1[u] = { {depart_time, route_id}, ... }
    // h2[u] = { {arrival_time, route_id}, ... }
    vector<vector<pair<int, int>>> h1(N + 1), h2(N + 1);

    for (const auto& route : routes) {
        if (!can_reach_dest[route.from]) continue;
        // 处理跨天，增加 t1+H 的出发时间
        h1[route.from].push_back({route.depart_time, route.id});
        h1[route.from].push_back({route.depart_time + H, route.id});
        h2[route.to].push_back({route.arrival_time, route.id});
    }

    for (int i = 1; i <= N; ++i) {
        sort(h1[i].begin(), h1[i].end());
        sort(h2[i].begin(), h2[i].end());
    }

    // 初始化：从起点出发的第一趟车
    for (int i = 1; i <= N; ++i) {
        if (is_start_node[i]) {
            for (auto const& [dep_time, route_id] : h1[i]) {
                const auto& route = routes[route_id];
                long double value = (long double)route.comfort 
                                  - lambda * (B * route.travel_time + A * dep_time);
                if (value > dp[route_id]) {
                    dp[route_id] = value;
                }
            }
        }
    }

    // Bellman-Ford 松弛过程
    // 迭代 N 次足够覆盖所有无环最长路
    for (int iter = 0; iter < N; ++iter) {
        for (int u = 1; u <= N; ++u) {
            if (h1[u].empty() || h2[u].empty()) continue;

            long double max_prev_val = -INF;
            auto it_h2 = h2[u].begin();

            // 对每个从 u 出发的车，找到最优的前驱列车
            for (auto const& [dep_time, dep_route_id] : h1[u]) {
                // 更新前驱最大值：所有在 dep_time 之前到达的车
                while (it_h2 != h2[u].end() && it_h2->first <= dep_time) {
                    int prev_route_id = it_h2->second;
                    if (dp[prev_route_id] > -INF + 1) {
                        long double prev_path_val = dp[prev_route_id] + lambda * A * it_h2->first;
                        if (prev_path_val > max_prev_val) {
                            max_prev_val = prev_path_val;
                        }
                    }
                    ++it_h2;
                }

                // 如果存在合法的前驱路径
                if (max_prev_val > -INF + 1) {
                    const auto& current_route = routes[dep_route_id];
                    long double new_val = max_prev_val + (long double)current_route.comfort 
                                        - lambda * (B * current_route.travel_time + A * dep_time);
                    if (new_val > dp[dep_route_id]) {
                        dp[dep_route_id] = new_val;
                    }
                }
            }
        }
    }

    // 检查是否存在能到达终点 N 的正价值路径
    for (const auto& route : routes) {
        if (route.to == N && dp[route.id] > EPS) {
            return true;
        }
    }
    
    // 检查正环: 再迭代一次，如果还能更新，说明有正环
    // 只要环路可达，就可以刷到无限大价值
    for (int u = 1; u <= N; ++u) {
        if (h1[u].empty() || h2[u].empty()) continue;
        long double max_prev_val = -INF;
        auto it_h2 = h2[u].begin();
        for (auto const& [dep_time, dep_route_id] : h1[u]) {
            while (it_h2 != h2[u].end() && it_h2->first <= dep_time) {
                 int prev_route_id = it_h2->second;
                 if (dp[prev_route_id] > -INF + 1) {
                    long double prev_path_val = dp[prev_route_id] + lambda * A * it_h2->first;
                    if (prev_path_val > max_prev_val) max_prev_val = prev_path_val;
                 }
                 it_h2++;
            }
            if (max_prev_val > -INF + 1) {
                const auto& current_route = routes[dep_route_id];
                long double new_val = max_prev_val + (long double)current_route.comfort 
                                    - lambda * (B * current_route.travel_time + A * dep_time);
                if (new_val > dp[dep_route_id] + EPS) {
                    return true; // 发现正环
                }
            }
        }
    }

    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> M >> K >> H >> A >> B;

    is_start_node.resize(N + 1, false);
    for (int i = 0; i < K; ++i) {
        int s;
        cin >> s;
        is_start_node[s] = true;
    }

    routes.resize(M);
    vector<vector<int>> reverse_adj(N + 1);
    for (int i = 0; i < M; ++i) {
        routes[i].id = i;
        cin >> routes[i].from >> routes[i].to >> routes[i].depart_time >> routes[i].travel_time >> routes[i].comfort;
        routes[i].arrival_time = (routes[i].depart_time + routes[i].travel_time) % H;
        reverse_adj[routes[i].to].push_back(routes[i].from);
    }

    // BFS 预处理，标记所有能到达终点 N 的节点
    can_reach_dest.resize(N + 1, false);
    queue<int> q;
    q.push(N);
    can_reach_dest[N] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : reverse_adj[u]) {
            if (!can_reach_dest[v]) {
                can_reach_dest[v] = true;
                q.push(v);
            }
        }
    }
    
    // 任何一个起点必须能到达终点
    bool possible = false;
    for(int i = 1; i <= N; ++i) {
        if(is_start_node[i] && can_reach_dest[i]) {
            possible = true;
            break;
        }
    }
    if (!possible) {
        cout << fixed << setprecision(12) << 0.0 << endl;
        return 0;
    }


    double low = 0.0, high = 2e9; // 设定一个足够大的上界
    // 二分答案
    for (int i = 0; i < 100; ++i) {
        double mid = low + (high - low) / 2;
        if (check(mid)) {
            low = mid;
        } else {
            high = mid;
        }
    }

    cout << fixed << setprecision(12) << low << endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(\log(\text{Range}) \cdot N \cdot M)$
    我们进行了大约 100 次二分迭代。在每次 `check` 函数中：
    1.  对 `h1`, `h2` 排序，总共需要 $O(M \log M)$。
    2.  SPFA/Bellman-Ford 松弛部分，我们迭代 $N$ 轮。每一轮中，遍历所有城市 `u`，然后对每个从 `u` 出发的列车，我们用一个指针扫过到达 `u` 的列车。对一个固定的城市 `u`，两个指针总共移动的步数是 $O(\text{deg}^+(u) + \text{deg}^-(u))$。所以一轮松弛的总复杂度是 $O(\sum_u (\text{deg}^+(u) + \text{deg}^-(u))) = O(M)$。
    3.  因此，`check` 函数的主体部分复杂度是 $O(N \cdot M)$。
    总时间复杂度就是 $O(\log(\text{Range}) \cdot (M \log M + N \cdot M))$。考虑到 $N, M$ 的范围，这完全可以在时限内跑完，喵~

*   **空间复杂度**: $O(N+M)$
    我们主要存储了图的邻接表、列车信息、`dp` 数组等，这些都需要 $O(N+M)$ 的空间。

## 知识点总结

这真是一道融合了多种算法的精彩题目呀！解开它就像完成了一次有趣的探险，喵~

1.  **0/1 分数规划**: 遇到最大化或最小化一个分式 $\frac{\sum a_i}{\sum b_i}$ 的问题时，要立刻想到二分答案 $\lambda$，然后转化为判断 $\sum(a_i - \lambda b_i)$ 是否能大于/小于 0 的问题。
2.  **图论建模**: 最困难的部分往往是如何把问题抽象成一个图论模型。这道题的巧妙之处在于，没有直接在城市上建图，而是把**列车线路**作为节点，建立了它们之间的连接关系，从而解决了动态边权的问题。
3.  **最长路算法 (SPFA/Bellman-Ford)**: 因为转化后的问题中可能出现正权边（对应原问题中的负边权），所以需要使用能处理这种情况的 SPFA 或 Bellman-Ford 算法。同时，还要能检测出正权环路。
4.  **计算几何/双指针思想**: 在实现松弛过程时，通过对到达和出发时间排序，并用类似双指针/扫描线的思想来高效地找到最优的前驱，是避免暴力 $O(M^2)$ 转移的关键。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以来问我哦！一起加油，成为更厉害的算法大师吧，喵~！