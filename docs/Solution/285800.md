# 小灰灰的幸运石 - 题解

### 比赛与标签
> **比赛**: 计蒜客 2023 夏季挑战赛
> **标签**: 数据结构, 线段树, 扫描线, 离线
> **难度**: *2200

## 喵~来概括一下题目吧！
主人，你好喵~！这道题是关于小灰灰和小蓝在河边捡石子的故事呢~

简单来说，题目是这样的：
河边有 `n` 颗石子，每颗石子都有一个颜色 `c_i`。小蓝有一个幸运数字 `k`。
接下来，小蓝会提出 `m` 个问题。每个问题都是一个区间 `[l, r]`。
对于每个问题，我们需要找出在第 `l` 颗到第 `r` 颗石子这个范围里，所有出现次数**恰好**为 `k` 次的颜色，然后把这些颜色的值（不是种类数哦！）加起来，作为这个问题的答案。

**输入**:
- 第一行是三个整数 `n`, `m`, `k`。
- 第二行是 `n` 个整数，代表从 `1` 到 `n` 的石子的颜色。
- 接下来 `m` 行，每行两个整数 `l` 和 `r`，代表一个查询。

**输出**:
- 对每个查询，输出一个整数，就是我们计算出的颜色值之和。

## 猫娘的思维火花喵~
这道题要求我们处理大量的区间查询，如果对每个查询都傻乎乎地去遍历一遍区间 `[l, r]`，统计每种颜色的出现次数，那时间复杂度会是 O(m * n)，面对 `n` 和 `m` 都是十万级别的数据，肯定会超时超到天上去的，不行不行喵！

这种题目，通常都有一个很棒的魔法——**离线处理**！既然在线一个一个回答太慢了，不如我们把所有问题收集起来，一口气解决掉，呐！

### 换个角度看问题
我们不要再想“对于一个查询 `[l, r]`，答案是多少？”了，而是换个角度：“对于一种特定的颜色 `C`，它会对哪些查询 `[l, r]` 产生贡献呢？”

一种颜色 `C` 要产生贡献，它必须在区间 `[l, r]` 中不多不少，正好出现 `k` 次。

假设颜色 `C` 在整个序列中出现了 `s` 次，位置分别是 `pos_1, pos_2, ..., pos_s`。
为了让它在 `[l, r]` 中恰好出现 `k` 次，这个区间 `[l, r]` 必须完整地包含某连续的 `k` 个 `pos`，比如 `pos_i, pos_{i+1}, ..., pos_{i+k-1}`，同时，还**不能**包含它前一个的 `pos_{i-1}` 和后一个的 `pos_{i+k}`。

这样一来，我们就可以确定查询区间 `[l, r]` 需要满足的条件啦：
1.  左端点 `l` 必须在 `pos_{i-1}` 之后，但在 `pos_i` 或之前。也就是 `pos_{i-1} < l \le pos_i`。
    -   （如果 `i=1`，那么 `l` 只要 `\le pos_1` 就行，所以是 `1 \le l \le pos_1`）。
2.  右端点 `r` 必须在 `pos_{i+k-1}` 或之后，但在 `pos_{i+k}` 之前。也就是 `pos_{i+k-1} \le r < pos_{i+k}`。
    -   （如果 `i+k-1` 已经是最后一个了，那么 `r` 只要 `\ge pos_{i+k-1}` 就行，所以是 `pos_{i+k-1} \le r \le n`）。

### 二维平面与扫描线魔法！
喵~！你看，这不就变成了一个几何问题了嘛？每个查询 `(l, r)` 可以看作是二维平面上的一个点。而我们刚才分析出的条件，比如 `L_{low} \le l \le L_{high}` 和 `R_{low} \le r \le R_{high}`，就定义了一个**矩形区域**！所有落在这个矩形里的查询点 `(l, r)`，它们的答案都要加上这个颜色 `C` 的值！

现在问题就转化成了：平面上有很多带权值的矩形，还有很多查询点，问每个点被哪些矩形覆盖了，权值总和是多少？

这就是经典的“矩形加，单点求值”问题，可以用**扫描线**算法来解决！

我们想象有一条竖直的线，从左到右（`l` 从 1 到 `n`）扫描整个平面。
- 当扫描线遇到一个矩形的左边界 `l = L_{low}` 时，说明对于之后 `l` 在这个矩形内的所有查询，它们的 `r` 如果在 `[R_{low}, R_{high}]` 这个区间内，就应该开始计算这个矩形的权值了。于是，我们对 `r` 轴上的 `[R_{low}, R_{high}]` 区间**加上**这个矩形的权值（也就是颜色值 `C`）。
- 当扫描线扫过这个矩形的右边界，到达 `l = L_{high} + 1` 时，这个矩形的贡献就结束了。所以我们要在 `r` 轴上的 `[R_{low}, R_{high}]` 区间**减去**之前加上的权值。
- 当扫描线扫到一个查询点 `(l, r)` 时，我们只需要查询一下 `r` 轴上 `r` 这个点的累积权值是多少，就是这个查询在当前 `l` 值下所累积到的所有贡献啦！

用来维护 `r` 轴信息的数据结构，需要支持**区间更新**（加上/减去一个值）和**单点查询**。当当当当~ **带懒惰标记的线段树**闪亮登场！它可以完美地胜任这个工作，喵~

### 最终步骤总结
1.  **预处理**：用一个 `map` 或者 `unordered_map` 记录下每种颜色出现的所有位置。
2.  **生成事件**：遍历每一种颜色。对于该颜色的每一个满足条件的连续 `k` 个出现位置，我们生成两个“更新事件”：
    -   一个是在 `L_{low}` 位置，给 `r` 轴的 `[R_{low}, R_{high}]` 区间加上颜色值。
    -   另一个是在 `L_{high} + 1` 位置，给 `r` 轴的 `[R_{low}, R_{high}]` 区间减去颜色值。
3.  **整合事件和查询**：把所有的更新事件和查询（也看作一种事件）都放进一个列表里。
4.  **排序**：按照事件发生的 `l` 坐标（我们称之为 `x`）从小到大排序。如果 `x` 相同，**更新事件要排在查询事件前面**，这样才能保证查询 `(l, r)` 时，所有在 `l` 生效的更新都已经被处理了。
5.  **扫描**：遍历排好序的列表。
    -   遇到更新事件，就在线段树上执行区间更新。
    -   遇到查询事件，就在线段树上对 `r` 坐标进行单点查询，把结果存起来。
6.  **输出**：最后按原始查询顺序输出所有答案。

这样，我们就用聪明的办法解决了这个问题啦，喵~

## 看我把思路变成魔法代码喵！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;

// 事件结构体，用于扫描线。表示在横坐标x处，对纵坐标区间[l, r]产生val的影响
struct Event {
    int x;   // 事件发生的横坐标 (对应查询的 l)
    int l;   // 影响的纵坐标区间的左端点 (对应查询的 r)
    int r;   // 影响的纵坐标区间的右端点 (对应查询的 r)
    int val; // 影响的值 (颜色值)
    Event(int x, int l, int r, int val) : x(x), l(l), r(r), val(val) {}
};

// 查询结构体，也看作一种事件
struct Query {
    int x;   // 查询的横坐标 (l)
    int r;   // 查询的纵坐标 (r)
    int idx; // 原始查询的编号，用于最后按顺序输出答案
    Query(int x, int r, int idx) : x(x), r(r), idx(idx) {}
};

// 带懒惰标记的线段树，支持区间加和单点查询
class SegmentTree {
private:
    vector<long long> sum;  // 区间和
    vector<long long> lazy; // 懒惰标记
    int n;

    // 下推懒惰标记
    void push(int node, int l, int r) {
        if (lazy[node] == 0) return;
        int mid = (l + r) >> 1;
        // 更新左子节点的sum和lazy
        sum[node<<1] += lazy[node] * (mid - l + 1);
        lazy[node<<1] += lazy[node];
        // 更新右子节点的sum和lazy
        sum[node<<1|1] += lazy[node] * (r - mid);
        lazy[node<<1|1] += lazy[node];
        // 清除当前节点的懒惰标记
        lazy[node] = 0;
    }

    // 区间更新 [ul, ur] 加上 val
    void update_range(int node, int l, int r, int ul, int ur, int val) {
        if (ul > r || ur < l) return; // 当前区间与更新区间无交集
        if (ul <= l && r <= ur) { // 当前区间被更新区间完全覆盖
            sum[node] += (long long)val * (r - l + 1);
            lazy[node] += val;
            return;
        }
        push(node, l, r); // 下推标记
        int mid = (l + r) >> 1;
        update_range(node<<1, l, mid, ul, ur, val);
        update_range(node<<1|1, mid+1, r, ul, ur, val);
        sum[node] = sum[node<<1] + sum[node<<1|1]; // 回溯更新
    }

    // 单点查询 pos 的值
    long long query_point(int node, int l, int r, int pos) {
        if (l == r) {
            return sum[node];
        }
        push(node, l, r); // 查询路径上需要下推标记
        int mid = (l + r) >> 1;
        if (pos <= mid) return query_point(node<<1, l, mid, pos);
        else return query_point(node<<1|1, mid+1, r, pos);
    }

public:
    SegmentTree(int _n) : n(_n) {
        sum.resize(4 * n + 10, 0);
        lazy.resize(4 * n + 10, 0);
    }

    void update(int l, int r, int val) {
        if (l > r) return; // 非法区间
        update_range(1, 1, n, l, r, val);
    }

    long long query(int pos) {
        return query_point(1, 1, n, pos);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, k;
    cin >> n >> m >> k;
    vector<int> c(n + 1);
    unordered_map<int, vector<int>> color_pos; // 记录每种颜色出现的位置

    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
        color_pos[c[i]].push_back(i);
    }

    vector<Event> events; // 存放所有更新事件

    // 遍历每种颜色，生成对应的矩形加减事件
    for (const auto& entry : color_pos) {
        int color_val = entry.first;
        const auto& pos = entry.second;
        int m_x = pos.size();
        if (m_x < k) continue; // 出现次数不足k，不可能有贡献

        // 滑动窗口，窗口大小为k
        for (int i = 0; i <= m_x - k; ++i) {
            // 确定矩形的l范围 [L_low, L_high]
            int L_low = (i == 0) ? 1 : (pos[i - 1] + 1);
            int L_high = pos[i];
            
            // 确定矩形的r范围 [R_low, R_high]
            int R_low = pos[i + k - 1];
            int R_high;

            if (i + k < m_x) {
                R_high = pos[i + k] - 1;
            } else {
                R_high = n;
            }

            // 生成矩形加事件和减事件
            events.emplace_back(L_low, R_low, R_high, color_val);
            events.emplace_back(L_high + 1, R_low, R_high, -color_val);
        }
    }

    vector<Query> queries; // 存放所有查询
    for (int i = 0; i < m; ++i) {
        int l, r;
        cin >> l >> r;
        queries.emplace_back(l, r, i);
    }

    // 将更新事件和查询事件统一处理
    vector<tuple<int, bool, int, int, int>> elements;

    for (const auto& e : events) {
        // tuple: {x坐标, 是否是查询(false), l/r, r/idx, val}
        elements.emplace_back(e.x, false, e.l, e.r, e.val);
    }

    for (const auto& q : queries) {
        elements.emplace_back(q.x, true, q.r, q.idx, 0);
    }

    // 排序是扫描线的核心
    sort(elements.begin(), elements.end(), [](const auto& a, const auto& b) {
        if (get<0>(a) != get<0>(b)) return get<0>(a) < get<0>(b); // 按x坐标升序
        return get<1>(a) < get<1>(b); // x相同时，更新事件(false)在前，查询事件(true)在后
    });

    vector<long long> ans(m, 0);
    SegmentTree st(n); // 我们的扫描线数据结构

    // 开始扫描！
    for (const auto& elem : elements) {
        bool is_query = get<1>(elem);
        if (!is_query) { // 是更新事件
            int l = get<2>(elem);
            int r = get<3>(elem);
            int val = get<4>(elem);
            st.update(l, r, val);
        } else { // 是查询事件
            int r = get<2>(elem);
            int idx = get<3>(elem);
            ans[idx] = st.query(r);
        }
    }

    for (long long res : ans) {
        cout << res << '\n';
    }

    return 0;
}
```

## 复杂度分析~
- **时间复杂度**: O((N+M)logN) 的说
    - 我们需要 `O(N)` 的时间来读取颜色并记录它们的位置。
    - 生成事件的数量最多和 `N` 是一个数量级的，因为每个位置最多属于一个颜色的一个特定出现。所以事件总数是 `O(N)`。
    - 查询总数是 `M`。
    - 我们将 `O(N)` 个更新事件和 `O(M)` 个查询事件放在一起排序，排序的时间复杂度是 `O((N+M)log(N+M))`。
    - 之后，我们遍历这个排好序的列表，对每个元素在线段树上进行一次操作（更新或查询），每次操作的复杂度是 `O(logN)`。
    - 所以总的时间复杂度就是排序的复杂度加上扫描的复杂度，主要是 `O((N+M)logN)` 啦。

- **空间复杂度**: O(N+M) 的说
    - `color_pos` 最多存储 `N` 个位置，所以是 `O(N)`。
    - 事件和查询列表加起来的大小是 `O(N+M)`。
    - 线段树需要 `O(N)` 的空间。
    - 答案数组需要 `O(M)` 的空间。
    - 所以总的空间复杂度是 `O(N+M)`。

## 这次又学到了什么新姿势呢？喵~
这道题真是一次精彩的思维探险！我们来总结一下这次冒险中学到的知识点吧：

1.  **核心思想 - 离线处理与扫描线**：这是解决许多复杂区间查询问题的屠龙宝刀！当在线处理棘手时，不妨试试把所有查询收集起来，通过排序等方式优化处理流程。扫描线算法是离线思想的经典应用，它能巧妙地将二维问题降维到一维，从而用更简单的数据结构解决。

2.  **问题转化能力**：本题最最关键的一步，就是将“区间内颜色出现恰好k次”这个抽象的计数条件，转化为二维平面上 `(l, r)` 查询点与一系列矩形区域的关系。这种将问题模型化的能力是成为算法高手的必备技能哦！

3.  **数据结构 - 带懒惰标记的线段树**：线段树是维护区间信息的神器。这道题让我们再次看到了它与懒惰标记结合，在处理“区间更新、单点查询”这类问题时的强大威力。

4.  **实现细节**：
    -   定义矩形边界时要特别小心，尤其是处理序列的开头和结尾部分。
    -   在对事件和查询进行排序时，一定要记住把同一坐标上的更新操作放在查询操作之前，这是保证正确性的关键。
    -   答案可能会很大，记得使用 `long long` 来存储，防止溢出喵。

希望这篇题解能帮到你哦！多练习这类问题，你也会变成算法大师的，喵~！加油！