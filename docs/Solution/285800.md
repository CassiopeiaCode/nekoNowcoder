# 区间内恰好出现k次的颜色值之和 - 题解

### 比赛与标签
> **比赛**: 未提供

> **标签**: 未提供

> **难度**: 未提供

## 题目大意喵~

各位小伙伴们好呀，本猫娘又来带大家解题啦！(ฅ'ω'ฅ)

这道题是说，小灰灰和小蓝在河边发现了一排 $n$ 颗漂亮的石子，每颗石子都有一个颜色 $c_i$。小蓝有一个幸运数字 $k$。她会向小灰灰提出 $m$ 个问题。每个问题都是一个区间 $[l_i, r_i]$，她想知道，在这个区间里的石子中，有哪些颜色的石子**恰好**出现了 $k$ 次？

因为这些颜色可能有很多，所以小灰灰只需要回答这些颜色的**数值之和**就可以啦。我们的任务就是帮粗心的小灰灰计算出每个问题的答案，喵~

简单来说，就是对于每个查询 $[l, r]$，计算 $\sum C$，其中颜色 $C$ 在数组片段 $c[l \dots r]$ 中出现的次数正好为 $k$。

## 解题思路分析

一看到这种区间查询的问题，我们的第一反应可能是暴力求解，对吧？就是对每个查询 $[l, r]$，都跑一遍循环，用一个哈希表或者数组来统计区间内每种颜色的出现次数。统计完之后，再遍历一遍哈希表，把出现次数为 $k$ 的颜色加起来。

这种方法的时间复杂度是 $O(m \cdot n)$。如果 $n$ 和 $m$ 都很大（比如 $10^5$），那肯定会超时超到姥姥家的说！所以，我们得想个更聪明的办法，喵~

注意到所有的查询都是事先给出的，而不是在线一个个回答的。这是一个重要的信号，它在暗示我们：“可以离线处理哦！”。离线处理的意思是，我们可以把所有查询读进来，然后按照某种方便我们计算的顺序来处理它们，最后再把答案按原来的顺序输出。

这道题就是一个非常经典的**扫描线 (Sweep-Line)** 问题！让本猫娘来给你解释一下这是怎么回事吧~

### 将问题转化为二维平面

我们来换个角度思考这个条件：“颜色 $C$ 在区间 $[l, r]$ 中恰好出现 $k$ 次”。

假设颜色 $C$ 在整个石子序列中一共出现了 $s$ 次，位置分别是 $p_1, p_2, \dots, p_s$。
为了让颜色 $C$ 在 $[l, r]$ 中恰好出现 $k$ 次，这个区间 $[l, r]$ 必须完整地包含某连续的 $k$ 个 $C$ 的位置，并且不能包含更多。

比如说，它包含了 $p_i, p_{i+1}, \dots, p_{i+k-1}$ 这 $k$ 个位置。
那么，查询的左端点 $l$ 必须在 $p_{i-1}$ 的右边，并且不能超过 $p_i$，也就是 $p_{i-1} < l \le p_i$。
同时，查询的右端点 $r$ 必须在 $p_{i+k-1}$ 的右边，并且不能超过 $p_{i+k}$，也就是 $p_{i+k-1} \le r < p_{i+k}$。

为了方便处理边界情况，我们可以假想有两个哨兵：$p_0 = 0$ 和 $p_{s+1} = n+1$。
这样，对于从第 $i$ 个出现位置开始的连续 $k$ 个石头（即 $p_i, \dots, p_{i+k-1}$），它会对满足以下条件的查询 $[l, r]$ 产生贡献（贡献值为颜色 $C$）：
$$
p_{i-1} + 1 \le l \le p_i
$$
$$
p_{i+k-1} \le r \le p_{i+k} - 1
$$
是不是有点神奇？我们把一个关于一维数组的计数问题，变成了一个二维平面上的问题！我们可以把每个查询 $(l_i, r_i)$ 看作是 $l-r$ 平面上的一个点。而每一种颜色 $C$ 的每一次满足条件的 $k$ 次出现，都对应着一个矩形区域。所有落在这个矩形区域内的查询点，它们的答案都应该加上 $C$。

我们的问题就变成了：平面上有若干个带权值的矩形，还有若干个查询点，求每个查询点被哪些矩形覆盖，并计算权值之和。

### 用扫描线解决二维问题

直接处理二维问题还是有点复杂，但我们可以用扫描线把它“拍扁”成一维问题来解决，喵~

想象有一条垂直的线（扫描线）从左到右（即 $l$ 从 1 到 $n$）扫过这个 $l-r$ 平面。当这条扫描线移动时，我们只关心在扫描线经过的 $l$ 坐标上发生了什么事件。

有哪些事件呢？
1.  **矩形进入事件**：扫描线到达一个矩形的左边界 $l_{start} = p_{i-1} + 1$。这意味着，对于当前及以后所有 $l \ge l_{start}$ 的查询，如果它们的 $r$ 坐标在矩形的 $r$ 范围 $[r_{start}, r_{end}]$ 内，就需要开始计算这个矩形的贡献了。
2.  **矩形离开事件**：扫描线到达一个矩形的右边界的后一个位置 $l_{end} + 1 = p_i + 1$。这意味着，从这个 $l$ 开始的查询，不再受这个矩形的影响了，我们需要撤销它的贡献。
3.  **查询事件**：扫描线到达一个查询的 $l$ 坐标。这时，我们需要查询它对应的 $r$ 坐标上的累计权值总和。

我们可以把这些事件都存起来，按它们的 $l$ 坐标排序。然后按顺序处理事件。
当处理一个“矩形进入”事件时，我们给它对应的 $r$ 坐标区间 $[r_{start}, r_{end}]$ 统一加上权值 $C$。
当处理一个“矩形离开”事件时，我们给对应的 $r$ 坐标区间统一减去权值 $C$。
当处理一个“查询”事件时，我们查询它对应的 $r$ 坐标上的值是多少。

这个“对一个区间进行加/减，并查询单点的值”的操作，是不是很熟悉？对啦！这正是**树状数组（Fenwick Tree）**或**线段树（Segment Tree）**的拿手好戏！

我们可以用一个树状数组来维护 $r$ 坐标轴。
- **区间更新 `[a, b]` 加上 `val`**：在树状数组的 `a` 位置加上 `val`，在 `b+1` 位置减去 `val`。
- **单点查询 `pos`**：计算树状数组在 `pos` 位置的前缀和。

这样，每次事件处理的复杂度就是 $O(\log n)$。总共有 $O(n)$ 个矩形（每个位置最多是一个矩形的左/右边界），产生 $O(n)$ 个更新事件，加上 $m$ 个查询事件。总的复杂度就是 $O((n+m)\log n)$，非常高效，可以通过本题啦！

### 算法步骤总结

1.  **预处理**：用一个 `map` 或 `vector` 数组记录每种颜色出现的所有位置。
2.  **生成更新事件**：遍历每一种颜色。如果它的出现次数 $s \ge k$，就遍历它的所有可能构成“恰好 $k$ 次”的连续段。对于每个连续段，计算出它所影响的查询矩形 $[l_{low}, l_{high}] \times [r_{low}, r_{high}]$，并生成两个更新事件：
    - 在 $l_{low}$ 处，给 $r$ 轴上的 $[r_{low}, r_{high}]$ 加上颜色值。
    - 在 $l_{high}+1$ 处，给 $r$ 轴上的 $[r_{low}, r_{high}]$ 减去颜色值。
3.  **生成查询事件**：把 $m$ 个查询 $(l_i, r_i)$ 也变成事件。
4.  **扫描**：将所有更新事件和查询事件放在一个列表里，按照横坐标（$l$ 值）从小到大排序。如果横坐标相同，更新事件要排在查询事件前面，以保证查询能看到在同一位置的更新。
5.  **计算**：初始化一个大小为 $n$ 的树状数组。遍历排序后的事件列表：
    - 如果是更新事件，就在树状数组上执行相应的区间更新操作。
    - 如果是查询事件，就在树状数组上查询对应 $r$ 坐标的值，并存入答案数组。
6.  **输出**：按原始查询顺序输出答案。

好啦，思路就是这样！是不是感觉清晰多啦？下面就让我们把这个思路变成漂亮的代码吧，喵~

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

// 使用 long long 防止求和时溢出
using ll = long long;

const int MAXN = 100005; // 假设 n 和 m 的最大值

// 树状数组 (Fenwick Tree), 用于维护 r 轴上的值
// 支持区间加和单点查询
vector<ll> bit;
int N_size;

void update_point(int index, ll value) {
    for (; index <= N_size; index += index & -index) {
        bit[index] += value;
    }
}

void update_range(int left, int right, int value) {
    update_point(left, value);
    if (right + 1 <= N_size) {
        update_point(right + 1, -value);
    }
}

ll query_point(int index) {
    ll sum = 0;
    for (; index > 0; index -= index & -index) {
        sum += bit[index];
    }
    return sum;
}

// 定义事件结构体，方便排序和处理
enum EventType { UPDATE, QUERY };
struct Event {
    int x;          // 事件发生的 l 坐标
    int y_or_r;     // 对于更新事件是 r_low, 对于查询事件是 r
    int y_high;     // 对于更新事件是 r_high
    int value;      // 对于更新事件是颜色值 (+C 或 -C)
    int query_idx;  // 对于查询事件是原始查询的索引
    EventType type;

    // 自定义排序规则
    bool operator<(const Event& other) const {
        if (x != other.x) {
            return x < other.x;
        }
        // x 坐标相同时，更新事件优先于查询事件
        return type < other.type;
    }
};

int main() {
    // 加速输入输出，喵~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m, k;
    cin >> n >> m >> k;

    N_size = n; // 初始化树状数组大小
    bit.resize(n + 2, 0);

    vector<int> colors(n + 1);
    map<int, vector<int>> color_positions;
    for (int i = 1; i <= n; ++i) {
        cin >> colors[i];
        color_positions[colors[i]].push_back(i);
    }

    vector<Event> all_events;

    // 1. 生成更新事件
    for (auto const& [color_val, positions] : color_positions) {
        if (positions.size() < k) {
            continue; // 出现次数不够k，不可能有贡献
        }

        // 遍历所有长度为 k 的连续出现子序列
        for (int i = 0; i <= (int)positions.size() - k; ++i) {
            // 这 k 个石子的位置是 positions[i] 到 positions[i+k-1]
            
            // 确定 l 的范围 [l_low, l_high]
            int l_low = (i == 0) ? 1 : positions[i - 1] + 1;
            int l_high = positions[i];

            // 确定 r 的范围 [r_low, r_high]
            int r_low = positions[i + k - 1];
            int r_high = (i + k < positions.size()) ? positions[i + k] - 1 : n;

            if (l_low <= l_high && r_low <= r_high) {
                // 添加 "矩形进入" 事件
                all_events.push_back({l_low, r_low, r_high, color_val, -1, UPDATE});
                // 添加 "矩形离开" 事件
                if (l_high + 1 <= n) {
                    all_events.push_back({l_high + 1, r_low, r_high, -color_val, -1, UPDATE});
                }
            }
        }
    }

    // 2. 生成查询事件
    vector<ll> answers(m);
    for (int i = 0; i < m; ++i) {
        int l, r;
        cin >> l >> r;
        all_events.push_back({l, r, 0, 0, i, QUERY});
    }

    // 3. 排序所有事件
    sort(all_events.begin(), all_events.end());

    // 4. 执行扫描线
    for (const auto& event : all_events) {
        if (event.type == UPDATE) {
            update_range(event.y_or_r, event.y_high, event.value);
        } else { // QUERY
            answers[event.query_idx] = query_point(event.y_or_r);
        }
    }

    // 5. 输出答案
    for (int i = 0; i < m; ++i) {
        cout << answers[i] << "\n";
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O((N+M)\log N)$
    - 我们需要 $O(N)$ 的时间来读取颜色并按颜色分组。
    - 生成更新事件的总数最多是 $2 \times N$（每个位置最多是一个矩形的左边界和右边界），所以是 $O(N)$。
    - 总事件数是 $O(N+M)$。
    - 对所有事件排序需要 $O((N+M)\log(N+M))$ 的时间。
    - 遍历所有事件，每次在树状数组上操作需要 $O(\log N)$ 的时间。总共是 $O((N+M)\log N)$。
    - 所以，总的时间复杂度由排序和扫描线处理主导，为 $O((N+M)\log N)$。

- **空间复杂度**: $O(N+M)$
    - `color_positions` 最多存储 $N$ 个位置，空间为 $O(N)$。
    - `all_events` 列表存储了 $O(N+M)$ 个事件。
    - 树状数组 `bit` 的大小为 $O(N)$。
    - 答案数组 `answers` 的大小为 $O(M)$。
    - 因此，总的空间复杂度是 $O(N+M)$ 的说。

## 知识点总结

这道题真是一道非常好的练习题，它教会了我们如何优雅地处理复杂的区间问题，喵~

1.  **离线处理 (Offline Processing)**：当所有查询都预先知道时，可以不按顺序回答，而是通过重新组织计算顺序来优化算法。这是解决许多高级数据结构问题的关键思想。
2.  **问题转化**：将一个看似棘手的一维区间计数问题，转化为二维平面上的矩形求和问题，是解题的神来之笔！这种思维转换能力在算法竞赛中非常重要。
3.  **扫描线算法 (Sweep-Line Algorithm)**：通过一条线扫过一个维度，将高维问题降维处理。在这里，我们用扫描线处理了 $l$ 轴，将二维问题简化为在 $r$ 轴上的一系列一维动态操作。
4.  **树状数组/线段树**：它们是实现扫描线算法时强大的数据结构工具。本题解中使用了树状数组来高效地实现“区间加，单点查”，代码简洁且效率高。

好啦，今天的小课堂就到这里啦！希望大家都能掌握扫描线这个强大的工具，以后再遇到类似的题目就不用怕啦！我们下次再见，喵~ (挥爪)