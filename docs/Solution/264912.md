# 选秀节目 - 题解

### 比赛与标签
> **比赛**: 未提供

> **标签**: 未提供

> **难度**: 未提供

## 题目大意喵~

一位名叫 Crying 的观众正在看一个有 $n$ 位选手的选秀节目，喵~ 选手们按 $1$ 到 $n$ 的顺序依次登场，并获得一个在 $[90, 100]$ 区间内的、有7位小数的评分。每个人的分数都是独一无二的哦！

节目最终只会选出分数最高的 $6$ 位选手。所以，每当一位新选手表演完毕并获得分数后，我们需要实时更新并展示当前的前六名榜单。

我们的任务是，统计一下总共有多少位选手，在他们出场时成功进入了当时的前六名。并且，对于每一位成功晋级的选手，我们要记录下他们是把哪一位选手“挤”出前六的。如果他们晋级时，前六名还没满员，那自然就没有挤掉任何人啦。

**输入:**
*   第一行是一个整数 $n$，代表选手总数。
*   第二行是 $n$ 个用空格隔开的7位小数字符串，代表每位选手的得分。

**输出:**
*   第一行输出一个整数，表示总共有多少人次成功进入前六名。
*   第二行输出 $n$ 个整数，用空格隔开。第 $i$ 个整数代表第 $i$ 位选手的情况：
    *   如果第 $i$ 位选手没能进入前六，则输出 `0`。
    *   如果第 $i$ 位选手成功进入前六，并且当时前六名还未满员，也输出 `0`。
    *   如果第 $i$ 位选手成功进入前六，并挤掉了另一位选手，则输出被挤掉选手的编号。

## 解题思路分析

喵哈~ 这道题看起来就是要我们实时追踪一个动态的排行榜呢！每来一位新选手，我们就要看看他/她能不能冲进前六名。这让我想起了我追逐毛线球的时候，总有新的毛线球滚过来，我得决定要不要换一个追，嘻嘻~

问题的核心是：我们需要一个数据结构，能帮我们快速地知道当前“前六名”里的**最低分**是多少。这个最低分就像是晋级的“门槛分”一样，呐。

1.  **当新选手登场时...**
    *   如果他/她的分数高于这个“门槛分”，那么恭喜！他/她成功晋级！同时，原来在榜单上垫底（也就是拿到门槛分）的那位选手就要被淘汰啦。
    *   如果他/她的分数等于或低于这个“门槛分”，那就只能遗憾地和前六名说拜拜了。

2.  **什么数据结构最合适呢？**
    我们想要维护一个固定大小（最多6个元素）的集合，并且能以 $O(1)$ 的速度找到其中的最小值。同时，当有新元素替换掉旧的最小值时，这个操作也要尽可能快。

    *   用一个普通的数组或列表，每次替换后都重新排序？可以是可以，但每次排序都要花费 $O(k \log k)$ 的时间（这里 $k=6$），有点慢呢。
    *   一个更好的选择是 **最小堆 (Min-Heap)**！喵~ 最小堆是一种神奇的树状结构，它的堆顶永远是最小的元素。
        *   查看最小值（堆顶）：$O(1)$ 时间。
        *   删除最小值：$O(\log k)$ 时间。
        *   插入新元素：$O(\log k)$ 时间。

    这不就完美契合我们的需求了嘛！我们可以用一个大小为 6 的最小堆来存放当前排名前六的选手信息（分数和编号）。

3.  **算法流程喵~**
    *   我们创建一个最小堆，用来存放 `(分数, 选手编号)` 这样的组合。
    *   我们再创建一个数组 `elimination_log`，大小为 $n$，初始值都为 0，用来记录每个选手淘汰了谁。
    *   然后我们开始遍历从第 1 位到第 $n$ 位的每一位选手：
        *   **如果堆的大小还不到 6**：说明前六名还没满员。这位新选手可以直接晋级！我们把他/她的 `(分数, 编号)` 推入堆中，并且晋级总人数加一。因为没人被淘汰，所以 `elimination_log` 里对应位置记为 0。
        *   **如果堆的大小已经是 6 了**：这时就要看新选手的实力了！我们取出堆顶元素，也就是当前前六名中的最低分 `min_score_in_top6`。
            *   如果新选手的得分 **大于** `min_score_in_top6`，那么他/她就能晋级！此时，堆顶的那位选手就要被淘汰了。我们记下被淘汰选手的编号，更新到 `elimination_log` 中。然后，我们用新选手替换掉堆顶的旧选手（弹出堆顶，再推入新的），并把晋级总人数加一。
            *   如果新选手的得分 **小于或等于** `min_score_in_top6`，那他/她就无法晋级，什么也不用做。

4.  **一个重要的小技巧！**
    题目给的分数是7位小数，直接用浮点数 `double` 或 `float` 进行比较，有时候可能会因为精度问题出错，这可是个小陷阱哦！为了百分百精确，我们可以把小数变成整数来处理。比如分数 `98.1234567`，我们可以把它看作 `981234567`。这样比较起来就万无一失啦！

把这些思路整理一下，就能写出漂亮又高效的代码了，喵~

## 代码实现

这是本猫娘根据上面的思路，精心编写的C++代码哦~ 注释超详细的，希望能帮到你，喵！

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <utility> // for std::pair

// 为了代码更清晰，我们定义一个结构体来存放选手信息
struct Contestant {
    long long score; // 用 long long 存储整数化之后的分数，避免精度问题
    int id;          // 选手编号

    // 自定义比较运算符，让优先队列能正确地比较 Contestant 对象
    // 默认的 priority_queue 是最大堆，我们需要最小堆，所以这里用 >
    bool operator>(const Contestant& other) const {
        return score > other.score;
    }
};

// 将字符串形式的分数转换为 long long 类型的整数
long long parse_score(const std::string& s) {
    long long integer_part = 0;
    long long fractional_part = 0;
    bool after_dot = false;
    for (char c : s) {
        if (c == '.') {
            after_dot = true;
        } else if (!after_dot) {
            integer_part = integer_part * 10 + (c - '0');
        } else {
            fractional_part = fractional_part * 10 + (c - '0');
        }
    }
    return integer_part * 10000000LL + fractional_part;
}

int main() {
    // 加速 C++ 的 I/O，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 使用最小堆来维护前6名的选手
    // std::priority_queue<Type, Container, Compare>
    // 我们用 std::greater 来实现最小堆
    std::priority_queue<Contestant, std::vector<Contestant>, std::greater<Contestant>> top6_heap;

    int promoted_count = 0;
    std::vector<int> elimination_log(n + 1, 0); // 记录每个选手淘汰了谁，编号从1到n

    for (int i = 1; i <= n; ++i) {
        std::string score_str;
        std::cin >> score_str;
        long long current_score = parse_score(score_str);

        if (top6_heap.size() < 6) {
            // Case 1: 前六名还没满，新选手直接晋级
            top6_heap.push({current_score, i});
            promoted_count++;
            // elimination_log[i] 默认为 0，表示没有淘汰任何人
        } else {
            // Case 2: 前六名已满，需要和榜单最低分比较
            Contestant weakest_in_top6 = top6_heap.top();
            if (current_score > weakest_in_top6.score) {
                // 新选手分数更高，成功晋级！
                promoted_count++;
                
                // 记录被淘汰的选手编号
                elimination_log[i] = weakest_in_top6.id;

                // 更新堆：弹出最低分，推入新选手
                top6_heap.pop();
                top6_heap.push({current_score, i});
            }
            // 如果分数不够高，则什么都不发生，这位选手被淘汰
        }
    }

    // 输出结果
    std::cout << promoted_count << "\n";
    for (int i = 1; i <= n; ++i) {
        std::cout << elimination_log[i] << (i == n ? "" : " ");
    }
    std::cout << "\n";

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N \log K)$。
    其中 $N$ 是选手的总数，$K$ 是我们要维护的榜单大小（这里 $K=6$）。对于每一个选手，我们最多进行一次堆的操作（`push` 或 `pop`+`push`），而堆操作的时间复杂度是 $O(\log K)$。因为 $K$ 是一个很小的常数，所以总的时间复杂度近似于线性时间 $O(N)$，非常高效，喵~

*   **空间复杂度**: $O(N)$。
    主要的额外空间开销来自于 `elimination_log` 数组，它的大小和选手总数 $N$ 成正比。我们使用的最小堆 `top6_heap` 最多只存储 $K$ 个元素，所以它的空间是 $O(K)$，也就是 $O(1)$ 的常数空间。所以总的空间复杂度是 $O(N)$。

## 知识点总结

这道题是一个非常经典的 **动态Top-K问题** 的应用，呐。通过这道题，我们可以学到：

1.  **最小堆 (Min-Heap)**: 它是解决 Top-K 问题的神器！当需要频繁地找到并替换一个集合中的最小值（或最大值，用最大堆）时，优先队列（堆的实现）是我们的不二之选。
2.  **问题建模**: 将“晋级门槛”抽象为“Top-K集合中的最小值”，是解题的关键一步。
3.  **精度处理**: 在处理浮点数时，要时刻警惕精度问题。将固定位数的小数转换为整数进行计算，是一种非常安全和常用的技巧。
4.  **C++ STL**: 熟练使用 `std::priority_queue` 可以让代码变得非常简洁。通过自定义比较函数或使用 `std::greater`，可以轻松实现最小堆。

希望这篇题解能帮助你更好地理解这个问题！继续加油，算法的世界还有很多有趣的挑战等着我们去探索，喵~