# 牛牛爱伐木 (easy version) - 题解

### 比赛与标签
> **比赛**: 牛客小白月赛93

> **标签**: 贪心, 排序, 双指针

> **难度**: *1300

## 题目大意喵~

主人你好呀~！这次的任务是去森林里伐木，喵~！

我们有 `n` 棵树和 `m` 把斧头。
- 每棵树 `i` 都有一个坚硬程度 $a_i$。
- 每把斧头 `j 都有一个破坏程度 $b_j$。

一把斧头可以砍倒一棵树，当且仅当斧头的破坏程度 **不小于** 树的坚硬程度（也就是 $b_j \ge a_i$）。但是，可露希尔发明的这些“无敌手斧”很脆弱，每把斧头只能用一次，砍完一棵树就坏掉了，喵呜~

我们的目标是，用这 m` 把斧头，尽可能多地砍倒树木。请问最多能砍倒多少棵呢？

**输入:**
- 第一行是两个整数 `n` 和 `m`，代表树和斧头的数量。
- 第二行是 `n` 个整数，代表每棵树的坚硬程度 `a_i`。
- 第三行是 `m` 个整数，代表每把斧头的破坏程度 `b_j`。

**输出:**
- 一个整数，表示最多能砍倒的树木数量。

## 解题思路分析

这道题的目标是最大化我们能砍的树的数量，这是一个典型的最优化问题，我们可以尝试用贪心的思想来解决，喵~

**核心问题**：我们应该如何配对斧头和树，才能保证砍的数量最多呢？

想象一下，我们面前有一堆不同硬度的树，和一堆不同破坏力的斧头。

一个很自然的想法是：为了尽可能地省下我们那些强力的斧头去对付更坚硬的树，我们对于比较“软”的树，应该尽可能用“刚刚好”能砍动它的、最弱的斧头。如果用一把能开山裂石的超强斧头去砍一棵小树苗，那也太浪费了呀，对不对？这把强力斧头本可以去挑战更难对付的大树的！

基于这个“勤俭持家”的贪心策略，我们的思路就清晰起来啦：

1.  **排序是关键的第一步！**
    为了方便我们总是能拿到“最弱”的树和“最弱”的斧头，我们应该先把它们都排个序。
    - 将所有树按照坚硬程度从小到大排序。
    - 将所有斧头按照破坏程度从小到大排序。

2.  **双指针来帮忙匹配！**
    排好序之后，我们就可以开始愉快地配对啦。我们可以用两个指针，一个指向当前最“软”的树（记为 `tree_ptr`），另一个指向当前最“弱”的斧头（记为 `axe_ptr`）。

    我们从最软的树开始，尝试为它寻找一把合适的斧头：
    - 我们拿出当前最弱的斧头 `axes[axe_ptr]`，去和当前最软的树 `trees[tree_ptr] 比较一下。
    - **情况一：斧头够给力！** ($axe\_damage \ge tree\_hardness$)
      太棒了！这把斧头可以砍倒这棵树！因为我们是从最弱的斧头开始找的，所以这把 axes[axe_ptr]` 就是能砍倒 `trees[tree_ptr]` 的所有可用斧头里最弱的一把。这个选择非常经济，不会浪费~ 于是我们成功砍倒一棵树，计数器加一。然后这棵树和这把斧头都“功成身退”了，我们把两个指针都向后移动一位 (`tree_ptr++`, `axe_ptr++)，去考虑下一棵树和下一把斧头。

    - **情况二：斧头太弱了...** ($axe\_damage < tree\_hardness$)
      喵呜... 这把斧头 axes[axe_ptr]` 连当前最软的树都砍不动。因为我们已经把树按硬度排好序了，所以这把斧头肯定也砍不动后面那些更硬的树。所以，这把可怜的斧头对我们剩下的任务来说是没用的了，我们只能放弃它，挪动斧头指针 `axe_ptr++`，去试试下一把更强的斧头，但我们仍然需要为当前这棵树 `trees[tree_ptr]` 寻找斧头（所以 `tree_ptr` 不动）。

3.  **循环结束**
    我们不断重复上面的过程，直到我们的树指针越界（所有树都考虑完了）或者斧头指针越界（所有斧头都试过了）。这时，我们得到的计数就是能砍倒的最大树木数量啦！

举个栗子，喵~
- 树的硬度 `a = [10, 20, 8]`
- 斧头破坏力 `b = [12, 7, 25]`

**步骤:**
1.  排序：
    - `a` -> `[8, 10, 20]`
    - `b` -> `[7, 12, 25]`
2.  双指针匹配：
    - `tree_ptr = 0` (树 `8`), `axe_ptr = 0` (斧头 `7`)
      - `7 < 8`，斧头太弱，砍不动。`axe_ptr` 移动到 `1`。
    - `tree_ptr = 0` (树 `8`), `axe_ptr = 1` (斧头 `12`)
      - `12 >= 8`，成功！砍倒一棵树。`count = 1`。`tree_ptr` 移动到 `1`，`axe_ptr` 移动到 `2`。
    - `tree_ptr = 1` (树 `10`), `axe_ptr = 2` (斧头 `25`)
      - `25 >= 10`，成功！又砍倒一棵树。`count = 2`。`tree_ptr` 移动到 `2`，`axe_ptr` 移动到 `3`。
    - `tree_ptr = 2` (树 `20`), `axe_ptr = 3` (斧头指针越界了！)
      - 没有斧头了，循环结束。

最终，我们最多能砍 `2` 棵树。这个方法是不是很清晰呢，的说！

## 代码实现

这是本猫娘根据上面的思路，精心编写的 C++ 代码哦~ 变量名都很好懂，还加了详细的注释，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 使用 C++ 的一些好习惯，让程序跑得快一点，喵~
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    fast_io();

    int n, m;
    std::cin >> n >> m;

    // 用 vector 来存储树的硬度和斧头的破坏力
    std::vector<int> tree_hardness(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> tree_hardness[i];
    }

    std::vector<int> axe_damage(m);
    for (int i = 0; i < m; ++i) {
        std::cin >> axe_damage[i];
    }

    // 第一步：将树和斧头都按从小到大的顺序排序
    std::sort(tree_hardness.begin(), tree_hardness.end());
    std::sort(axe_damage.begin(), axe_damage.end());

    int cut_count = 0; // 记录成功砍倒的树木数量
    int tree_idx = 0;  // 指向当前要砍的树
    int axe_idx = 0;   // 指向当前要用的斧头

    // 第二步：双指针遍历，进行贪心匹配
    while (tree_idx < n && axe_idx < m) {
        // 如果当前最弱的斧头可以砍倒当前最软的树
        if (axe_damage[axe_idx] >= tree_hardness[tree_idx]) {
            // 成功匹配！
            cut_count++;      // 砍倒的树+1
            tree_idx++;       // 考虑下一棵树
            axe_idx++;        // 这把斧头用掉了，考虑下一把
        } else {
            // 这把斧头太弱了，砍不动当前的树
            // 它也肯定砍不动后面更硬的树，所以只能放弃它
            axe_idx++;        // 试试下一把更强的斧头
        }
    }

    std::cout << cut_count << std::endl;

    return 0;
}
``

## 复杂度分析

- **时间复杂度**: $O(N \log N + M \log M)$
  - 我们需要对树的硬度数组进行排序，时间复杂度是 $O(N \log N)$。
  - 我们还需要对斧头的破坏力数组进行排序，时间复杂度是 $O(M \log M)$。
  - 之后的双指针遍历过程，两个指针最多各自移动 n` 和 `m 次，所以这部分的时间复杂度是 $O(N+M)$。
  - 总的时间复杂度由排序决定，所以是 $O(N \log N + M \log M)$，喵~

- **空间复杂度**: $O(N + M)$
  - 我们需要两个 vector` 来分别存储 `n` 棵树的硬度和 `m` 把斧头的破坏力，所以占用的空间是 $O(N+M)$。如果是在函数中处理并且输入数组不能修改，也需要这么大的空间来创建副本。

## 知识点总结

这道题是一个很好的贪心算法入门练习，它教会了我们：

1.  **贪心思想**: 面对一个最优化问题时，可以尝试寻找一个局部最优策略，并希望这个策略能导向全局最优解。本题的贪心策略是“用最弱的可用斧头去砍最弱的树”。
2.  **排序**: 排序是实现很多贪心策略的预处理步骤。通过排序，我们可以将问题转化为一个有序的、更容易处理的结构。
3.  **双指针**: 双指针是一种非常高效的算法技巧，常用于处理已排序的数组。它通过维护两个（或多个）指针，以线性时间复杂度完成需要嵌套循环才能解决的问题，大大提高了效率！

希望这篇题解能帮助到你哦！如果还有不明白的地方，随时可以再来问我，喵~ >w<