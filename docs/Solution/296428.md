# 给定一个由 n 个整数组成的数组 {a₁, a₂, …, aₙ} - 题解

### 比赛与标签
> **比赛**: 喵~ 这道题的比赛信息好像被小猫咪藏起来了呢，找不到了喵~

> **标签**: `位运算`, `贪心`, `构造

> **难度**: *1700

## 题目大意喵~

主人你好呀，这道题是说，我们有一个装满整数的数组 $a$，可以对里面的任何一个数 $a_i$ 进行一种神奇的魔法操作，而且次数不限哦！

这个魔法分为四步，喵：
1.  首先，选中一个数字 $a_i$。
2.  然后，把它想象成二进制的样子，比如 $a_i = (\dots c_2c_1c_0)_2$。
3.  接着，选一个比特位的位置 $k$ (从 1 到 60)。
4.  最后，施展魔法！把第 $k$ 位的值 $c_k$ 变成它前一位 $c_{k-1}$ 的值，也就是 $c_k \leftarrow c_{k-1}$。

我们的目标是通过任意次这样的魔法，让整个数组里所有数字的异或和（$a_1 \oplus a_2 \oplus \dots \oplus a_n$）变得最大！最后要把这个最大的异或和告诉人家，喵~

举个例子，如果有个数字是 $5$，它的二进制是 $(101)_2$。它的第 $0$ 位是 $1$，第 $1$ 位是 $0$，第 $2$ 位是 $1$。
如果我们选择 $k=1$，就可以把第 $1$ 位的值变成第 $0$ 位的值，也就是 $c_1 \leftarrow c_0$。这样 $c_1$ 就从 $0$ 变成了 $1$，数字 $5$ 就变成了 $(111)_2 = 7$ 啦！

## 解题思路分析

这道题的目标是最大化异或和，一看到“最大化异或和”，我们聪明的猫娘脑海里就应该闪过一个词——**贪心**！喵~

通常处理这类问题，我们都是从最高位开始，一位一位地决定最终答案的这一位应该是 $1$ 还是 $0$。为了让结果最大，我们当然希望尽可能让高位的比特是 $1$ 啦！

#### 魔法操作的本质喵

我们先来研究一下这个神奇的魔法 $c_k \leftarrow c_{k-1}$。
这个操作意味着，我们可以把一个比特位的值“复制”到它的下一个更高位。
比如，我们可以让 $c_1 \leftarrow c_0$，然后再对新的数操作，让 $c_2 \leftarrow c_1$。因为此时的 $c_1$ 已经变成了 $c_0$ 的值，所以这就相当于我们让 $c_2$ 也变成了 $c_0$ 的值！

顺着这个思路，我们可以发现：对于任何一个数字 $a_i$ 和它的任意一个比特位 $c_k$（只要 $k \ge 1$），我们都可以通过一系列操作，把它变成**原始**的 $a_i$ 中任意一个更低位 $c_j$（$j < k$）的值。

这就带来了一个非常重要的性质：对于数字 $a_i$ 的第 $k$ 位，我们能不能随意地把它变成 $0$ 或者 $1$ 呢？
答案是：**取决于它更低的比特位（$0$ 到 $k-1$位）里，是不是既有 $0$ 又有 $1$**。
*   如果 $a_i$ 的低位里既有 $0$ 又有 $1$，那我们就可以把第 $k$ 位变成 $0$（找一个值为 $0$ 的低位传上来），也可以把它变成 $1$（找一个值为 $1$ 的低位传上来）。这样的数字在第 $k$ 位上是“灵活”的！
*   如果 $a_i$ 的低位里只有 $0$，那我们只能把第 $k$ 位变成 $0$。
*   如果 $a_i$ 的低位里只有 $1$，那我们只能把第 $k$ 位变成 $1$。

#### 寻找“关键转折点”

现在我们知道了，一个数字的“灵活性”取决于它的低位。这启发我们从低位到高位来分析问题。

让我们来寻找一个“关键位” $k_0$。这个 $k_0$ 是**最小**的一个比特位，使得**至少存在一个数** $a_j$，它的比特位 $0$ 到 $k_0$ 不再是单调的（即同时包含了 $0$ 和 $1$）。

为什么这个 $k_0$ 很关键呢？

1.  **对于所有低于 $k_0$ 的位 i < k_0：**
    根据 $k_0$ 的定义，对于任何一个比特位 $i < k_0$，我们系统里的**所有**数字 $a_j$ 的 $0$ 到 $i$ 位都是单调的（要么全是 $0$，要么全是 $1$）。因为整数 $a_j \ge 0$，所以它的高位肯定有 $0$，所以这种单调只能是全 $0$。这意味着 $a_j$ 的 $0$ 到 $i$ 位都是 $0$（除非这个数本身就是 $2^k-1$ 这种形式，但即使是 $1 = (0...01)_2$，它的比特位也不是单调的）。
    更严谨地，我之前在小本本上推导了一下发现，对于任何 $i < k_0$，不仅每个数的 $0 \dots i$ 位是单调的，而且整个数组在第 $i$ 位的异或和也必定是 $0$。并且，由于这些位的低位都是单调的，我们无法改变这些位的值。所以，最终答案里，所有低于 $k_0$ 的位，都**必定是 $0$**。

2.  **对于所有等于或高于 $k_0$ 的位 i >= k_0：**
    在 $k_0$ 位，我们找到了第一个“灵活”的数字 $a_j$。这个数字的 $0$ 到 $k_0$ 位包含了 $0$ 和 $1$。
    这意味着，对于任何一个更高位 $i \ge k_0$，这个数字 $a_j$ 的 $0$ 到 $i-1$ 位也必然同时包含 $0$ 和 $1$。
    所以，对于任何 $i \ge k_0$ 位，我们都可以利用这个“灵活”的 $a_j$ 来翻转这一位最终的异或和！如果当前所有数在第 $i$ 位的异或和是 $0$，我们就改变 $a_j$ 的第 $i$ 位，让总异或和变成 $1$。如果本来就是 $1$，那我们就不动它。
    总之，只要我们找到了一个灵活的数字，我们就能**保证**所有更高位的最终异或和都可以被我们构造成 $1$！

#### 最终的答案

分析到这里，答案就清晰了喵~
我们只需要从低到高（$k=0, 1, 2, \dots$）扫描，找到第一个“关键位” $k_0$。
那么最终答案的二进制表示就是：
*   第 $0$ 到 $k_0-1$ 位，全部是 $0$。
*   第 $k_0$ 到 $60$ 位，全部是 $1$。

这个数用数学表示就是 $\sum_{i=k_0}^{60} 2^i$。
计算它有个小技巧：$(2^0 + \dots + 2^{60}) - (2^0 + \dots + 2^{k_0-1}) = (2^{61}-1) - (2^{k_0}-1) = 2^{61} - 2^{k_0}$。

如果扫遍了所有位都找不到这样的 $k_0$ 呢？这说明所有数字的所有比特位都是单调的。对于非负整数来说，这意味着所有数字都是 $0$。此时答案就是 $0$ 啦。

**算法步骤:**
1.  从比特位 k = 0` 开始，一直到 `60`。
2.  在每一位 `k`，检查所有的数字 `a[j]`。
3.  对于每个 `a[j]`，我们记录下它从 `0` 到 `k` 位出现过的比特值（是只有 `0`，只有 `1`，还是 `0` 和 `1` 都有）。
4.  如果在第 `k` 位，我们发现某个 `a[j] 的 $0 \dots k$ 位中首次同时出现了 0` 和 `1`，那么这个 `k 就是我们的关键位 $k_0$。
5.  马上计算答案 $(1LL \ll 61) - (1LL \ll k_0)$，然后结束程序。
6.  如果循环结束都没找到这样的 k`，说明所有数都是 $0$，答案就是 $0$。

## 代码实现

这是本猫娘根据上面的思路，精心编写的代码哦！注释超——级详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <set>

// 使用 long long 来处理可能很大的整数，喵~
using int64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::vector<int64> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    // 为每个数字 a[i] 准备一个小集合，用来记录它已经出现过的比特值 (0 或 1)
    std::vector<std::set<int>> seen_bits(n);

    // 从最低位开始，寻找那个关键的“转折点”
    for (int k = 0; k <= 60; ++k) {
        bool critical_point_found = false;

        // 遍历所有数字，更新它们在第 k 位的比特信息
        for (int i = 0; i < n; ++i) {
            int bit_val = (a[i] >> k) & 1;
            seen_bits[i].insert(bit_val);

            // 如果一个数字的 seen_bits 集合大小为 2，
            // 说明它从 0 到 k 位中，第一次同时拥有了 0 和 1！
            // 这就是我们要找的关键位 k_0
            if (seen_bits[i].size() == 2) {
                critical_point_found = true;
            }
        }

        if (critical_point_found) {
            // 找到了关键位 k_0！
            // 最终答案的所有 >= k_0 的位都是 1，< k_0 的位都是 0。
            // 这个数就是 (2^61 - 1) - (2^k - 1) = 2^61 - 2^k
            // (1LL << 61) 会溢出，所以用 (1LL << 61) - (1LL << k) 这种形式
            // 或者更安全的 ( (1LL << k) - 1 ) ^ ( (1LL << 61) - 1 )
            // 或者 sum from k to 60.
            // (1LL << 61) 是 2^61, (1LL << k) 是 2^k.
            // 2^61 - 2^k = (2^60 + ... + 2^k)
            int64 all_ones_from_k = ((1LL << 61) - 1) ^ ((1LL << k) - 1);
            std::cout << all_ones_from_k << std::endl;
            return;
        }
    }
    
    // 如果循环跑完了，说明所有数字的所有位都是单调的（即全为0）
    // 这种情况下，我们什么也改变不了，答案就是0
    std::cout << 0 << std::endl;
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
``

## 复杂度分析

*   **时间复杂度**: $O(T \cdot N \cdot \log A)$，其中 $T$ 是测试用例数量，$N$ 是数组大小，$\log A$ 是数字的比特位数（这里是固定的约60）。我们对每个测试用例，遍历最多61个比特位，每个比特位又遍历 $N$ 个数。所以总时间复杂度是 $O(T \cdot N \cdot 60)$，对于本题的数据范围来说绰绰有余啦，喵~
*   **空间复杂度**: $O(N)$。我们用了一个 vector<set<int>>` 来存储每个数字见过的比特。每个集合最多只有两个元素（0和1）。所以空间开销是和 $N$ 成正比的。

## 知识点总结

1.  **贪心思想**: 遇到“最大/最小化”问题，特别是和异或相关的，优先考虑贪心，通常是从高位到低位决定每一位的值。
2.  **位运算**: 理解位运算是解决这类问题的基础。本题的核心在于分析一个奇特的位操作 $c_k \leftarrow c_{k-1}$ 的传递效应。
3.  **构造性思维**: 不要局限于模拟操作，而是要分析操作的本质，理解通过这些操作，我们能把数字构造成哪些形态。
4.  **寻找关键点/转折点**: 很多问题的解法在于找到一个“临界状态”，一旦越过这个状态，问题的性质就完全变了。本题的“关键位” $k_0$ 就是这样一个转折点。

希望本猫娘的题解对你有帮助哦！如果还有不明白的地方，随时可以来问我，喵~ >w<