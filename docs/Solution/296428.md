# 位操作与异或和 - 题解

### 比赛与标签
> **比赛**: 牛客练习赛93
> **标签**: 位运算, 贪心
> **难度**: *1800

## 题目大意喵~
哈喵~ 各位算法大师们好呀！今天我们来解决一道非常有趣的位运算题目！(ฅ'ω'ฅ)

题目是这样子的：给定一个有 `n` 个整数的数组 `a`。我们可以对数组里的任何一个数 `a_i` 进行一种神奇的操作，而且想做多少次都行！

这个操作是这样的：
1.  首先，选中一个数字 `a_i`。
2.  把它看成二进制数，比如 `(...c_2c_1c_0)_2`。
3.  然后，再选一个位置 `k`（`1 ≤ k ≤ 60`）。
4.  最后，把第 `k` 位 `c_k` 的值，变成它前一位 `c_{k-1}` 的值。

我们的目标就是，通过任意多次这样的操作，让整个数组所有元素的**异或和**变得最大！最后输出这个最大的异或和就可以啦，喵~

## 解题思路分析呐~
这道题的目标是最大化异或和，很多同学可能第一反应就是从最高位开始的贪心策略，对吧？这确实是一个非常经典的想法！我们尝试让答案的最高位尽可能为 1，然后是次高位，以此类推。

但是，这道题的操作 `c_k ← c_{k-1}` 非常特别。让我们来仔细研究一下这个操作能带来什么效果吧！

这个操作意味着，一个数字 `a_i` 的第 `k` 位 `c_k` 可以被第 `k-1` 位 `c_{k-1}` 的值覆盖。如果再对 `k+1` 位操作，`c_{k+1}` 就可以被新的 `c_k`（也就是旧的 `c_{k-1}`）覆盖。这样一层一层地，就像多米诺骨牌一样，第 `p` 位（`p < k`）的值可以一直“传播”到第 `k` 位！

所以，对于任何一个数字 `a_i`，它的第 `k` 位 `a_{i,k}` 最终可以变成它原始的 `0` 到 `k-1` 位中的**任意一位**的值。

这个发现非常关键！但是，这也意味着我们能改变一个位，依赖于它下面有哪些位。所以，从最高位开始贪心，我们不知道低位能提供什么样的“弹药”（0 或 1）。

反过来想，一个数的低位决定了它高位的变化潜力！这启发我们从**最低位（LSB）**开始分析，看看我们最早能在哪个位上“搞事情”，喵~

我们从低到高（`i` 从 0 到 60）遍历每一个比特位，寻找一个“引爆点” `i_0`。这个 `i_0` 是我们**首次**获得改变全局异或和的能力的最低比特位。

**1. 什么时候我们才能改变全局异或和呢？**

对于第 `i` 位，我们想让最终的全局异或和在这一位上是 1。
- 如果原始所有数字的第 `i` 位异或和本来就是 1，那太棒了！我们什么都不用做，这一位就能是 1。
- 如果原始异或和是 0，我们就需要通过操作，把奇数个数字的第 `i` 位翻转。要翻转 `a_j` 的第 `i` 位，就需要 `a_j` 在 `i` 位以下存在一个和 `a_{j,i}` 不同的位。

**2. 寻找引爆点 `i_0`**

我们从 `i = 0` 开始，一位一位往上检查：
- `cnt`: 记录当前第 `i` 位是 1 的数字个数。如果 `cnt` 是奇数，那么原始的第 `i` 位异或和就是 1。
- `p`: 一个标志位。如果对于某个数字 `a_j`，在 `0` 到 `i` 位之间同时出现过 0 和 1，我们就把 `p` 设为 1。

我们寻找最小的 `i`，记作 `i_0`，满足以下两个条件之一：
- `cnt % 2 == 1`：第 `i_0` 位的原始异或和就是 1。
- `p == 1`：在第 `i_0` 位，我们发现至少有一个数 `a_j`，它的 `0` 到 `i_0` 位中既有 0 又有 1。这意味着我们获得了将这个 `a_j` 的更高位变成 0 或 1 的能力！

**3. 分析 `i_0` 以下和以上的位**

*   **对于所有 `k < i_0` 的位：**
    因为 `i_0` 是我们找到的第一个引爆点，所以在 `i_0` 之前，`cnt_k % 2` 总是 0，并且 `p_k` 总是 0。`p_k=0` 意味着对任何数 `a_j`，它的 `0` 到 `k` 位都是完全相同的（要么全是0，要么全是1）。这导致 `a_{j,k}` 无法被 `a_{j,k-1}` 改变（因为它们值相同）。所以，`k < i_0` 的这些位的异或和永远是它们初始的异或和，也就是 0。我们无能为力，这些位只能是 0 了。

*   **对于所有 `k >= i_0` 的位：**
    在 `i_0` 位，我们终于获得了力量！
    - 如果是因为 `p_{i_0} == 1`，说明有个 `a_j` 在 `i_0` 以下同时有 0 和 1 作为“弹药”。对于任何 `k > i_0`，我们都可以把 `a_{j,k}` 随意变成 0 或者 1。有了这么一个“万能工具人”，我们就能随意翻转任意高位的全局异或和，自然可以把它们全都变成 1！
    - 如果是因为 `cnt_{i_0} % 2 == 1`（并且 `p_{i_0} == 0`），说明在 `i_0` 位原始异或和就是 1。`p_{i_0}=0` 意味着每个数的 `0` 到 `i_0` 位都相同。对于更高的位 `k > i_0`，如果全局异或和是 0，我们能翻转它吗？我们只需要找到一个 `a_j` 使得 `a_{j,k}` 不等于它 `0` 到 `i_0` 位的那个统一值。如果找不到这样的 `a_j`（即所有 `a_{j,k}` 都等于它自己的低位统一值），那么第 `k` 位的异或和就等于第 `i_0` 位的异或和，也就是 1，根本不需要翻转！所以，我们总能把第 `k` 位的异或和变成 1。

**结论**

我们找到的这个最小的 `i_0`，就是答案中最低的为 1 的比特位！所有比 `i_0` 高的位我们都能设为 1，所有比它低的位都只能是 0。
所以，最大异或和就是 `2^i_0 + 2^(i_0+1) + ... + 2^60`。
这个等比数列的和等于 `(2^61 - 1) - (2^i_0 - 1) = 2^61 - 2^i_0`。

如果循环跑完了都没找到这样的 `i_0` 呢？这说明对于所有数字，它们的所有位都是相同的（要么全是0，要么全是1），并且每一位的异或和都是0（即有偶数个全1的数）。这种情况下，我们无法进行任何有效的改变，最终异或和只能是 0。

## 代码实现喵！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
#define int long long // 使用 long long 防止溢出，因为数字和结果可能很大
using namespace std;
const int N = 200010;
int a[N];

signed main()
{
    // 提高cin/cout效率
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int T; cin >> T; // T组测试数据
    while(T--)
    {
        int n; cin >> n;
        for(int i = 1; i <= n; i++)
            cin >> a[i];

        // mp[j] 用来存储数字 a[j] 从第 0 位到当前位的比特值集合
        // 如果集合大小为2，说明这个数字在低位里既有0也有1
        unordered_map<int, unordered_set<int>> mp;
        
        int ling = 1; // ling 是一个标志，如果最后还是1，说明最大异或和为0

        // 从最低位 i = 0 遍历到第 60 位
        for(int i = 0; i <= 60; i++)
        {
            int cnt = 0; // 记录当前第 i 位为 1 的数字个数
            int p = 0;   // 标志位，如果存在某个 a[j] 的 0~i 位中既有0也1，p就为1

            for(int j = 1; j <= n; j++)
            {
                // 取出 a[j] 的第 i 位
                int t = (a[j] >> i) & 1;
                if(t) cnt++;

                // 将第 i 位的值存入对应数字的集合中
                mp[j].insert(t); 
                
                // 如果一个数的低位比特集合大小为2，说明它有潜力改变高位
                if(mp[j].size() == 2) p = 1;
            }

            // 找到了引爆点 i_0！
            // cnt % 2 == 1: 第 i 位原始异或和为 1
            // p == 1: 找到了一个“万能工具人”，可以随意改变高位
            if(cnt % 2 || p) 
            {
                // 能够做到的最大异或和，是 i 位及以上全为 1
                // 2^i + 2^(i+1) + ... + 2^60 = 2^61 - 2^i
                cout << ((1LL << 61) - (1LL << i)) << endl;
                ling = 0; // 找到了答案，把标志设为0
                break;    // 找到最小的 i 就可以退出了
            }
        }

        // 如果循环结束 ling 仍然是 1，说明所有位的异或和都是0且无法改变
        if(ling) cout << 0 << endl;
    }
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(T * N * logA) 的说。其中 T 是测试用例数，N 是数组大小，logA 是数字的比特位数（这里是常数61）。所以整体可以看作 O(T * N) 呐。
- **空间复杂度**: O(N) 的说。我们用了一个 `unordered_map` 来存储每个数字的低位比特集合，最多存 N 个键，每个键对应的值（`unordered_set`）大小最多为2，所以是 O(N) 的空间。

## 知识点与总结
这道题真是一只狡猾的小猫咪，它伪装成一个常规的最高位贪心问题，但实际上核心在于分析操作的本质！

1.  **逆向思维**: 常规的从高到低贪心走不通时，不妨试试从低到高分析问题。低位的性质可能会决定高位的可能性。
2.  **操作本质分析**: `c_k ← c_{k-1}` 的本质是“低位信息向高位传播”。深刻理解操作能做什么、不能做什么，是解题的关键。
3.  **寻找“引爆点”**: 整个解法的核心是找到那个我们“首次获得超能力”的最低比特位 `i_0`。一旦找到，问题就迎刃而解了。
4.  **位运算技巧**: `(1LL << 61) - (1LL << i)` 是计算 `2^i + ... + 2^60` 的一个快捷方式，利用了等比数列求和 `2^i * (2^(61-i) - 1) = 2^61 - 2^i` 或者 `(2^61 - 1) - (2^i - 1)` 的思想。

希望这篇题解能帮助到你喵~ 如果还有不懂的地方，随时可以再来问本猫娘哦！我们一起变强！(๑•̀ㅂ•́)و✧