# 给定素数 P 和一个包含 Q 个整数的集合 S - 题解

### 比赛与标签
> **比赛**: N/A

> **标签**: 多项式 NTT, 原根, 数论, 卷积, 计数

> **难度**: N/A

## 题目大意喵~

主人你好喵~ 这是一道将数论和多项式巧妙结合起来的计数题哦！

题目是这样哒：
我们有一个素数 $P$，一个包含 $Q$ 个整数的集合 $S$，还有三个整数 $N, M, K$。
我们需要构造两个长度为 $K$ 的数组 $a = [a_1, \dots, a_K]$ 和 $b = [b_1, \dots, b_K]$。一个构造方案被称为“合法的”，需要满足下面三个条件：
1.  数组 $a$ 和 $b$ 中的所有元素（$a_i$ 和 $b_i$）都必须来自集合 $S$。
2.  数组 $a$ 中所有元素的乘积，在模 $P$ 意义下等于 $N$。也就是 $\prod_{i=1}^{K} a_i \equiv N \pmod{P}$。
3.  数组 $b$ 中所有元素的乘积，在模 $P$ 意义下等于 $M$。也就是 $\prod_{i=1}^{K} b_i \equiv M \pmod{P}$。

对于每一个合法的构造方案，它的“权值”是 $\sum_{i=1}^{K} \min(a_i, b_i)$。

我们的任务，就是计算**所有**合法的构造方案的权值总和，最后结果对 $998244353$ 取模。

简单来说，就是要找到所有满足条件的数组对 $(a, b)$，把它们各自的权值加起来，得到最终答案，喵~

## 解题思路分析

这道题看起来好复杂呀，要计算所有方案的权值和，直接暴力枚举肯定是不行的说。不过别担心，跟着猫娘的思路，一步一步就能把它解开喵！

#### 步骤一：转化求和目标

我们要求的是所有合法方案的 $\sum_{i=1}^{K} \min(a_i, b_i)$ 的总和。根据和的线性性质，我们可以把求和符号交换一下：

$$
\text{总和} = \sum_{\text{所有合法方案 }(a,b)} \sum_{i=1}^{K} \min(a_i, b_i) = \sum_{i=1}^{K} \sum_{\text{所有合法方案 }(a,b)} \min(a_i, b_i)
$$

因为对于任意位置 $i$ 和 $j$，它们的地位是完全相同的（对称性），所以 $\sum_{\text{所有合法方案}} \min(a_i, b_i)$ 的值对于任何 $i$ 都是一样的。那我们就可以只计算 $i=1$ 的情况，然后乘以 $K$ 就好啦！

$$
\text{总和} = K \times \sum_{\text{所有合法方案 }(a,b)} \min(a_1, b_1)
$$

一个“合法方案”是由一个合法的数组 $a$ 和一个合法的数组 $b$ 组成的。两者是独立选择的，所以我们可以把求和进一步拆分：

$$
\text{总和} = K \times \sum_{s_a \in S} \sum_{s_b \in S} \min(s_a, s_b) \times (\text{以 } s_a \text{ 开头的合法 } a \text{ 数组数量}) \times (\text{以 } s_b \text{ 开头的合法 } b \text{ 数组数量})
$$

现在问题变成了：对于任意一个从 $S$ 中选出的数 $s$，有多少个合法的、以 $s$ 开头的长度为 $K$ 的数组呢？

一个以 $s_a$ 开头的数组 $a$ 是合法的，意味着 $s_a \times \prod_{i=2}^{K} a_i \equiv N \pmod{P}$。这等价于，我们需要从 $S$ 中选出 $K-1$ 个数（$a_2, \dots, a_K$），使得它们的乘积模 $P$ 等于 $N \cdot s_a^{-1} \pmod{P}$。我们把这个计数问题记作 `Count(k, target)`，表示从 $S$ 中选 $k$ 个数，使其乘积为 `target 的方案数。

于是，我们的总和公式变成了：

$$
\text{总和} = K \times \sum_{s_a \in S} \sum_{s_b \in S} \min(s_a, s_b) \times \text{Count}(K-1, N \cdot s_a^{-1}) \times \text{Count}(K-1, M \cdot s_b^{-1})
$$

#### 步骤二：乘法变加法 - 原根的魔法！

计算 Count(k, target) 还是很麻烦，因为涉及到乘法。在模意义下处理乘法，我们有个超级厉害的工具——**原根**和**离散对数**！

因为 $P$ 是素数，所以模 $P$ 的乘法群 $(\mathbb{Z}/P\mathbb{Z})^*$ 是一个循环群。我们可以找到一个**原根** $g$，使得 $g^0, g^1, \dots, g^{P-2}$ 恰好能不重不漏地表示 $1, 2, \dots, P-1$ 中所有的数。

这样，任何一个数 $x \in \{1, \dots, P-1\}$ 都可以表示成 $g^{\text{ind}(x)}$ 的形式，其中 $\text{ind}(x)$ 叫做 $x$ 的离散对数。乘法就变成了指数的加法：
$x \cdot y \equiv g^{\text{ind}(x)} \cdot g^{\text{ind}(y)} = g^{\text{ind}(x) + \text{ind}(y)} \pmod{P}$。
指数上的加法是在模 $P-1$ 意义下进行的。

于是，Count(k, target) 的问题就变成了：从 $S$ 中选 $k$ 个数，使得它们的**离散对数之和**等于 $\text{ind}(\text{target}) \pmod{P-1}$。

这不就是经典的**卷积**形式嘛！

#### 步骤三：NTT 加速卷积

我们可以构造一个生成多项式 $F(x)$。让 $F(x)$ 的第 $i$ 次项系数 $[x^i]F(x)$ 表示集合 $S$ 中离散对数为 $i$ 的非零数的个数。

$$
F(x) = \sum_{s \in S, s \not\equiv 0 \pmod P} x^{\text{ind}(s)}
$$

那么，$(F(x))^k$ 这个多项式，它的第 $j$ 次项系数 $[x^j](F(x))^k$ 就代表了从 $S$ 中选 $k$ 个非零数，使得它们的离散对数之和为 $j$ 的方案数。这也就是它们的乘积为 $g^j \pmod P$ 的方案数！

我们可以用**多项式快速幂**来计算 $G(x) = (F(x))^{K-1}$，其中的多项式乘法用**NTT (数论变换)** 来加速。NTT 就像是专门为模运算设计的 FFT，可以在 $O(P \log P)$ 的时间内完成卷积。

#### 步骤四：处理讨厌的 0

上面的方法只适用于非零数。如果 $N, M$ 或者 $S$ 中的数有 $0$ 怎么办呢？我们需要分类讨论喵~

Let $c_0$ be the number of elements in $S$ that are $0 \pmod P$.
Let's analyze Count(k, target)`:
1.  **If `target $\ne 0$**: To get a non-zero product, all $k$ chosen numbers must be non-zero. The number of ways is simply $[x^{\text{ind}(\text{target})}] (F(x))^k$.
2.  **If target $= 0$**: To get a zero product, at least one of the $k$ chosen numbers must be $0 \pmod P$.
    总方案数 = (从 $S$ 中任选 $k$ 个数的总方案数) - (从 $S$ 中选 $k$ 个**非零**数的方案数)
    $= Q^k - (Q-c_0)^k$.

现在我们来计算 $\text{Count}(K-1, N \cdot s_a^{-1})$：
*   **当 $s_a \equiv 0 \pmod P$**:
    *   如果 $N \ne 0$，乘积一定是 $0$，不可能等于 $N$。方案数是 $0$。
    *   如果 $N = 0$，乘积已经是 $0$了，剩下的 $K-1$ 个数可以随便选。方案数是 $Q^{K-1}$。
*   **当 $s_a \not\equiv 0 \pmod P$**:
    *   如果 $N \ne 0$，我们需要 $\prod_{i=2}^K a_i \equiv N \cdot s_a^{-1} \pmod P$。方案数是 $[x^{\text{ind}(N \cdot s_a^{-1})}] G(x)$。
    *   如果 $N = 0$，我们需要 $\prod_{i=2}^K a_i \equiv 0 \pmod P$。方案数是 $Q^{K-1} - (Q-c_0)^{K-1}$。

这样，我们就可以计算出所有的 $\text{Count}(K-1, \dots)$ 的值了。

#### 步骤五：优雅地求和

我们得到了两个数组，contrib_N[i] = Count(K-1, N * s_i^{-1})` 和 `contrib_M[i] = Count(K-1, M * s_i^{-1})。现在需要计算：
$$
\text{SumPart} = \sum_{i=0}^{Q-1} \sum_{j=0}^{Q-1} \min(s_i, s_j) \times \text{contrib\_N}[i] \times \text{contrib\_M}[j]
$$
其中 $s_i$ 是排序后 $S$ 中的第 $i$ 个元素。

这个 $O(Q^2)$ 的双重循环还是太慢了。但是我们可以用一个很帅的 $O(Q)$ 技巧来解决！
我们把 $S$ 从大到小遍历。当我们遍历到 $s_i$ 时，我们把所有 $\min(s_i, s_j)$ 的贡献加起来。
$\min(s_i, s_j)$ 要么是 $s_i$ (当 $j < i$)，要么是 $s_j$ (当 $j \ge i$)。（假设 $S$ 已升序排序）。
为了方便，我们从大到小遍历 $s_i$（即 $i$ from $Q-1$ to $0$）。
在处理 $s_i$ 时，对于所有 $j>i$，我们有 $\min(s_i, s_j) = s_i$。
这个求和可以被巧妙地组织起来：
$$
\text{SumPart} = \sum_{i=0}^{Q-1} s_i \left( \text{contrib\_N}[i]\text{contrib\_M}[i] + \text{contrib\_N}[i]\sum_{j>i}\text{contrib\_M}[j] + \text{contrib\_M}[i]\sum_{j>i}\text{contrib\_N}[j] \right)
$$
当我们从 $i=Q-1$ 倒着循环到 $0$ 时，我们可以动态维护 $\sum_{j>i}\text{contrib\_N}[j]$ 和 $\sum_{j>i}\text{contrib\_M}[j]$ 这两个后缀和。这样，每次计算括号里的内容就是 $O(1)$ 的啦！

总的来说，我们的算法流程就是：
1.  找到原根，建立离散对数表。
2.  构造多项式 $F(x)$。
3.  用 NTT 和多项式快速幂计算 $G(x) = (F(x))^{K-1}$。
4.  根据 $N, M$ 和 $s_i$ 的值，分类讨论计算出贡献数组 contrib_N` 和 `contrib_M`。
5.  使用 $O(Q)$ 的后缀和技巧计算出最终的和。
6.  别忘了乘以 $K$！

好啦，思路清晰了，可以开始写代码了喵！

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

using namespace std;

const int MOD = 998244353;
const int NTT_PRIMITIVE_ROOT = 3;

long long power(long long base, long long exp) {
    long long res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

long long modInverse(long long n) {
    return power(n, MOD - 2);
}

// NTT 核心实现
void ntt(vector<long long>& a, bool invert) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        long long wlen = power(NTT_PRIMITIVE_ROOT, (MOD - 1) / len);
        if (invert) wlen = modInverse(wlen);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j], v = (a[i + j + len / 2] * w) % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len / 2] = (u - v + MOD) % MOD;
                w = (w * wlen) % MOD;
            }
        }
    }
    if (invert) {
        long long n_inv = modInverse(n);
        for (long long& x : a)
            x = (x * n_inv) % MOD;
    }
}

// 循环卷积
vector<long long> multiply(vector<long long> a, vector<long long> b, int cyclic_len) {
    int sz = 1;
    while (sz < a.size() + b.size() - 1) sz <<= 1;
    a.resize(sz);
    b.resize(sz);

    ntt(a, false);
    ntt(b, false);
    for (int i = 0; i < sz; i++) a[i] = (a[i] * b[i]) % MOD;
    ntt(a, true);
    
    a.resize(cyclic_len * 2 - 1);
    for(int i = cyclic_len; i < a.size(); ++i) {
        if (i - cyclic_len < cyclic_len) {
            a[i - cyclic_len] = (a[i - cyclic_len] + a[i]) % MOD;
        }
    }
    a.resize(cyclic_len);
    return a;
}

vector<long long> poly_power(vector<long long> base, int exp, int cyclic_len) {
    vector<long long> res(cyclic_len, 0);
    res[0] = 1;
    while (exp > 0) {
        if (exp % 2 == 1) res = multiply(res, base, cyclic_len);
        base = multiply(base, base, cyclic_len);
        exp /= 2;
    }
    return res;
}

// 找到一个P的原根
int find_primitive_root(int p) {
    if (p == 2) return 1;
    vector<int> factors;
    int phi = p - 1;
    int temp_phi = phi;
    for (int i = 2; i * i <= temp_phi; ++i) {
        if (temp_phi % i == 0) {
            factors.push_back(i);
            while (temp_phi % i == 0) temp_phi /= i;
        }
    }
    if (temp_phi > 1) factors.push_back(temp_phi);

    for (int g = 2; g < p; ++g) {
        bool ok = true;
        for (int factor : factors) {
            if (power(g, phi / factor) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
    return -1;
}

// 计算贡献数组
vector<long long> get_contributions(int target, int k, int q, int p, const vector<int>& s,
                                    const vector<long long>& counts_poly,
                                    const vector<int>& val_to_log, const vector<int>& log_to_val,
                                    const vector<vector<int>>& s_indices_by_rem, int zero_count_in_s) {
    vector<long long> contrib(q);
    if (target == 0) {
        long long ways_prod_zero = (power(q, k - 1) - power(q - zero_count_in_s, k - 1) + MOD) % MOD;
        long long ways_any_prod = power(q, k - 1);
        for (int idx : s_indices_by_rem[0]) {
            contrib[idx] = ways_any_prod;
        }
        for (int i = 0; i < q; ++i) {
            if (s[i] % p != 0) {
                contrib[i] = ways_prod_zero;
            }
        }
    } else {
        int target_log = val_to_log[target];
        for (int i = 0; i < q; ++i) {
            if (s[i] % p == 0) {
                contrib[i] = 0;
            } else {
                int s_log = val_to_log[s[i] % p];
                int needed_log = (target_log - s_log + p - 1) % (p - 1);
                contrib[i] = counts_poly[needed_log];
            }
        }
    }
    return contrib;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int p, q;
    long long n, m, k;
    cin >> p >> q >> n >> m >> k;

    vector<int> s(q);
    int zero_count_in_s = 0;
    vector<vector<int>> s_indices_by_rem(p);
    for (int i = 0; i < q; ++i) {
        cin >> s[i];
    }
    sort(s.begin(), s.end());
    for(int i = 0; i < q; ++i) {
        s_indices_by_rem[s[i] % p].push_back(i);
        if (s[i] % p == 0) {
            zero_count_in_s++;
        }
    }
    
    if (k == 0) {
        if (n % p == 1 && m % p == 1) {
            cout << 0 << endl;
        } else {
            cout << 0 << endl;
        }
        return 0;
    }


    int g = find_primitive_root(p);
    vector<int> val_to_log(p), log_to_val(p - 1);
    int current_val = 1;
    for (int i = 0; i < p - 1; ++i) {
        val_to_log[current_val] = i;
        log_to_val[i] = current_val;
        current_val = (1LL * current_val * g) % p;
    }

    vector<long long> base_poly(p - 1, 0);
    for (int i = 1; i < p; ++i) {
        base_poly[val_to_log[i]] = s_indices_by_rem[i].size();
    }

    vector<long long> counts_poly = poly_power(base_poly, k - 1, p - 1);

    vector<long long> contrib_n = get_contributions(n % p, k, q, p, s, counts_poly, val_to_log, log_to_val, s_indices_by_rem, zero_count_in_s);
    vector<long long> contrib_m = get_contributions(m % p, k, q, p, s, counts_poly, val_to_log, log_to_val, s_indices_by_rem, zero_count_in_s);

    long long final_sum = 0;
    long long suffix_sum_n = 0;
    long long suffix_sum_m = 0;

    for (int i = q - 1; i >= 0; --i) {
        long long n_i = contrib_n[i];
        long long m_i = contrib_m[i];
        
        long long term1 = (n_i * suffix_sum_m) % MOD;
        long long term2 = (m_i * suffix_sum_n) % MOD;
        long long term3 = (n_i * m_i) % MOD;
        
        long long total_contrib_for_si = (term1 + term2 + term3) % MOD;
        final_sum = (final_sum + (long long)s[i] * total_contrib_for_si) % MOD;

        suffix_sum_n = (suffix_sum_n + n_i) % MOD;
        suffix_sum_m = (suffix_sum_m + m_i) % MOD;
    }
    
    cout << (final_sum * k) % MOD << endl;

    return 0;
}
``

## 复杂度分析

-   **时间复杂度**: $O(P \log P \log K + Q)$
    -   寻找原根：需要对 $P-1$ 进行质因数分解，复杂度大约是 $O(\sqrt{P})$。然后进行若干次快速幂，总复杂度约为 $O(\sqrt{P} \log P)$。
    -   多项式快速幂：我们计算 $(F(x))^{K-1}$。这需要 $O(\log K)$ 次多项式乘法。每次乘法使用 NTT，长度为 $O(P)$，所以复杂度是 $O(P \log P)$。总共是 $O(P \log P \log K)$。
    -   计算贡献数组：对于 $N$ 和 $M$，都需要遍历一遍 $S$ 或者离散对数表，复杂度为 $O(Q+P)$。
    -   最后求和：我们使用后缀和技巧，只需要遍历一次排序后的 $S$，复杂度为 $O(Q)$。
    -   总的来看，瓶颈在于多项式快速幂，所以整体时间复杂度是 $O(P \log P \log K)$。

-   **空间复杂度**: $O(P+Q)$
    -   存储集合 $S$ 和按模 $P$ 余数分组的索引需要 $O(Q)$ 的空间。
    -   离散对数表和原根相关计算需要 $O(P)$ 的空间。
    -   NTT 和多项式运算需要 $O(P)$ 的空间来存储多项式系数。
    -   贡献数组 contrib_N` 和 `contrib_M` 需要 $O(Q)$ 的空间。
    -   因此，总空间复杂度是 $O(P+Q)$。

## 知识点总结

这道题是数论和多项式算法的完美结合，喵~ 涉及到的知识点非常多，是很好的练习题！

1.  **贡献法思想**: 将复杂的大求和问题，通过交换求和次序、利用对称性等方法，转化为对每个基本单元（比如本题中的 $\min(a_i, b_i)$）的贡献进行求和。这是组合计数问题中非常常用的思想。

2.  **原根与离散对数**: 这是解决模意义下乘法问题的关键工具。它能将一个乘法循环群的问题，转化为指数上的加法问题，从而可以使用我们更熟悉的加法卷积工具。

3.  **生成函数与多项式**: 将计数问题用多项式来表示。多项式的乘法（卷积）天然地对应了组合方案的合并，即指数相加。

4.  **NTT (数论变换)**: 在模意义下实现快速多项式卷积的算法。它是解决大规模计数问题的利器。

5.  **多项式快速幂**: 类似于整数的快速幂，用于高效计算一个多项式的 $k$ 次方。

6.  **分类讨论**: 在算法问题中，对于一些特殊值（比如本题中的 $0$）要格外小心，常常需要单独处理，确保逻辑的完备性。

7.  **$O(Q)$ 求和技巧**: 对于形如 $\sum\sum \min(s_i, s_j) \dots$ 的式子，通过排序和维护前后缀和，可以将 $O(Q^2)$ 的计算量优化到 $O(Q)$。

希望这篇题解能帮助到你，喵~ 如果还有不懂的地方，随时可以再来问我哦！