# Kabaleo Lite - 题解

### 比赛与标签
> **比赛**: The 2nd Universal Cup. Stage 1: Shenyang

> **标签**: Greedy, Prefix Sum

> **难度**: *1900

## 题目大意喵~

主人，你好呀！这道题是关于 Apollo 开的一家叫做 **Kabaleo Lite** 的快餐店的故事，喵~

店里有 $n$ 种食物，从 1 到 $n$ 编号。第 $i$ 种食物的利润是 $a_i$（可能是负数哦，因为食材很贵！），初始库存是 $b_i$ 份。

Apollo 有一套独特的待客之道：
1.  每位客人都至少会得到一道菜。
2.  每位客人得到的菜品，都是从 1 号食物开始的连续套餐。也就是说，客人可以得到套餐 `{1}`，或者 `{1, 2}`，或者 `{1, 2, 3}`，...，一直到 `{1, 2, ..., k}`。每种套餐里的食物都只给一份。

我们需要帮 Apollo 计算两个问题：
1.  他最多能招待多少位客人？
2.  在招待最多客人的前提下，他能获得的最大总利润是多少呢？

## 解题思路分析

这道题看起来有点复杂，但别担心，跟着本猫娘的思路一步步来，很快就能理清头绪啦，喵~

### 第一步：最多能招待多少客人？

我们先来解决第一个问题：最多能招待多少客人？

仔细看规则，每位客人收到的套餐，无论是 `{1}` 还是 `{1, 2, ..., k}`，都包含了 1 号食物。这意味着，**每招待一位客人，都必须消耗一份 1 号食物**。

店里 1 号食物的库存是 $b_1$ 份。所以，无论我们怎么组合套餐，总共能招待的客人数量绝对不可能超过 $b_1$！

那么，我们能恰好招待 $b_1$ 位客人吗？当然可以！最简单的方法就是，给所有 $b_1$ 位客人都提供最基础的 `{1}` 号套餐。这样做只消耗 $b_1$ 份 1 号食物，不会用到其他食物，所以库存肯定是足够的。

所以，第一个问题的答案就出来啦：**最多能招待 $b_1$ 位客人**。

### 第二步：如何最大化利润？

既然我们已经确定了要招待 $b_1$ 位客人，接下来的目标就是在满足库存限制的前提下，为这 $b_1$ 位客人分配合理的套餐，使得总利润最大化。

这是一个典型的贪心问题！为了让总利润最大，我们应该尽可能地给客人们提供利润最高的套餐。

首先，我们定义一下套餐的利润。一个大小为 $k$ 的套餐 `{1, 2, ..., k} 的利润 $P_k$ 就是前 $k$ 种食物利润的总和：
$$
P_k = \sum_{i=1}^{k} a_i
$$
我们可以用前缀和在 $O(n)$ 的时间里预处理出所有 $P_1, P_2, \dots, P_n$。

接下来，我们得考虑库存的限制。要给一位客人提供大小为 $k$ 的套餐，我们需要保证食物 $1, 2, \dots, k$ 的库存都至少有一份。如果我们想给多位客人提供这个套餐，那他们共同受到的限制就是食物 $1, 2, \dots, k$ 中库存最少的那一种。

我们可以定义一个 "潜力" 值 $m_k$，表示我们最多能提供多少份大小至少为 $k$ 的套餐。这个数量显然受限于 $b_1, b_2, \dots, b_k$ 的库存，所以：
$$
m_k = \min(b_1, b_2, \dots, b_k)
$$
这个 $m_k$ 也可以用前缀最小值在 $O(n)$ 的时间里预处理出来。注意，$m_1 \ge m_2 \ge \dots \ge m_n$。

现在，最关键的思路来啦！我们可以把 $b_1$ 位客人根据他们的“潜力”进行分组：

1.  **“精英”客人组 (Elite Group)**: 有多少客人有潜力获得最大 (到 $n$) 的套餐呢？答案是 $m_n$ 位。因为这需要 $b_1, \dots, b_n$ 的库存都支持。对于这 $m_n$ 位最尊贵的客人，我们当然要给他们提供 $[1, n]$ 范围里最赚钱的套餐！这个套餐的利润是 $\max(P_1, P_2, \dots, P_n)$。我们称之为 $\text{maxP}_n$。
    这组客人的利润贡献是: $m_n \cdot \text{maxP}_n$。

2.  **“次级”客人组 (Very Good Group)**: 接下来，有多少客人最多只能拿到大小为 $n-1$ 的套餐呢？总共有 $m_{n-1}$ 位客人有潜力拿到大小至少为 $n-1$ 的套餐。除去上面那 $m_n$ 位精英客人，剩下的 $m_{n-1} - m_n$ 位客人就是这个组的。他们能获得的最好套餐是在 $[1, n-1]$ 范围里最赚钱的，利润为 $\text{maxP}_{n-1} = \max(P_1, \dots, P_{n-1})$。
    这组客人的利润贡献是: $(m_{n-1} - m_n) \cdot \text{maxP}_{n-1}$。

3.  **通用分组逻辑**: 依此类推，对于任何 $i \in [1, n]$，有 $m_i - m_{i+1}$ 位客人（我们定义 $m_{n+1}=0$），他们最多能拿到大小为 $i$ 的套餐。我们应该给他们 $[1, i]$ 范围内最赚钱的套餐，其利润为 $\text{maxP}_i = \max(P_1, \dots, P_i)$。
    第 $i$ 组客人的利润贡献是: $(m_i - m_{i+1}) \cdot \text{maxP}_i$。

我们把所有组的利润贡献加起来，就是我们能获得的最大总利润啦！
$$
\text{Total Profit} = \sum_{i=1}^{n} (m_i - m_{i+1}) \cdot \text{maxP}_i
$$
其中 $\text{maxP}_i$ 也可以通过对 $P$ 数组求前缀最大值来 $O(n)$ 预处理。

整个算法的步骤就是：
1.  计算利润前缀和 $P$。
2.  计算库存前缀最小值 $m$。
3.  计算利润前缀和的前缀最大值 $\text{maxP}$。
4.  根据上面的公式计算总利润。

因为利润的计算结果可能会非常大，会超出 long long` 的范围，所以我们需要使用 `__int128_t` 来存储总利润，喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦！注释超级详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 __int128_t 类型来处理可能非常大的利润值
using int128 = __int128_t;

// 一个辅助函数，用来打印 __int128_t 类型的数字，喵~
void print_int128(int128 x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x == 0) {
        putchar('0');
        return;
    }
    std::string s = "";
    while (x > 0) {
        s += (x % 10) + '0';
        x /= 10;
    }
    std::reverse(s.begin(), s.end());
    for (char c : s) {
        putchar(c);
    }
}

void solve(int case_num) {
    int n;
    scanf("%d", &n);

    std::vector<long long> a(n);
    std::vector<long long> b(n);

    for (int i = 0; i < n; ++i) scanf("%lld", &a[i]);
    for (int i = 0; i < n; ++i) scanf("%lld", &b[i]);

    // 第一问的答案：最多能招待的客人数量就是 b[0] (即 b_1)
    long long max_visitors = (n > 0) ? b[0] : 0;

    if (n == 0) {
        printf("Case #%d: 0 0\n", case_num);
        return;
    }

    // --- 第二问：计算最大利润 ---

    // 1. 计算利润的前缀和 P_k = sum_{i=1 to k} a_i
    std::vector<long long> prefix_sum_profits(n);
    prefix_sum_profits[0] = a[0];
    for (int i = 1; i < n; ++i) {
        prefix_sum_profits[i] = prefix_sum_profits[i - 1] + a[i];
    }

    // 2. 计算库存的前缀最小值 m_k = min(b_1, ..., b_k)
    std::vector<long long> prefix_min_stocks(n);
    prefix_min_stocks[0] = b[0];
    for (int i = 1; i < n; ++i) {
        prefix_min_stocks[i] = std::min(prefix_min_stocks[i - 1], b[i]);
    }

    // 3. 计算利润前缀和的前缀最大值 maxP_k = max(P_1, ..., P_k)
    std::vector<long long> prefix_max_profits(n);
    prefix_max_profits[0] = prefix_sum_profits[0];
    for (int i = 1; i < n; ++i) {
        prefix_max_profits[i] = std::max(prefix_max_profits[i - 1], prefix_sum_profits[i]);
    }

    // 4. 根据公式计算总利润
    // Total Profit = sum_{i=1 to n} (m_i - m_{i+1}) * maxP_i
    int128 total_profit = 0;
    for (int i = 0; i < n; ++i) {
        long long m_i = prefix_min_stocks[i];
        // 如果是最后一组，m_{i+1} 就当做 0
        long long m_i_plus_1 = (i + 1 < n) ? prefix_min_stocks[i + 1] : 0;
        
        // 第 i 组客人的数量
        long long group_size = m_i - m_i_plus_1;
        
        // 第 i 组客人能获得的最佳单位利润
        long long profit_per_visitor = prefix_max_profits[i];
        
        total_profit += (int128)group_size * profit_per_visitor;
    }

    printf("Case #%d: %lld ", case_num, max_visitors);
    print_int128(total_profit);
    printf("\n");
}

int main() {
    // 为了更快的输入输出，喵~
    // std::ios_base::sync_with_stdio(false);
    // std::cin.tie(NULL);

    int t;
    scanf("%d", &t);
    for (int i = 1; i <= t; ++i) {
        solve(i);
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N)$
    我们计算利润前缀和、库存前缀最小值、利润前缀最大值，都只需要一次线性遍历，复杂度是 $O(N)$。最后计算总利润的循环也只遍历一次，是 $O(N)$。所以总的时间复杂度是 $O(N)$，非常高效！

-   **空间复杂度**: $O(N)$
    我们使用了几个大小为 $N$ 的 `vector` 来存储预处理的结果（`prefix_sum_profits`, `prefix_min_stocks`, `prefix_max_profits`），所以占用的额外空间是 $O(N)$。

## 知识点总结

这道题虽然包装在一个有趣的故事里，但核心考察的是对问题本质的洞察和贪心思想的应用，呐。

1.  **问题分解**: 成功地将问题分解为“求最大访客数”和“求最大利润”两个子问题是关键的第一步。
2.  **贪心策略**: 在确定了访客数后，最大化利润的问题可以通过贪心解决。核心是“让有潜力的客人拿最赚钱的套餐”。
3.  **前缀和/最小值/最大值**: 这是解决这类问题的常用技巧！通过预处理，可以把一些需要在循环中反复计算的值（如套餐利润、库存瓶颈）降到 $O(1)$ 查询，大大优化了时间复杂度。
4.  **贡献法思想**: 把总利润看作是不同“客人组”贡献的总和，这种思考方式让复杂的计算变得清晰明了。
5.  **大数处理**: 注意到题目数据范围可能导致结果溢出 `long long`，并正确使用 `__int128_t` 是AC的最后一道保障！

希望这篇题解能帮助你更好地理解这道题！继续加油哦，主人！喵~