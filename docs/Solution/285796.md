# 颜色与方格 - 题解

### 比赛与标签
> **比赛**: NowCoder
> **标签**: 喵~ 这道题没有标签的说~
> **难度**: 喵~ 这道题没有难度评分的说~

## 小灰灰的袜子难题喵~
各位小伙伴们好呀，我是你们最喜欢算法的猫娘~ ฅ'ω'ฅ

今天我们来帮帮小灰灰解决他的袜子烦恼吧！题目是这样的呐：

我们有一个 `n x n` 的大盒子，里面放满了五颜六色的袜子。对于每一个格子 `(i, j)`，都有一只颜色为 `c(i, j)` 的袜子。

小灰灰的视力不太好，他每次只能在一个 `K x K` 的小区域里找袜子。现在有 `m` 次提问，每次提问会给出一个区域的左上角坐标 `(x, y)`。我们需要回答的问题是：在这个从 `(x, y)` 开始的 `K x K` 区域里，有多少种颜色的袜子，是至少有两只（也就是可以凑成一双）的呢？

因为提问的次数 `m` 可能会非常非常多，如果我们每次都傻乎乎地去数一遍，小灰灰可就要穿着一只袜子去上课啦！所以，我们需要一个更聪明的办法，喵~

## 猫猫的奇妙滑动窗口~
面对这种“固定数据、多次查询”的问题，猫娘我的第一反应就是——**预处理**！就像猫猫我提前把所有小鱼干的位置都记下来一样，我们也可以预先计算出**所有**可能的 `K x K` 窗口的答案，然后把它们存起来。这样，每次提问时，我们只需要一瞬间就能拿出答案，是不是很棒？

那么，要怎么高效地计算所有窗口的答案呢？这就需要我们的主角——**二维滑动窗口**登场啦！

想象一个 `K x K` 的小窗户在 `n x n` 的大玻璃上移动。如果我们直接计算第一个窗口（左上角在 `(1,1)`）的答案，这很简单，遍历 `K*K` 个格子，用一个计数器（比如一个叫 `mp` 的数组或哈希表）来统计每种颜色的数量，同时用一个变量 `sum` 记录满足“数量>=2”的颜色有多少种。

关键在于，当我们的窗口从 `(1,1)` 移动到 `(1,2)` 时，我们没必要重新计算一切！仔细观察，新窗口和旧窗口大部分是重叠的。变化的部分仅仅是：
- **失去了**最左边的一列格子。
- **得到了**最右边的一列新格子。

所以，我们只需要根据这两列的变化来更新我们的计数器 `mp` 和最终答案 `sum` 就好啦！
- 对于**离开窗口**的每个格子，我们把它对应颜色的计数减一。如果这个颜色的数量从 `2` 变成了 `1`，说明我们失去了一双袜子，`sum` 就要减一。
- 对于**进入窗口**的每个格子，我们把它对应颜色的计数加一。如果这个颜色的数量从 `1` 变成了 `2`，说明我们凑成了一双新袜子，`sum` 就要加一。

这样，每次窗口水平移动一步，我们只需要 `O(K)` 的时间来更新，比 `O(K*K)` 快多啦！

同理，当窗口向下移动一步，比如从 `(1, y)` 移动到 `(2, y)`，我们也是更新最上面离开的一行和最下面进入的一行。

代码里采用了一种非常优雅的**蛇形遍历**方式来移动窗口：
1.  先计算出 `(1,1)` 窗口的答案。
2.  窗口向右一路滑到底，计算出第一行所有窗口的答案。
3.  然后向下滑动一格。
4.  再向左一路滑到底，计算出第二行所有窗口的答案。
5.  再向下滑动一格...
...如此反复，就像一条贪吃蛇一样，喵呜~ 这样就能不重不漏地覆盖所有可能的 `K x K` 窗口啦！

通过这种方式，我们用 `O(n*n)` 的时间预处理出 `ans` 数组，之后每次查询只需要 `O(1)` 的时间，完美解决问题！

## 代码魔法，变身！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
#define cintie ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define Trd int T;cin>>T;while (T--)solve();
#define LLinf 9e18
#define Iinf 2e9
#define LL long long
#define ULL unsigned long long 
#define Lc p<<1
#define Rc p<<1|1
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
 
using namespace std;
 
int n,m,k;
int a[710][710];       // 存储n*n的袜子颜色矩阵，喵~
int mp[1000010];       // 用来当做哈希表，统计每种颜色的袜子有多少只
int ans[710][710];     // 存储每个(x,y)作为左上角时，K*K区域内的答案
 
void init(){
    int sum=0; // 当前窗口内，能凑成对的颜色种类数
     
    // 1. 先计算出左上角第一个 K*K 窗口 (1,1) 的答案
    for (int i=1;i<=k;i++){
        for (int j=1;j<=k;j++){
            mp[a[i][j]]++;
            if (mp[a[i][j]]==2) sum++; // 当某个颜色的袜子达到2只时，我们就多了一种可以凑对的颜色
        }
    }
    ans[1][1]=sum;
    
    // 2. 开始蛇形滑动窗口，计算所有可能的答案
    int x=1,y=1;
    while (x<=n-k+1){
        // 2.1 窗口向右滑动
        while (y<n-k+1){
            y++;
            // 移出最左边一列，加入最右边一列
            for (int i=x;i<x+k;i++){
                mp[a[i][y-1]]--; // 左边列的颜色数量减一
                if (mp[a[i][y-1]]==1) sum--; // 如果从2只变成1只，能凑对的颜色数就减一
                mp[a[i][y+k-1]]++; // 右边列的颜色数量加一
                if (mp[a[i][y+k-1]]==2) sum++; // 如果从1只变成2只，能凑对的颜色数就加一
            }
            ans[x][y]=sum; // 记录当前窗口的答案
        }
         
        x++; // 向下滑动一格
        if (x>n-k+1) break; // 如果滑出边界了就结束
        // 移出最上面一行，加入最下面一行
        for (int i=y;i<=y+k-1;i++){
            mp[a[x-1][i]]--;
            if (mp[a[x-1][i]]==1) sum--;
            mp[a[x+k-1][i]]++;
            if (mp[a[x+k-1][i]]==2) sum++;
        }
        ans[x][y]=sum;
         
        // 2.2 窗口向左滑动
        while (y>1){
            y--;
            // 移出最右边一列，加入最左边一列
            for (int i=x;i<x+k;i++){
                mp[a[i][y+k]]--; // 右边列的颜色数量减一
                if (mp[a[i][y+k]]==1) sum--;
                mp[a[i][y]]++; // 左边列的颜色数量加一
                if (mp[a[i][y]]==2) sum++;
            }
            ans[x][y]=sum;
        }
         
        x++; // 再向下滑动一格
        if (x>n-k+1) break;
        // 移出最上面一行，加入最下面一行
        for (int i=y;i<=y+k-1;i++){
            mp[a[x-1][i]]--;
            if (mp[a[x-1][i]]==1) sum--;
            mp[a[x+k-1][i]]++;
            if (mp[a[x+k-1][i]]==2) sum++;
        }
        ans[x][y]=sum;
    }
}
 
void solve(){
     
    cin>>n>>m>>k;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            cin>>a[i][j];
            
    init(); // 进行预处理，把所有答案都算好
    
    // 回答m次询问，因为答案都算好了，所以每次都是O(1)的哦
    for (int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        cout<<ans[x][y]<<endl;
    }
     
}
 
int main()
{
    cintie;
    solve();
     
     
    return 0;
}
```

## 时空魔法的消耗~
- **时间复杂度**: O(n² + m) 的说。
  我们的 `init()` 函数是时间消耗的大头。虽然看起来有很多层循环，但它的本质是让每个格子都作为“进入窗口”的元素和“离开窗口”的元素各被访问一次。整个 `n x n` 的大网格被完整地扫描了一遍，所以预处理的总时间复杂度是 O(n²)。之后回答 `m` 个询问，每次查询都是 O(1) 的查表操作，所以查询部分是 O(m)。加起来总共就是 O(n² + m) 啦！

- **空间复杂度**: O(n² + C) 的说。
  这里 `C` 是袜子颜色的最大值。我们需要 `a[710][710]` 和 `ans[710][710]` 两个二维数组来存数据和答案，这部分空间是 O(n²)。另外，我们还需要一个 `mp` 数组来统计颜色数量，它的空间取决于颜色的范围，也就是 O(C)。所以总的空间复杂度就是 O(n² + C) 啦。

## 猫娘的小小总结~
这道题真是一个非常经典的二维滑动窗口应用呢！通过它，我们可以学到：

1.  **预处理思想**: 当遇到固定数据集上的多次范围查询时，优先考虑是否可以预处理所有可能查询的答案。
2.  **增量更新**: 滑动窗口的核心就是“增量更新”。不要从头计算，而是关注新旧窗口之间的差异，只更新变化的部分。这能极大地提高效率！
3.  **蛇形遍历**: 这是一种实现二维滑动窗口的巧妙技巧，可以让代码逻辑更连贯，避免了复杂的边界判断。

希望这篇题解能帮到你哦，喵~ 算法的世界充满了奇思妙想，只要我们多动脑筋，就能找到像滑动窗口这样优雅又高效的解决方法。一起加油，成为更厉害的算法大师吧！(๑•̀ㅂ•́)و✧