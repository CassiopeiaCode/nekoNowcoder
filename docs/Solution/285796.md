# 颜色与方格 - 题解

### 比赛与标签
> **比赛**: NowCoder

> **标签**: 二维滑动窗口, 预处理

> **难度**: *1900

## 题目大意喵~

各位看官，乃好呀！咱是乃们的猫娘解题官，喵~ 今天我们要解决的是一个关于五彩斑斓的袜子的问题，听起来就很有趣对不对？

事情是这样哒：有一个名叫小灰灰的同学，他有一个巨大的 $n \times n$ 方格盒子，里面装满了袜子。每个格子 `(i, j) 都有一只颜色为 $c_{i,j}$ 的袜子。

小灰灰眼神不太好，每次找袜子时，他只会盯着一个 $K \times K$ 的区域看。现在，小蓝提出了 $m$ 个问题，每个问题都会给出一个 $K \times K$ 区域的左上角坐标 $(x, y)$。我们需要帮小灰灰回答，在他盯住的这个 $K \times K$ 区域里，有多少种颜色的袜子，他至少能找到两只（也就是能凑成一双）？

简单来说，就是对 $m$ 个指定的 $K \times K$ 子矩阵，分别求出其中出现次数 $\ge 2$ 的颜色种类数，的说。

## 解题思路分析

喵~ 这个问题看起来有点棘手，尤其是当 $m$ 和 $n$ 都很大的时候。让本猫娘来带大家一步步把它搞定吧！

### 暴力出奇迹？喵呜~

最直接的想法，就是小蓝每问一次，咱就老老实实地去数一次。对于每个查询的左上角 $(x, y)$，我们都遍历一遍从 $(x, y)$ 到 $(x+K-1, y+K-1)$ 的所有袜子。

1.  开一个计数器数组 counts（或者哈希表），用来记录每种颜色袜子的数量。
2.  遍历这个 $K \times K$ 的区域，把每只袜子的颜色都在 counts` 里加一。
3.  遍历完后，再检查一遍 `counts 数组，看看有多少个颜色的计数值是大于等于 2 的。

这个方法思路清晰，但是效率怎么样呢？每次查询都要遍历 $K \times K$ 个格子，总共有 $m$ 次查询。所以总的时间复杂度就是 $O(m \cdot K^2)$。

让我们看看数据范围：$n \le 700, m \le 10^5, K \le n$。在最坏的情况下，$m$ 和 $K$ 都很大，比如 $10^5 \times 700^2$，这可是一个天文数字，计算机会累坏的！所以，暴力的方法是行不通的，喵~

### 聪明的预处理大法！

既然每次查询都重新计算太慢了，那我们能不能换个思路呢？小蓝的查询都是针对固定的 $K \times K$ 区域的，这些区域的数量是有限的。我们可以不可以提前把 **所有** 可能的 $K \times K$ 区域的答案都算出来，存起来呢？

这样一来，每次小蓝提问，我们只需要 $O(1)$ 的时间就能从我们预先算好的答案表里直接找到答案！这就像猫咪提前把所有玩具藏在各个角落，想玩哪个直接去拿就行啦，不用每次都翻箱倒柜地找，嘻嘻~

这个方法的核心就变成了：**如何高效地计算出所有 $(N-K+1) \times (N-K+1)$ 个 $K \times K$ 窗口的答案？**

### 神奇的二维滑动窗口！

这就是我们今天的主角——**二维滑动窗口**！

想象一下，我们有一个 $K \times K$ 的“观察窗”。当我们把它从位置 $(r, c)$ 移动到相邻的位置 $(r, c+1)$ 时，发生了什么变化？

*   整个窗口向右平移了一格。
*   第 $c$ 列的袜子，从我们的视野里消失了。
*   第 $c+K$ 列的袜子，进入了我们的视野。
*   中间的 $K \times (K-1)$ 部分是完全重合的，根本不需要重新计算！

我们只需要更新那些“离开”和“进入”的袜子对答案的影响就好啦！这个思想就是滑动窗口的核心。

**具体更新逻辑是这样哒：**

我们维护一个全局的颜色计数器 color_counts` 和一个当前答案 `current_pair_count`。

-   **当一只颜色为 `C` 的袜子离开窗口时**：
    1.  `color_counts[C]` 减 1。
    2.  如果 `color_counts[C]` 在减 1 之前正好是 2，说明我们刚刚拆散了一对 `C` 色的袜子，所以 `current_pair_count` 需要减 1。

-   **当一只颜色为 `C` 的袜子进入窗口时**：
    1.  `color_counts[C]` 加 1。
    2.  如果 `color_counts[C]` 在加 1 之后正好是 2，说明我们刚刚凑成了一对新的 `C` 色袜子，所以 `current_pair_count` 需要加 1。

**滑动的路径**

为了能用上这个技巧，我们需要规划一条路线，让窗口能一步一步地滑过所有可能的位置。一个非常优雅的路径是“蛇形遍历”：

1.  首先，花 $O(K^2)$ 的时间计算出最左上角 `(1, 1)` 窗口的初始答案。
2.  从 `(1, 1)` 开始，一直向右滑动，直到 `(1, N-K+1)`，填满我们答案表的第一行。
3.  然后，从 `(1, N-K+1)` 向下滑动一格到 `(2, N-K+1)`。
4.  接着，从 `(2, N-K+1)` 开始，一直向左滑动，直到 `(2, 1)`，填满答案表的第二行。
5.  再向下滑动一格到 `(3, 1)`，然后向右滑...

就像这样，一行向右，一行向左，像小蛇一样蜿蜒前进，喵~

```
(1,1) -> -> -> (1,N-K+1)
                  |
(2,1) <- <- <- (2,N-K+1)
  |
(3,1) -> -> -> ...
``

每一次滑动（无论是左、右还是下），我们都只需要更新 $K$ 个离开的格子和 $K$ 个进入的格子，所以单次滑动的复杂度是 $O(K)$。总共有大约 $(N-K+1)^2$ 个窗口位置，所以预处理的总复杂度是 $O(K^2 + (N-K+1)^2 \cdot K)$，约等于 $O(N^2 K)$。

虽然这个复杂度看起来还是有点高，但在本题给定的条件下是可以通过的哦！预处理完成后，所有 $m$ 个查询就都是 $O(1)$ 的啦！

## 代码实现

下面是本猫娘根据上面的思路，精心重构的一份代码，加了详细的注释，希望能帮到你，喵~

``cpp
#include <iostream>
#include <vector>
#include <map>

// 使用猫娘最喜欢的快读快写，让程序跑得飞快~
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
}

int main() {
    fast_io();

    int n, m, k;
    std::cin >> n >> m >> k;

    // 用 vector 来存储袜子颜色的网格，喵~
    std::vector<std::vector<int>> grid(n, std::vector<int>(n));
    int max_color = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> grid[i][j];
            if (grid[i][j] > max_color) {
                max_color = grid[i][j];
            }
        }
    }

    // 预处理所有 KxK 窗口的答案
    std::vector<std::vector<int>> answers(n - k + 1, std::vector<int>(n - k + 1));
    std::vector<int> color_counts(max_color + 1, 0);
    int current_pair_count = 0;

    // 1. 计算第一个窗口 (0, 0) 的初始值
    for (int i = 0; i < k; ++i) {
        for (int j = 0; j < k; ++j) {
            int color = grid[i][j];
            color_counts[color]++;
            if (color_counts[color] == 2) {
                current_pair_count++;
            }
        }
    }
    answers[0][0] = current_pair_count;

    // 2. 蛇形遍历，滑动窗口计算所有答案
    for (int r = 0; r < n - k + 1; ++r) {
        if (r % 2 == 0) { // 偶数行，从左向右滑
            for (int c = 0; c < n - k; ++c) {
                // 移除左边一列
                for (int i = 0; i < k; ++i) {
                    int old_color = grid[r + i][c];
                    if (color_counts[old_color] == 2) {
                        current_pair_count--;
                    }
                    color_counts[old_color]--;
                }
                // 添加右边一列
                for (int i = 0; i < k; ++i) {
                    int new_color = grid[r + i][c + k];
                    color_counts[new_color]++;
                    if (color_counts[new_color] == 2) {
                        current_pair_count++;
                    }
                }
                answers[r][c + 1] = current_pair_count;
            }
        } else { // 奇数行，从右向左滑
            for (int c = n - k; c > 0; --c) {
                // 移除右边一列
                for (int i = 0; i < k; ++i) {
                    int old_color = grid[r + i][c + k -1];
                    if (color_counts[old_color] == 2) {
                        current_pair_count--;
                    }
                    color_counts[old_color]--;
                }
                // 添加左边一列
                for (int i = 0; i < k; ++i) {
                    int new_color = grid[r + i][c - 1];
                    color_counts[new_color]++;
                    if (color_counts[new_color] == 2) {
                        current_pair_count++;
                    }
                }
                answers[r][c - 1] = current_pair_count;
            }
        }

        // 如果不是最后一行，就向下滑动一格
        if (r + 1 < n - k + 1) {
            int current_c = (r % 2 == 0) ? (n - k) : 0;
            // 移除最上面一行
            for (int j = 0; j < k; ++j) {
                int old_color = grid[r][current_c + j];
                if (color_counts[old_color] == 2) {
                    current_pair_count--;
                }
                color_counts[old_color]--;
            }
            // 添加最下面一行
            for (int j = 0; j < k; ++j) {
                int new_color = grid[r + k][current_c + j];
                color_counts[new_color]++;
                if (color_counts[new_color] == 2) {
                    current_pair_count++;
                }
            }
            answers[r + 1][current_c] = current_pair_count;
        }
    }

    // 3. 回答 m 个查询
    for (int i = 0; i < m; ++i) {
        int r, c;
        std::cin >> r >> c;
        // 题目是1-based索引，我们代码是0-based，需要转换一下
        std::cout << answers[r - 1][c - 1] << "\n";
    }

    return 0;
}
``

## 复杂度分析

-   **时间复杂度**: $O(N^2 K + M)$
    -   预处理部分：计算第一个窗口需要 $O(K^2)$。之后有大约 $(N-K+1)^2$ 个窗口位置，每个位置都是从相邻位置通过 $O(K)$ 的操作滑过来的。总的预处理时间复杂度是 $O(K^2 + (N-K+1)^2 \cdot K)$，可以近似看作 $O(N^2 K)$。
    -   查询部分：预处理之后，每个查询都只是一个数组查询，所以 $M$ 个查询总共需要 $O(M)$ 的时间。
    -   总和起来就是 $O(N^2 K + M)$。

-   **空间复杂度**: $O(N^2 + C_{max})$
    -   我们需要 $O(N^2)$ 的空间来存储输入的袜子网格 grid`。
    -   还需要 $O((N-K+1)^2)$ 的空间来存储预处理的答案 `answers`，这也是 $O(N^2)$ 级别的。
    -   颜色计数器 `color_counts` 需要 $O(C_{max})$ 的空间，其中 $C_{max}$ 是颜色的最大编号。

## 知识点总结

这道题真是一次有趣的冒险，喵~ 我们可以从中学会：

1.  **预处理思想**: 当遇到大量重复性查询时，可以考虑“一次性计算，多次使用”的预处理思想。这是一种用空间换时间的经典策略。
2.  **二维滑动窗口**: 这是在二维数据结构（如矩阵）上进行高效计算的利器。核心在于，当窗口移动时，只关注变化的部分，而不是全部重新计算。
3.  **蛇形遍历**: 一种巧妙的遍历方式，可以保证二维滑动窗口每次只移动一格，从而使得每次更新的代价最小化。
4.  **差分更新**: 在滑动窗口中，我们对计数的更新是基于“进入”和“离开”的元素的，这本质上是一种差分思想。

希望这篇题解能帮到大家！如果还有问题，随时可以来找本猫娘哦，喵~ 祝大家刷题愉快！