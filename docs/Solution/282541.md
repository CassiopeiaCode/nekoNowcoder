# 夺棒 - 题解

### 比赛与标签
> **比赛**: 牛客练习赛120
> **标签**: 期望, 概率, 数学, 思维
> **难度**: *2500

## 题目大意喵~
主人 sama，欢迎来到猫娘的题解小屋喵~ 这次我们要解决的是一道关于期望的有趣问题呐！

题目是这样子的：我们有一个长度为 `n` 的序列 `a`，代表 `n` 个人的才能。
- 有些人的才能是已经确定的，`a[i]` 是一个 `[1, m]` 之间的数字，代表第 `i` 个人擅长第 `a[i]` 个方面。
- 还有些人是待定的，`a[i]` 是 `0`，表示这个人的才能会从 `[1, m]` 中等概率随机选择一个。

现在，红方会随机选择一个区间 `[l, r]` (其中 `1 <= l <= r <= n`) 进行攻击。一个区间的“牢固度”被定义为这个区间内 **不同才能的种数**。

我们的任务就是，计算在所有可能的随机情况下（包括随机选人和随机选区间），区间牢固度的 **期望值** 是多少。最后结果要对 `998244353` 取模哦！

## 解题思路大揭秘！
一看到“期望”两个字，猫娘的DNA就动了喵！这种时候，**期望的线性性质** 就是我们的超级武器呐！

#### 第一步：期望的线性性
一个区间的期望牢固度，等于区间内每一种才能（颜色）出现的概率之和。
也就是说：
`E(一个区间里的不同才能数) = Σ (对于所有才能 c from 1 to m) P(才能 c 在这个区间里出现)`

因为区间也是随机选的，所以我们要求的是在所有 `n*(n+1)/2` 个区间上的期望的平均值。根据期望的线性性质，我们可以先计算每种才能 `c` 对总期望的贡献，再加起来。

`总期望值 = Σ (对于所有才能 c from 1 to m) P(才能 c 在一个随机选的区间里出现)`

#### 第二步：正难则反
直接计算“出现”的概率有点麻烦的说，因为它可能出现在一个位置，也可能出现在好多个位置。不如我们反过来想想？计算“才能 c 在区间中 **不** 出现”的概率，然后用 1 减掉它，是不是就简单多啦？

`P(c 出现) = 1 - P(c 不出现)`

代入上面的公式，总期望值就变成了：
`总期望值 = Σ (1 - P(c 不出现)) = m - Σ P(c 在一个随机选的区间里不出现)`

我们的目标就变成了计算 **“对于每一种才能 c，它在一个随机区间 [l, r] 中不出现的概率”**，然后把它们都加起来！

#### 第三步：聚焦单个才能 c
我们来分析一下，对于一个固定的才能 `c` 和一个固定的区间 `[l, r]`，它不出现的概率是多少。
1.  首先，这个区间 `[l, r]` **不能包含** 任何一个已经确定为才能 `c` 的位置。如果包含了，那 `c` 肯定出现，不出现的概率就是 0。
2.  其次，对于区间 `[l, r]` 内所有待定（`a[i] = 0`）的位置，它们随机选择的才能都 **不能是 c**。每一个待定位置选到非 `c` 才能的概率是 `(m-1)/m`。

假设区间 `[l, r]` 里有 `cnt0(l, r)` 个待定位置，并且没有固定的 `c` 才能。那么 `c` 在这个区间不出现的概率就是 `((m-1)/m) ^ cnt0(l, r)`。

#### 第四步：分段计算贡献
对于每种才能 `c`，我们把它所有固定的位置 `p_1, p_2, ...` 找出来。为了方便，我们再加入两个“哨兵”位置 `p_0 = 0` 和 `p_{k+1} = n+1`。

这样，整个序列 `[1, n]` 就被这些固定位置分成了好几个小段 `[p_j + 1, p_{j+1} - 1]`。
一个区间 `[l, r]` 如果想要满足“不包含固定才能c”的条件，它就必须 **完全** 位于某一个小段 `[p_j + 1, p_{j+1} - 1]` 内部。

所以，对于才能 `c`，所有让它“可能不出现”的区间 `[l, r]`，都存在于这些小段中。
我们需要计算的就是：
`Σ_{所有小段 j} Σ_{l,r 在第 j 个小段内} P(c 在 [l,r] 中不出现)`

#### 第五步：前缀和加速！
最关键的一步来啦！我们怎么快速计算一个小段 `[L, R]` 内所有子区间的贡献和呢？
我们要计算 `Sum = Σ_{L <= l <= r <= R} ((m-1)/m) ^ cnt0(l, r)`。

这看起来是个 O(N^2) 的双重循环，直接算肯定会超时的喵！这时候就要用 **前缀和优化** 大法！
- 设 `f = (m-1)/m`。
- 设 `z[i]` 为 `[1, i]` 中 `0` 的数量。那么 `cnt0(l, r) = z[r] - z[l-1]`。
- 设 `g[i] = f ^ z[i]`。
- 我们要求的就是 `Σ_{L <= l <= r <= R} g[r] * (g[l-1])^{-1}`。

这个式子可以被拆解和预处理：
`Sum = Σ_{r=L to R} g[r] * (Σ_{l=L to r} (g[l-1])^{-1})`

我们可以预处理出三个前缀和数组：
1. `su2[i]`: `g[k]` 的前缀和 `Σ_{k=1 to i} g[k]`
2. `su3[i]`: `(g[k])^{-1}` 的前缀和 `Σ_{k=0 to i} (g[k])^{-1}`
3. `su[i]`: `g[k] * su3[k-1]` 的前缀和 `Σ_{k=1 to i} g[k] * su3[k-1]`

通过这三个数组，我们就可以用 O(1) 的时间计算出任意 `S(L, R)` 的值啦！具体的推导有点复杂，但核心思想就是把双重循环拆成可以通过前缀和相减得到的项。

最后，我们对每种才能 `c`，把它对应的所有小段的贡献和加起来，得到一个总和 `TotalSum`。
`P(c 不出现)` 的总和就是 `TotalSum`。
最终答案就是 `m - (Σ_{c=1 to m} TotalSum_c) / (总区间数)`。

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
#define MOD 998244353

// 快速幂，喵~ 用来求 a^b % MOD
inline int pw(int a,int b) {
    int as=1;
    while(b) {
        if(b&1) as=1ll*as*a%MOD;
        a=1ll*a*a%MOD;
        b>>=1;
    }
    return as;
}

// 求逆元，根据费马小定理 a^(MOD-2) 就是 a 的逆元
inline int ni(int a) {
    return pw(a,MOD-2);
}

int N,M,a[5000009],gl[5000009],su2[5000009],su3[5000009],su[5000009];
std::vector<int> t[5000009]; // t[c] 存储才能 c 出现的所有位置

// 这个函数 cl(l, r) 就是我们上面说的 S(l, r)
// 用 O(1) 的时间计算出 Σ_{l <= i <= j <= r} ((m-1)/m)^cnt0(i,j)
int cl(int l,int r) {
    if (l > r) return 0; // 如果区间无效，贡献为0
    int ans=(su[r]-su[l-1]+MOD)%MOD;
    if(l>1) ans=(ans+1ll*(su2[r]-su2[l-1]+MOD)*(MOD-su3[l-2]))%MOD;
    return ans;
}

signed main(void) {
    scanf("%d %d",&N,&M);
    
    // f 是 (m-1)/m，即某个待定位置不选到某个特定才能的概率
    int f=1ll*(M-1)*ni(M)%MOD;
    
    // gl[i] 存的是 f 的 (前 i 个位置中 0 的数量) 次方
    gl[0]=1;
    for(int i=1;i<=N;i++) {
        scanf("%d",&a[i]);
        gl[i]=gl[i-1];
        if(a[i]) t[a[i]].push_back(i); // 如果才能确定，记录位置
        else gl[i]=1ll*gl[i]*f%MOD;   // 如果是待定，多乘一个 f
    }

    // 预处理三个前缀和数组，喵~
    su3[0]=1; // su3[i] = Σ_{k=0 to i} (gl[k])^{-1}
    su2[0]=1; // su2[i] = Σ_{k=0 to i} gl[k] (代码实现是从1开始，但su2[0]设为1便于计算)
    // su[i] = Σ_{k=1 to i} gl[k] * su3[k-1]
    for(int i=1;i<=N;i++) {
        su3[i]=(su3[i-1]+ni(gl[i]))%MOD;
        su2[i]=(su2[i-1]+gl[i])%MOD;
        su[i]=(su[i-1]+1ll*gl[i]*su3[i-1])%MOD;
    }

    int ans=0; // ans 用来累计 Σ P(c不出现于[l,r])
    for(int i=1;i<=M;i++) {
        t[i].push_back(N+1); // 加入右边界哨兵 n+1
        int la=0; // la (last) 是上一个固定位置，初始为0
        for(int j=0;j<t[i].size();j++) {
            // 计算小段 [la+1, t[i][j]-1] 的贡献和
            ans=(ans+cl(la+1,t[i][j]-1))%MOD;
            la=t[i][j]; // 更新上一个固定位置
        }
    }   
    
    // ans 现在是 Σ_{c} Σ_{[l,r]} P(c不出现于[l,r])
    // 我们要除以总区间数，得到 Σ P(c在一个随机区间不出现)
    long long total_intervals = 1ll * N * (N + 1) / 2 % MOD;
    ans = 1ll * ans * ni(total_intervals) % MOD;
    
    // 最终答案是 m - Σ P(c不出现)
    ans = (M - ans + MOD) % MOD;
    printf("%d",ans);
}
```

## 复杂度分析的说
- **时间复杂度**: O(N + M) 的说
  预处理 `gl` 数组和三个前缀和数组 `su`, `su2`, `su3` 的时间是 O(N)。
  主循环遍历 `M` 种才能。对于每种才能，我们遍历其所有固定出现的位置。因为每个位置最多只属于一种固定才能，所以所有才能的固定位置总数不会超过 `N`。因此，这部分的总时间复杂度是 O(N + M)。
  总的来说，就是 O(N + M)，非常高效！

- **空间复杂度**: O(N + M) 的说
  我们用了 `a`, `gl`, `su`, `su2`, `su3` 这几个大小为 `N` 的数组，以及一个 `t` 数组来存储 `M` 种才能的位置，总共占用的空间是 O(N+M)。空间也完全够用呢，喵~

## 知识点与总结
这道题真是一次精彩的思维体操呢！我们来总结一下用到的法宝吧：

1.  **期望的线性性**: 绝对的核心！遇到期望问题，第一时间就应该想到它。它能把一个复杂问题分解成一堆简单子问题的和，是解决期望题目的万能钥匙！
2.  **正难则反 (Complementary Thinking)**: 当直接计算一个事件的概率很复杂时，不妨试试计算它的对立事件的概率。`P(出现) = 1 - P(不出现)` 这个简单的公式威力无穷！
3.  **前缀和优化**: 对于求解特定形式的区间和问题，前缀和是降维打击的神器。本题中对 `Σ g[r] * (g[l-1])^{-1}` 形式的和的优化是一个非常经典的技巧，值得主人 sama 记在小本本上哦！
4.  **分段计算与哨兵思想**: 通过固定点（哨兵）将整个序列切分成互不影响的段落，然后对每个段落分别计算贡献，最后汇总。这也是处理带有固定点约束问题的一个常用思路。

希望这篇题解能帮助到主人 sama 哦！继续加油，在算法的世界里探险吧！喵~