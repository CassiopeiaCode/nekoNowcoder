# 随机序列区间期望颜色数 - 题解

### 比赛与标签
> **比赛**: 未提供
> **标签**: 未提供
> **难度**: 未提供

喵~ 主人，这道题的侧边栏信息是空的呢，所以比赛、标签和难度评分就只好留空啦。不过没关系，我们依然可以漂亮地解决它！

## 题目大意喵~

主人你好呀！这道题是说，我们有一个长度为 $n$ 的序列 $a$，代表着 $n$ 个位置上的人员安排。序列里的每个数字 $a_i$ 代表第 $i$ 个人的才能（也就是颜色），一共有 $m$ 种不同的才能。

这个序列有点特别哦：
*   如果 $a_i$ 是一个从 $1$ 到 $m$ 的正整数，那这个位置上的人选和他的才能就已经定下来啦。
*   如果 $a_i$ 是 $0$，那这个位置的人还没定，他的才能会从 $[1, m]$ 这 $m$ 种才能里等概率随机选一种。

题目定义了一个区间的“牢固度”，就是这个区间里不同才能（颜色）的数量。

现在，红方会从所有可能的区间 $[l, r]$（其中 $1 \le l \le r \le n$）中，等概率随机选一个进行攻击。我们的任务就是，计算出这个随机选出的攻击区间的“牢固度”的**期望值**是多少。

最后的结果需要对 $998244353$ 取模，可不能忘了哦！

## 解题思路分析

这道题要求我们计算一个随机事件的期望值，一看到“期望”两个字，本猫娘的DNA就动了，喵！对付期望问题，有一个超级好用的法宝，那就是**期望的线性性**！

**期望的线性性**告诉我们，“和的期望”等于“期望的和”。这让我们可以把一个复杂的大问题，拆解成一堆简单的小问题分别计算，最后再加起来，是不是很方便呀？

#### 第一步：拆解期望

我们要求的期望是“随机区间的颜色数”。
设 $N_{intervals} = \frac{n(n+1)}{2}$ 是总的区间数量。
设 $C(l,r)$ 是区间 $[l,r]$ 的颜色数。
我们要计算的是 $E[\text{随机区间的颜色数}] = \frac{1}{N_{intervals}} \sum_{1 \le l \le r \le n} E[C(l,r)]$。

这里的 $E[C(l,r)]$ 是对于一个**固定**的区间 $[l,r]$，它的期望颜色数（因为序列中的 $0$ 是随机的嘛）。

我们再用一次期望的线性性！一个区间里的颜色数，可以看成是“颜色1出现”+“颜色2出现”+...+“颜色m出现”的和（这里用指示函数 $I$ 来表示，如果颜色 $c$ 出现则 $I_c=1$，否则为 $0$）。
$$
E[C(l,r)] = E[\sum_{c=1}^{m} I(c \text{ 在 } [l,r] \text{ 中出现})] = \sum_{c=1}^{m} E[I(c \text{ 在 } [l,r] \text{ 中出现})]
$$
一个指示函数的期望，就是它取值为1的概率。所以：
$$
E[C(l,r)] = \sum_{c=1}^{m} P(c \text{ 在 } [l,r] \text{ 中出现})
$$
把这个代回到最开始的式子里，得到：
$$
E[\text{总}] = \frac{1}{N_{intervals}} \sum_{1 \le l \le r \le n} \sum_{c=1}^{m} P(c \text{ 在 } [l,r] \text{ 中出现})
$$
我们交换一下求和的顺序，先对颜色求和：
$$
E[\text{总}] = \frac{1}{N_{intervals}} \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} P(c \text{ 在 } [l,r] \text{ 中出现})
$$
这个式子看起来清爽多了！我们可以对每一种颜色 $c$ 单独计算它的贡献，最后加起来。

#### 第二步：正难则反，切换思路

计算“出现”的概率有点麻烦，因为它只要出现一次就算。我们不妨换个角度，计算它“不出现”的概率，这个就简单多啦！
$$
P(c \text{ 出现}) = 1 - P(c \text{ 不出现})
$$
代入上面的总期望公式：
$$
E[\text{总}] = \frac{1}{N_{intervals}} \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} (1 - P(c \text{ 在 } [l,r] \text{ 中不出现}))
$$
$$
E[\text{总}] = \frac{1}{N_{intervals}} \left( \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} 1 - \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} P(c \text{ 不出现}) \right)
$$
$$
E[\text{总}] = \frac{1}{N_{intervals}} \left( m \cdot N_{intervals} - \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} P(c \text{ 不出现}) \right)
$$
$$
E[\text{总}] = m - \frac{1}{N_{intervals}} \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} P(c \text{ 在 } [l,r] \text{ 中不出现})
$$
好耶！问题转化成了计算所有颜色、所有区间，“颜色c不出现”的概率之和。我们把它记作 $T_{total}$。
$T_{total} = \sum_{c=1}^{m} \sum_{1 \le l \le r \le n} P(c \text{ 在 } [l,r] \text{ 中不出现})$。

#### 第三步：计算“不出现”的概率

颜色 $c$ 在区间 $[l,r]$ 中不出现，意味着对于所有 $i \in [l,r]$，都有 $a_i \neq c$。
*   如果 $a_i$ 是一个固定的颜色 $k$，且 $k=c$，那么 $P(a_i \neq c) = 0$。
*   如果 $a_i$ 是一个固定的颜色 $k$，且 $k \neq c$，那么 $P(a_i \neq c) = 1$。
*   如果 $a_i=0$，那么 $a_i$ 可以是 $[1,m]$ 中的任意一个，所以 $P(a_i \neq c) = \frac{m-1}{m}$。

由于每个位置的随机选择是独立的，所以 $P(c \text{ 不出现}) = \prod_{i=l}^{r} P(a_i \neq c)$。

如果区间 $[l,r]$ 里有任何一个位置 $j$ 的颜色被固定为 $c$（即 $a_j=c$），那么 $P(c \text{ 不出现}) = 0$。
所以，对于一个颜色 $c$，我们只需要考虑那些**完全不包含**任何固定颜色 $c$ 的区间。

这些区间被固定的颜色 $c$ 分割成了一段一段的。比如，如果颜色 $c$ 出现在位置 $p_1, p_2, \dots, p_k$，那么我们只需要考虑在 $(0, p_1), (p_1, p_2), \dots, (p_k, n+1)$ 这些开区间内部的子区间。

在这样一段“纯净”的区间（比如从 $L+1$ 到 $R-1$）里，对于任意 $i$，都有 $a_i \neq c$。所以 $P(a_i \neq c)$ 要么是 $1$（当 $a_i$ 是其他固定颜色），要么是 $\frac{m-1}{m}$（当 $a_i=0$）。
我们定义一个值 $g_i$：
*   $g_i = \frac{m-1}{m}$ 如果 $a_i = 0$
*   $g_i = 1$ 如果 $a_i > 0$

那么，对于一个不包含固定颜色 $c$ 的区间 $[l,r]$， $P(c \text{ 不出现}) = \prod_{i=l}^{r} g_i$。

我们的总和 $T_{total}$ 就变成了：
$$
T_{total} = \sum_{c=1}^{m} \sum_{\text{区间 } [l,r] \text{ 不含固定c}} \prod_{i=l}^{r} g_i
$$
注意到 $\prod_{i=l}^{r} g_i$ 这个值跟具体的颜色 $c$ 无关！它只跟区间 $[l,r]$ 内 $0$ 的个数有关。

#### 第四步：高效计算 $T_{total}$

直接计算 $T_{total}$ 还是太慢了，是 $O(N^2 M)$ 级别的。我们需要一个更快的办法！
我们可以把贡献按“纯净”的片段来计算。
对于颜色 $c$，设它出现的位置为 $p_{c,1}, p_{c,2}, \dots$。这些位置把 $[1,n]$ 分割成了多个片段。
$T_{total}$ 就是对所有颜色 $c$ 的所有片段，计算其内部所有子区间的 $\prod g_i$ 之和。
设 $S(i, j) = \sum_{l=i}^{j} \sum_{r=l}^{j} \prod_{k=l}^{r} g_k$。
那么 $T_{total} = \sum_{c=1}^{m} \sum_{\text{片段 } [i,j] \text{ of } c} S(i,j)$。

如果我们能快速算出 $S(i,j)$，问题就解决了！$S(i,j)$ 的计算看起来像是 $O((j-i)^2)$，但可以用前缀和优化到 $O(1)$！这需要一点点数学魔法，喵~

令 $G_k = \prod_{t=1}^{k} g_t$ (前缀积)，$G_0=1$。那么 $\prod_{k=l}^r g_k = G_r / G_{l-1}$。
$S(i,j) = \sum_{l=i}^{j} \sum_{r=l}^{j} \frac{G_r}{G_{l-1}}$。
交换求和次序：
$S(i,j) = \sum_{r=i}^{j} \sum_{l=i}^{r} \frac{G_r}{G_{l-1}} = \sum_{r=i}^{j} G_r \sum_{l=i}^{r} G_{l-1}^{-1}$。

令 $SumGinv_{k} = \sum_{t=0}^{k} G_t^{-1}$ (前缀和的逆元的前缀和)。
则 $\sum_{l=i}^{r} G_{l-1}^{-1} = SumGinv_{r-1} - SumGinv_{i-2}$。
$S(i,j) = \sum_{r=i}^{j} G_r (SumGinv_{r-1} - SumGinv_{i-2})$
$S(i,j) = \sum_{r=i}^{j} G_r \cdot SumGinv_{r-1} - SumGinv_{i-2} \sum_{r=i}^{j} G_r$

令 $SumG_k = \sum_{t=1}^k G_t$ (前缀积的前缀和)。
令 $P_k = G_k \cdot SumGinv_{k-1}$，再求它的前缀和 $SumP_k = \sum_{t=1}^k P_t$。
那么：
$S(i,j) = (SumP_j - SumP_{i-1}) - SumGinv_{i-2} \cdot (SumG_j - SumG_{i-1})$。

通过预处理 $G, SumG, SumGinv, SumP$ 这四个数组，我们就可以在 $O(1)$ 时间内算出任意 $S(i,j)$ 啦！整个预处理过程是 $O(N)$ 的。

#### 第五步：最终的算法

1.  **预处理 ($O(N)$)**:
    *   计算 $g_i$ 数组。
    *   计算前缀积 $G_i$ 和它的逆元 $G_i^{-1}$。
    *   计算 $SumG_i$, $SumGinv_i$, $SumP_i$ 等所有需要的前缀和数组。

2.  **计算 $T_{total}$ ($O(N+M)$)**:
    *   创建一个 `last_pos` 数组，大小为 $m+1$，初始化为 $0$，记录每种颜色上一次出现的位置。
    *   初始化 $T_{total} = 0$。
    *   遍历序列 $a$ from $i=1$ to $n$:
        *   如果 $a_i > 0$（是一个固定颜色 $c=a_i$）：
            *   它与上一个 $c$ 的位置 `last_pos[c]` 形成了一个“纯净”片段 `[last_pos[c] + 1, i - 1]`。
            *   计算 $S(\text{last\_pos}[c] + 1, i - 1)$ 并累加到 $T_{total}$。
            *   更新 `last_pos[c] = i`。
    *   遍历完序列后，对于每种颜色 $c$ from $1$ to $m$：
        *   最后一个 $c$ 的位置 `last_pos[c]` 与序列末尾 $n$ 形成了一个片段 `[last_pos[c] + 1, n]`。
        *   计算 $S(\text{last\_pos}[c] + 1, n)$ 并累加到 $T_{total}$。

3.  **计算最终答案**:
    *   $N_{intervals} = \frac{n(n+1)}{2} \pmod{MOD}$。
    *   最终期望值是 $(m - T_{total} \cdot (N_{intervals})^{-1}) \pmod{MOD}$。注意负数取模要加上模数。

这样，我们就在 $O(N+M)$ 的时间里解决了这个问题，是不是超级厉害，喵~

## 代码实现

这是本猫娘根据上面的思路，全新编写的代码哦，希望能帮助主人更好地理解！

```cpp
#include <iostream>
#include <vector>
#include <numeric>

// 使用 long long 防止乘法溢出
using ll = long long;

const int MOD = 998244353;
const int MAXN = 5000000 + 5;

int n, m;
int a[MAXN];

// 快速幂，用于计算模逆元
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 费马小定理求模逆元
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// g_i 的前缀积
ll g_prefix_prod[MAXN];
// g_i 的前缀积的逆元
ll g_inv_prefix_prod[MAXN];
// g_prefix_prod 的前缀和
ll sum_g_prefix_prod[MAXN];
// g_inv_prefix_prod 的前缀和
ll sum_g_inv_prefix_prod[MAXN];
// (g_prefix_prod * sum_g_inv_prefix_prod) 的前缀和
ll sum_term[MAXN];

int last_pos[MAXN];

// O(1) 计算 S(start, end)
ll calculate_S(int start, int end) {
    if (start > end) {
        return 0;
    }

    // S(i,j) = (SumP_j - SumP_{i-1}) - SumGinv_{i-2} * (SumG_j - SumG_{i-1})
    // 对应到我们的变量名:
    // S(start, end) = (sum_term[end] - sum_term[start-1]) - sum_g_inv_prefix_prod[start-2] * (sum_g_prefix_prod[end] - sum_g_prefix_prod[start-1])

    ll term1 = (sum_term[end] - sum_term[start - 1] + MOD) % MOD;
    
    ll term2_factor1 = (start >= 2) ? sum_g_inv_prefix_prod[start - 2] : 0;
    ll term2_factor2 = (sum_g_prefix_prod[end] - sum_g_prefix_prod[start - 1] + MOD) % MOD;
    ll term2 = (term2_factor1 * term2_factor2) % MOD;

    return (term1 - term2 + MOD) % MOD;
}

int main() {
    // 加速输入喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
    }

    // --- 预处理阶段 ---
    ll g_val_if_zero = ((ll)(m - 1) * modInverse(m)) % MOD;

    g_prefix_prod[0] = 1;
    g_inv_prefix_prod[0] = 1;
    sum_g_prefix_prod[0] = 1; // 包含 g_prefix_prod[0]
    sum_g_inv_prefix_prod[0] = 1; // 包含 g_inv_prefix_prod[0]
    sum_term[0] = 0;

    for (int i = 1; i <= n; ++i) {
        ll g_i = (a[i] == 0) ? g_val_if_zero : 1;
        
        g_prefix_prod[i] = (g_prefix_prod[i - 1] * g_i) % MOD;
        g_inv_prefix_prod[i] = modInverse(g_prefix_prod[i]);

        sum_g_prefix_prod[i] = (sum_g_prefix_prod[i - 1] + g_prefix_prod[i]) % MOD;
        sum_g_inv_prefix_prod[i] = (sum_g_inv_prefix_prod[i - 1] + g_inv_prefix_prod[i]) % MOD;
        
        // P_i = G_i * SumGinv_{i-1}
        ll p_i = (g_prefix_prod[i] * sum_g_inv_prefix_prod[i - 1]) % MOD;
        sum_term[i] = (sum_term[i - 1] + p_i) % MOD;
    }

    // --- 计算 T_total ---
    ll total_S = 0;

    // 遍历序列处理固定颜色分割的片段
    for (int i = 1; i <= n; ++i) {
        if (a[i] > 0) {
            int color = a[i];
            total_S = (total_S + calculate_S(last_pos[color] + 1, i - 1)) % MOD;
            last_pos[color] = i;
        }
    }

    // 处理每个颜色最后一次出现到序列末尾的片段
    for (int c = 1; c <= m; ++c) {
        total_S = (total_S + calculate_S(last_pos[c] + 1, n)) % MOD;
    }

    // --- 计算最终结果 ---
    ll total_intervals = ((ll)n * (n + 1) / 2) % MOD;
    ll inv_total_intervals = modInverse(total_intervals);

    ll expectation = (m - (total_S * inv_total_intervals) % MOD + MOD) % MOD;

    std::cout << expectation << std::endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N + M)$
    *   预处理所有前缀和数组需要遍历一次序列，复杂度是 $O(N)$。
    *   计算 `total_S` 的主循环遍历一次序列，其中对 `calculate_S` 的调用是 $O(1)$ 的。这部分是 $O(N)$。
    *   最后处理到序列末尾的片段，需要遍历所有颜色，复杂度是 $O(M)$。
    *   所以总时间复杂度是 $O(N+M)$，对于这道题的数据范围来说是完全可以接受的，喵！

*   **空间复杂度**: $O(N + M)$
    *   我们用了几个长度为 $N+1$ 的数组来存储前缀和，这部分是 $O(N)$。
    *   `last_pos` 数组的长度为 $M+1$，所以是 $O(M)$。
    *   总空间复杂度是 $O(N+M)$。

## 知识点总结

这道题真是一次有趣的冒险呢！我们用到了不少好玩的工具：

1.  **期望的线性性**: 这是解决概率期望问题的万能钥匙！它可以把复杂问题分解，是我们的核心思想。
2.  **补集思想 (正难则反)**: 当直接计算“至少一个”很困难时，可以尝试计算“一个都没有”的概率，然后用1去减。
3.  **前缀和与前缀积**: 这是序列问题中加速区间查询的经典技巧。这道题把它用到了极致，通过多重前缀和，硬是把一个复杂的区间求和问题优化到了 $O(1)$！
4.  **贡献法/分段计算**: 我们把问题分解成一个个“纯净”的片段来计算贡献，再把它们加起来，避免了复杂的逻辑判断。
5.  **模运算**: 在算法竞赛中，处理大数和取模是基本功，要熟练掌握快速幂和求逆元哦。

希望这篇题解能帮到主人，如果还有其他问题，随时可以来找我玩，喵~ ❤