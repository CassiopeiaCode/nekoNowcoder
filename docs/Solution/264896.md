# 哈密顿路 - 题解

### 比赛与标签
> **比赛**: 暂无喵~

> **标签**: 树形DP, 动态规划

> **难度**: *2500 (这是一个高难度的DP问题哦，很有挑战性，喵~)

## 题目大意喵~

一位叫做 Crying 的朋友想在一张特殊的图里找到一条价值最高的“哈密顿路”，需要主人的帮助，喵~

事情是这样的：
1.  首先，我们有一棵 $n$ 个节点的有根树，根是节点 1。每个节点 $i$ 都有一个自己的权值 $w_i$。
2.  然后，我们要根据这棵树，凭空想象出一张 $n$ 个节点的无向完全图。在这张新图里，任意两个节点 $u$ 和 $v$ 之间都有一条边，边的权值被定义为它们在**原来那棵树**上的**最近公共祖先 (LCA)** 的节点权值，也就是 $w_{\text{LCA}(u,v)}$。
3.  我们的任务，就是在这张新构造的完全图上，找到一条**哈密顿路**。哈密顿路是一条会访问到图中**每一个节点恰好一次**的路径。
4.  在所有可能的哈密顿路中，我们要找出那条经过的边权之和最大的一条，并告诉 Crying 这个最大的总权值是多少。

简单来说，就是要在 $n$ 个节点中找出一个排列 $p_1, p_2, \dots, p_n$，使得 $\sum_{i=1}^{n-1} w_{\text{LCA}(p_i, p_{i+1})}$ 的值最大，呐。

## 解题思路分析

喵哈~ 看到这道题，我的猫猫直觉告诉我，这一定和树形DP有关！直接在完全图上找哈密顿路是 NP-Hard 问题，肯定不能暴力解决。但这张图的边权和原来的树结构紧密相关，这正是我们的突破口，的说！

#### 贡献拆分

我们想最大化的总权值是 $\sum_{i=1}^{n-1} w_{\text{LCA}(p_i, p_{i+1})}$。这个和式不太好直接处理，但我们可以换个角度看！我们可以计算每个节点的权值 $w_u$ 对总和的贡献。$w_u$ 的贡献就是 $w_u$ 乘以“有多少条哈密顿路上的边 $(a, b)$ 满足 $\text{LCA}(a, b) = u$”。

所以，问题转化为了：设计一条哈密顿路，使得 $\sum_{u=1}^{n} w_u \times (\text{LCA为u的边的数量})$ 最大。

当 $\text{LCA}(a, b) = u$ 时，节点 $a$ 和 $b$ 必定位于 $u$ 的不同子树中（或者其中一个是 $u$ 本身，另一个在 $u$ 的某个子树里）。这个性质是树形DP的经典信号！

#### 树形DP的设计

我们可以在树上从下往上进行动态规划。对于每个节点 $u$，我们计算它的子树内的节点能构成的最优路径结构。

**DP状态定义**:
$dp[u][i]$ 表示：在以 $u$ 为根的子树中，将所有节点连接起来，形成了 $i$ 条不相交的路径，此时能获得的最大边权和是多少。

这里的“边权和”指的是，对于任意一条连接子树内两点的边 $(a, b)$，如果它们的LCA也在 $u$ 的子树内，我们就把 $w_{\text{LCA}(a, b)}$ 算进去。

**DP转移 (合并子树)**:
树形DP的核心就是合并。假设我们已经处理完了 $u$ 的所有子节点，现在要把它们的信息合并到 $u$ 上。我们一个一个地合并孩子。

假设在合并子节点 $v$ 之前，节点 $u$ 和它已经合并过的其他子树的节点们，构成了一个大小为 `size_u_current` 的组件，内部形成了 $i$ 条路径，最大价值为 $dp[u][i]$。
现在我们要合并子树 $v$。$v$ 的子树大小为 `size_v，内部形成了 $j$ 条路径，最大价值为 $dp[v][j]$。

当我们把这两个组件连接起来时，新加的边一定是连接一个在 $u$ 组件的点和一个在 $v$ 子树的点。这样的边的LCA恰好就是 $u$！所以，每连一条这样的边，我们就能获得 $w_u$ 的收益。

假设我们在这两个组件之间连了 $k$ 条边。
*   **收益**: 原来的总价值是 $dp[u][i] + dp[v][j]$。现在新连了 $k$ 条边，每条边的贡献都是 $w_u$，所以总价值增加了 $k \times w_u$。
*   **路径数量变化**: 原来有 $i$ 条路径和 $j$ 条路径。每连接一条边，就会把两条路径合并成一条，总路径数减 1。连接 $k$ 条边，总路径数就减少 $k$。所以新的路径数是 $i + j - k$。

**$k$ 的取值范围**:
那么，我们最多能连多少条边呢？也就是 $k$ 的最大值是多少？
我们可以把路径看成有很多“待连接”的端口。一条路径有两个端点，可以看作有两个端口。$i$ 条路径就有 $2i$ 个端口。
$u$ 的组件有 $i$ 条路径，提供了 $2i$ 个连接机会。
$v$ 的子树有 $j$ 条路径，提供了 $2j$ 个连接机会。
每次连接消耗双方各一个机会。所以我们最多能连 $\min(2i, 2j)$ 条边。
所以 $k$ 的取值范围是 $0 \le k \le 2 \times \min(i, j)$。

于是，我们的状态转移方程就出来啦：
$$
\text{new_dp}[i+j-k] = \max(\text{new_dp}[i+j-k], dp[u][i] + dp[v][j] + k \times w_u)
$$

**DP过程**:
1.  我们用深度优先搜索（DFS）来遍历树，实现自底向上的DP。
2.  对于一个叶子节点 $u$，它自己就是一条路径。所以 $dp[u][1] = 0$，子树大小为1。
3.  对于一个非叶子节点 $u$，先将它自己视为一个大小为1，路径数为1的组件，即 $dp[u][1]=0$。
4.  然后，依次遍历 $u$ 的每个子节点 $v$：
    a. 递归调用 dfs(v)` 算好 $v$ 子树的DP值。
    b. 使用一个临时数组 `temp_dp`，根据上面的转移方程，将 $v$ 子树的信息合并到 $u$ 的当前状态中。
    c. 合并完成后，用 `temp_dp` 更新 `dp[u]`，并更新 $u$ 的组件大小。
5.  当一个节点 $u$ 的所有子树都合并完毕后，$dp[u][i]$ 就代表了整个 $u$ 子树的最优解。

**最终答案**:
我们从根节点 1 开始DFS。当整个DFS过程结束后，$dp[1][i]$ 就存储了用全部 $n$ 个节点构成 $i$ 条路径的最大价值。因为题目要求的是一条哈密顿路，也就是一条包含所有节点的路径，所以我们想要的最终答案就是 $dp[1][1]$ 啦！喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码哦！注释很详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 使用 long long 来存储权值和，防止溢出喵
using namespace std;
typedef long long LL;

const int MAXN = 305;
// 用一个非常小的负数表示负无穷，用于DP初始化
const LL INF = 1e18;

int n;
int w[MAXN]; // 每个节点的权值
vector<int> children[MAXN]; // 存储树的结构（u -> v）
LL dp[MAXN][MAXN]; // dp[u][i]：在u的子树中，构成i条路径的最大权值和
int subtree_size[MAXN]; // 记录每个节点为根的子树大小

void dfs(int u) {
    // 初始化节点u自身：大小为1，路径数为1，权值为0
    subtree_size[u] = 1;
    for (int i = 0; i <= n; ++i) {
        dp[u][i] = -INF;
    }
    dp[u][1] = 0;

    // 遍历u的所有孩子，将它们的信息合并进来
    for (int v : children[u]) {
        // 先递归处理子树v
        dfs(v);

        // 临时DP数组，用于存放合并u和v之后的结果
        LL temp_dp[MAXN];
        for (int i = 0; i <= subtree_size[u] + subtree_size[v]; ++i) {
            temp_dp[i] = -INF;
        }

        // i: u当前组件中的路径数
        for (int i = 1; i <= subtree_size[u]; ++i) {
            if (dp[u][i] < -INF / 2) continue; // 如果是不可达状态，就跳过，喵~

            // j: v子树中的路径数
            for (int j = 1; j <= subtree_size[v]; ++j) {
                if (dp[v][j] < -INF / 2) continue; // v的这个状态也是不可达的

                // k: 在u的组件和v的子树之间连接k条边
                // 最多可以连 2 * min(i, j) 条
                for (int k = 0; k <= 2 * min(i, j); ++k) {
                    int new_paths = i + j - k;
                    // 新的路径数必须大于0，我们不能形成环
                    if (new_paths > 0) {
                        LL current_val = dp[u][i] + dp[v][j] + (LL)k * w[u];
                        temp_dp[new_paths] = max(temp_dp[new_paths], current_val);
                    }
                }
            }
        }

        // 更新u的子树大小
        subtree_size[u] += subtree_size[v];
        // 将合并后的结果从temp_dp复制回dp[u]
        for (int i = 1; i <= subtree_size[u]; ++i) {
            dp[u][i] = temp_dp[i];
        }
    }
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> w[i];
    }
    for (int i = 2; i <= n; ++i) {
        int parent;
        cin >> parent;
        children[parent].push_back(i);
    }

    // 从根节点1开始进行树形DP
    dfs(1);

    // 最终答案是：在整棵树（以1为根的子树）中，形成1条路径（哈密顿路）的最大权值
    cout << dp[1][1] << endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N^3)$ 或 $O(N^4)$，这取决于具体的分析方式，但对于 $N=300$ 的数据范围是可以通过的。
    这是一个树上背包/树形DP问题。`dfs`函数访问每个节点一次。在每个节点 `u`，我们合并它的孩子 `v`。合并操作的复杂度是关键。它涉及三层循环：`i` (到 `size[u]`)，`j` (到 `size[v]`)，和 `k` (到 `2*min(i,j))。
    对两个大小为 $S_1$ 和 $S_2$ 的子树进行合并的复杂度大约是 $O(S_1 \cdot S_2 \cdot \min(S_1, S_2))$。对整个树的所有合并操作进行积分，总复杂度可以被证明在 $O(N^3)$ 到 $O(N^4)$ 之间。虽然看起来很高，但由于树形背包的特性，它在实践中跑得比最坏情况快得多，足以通过此题，喵~

*   **空间复杂度**: $O(N^2)$。
    我们需要一个二维数组 dp[N][N]` 来存储DP状态，所以空间复杂度是 $O(N^2)$。另外，递归调用 `dfs` 会产生 $O(N)$ 的栈空间。所以总空间是 $O(N^2)$。

## 知识点总结

1.  **问题转换**: 将“最大化边权和”转换为“最大化每个节点权值的贡献”，是解决这类问题的关键一步。
2.  **树形动态规划 (Tree DP)**: 这是解决树上最优化问题的强大工具。核心是设计好DP状态，并找到从子节点向父节点转移状态的方法。
3.  **树上背包模型**: 本题的DP转移过程，特别是子树合并，非常类似树上背包问题。每次合并一个孩子的子树，就像是往背包里加入一组新物品。
4.  **路径合并思想**: DP状态中“路径数”这一维度的设计非常巧妙。它量化了子问题中的连通性，并通过分析连接操作对路径数的影响（`i+j-k`）来构建转移，这是本题的精髓所在，呐！

希望这篇题解能帮助你理解这道有趣的题目！继续加油哦，喵~！