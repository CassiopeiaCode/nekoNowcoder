# 卡车 (Truck) - 题解

### 比赛与标签
> **比赛**: 牛客小白月赛41 (Nowcoder White Monthly Contest 41)

> **标签**: NTT, 多项式乘法, 组合数学, 数学, LGV引理

> **难度**: 暂无

## 题目大意喵~

各位骑士大人，下午好喵~ Cuber QQ 在一个无限大的网格上遇到了一个有趣的问题，需要我们帮忙呢！

是这样的：有 $n$ 辆可爱的小卡车，它们一开始分别停在坐标为 $(0, a_1), (0, a_2), \dots, (0, a_n)$ 的位置。它们的目标是开到 $n$ 个不同的终点，这些终点分别是 $(1, 0), (2, 0), \dots, (n, 0)$。

每辆小卡车都很守规矩，每次只能从当前位置 $(x, y)$ 移动到 $(x+1, y)$（向下）或者 $(x, y-1)$（向左）。

最最重要的一点是，为了交通安全，任意两辆卡车的行驶路径都不能有任何交点！也就是说，一辆卡车走过的格子，另一辆卡车连碰都不能碰一下哦。

我们的任务就是计算一下，有多少种不同的方案，能让所有卡车都安全到达一个独一无二的目的地。答案要对 $998244353$ 取模哦！

## 解题思路分析

这道题看起来是在一个网格上走路，还要求路径不能相交，一听就感觉不简单呢，喵~ 这种问题通常都和一个非常厉害的数学工具——**LGV 引理 (Lindstrom-Gessel-Viennot Lemma)** 有关！

#### LGV 引理初探

LGV 引理告诉我们，在一个有向无环图（我们这个网格就是个例子）中，有一组起点 $S = \{S_1, \dots, S_n\}$ 和一组终点 $D = \{D_1, \dots, D_n\}$。如果我们想计算从 $S_i$ 到 $D_i$（一一对应）并且路径互不相交的方案数，答案就是一个行列式！

具体来说，方案数等于下面这个矩阵 $M$ 的行列式：
$$
\det(M) = \det
\begin{pmatrix}
e(S_1, D_1) & e(S_1, D_2) & \cdots & e(S_1, D_n) \\
e(S_2, D_1) & e(S_2, D_2) & \cdots & e(S_2, D_n) \\
\vdots & \vdots & \ddots & \vdots \\
e(S_n, D_1) & e(S_n, D_2) & \cdots & e(S_n, D_n)
\end{pmatrix}
$$
其中，$e(S_i, D_j)$ 表示从起点 $S_i$ 到终点 $D_j$ 的路径数量。

#### 应用到本题

1.  **确定起点和终点**：
    我们的起点是 $S_i = (0, a_i)$，终点是 $D_j = (j, 0)$。为了应用 LGV 引理，我们需要对起点和终点进行排序。终点 $D_j$ 已经按 $x$ 坐标排好序了。我们也需要对起点按 $y$ 坐标排序，也就是将给定的 $a_i$ 数组从小到大排序。这样，为了保证路径不相交，第 $i$ 个起点（排序后）必须去第 $i$ 个终点。

2.  **计算路径数 $e(S_i, D_j)$**：
    从 $(0, a_i)$ 到 $(j, 0)$，卡车需要向下走 $j$ 步，向左走 $a_i$ 步，总共是 $a_i+j$ 步。这相当于在 $a_i+j$ 个位置里选择 $j$ 个位置放“向下”的指令，剩下的就是“向左”。所以路径数是一个组合数：
    $$
    e(S_i, D_j) = \binom{a_i+j}{j}
    $$

3.  **构建行列式**：
    根据 LGV 引理，总方案数就是下面这个 $n \times n$ 矩阵的行列式的值（取绝对值，不过在这里结果总是正的）：
    $$
    \text{Ways} = \det \left( \binom{a_i+j}{j} \right)_{1 \le i,j \le n}
    $$
    其中 $a_i$ 是排序后的初始 $y$ 坐标。

#### 神奇的行列式化简

喵~ 这个行列式的计算可不简单呢，它涉及一些高深的组合数学恒等式。直接展开计算是 $O(n!)$，太慢了！但是，经过一番神奇的数学推导（本喵的小脑袋瓜都快转冒烟啦！），这个行列式可以被化简成一个非常漂亮的公式，呐：

$$
\text{Ways} = \left(\prod_{i=1}^n \frac{a_i+1}{i!}\right) \cdot \left(\prod_{1 \le j < k \le n} (a_k-a_j)\right)
$$

这个公式由两部分相乘得到：
*   **Part A**: $\prod_{i=1}^n \frac{a_i+1}{i!}$
*   **Part B**: $\prod_{1 \le j < k \le n} (a_k-a_j)$

Part A 很容易计算，我们只需要预处理阶乘和阶乘的逆元就可以 $O(n)$ 搞定。

#### 加速计算 Part B

Part B 是所有排序后 $a_i$ 两两之差的乘积。如果用一个二重循环来计算，复杂度是 $O(n^2)$，对于 $n$ 高达 $5 \cdot 10^5$ 的数据范围来说，肯定会超时的说。

所以，我们需要一种更快的计算方法。这时候，多项式乘法和 NTT (数论变换) 就要闪亮登场啦！

我们的目标是计算 $\prod_{1 \le j < k \le n} (a_k - a_j)$。
我们可以把它改写成 $\prod_{d=1}^{\max(a)} d^{C(d)}$，其中 $C(d)$ 是满足 $a_k - a_j = d$ 并且 $j<k$ 的数对 $(j, k)$ 的数量。

怎么快速求出所有 $C(d)$ 呢？这正是卷积的拿手好戏！

1.  **构造多项式**：
    我们构造两个多项式。设 $V_{max}$ 是 $a_i$ 的最大值。
    *   $P(x) = \sum_{i=1}^n x^{a_i}$
    *   $Q(x) = \sum_{i=1}^n x^{V_{max}-a_i}$ (这是 $P(x)$ 的系数在某种意义上的“反转”)

2.  **计算卷积**：
    我们将这两个多项式相乘，得到 $R(x) = P(x) \cdot Q(x)$。
    $$
    R(x) = \left(\sum_{k=1}^n x^{a_k}\right) \left(\sum_{j=1}^n x^{V_{max}-a_j}\right) = \sum_{k=1}^n \sum_{j=1}^n x^{a_k - a_j + V_{max}}
    $$
    观察 $R(x)$ 的第 $V_{max}+d$ 项的系数。这个系数，记作 $[x^{V_{max}+d}]R(x)$，正好是满足 $a_k - a_j = d$ 的数对 $(k,j)$ 的数量！
    因为我们已经对 $a_i$ 进行了排序，所以当 $d > 0$ 时，$a_k - a_j = d$ 自动保证了 $k>j$。所以这个系数就是我们想要的 $C(d)$！

3.  **NTT 实现**：
    多项式乘法可以通过 NTT 在 $O(V \log V)$ 的时间内高效完成，其中 $V$ 是多项式的最高次幂（大约是 $2 \cdot V_{max}$）。

#### 算法总结

好啦，整理一下我们的完整步骤：
1.  读入 $n$ 个卡车的初始 $y$ 坐标 $a_i$。
2.  对数组 $a$ 进行从小到大排序。
3.  **计算 Part A**:
    预处理阶乘和阶乘的逆元。然后计算 $\prod_{i=1}^n (a_i+1) \cdot (i!)^{-1} \pmod{P}$。
4.  **计算 Part B**:
    a. 确定多项式的最大次数，比如 `max_val = a[n]`。构造两个长度合适的数组（比如 $2 \cdot \text{max\_val} + 1$ 的下一个2的幂次）作为多项式 `poly_p` 和 `poly_q`。
    b. `for i=1 to n`: `poly_p[a[i]] = 1`, `poly_q[max_val - a[i]] = 1`。
    c. 使用 NTT 计算它们的卷积 `poly_r = poly_p * poly_q`。
    d. 初始化 Part B 的结果为 1。遍历 $d$ 从 1 到 `max_val`，`poly_r[max_val + d]` 就是差值为 $d$ 的数对数量。用快速幂计算 $d^{\text{poly\_r}[\text{max\_val}+d]}$，并累乘到 Part B 的结果中。
5.  **最终答案**: 将 Part A 和 Part B 的结果相乘，就是我们要求的总方案数啦！

## 代码实现

这是本喵根据上面的思路，精心准备的代码哦！希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

typedef long long ll;

const int MOD = 998244353;
const int G = 3; // 原根

// 快速幂，喵~
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模块逆元
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

namespace NTT {
    vector<int> rev;
    int limit = 1;
    int len = 0;

    void precompute_rev(int n) {
        limit = 1;
        len = 0;
        while (limit < n) {
            limit <<= 1;
            len++;
        }
        rev.resize(limit);
        for (int i = 0; i < limit; i++) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
        }
    }

    void transform(vector<ll>& a, int type) {
        for (int i = 0; i < limit; i++) {
            if (i < rev[i]) {
                swap(a[i], a[rev[i]]);
            }
        }
        for (int mid = 1; mid < limit; mid <<= 1) {
            ll wn = power(G, (MOD - 1) / (mid << 1));
            if (type == -1) {
                wn = modInverse(wn);
            }
            for (int j = 0; j < limit; j += (mid << 1)) {
                ll w = 1;
                for (int k = 0; k < mid; k++, w = (w * wn) % MOD) {
                    ll x = a[j + k];
                    ll y = (w * a[j + mid + k]) % MOD;
                    a[j + k] = (x + y) % MOD;
                    a[j + mid + k] = (x - y + MOD) % MOD;
                }
            }
        }
        if (type == -1) {
            ll inv_limit = modInverse(limit);
            for (int i = 0; i < limit; i++) {
                a[i] = (a[i] * inv_limit) % MOD;
            }
        }
    }
}

const int MAXN = 500005;
const int MAX_VAL = 1000000;
ll fact[MAX_VAL + MAXN], invFact[MAX_VAL + MAXN];

// 预处理阶乘和逆元
void precompute_factorials(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    invFact[n] = modInverse(fact[n]);
    for (int i = n - 1; i >= 0; i--) {
        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;
    }
}

int main() {
    // 加速输入输出，让程序跑得更快！
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<int> a(n);
    int max_a = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        if (a[i] > max_a) {
            max_a = a[i];
        }
    }

    // 排序是LGV引理和我们公式的前提哦
    sort(a.begin(), a.end());
    
    // 预处理阶乘
    precompute_factorials(max_a + n);

    // --- 计算 Part A ---
    ll part_a = 1;
    for (int i = 0; i < n; i++) {
        part_a = (part_a * (a[i] + 1)) % MOD;
        part_a = (part_a * invFact[i + 1]) % MOD;
    }
    
    // --- 计算 Part B ---
    // 确定NTT需要的长度
    int ntt_size = 1;
    while (ntt_size < 2 * max_a + 1) {
        ntt_size <<= 1;
    }
    
    vector<ll> p(ntt_size, 0), q(ntt_size, 0);
    for (int val : a) {
        p[val] = 1;
        q[max_a - val] = 1;
    }

    // 执行NTT
    NTT::precompute_rev(ntt_size);
    NTT::transform(p, 1);
    NTT::transform(q, 1);

    vector<ll> r(ntt_size);
    for (int i = 0; i < ntt_size; i++) {
        r[i] = (p[i] * q[i]) % MOD;
    }

    NTT::transform(r, -1);
    
    // 从卷积结果计算 Part B
    ll part_b = 1;
    for (int d = 1; d <= max_a; d++) {
        ll count = r[max_a + d];
        if (count > 0) {
            part_b = (part_b * power(d, count)) % MOD;
        }
    }

    // --- 合并答案 ---
    ll final_answer = (part_a * part_b) % MOD;
    cout << final_answer << endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(V \log V + N)$，其中 $N$ 是卡车的数量，$V$ 是卡车初始 $y$ 坐标的最大值。
    *   排序需要 $O(N \log N)$。
    *   计算 Part A 需要 $O(N)$（在预处理阶乘之后）。预处理阶乘需要 $O(V+N)$。
    *   计算 Part B 的主要开销是 NTT，其复杂度为 $O(V \log V)$。
    *   从卷积结果计算最终乘积需要 $O(V)$。
    *   所以总的时间复杂度由 NTT 主导，为 $O(V \log V)$。

*   **空间复杂度**: $O(V)$
    *   存储阶乘和逆元需要 $O(V+N)$ 的空间。
    *   NTT 中使用的多项式数组需要 $O(V)$ 的空间。
    *   因此，总空间复杂度为 $O(V)$。

## 知识点总结

这真是一道融合了多种算法思想的题目呀，喵~ 让我们来总结一下吧：

1.  **LGV 引理**: 解决格点图上不相交路径计数问题的终极武器。它巧妙地将组合计数问题转化为了线性代数中的行列式计算。
2.  **组合数学**: 核心公式的推导离不开组合恒等式和行列式性质。虽然我们没有深入推导，但了解其来源有助于我们更好地理解问题。
3.  **多项式乘法 (卷积)**: 当我们需要计算形如 $\sum f(i)g(k-i)$ 的式子时，卷积是最高效的工具。
4.  **NTT (数论变换)**: 在模意义下实现快速多项式乘法的算法，是 FFT 在数论领域的对应。它是解决许多计数类问题的关键。
5.  **算法思想**: 将一个复杂的问题（计数不相交路径）分解成一个数学公式，再对公式中的不同部分采用不同的高效算法（直接计算 + NTT）来求解，这是算法竞赛中非常重要的解题策略！

希望这篇题解能帮助你更好地理解这道题！继续加油哦，骑士大人！喵~