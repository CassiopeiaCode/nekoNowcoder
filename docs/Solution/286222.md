# 相信你一定接触过下面这个脑筋急转弯： - 题解

### 比赛与标签
> **比赛**: 未提供

> **标签**: 未提供

> **难度**: 未提供

## 题目大意喵~

主人你好呀，喵~ 这是一道关于如何最省事地切金条发工资的有趣问题！

是这样的呐：我们有一根总长度为 $len$ 的金条，需要给一位勤劳的工人发 $m$ 天的工资。规则是，在第 $j$ 天结束的时候（$j$ 从 1 到 $m$），工人手里不多不少，正好要有价值为 $j$ 的黄金。

我们可以像题目里的脑筋急转弯一样，不仅可以给工人金块，还可以从工人那里换回我们之前给过的金块，进行“找零”操作。

对于每一组给定的 $len$ 和 $m$，小蓝（也就是我们啦！）需要计算出，最少需要切多少刀，才能顺利地发完这 $m$ 天的工资。

简单来说就是：
- **输入**: $t$ 组测试数据，每组包含金条总长度 $len$ 和需要支付的天数 $m$。
- **输出**: 对于每组数据，输出一个整数，表示最少的切割次数。

## 解题思路分析

这道题看起来有点复杂，但其实藏着一个非常优雅的数学小秘密哦，就像藏在沙发底下的毛线球一样，只要我们耐心寻找，就能发现它的乐趣所在，喵~

### 从脑筋急转弯开始

题目开头的脑筋急转弯给了我们一个超——重要的提示！要支付7天的工资，可以把金条切成 `1`, `2`, `4` 三块。为什么是这三个数字呢？

- 第1天: 给工人 {1}
- 第2天: 给工人 {2}，收回 {1}。工人总资产：2
- 第3天: 给工人 {1}。工人总资产：{1, 2} -> 3
- 第4天: 给工人 {4}，收回 {1, 2}。工人总资产：4
- ... 以此类推

你看，通过这些大小为 $2$ 的幂次方的金块 ($1=2^0, 2=2^1, 4=2^2$)，我们可以组合出 $1$ 到 $7$ 之间的任何一个整数！这不就是二进制的魔法嘛，喵~ 任何一个十进制数都可以用二进制唯一表示，比如 $5 = (101)_2 = 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 4+1$。

### 推广到一般情况

所以，为了能支付 $m$ 天的工资，我们本质上需要一套金块，使得它们可以组合出从 $1$ 到 $m$ 的所有整数。最有效率的组合方式，就是使用 $2$ 的幂次方作为金块的大小：$1, 2, 4, 8, \dots$。

假设我们用了 $k$ 块这样理想的金块，它们的大小分别是 $2^0, 2^1, \dots, 2^{k-1}$。它们能组合出的最大金额是它们的总和：
$$
1 + 2 + 4 + \dots + 2^{k-1} = 2^k - 1
$$
为了能支付到第 $m$ 天，我们需要的这套金块能组合出的最大值，必须大于等于 $m$。也就是说，我们需要找到一个最小的 $k$，满足：
$$
2^k - 1 \ge m
$$
这个 $k$ 就是我们至少需要的金块数量。有了 $k$ 块金块，自然就需要切 $k-1$ 刀啦。

### 别忘了金条的总长度 `len`

刚才的分析是基于我们有“足够”的黄金来切出理想大小的金块。但现在我们只有一根总长度为 $len$ 的金条。这会带来什么影响呢？

我们来分两种情况讨论，这两种情况的分界点，就是我们上面算出的理想金块的总长度，我们叫它 `ideal_len` 吧，也就是 $2^k - 1$。

#### 情况一：我们的金条不够长 ($len \le ideal\_len$)

当我们的金条总长度 $len$ 小于等于理想长度 $2^k-1$ 时，事情比较简单。

我们至少需要 $k$ 个金块才能覆盖 $1$ 到 $m$ 的所有支付需求。所以最少也要切 $k-1$ 刀。

那 $k-1$ 刀到底够不够呢？是够的哦！我们可以这样切：先切下大小为 $1, 2, 4, \dots, 2^{k-2}$ 的 $k-1$ 个小金块。最后剩下的一大块金块的大小就是 $len - (1+2+\dots+2^{k-2}) = len - (2^{k-1}-1)$。

事实证明（这里的数学推导稍微有点绕，本喵就直接告诉你结论啦~），只要我们切出的 $k$ 块金块总和为 $len$，并且 $len \le 2^k-1$，我们总是可以找到一种切割方法（比如上面这种），使得它们能组合出 $1$ 到 $len$ 之间的所有整数。既然题目保证了 $len \ge m$，那么自然也就能组合出 $1$ 到 $m$ 的所有整数啦。

所以，在这种情况下，最少切割次数就是 $k-1$ 次。

#### 情况二：我们的金条太长了 ($len > ideal\_len$)

当我们的金条总长度 $len$ 大于理想长度 $2^k-1$ 时，情况就有点不一样了。

我们还能用 $k-1$ 刀（也就是 $k$ 块金块）解决问题吗？答案是：不行了，喵呜~

为什么呢？因为有一个小小的数学定理：$k$ 个正整数，如果它们的和超过了 $2^k-1$，那么它们一定无法组合出 $1$ 到它们总和之间的所有整数，中间必定会有“断层”。我们的 $k$ 块金块总和是 $len$，而 $len > 2^k-1$，所以用这 $k$ 块金块肯定无法满足支付 $1$ 到 $m$ 所有天数的需求。

所以，$k-1$ 刀不够了，我们必须再多切一刀，也就是总共切 $k$ 刀。

$k$ 刀够不够呢？当然够啦！$k$ 刀可以把金条分成 $k+1$ 块。我们完全可以从金条上切下 $k$ 块理想大小的金块：$1, 2, 4, \dots, 2^{k-1}$。这 $k$ 块金块本身就足以支付到第 $2^k-1$ 天了，而 $m \le 2^k-1$，所以支付 $m$ 天绰绰有余。

所以，在这种情况下，最少切割次数就是 $k$ 次。

### 总结一下算法思路

1.  **找到最小金块数 k**: 读入 $m$，然后计算出满足 $2^k - 1 \ge m$ 的最小整数 $k$。
2.  **计算理想总长度**: 这个 $k$ 对应的理想金块总和是 `ideal_len` $= 2^k - 1$。
3.  **分类讨论**:
    *   如果 $len \le ideal\_len$，那么答案是 $k-1$ 刀。
    *   如果 $len > ideal\_len$，那么答案是 $k$ 刀。

好啦，思路清晰了，可以开始写代码了，喵~

## 代码实现

这是本喵根据上面的思路，为你精心准备的一份 C++ 代码哦！注释超详细的，希望能帮到你，喵~

```cpp
#include <iostream>

// 为了防止数字太大溢出，我们使用 long long，这是一个好习惯哦！
using ll = long long;

void solve() {
    // len 是金条总长度，m 是需要支付的天数
    ll bar_length_len, num_days_m;
    std::cin >> bar_length_len >> num_days_m;

    // min_pieces_k: 至少需要的金块数量
    // ideal_bar_length: 这些金块能组合出的最大金额，也就是它们的理想总长度
    ll min_pieces_k = 0;
    ll ideal_bar_length = 0;

    // 核心循环：找到满足 2^k - 1 >= m 的最小 k
    // ideal_bar_length 从 0 开始，每次循环都代表增加一个 2 的幂次方的金块
    // 第一次循环 (k=1): ideal_bar_length = 2*0 + 1 = 1,  可以支付 1 天
    // 第二次循环 (k=2): ideal_bar_length = 2*1 + 1 = 3,  可以支付 1,2,3 天
    // 第三次循环 (k=3): ideal_bar_length = 2*3 + 1 = 7,  可以支付 1..7 天
    // ...以此类推
    while (ideal_bar_length < num_days_m) {
        min_pieces_k++;
        ideal_bar_length = ideal_bar_length * 2 + 1;
    }

    // k 个金块需要 k-1 刀。这是我们的基础切割数。
    ll cuts = min_pieces_k - 1;

    // 根据我们的分析进行分类讨论
    // 如果实际金条长度大于理想长度，就需要额外多切一刀
    if (bar_length_len > ideal_bar_length) {
        cuts = min_pieces_k; // 或者写成 cuts++;
    }

    std::cout << cuts << std::endl;
}

int main() {
    // 加速输入输出，让程序跑得更快，像猫一样敏捷！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(T \cdot \log m)$
  对于每一组测试数据（总共 $T$ 组），我们都需要执行一个 `while` 循环来找到最小的 $k$。循环的次数取决于 $m$ 的大小。因为 `ideal_bar_length` 是以指数级（大约是 $2^k$）增长的，所以循环的次数大约是 $\log_2(m)$。因此，总的时间复杂度就是 $O(T \cdot \log m)$，非常快，喵~

- **空间复杂度**: $O(1)$
  在每次调用 `solve` 函数时，我们只用了几个变量来存储 `len`, `m`, `k` 和 `ideal_len` 等。没有使用任何随输入规模增大的数据结构（比如数组或向量）。所以，空间复杂度是常数级别的，也就是 $O(1)$。

## 知识点总结

这道题虽然伪装成了一道脑筋急转弯，但它的内核是纯纯的数学和算法思维，喵~

1.  **二进制思想**: 解决这类“用少量单位组合出连续整数”问题的万能钥匙。任何数都可以由 $2$ 的幂次不重复地相加得到。
2.  **贪心策略**: 为了用最少的金块数覆盖 $1$ 到 $m$ 的范围，我们贪心地选择 $1, 2, 4, \dots$ 这样增长最快的金块大小。
3.  **数学证明与分类讨论**: 解题的关键在于理解为什么 $len$ 和 $2^k-1$ 的大小关系会影响最终的切割次数。这是对问题理解深度的考验。
4.  **编码技巧**: 使用 `long long` 来处理可能很大的输入数据，是一个避免溢出错误的好习惯。

希望这篇题解能让你对这个问题有更深的理解！如果还有不明白的地方，随时可以再来问本喵哦！加油，你超棒的！喵~ 🐾