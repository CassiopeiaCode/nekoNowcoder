# Little Rabbit loves hopping - 题解

### 比赛与标签
> **比赛**: The 2022 ICPC Asia Regionals Online Contest (I)

> **标签**: 扫描线, 线段树, 计算几何

> **难度**: *2500

## 题目大意喵~

各位主人，下午好喵~！今天我们来帮助一只可爱的小兔子！(ฅ'ω'ฅ)

这片草原上危机四伏，猎人设置了 $n$ 个矩形的陷阱。我们的小兔子是一只喜欢蹦蹦跳跳的乖孩子，它可不想掉进陷阱里。

题目是这样的：
1.  **场景**: 一个二维笛卡尔坐标平面。陷阱是 $n$ 个与坐标轴平行的矩形，由左下角坐标 $(x_1, y_1)$ 和右上角坐标 $(x_2, y_2)$ 定义。
2.  **小兔子的移动**: 小兔子每次可以沿着 x 轴或 y 轴方向跳跃固定的距离 $d$。也就是说，如果它在 $(x, y)$，下一步可以跳到 $(x \pm d, y)$ 或者 $(x, y \pm d)$。
3.  **目标**: 我们需要为小兔子找一个初始位置 $(x_0+0.5, y_0+0.5)$，其中 $x_0$ 和 $y_0$ 是整数。从这个点出发，无论小兔子怎么跳，它永远不会降落在任何一个陷阱的**内部或边界上**。
4.  **输入**: 第一行是整数 $n$ 和 $d$。接下来 $n$ 行，每行四个整数 $x_1, y_1, x_2, y_2$ 描述一个陷阱。
5.  **输出**: 如果能找到这样的安全点，就输出 "YES"，并在下一行输出任意一个满足条件的 $x_0$ 和 $y_0$。如果找不到，就输出 "NO"。

注意哦，小兔子只有在**落点**位于陷阱区域时才算掉进去，跳跃过程是安全的喵~

## 解题思路分析

这道题看起来有点复杂，涉及到无限的跳跃路径，但别担心，跟着本猫娘的思路，一步步就能解开谜题啦，喵~

### 关键洞察：周期的魔力！

小兔子的跳跃方式非常有规律！从一个点 $(x,y)$ 出发，它能到达的所有点的坐标都可以表示成 $(x+k \cdot d, y+l \cdot d)$ 的形式，其中 $k, l$ 是整数。

我们想找的初始点是 $(x_0+0.5, y_0+0.5)$。那么，从这个点出发，所有可以到达的点的坐标就是：
$$
(x_0 + 0.5 + k \cdot d, \quad y_0 + 0.5 + l \cdot d), \quad k, l \in \mathbb{Z}
$$

现在我们来观察一下这些坐标对 $d$ 取模的性质。
$$(x_0 + 0.5 + k \cdot d) \pmod d = (x_0 + 0.5) \pmod d$$
$$(y_0 + 0.5 + l \cdot d) \pmod d = (y_0 + 0.5) \pmod d$$

这意味着，对于一个固定的初始点 $(x_0, y_0)$，所有可达点的 x 坐标模 $d$ 的余数都相同，y 坐标也同理。

这个性质非常重要！它告诉我们，如果一个初始点 $(x_0', y_0')$ 满足 $x_0' \equiv x_0 \pmod d$ 且 $y_0' \equiv y_0 \pmod d$，那么从 $(x_0'+0.5, y_0'+0.5)$ 出发能到达的点集，和从 $(x_0+0.5, y_0+0.5)$ 出发能到达的点集，在空间中只是进行了 $d$ 的整数倍的平移，它们的相对结构是完全一样的。因此，它们的安全性也是一样的！

所以，我们不需要检查所有可能的整数 $(x_0, y_0)$，只需要检查 $0 \le x_0 < d$ 和 $0 \le y_0 < d$ 的 $d \times d$ 个“代表”就行啦！如果这些代表中有一个是安全的，我们就找到了答案；如果它们全都是危险的，那就真的没有安全点了，呜~

### 怎样才算危险呢？

一个初始类别 $(x_0, y_0)$ (其中 $0 \le x_0, y_0 < d$) 是危险的，当且仅当**存在**一个陷阱 $i$ 和一对整数 $(k, l)$，使得落点 $(x_0+0.5+k \cdot d, y_0+0.5+l \cdot d)$ 掉进了这个陷阱。

陷阱 $i$ 的范围是 $[x_{1i}, x_{2i}] \times [y_{1i}, y_{2i}]$。
落点 $(X, Y)$ 在陷阱里，意味着 $x_{1i} \le X \le x_{2i}$ 且 $y_{1i} \le Y \le y_{2i}$。
由于我们的落点坐标都是 `整数+0.5 的形式，而陷阱边界是整数，所以落点永远不会在边界上。因此，条件可以等价为 $x_{1i} < X < x_{2i}$ 且 $y_{1i} < Y < y_{2i}$。

代入 $X = x_0+0.5+k \cdot d$，我们得到：
$x_{1i} < x_0+0.5+k \cdot d < x_{2i}$
$\implies x_{1i} - 0.5 < x_0+k \cdot d < x_{2i} - 0.5$
因为 $x_0, k, d, x_{1i}, x_{2i}$ 都是整数，所以 $x_0+k \cdot d$ 也是整数。上面的不等式等价于：
$x_{1i} \le x_0+k \cdot d \le x_{2i}-1$

这意味着，对于某个整数 $k$， $x_0+k \cdot d$ 这个值必须落在 $[x_{1i}, x_{2i}-1]$ 这个整数区间内。这等价于说，$x_0 \pmod d$ 必须与 $[x_{1i}, x_{2i}-1]$ 区间中某个整数模 $d$ 的余数相同。

我们把这些“危险”的 $x_0$ 余数集合记为 $F_{x,i}$，同样地，对于 y 坐标，我们也有一个危险的余数集合 $F_{y,i}$。一个初始类别 $(x_0, y_0)$ 被陷阱 $i$ "封锁"，当且仅当 $x_0 \in F_{x,i}$ 并且 $y_0 \in F_{y,i}$。

所以，每个陷阱都在我们 $d \times d$ 的 $(x_0, y_0)$ 网格上定义了一个矩形的“禁区”：$F_{x,i} \times F_{y,i}$。我们的任务就是，判断所有陷阱定义的禁区的并集，是否覆盖了整个 $d \times d$ 网格。如果没覆盖，我们就找到了安全点！

### 计算禁区 $F_{x,i}$ 和 $F_{y,i}$

如何计算 $F_{x,i}$ 呢？它是由整数区间 $[L, R] = [x_{1i}, x_{2i}-1]$ 决定的。
1.  如果 $R < L$，说明这个陷阱太窄了，不可能有整数落点，是安全的。
2.  如果区间长度 $R-L+1 \ge d$，那么这个区间覆盖了模 $d$ 的所有余数。所以 $F_{x,i} = [0, d-1]$。
3.  如果 $R-L+1 < d$，设 $L' = L \pmod d$，$R' = R \pmod d$。
    -   如果 $L' \le R'$，那么 $F_{x,i}$ 就是一个连续的区间 $[L', R']$。
    -   如果 $L' > R'$，那么 $F_{x,i}$ 就被分成了两段：$[L', d-1]$ 和 $[0, R']$。

对于 $F_{y,i}$ 也是同理。这样，每个陷阱就对应了我们 $d \times d$ 网格中的最多4个禁区矩形（因为 $F_x$ 和 $F_y$ 都可能被分成两段）。

### 扫描线 + 线段树 = 完美！

现在问题转化为了一个经典的计算几何问题：给定一堆矩形，求它们并集的面积，或者找一个没有被覆盖的点。这正是**扫描线算法**大显身手的地方！

我们可以想象有一条竖直的线，从 $x_0=0$ 扫到 $x_0=d-1$。在每个整数 $x_0$ 位置，我们想知道：对于当前的 $x_0$，y 轴方向上 $[0, d-1]$ 的哪些 $y_0$ 是被禁止的？

-   **事件**: 当扫描线遇到一个禁区矩形的左边界时，这是一个“进入”事件；遇到右边界的后一个位置时，是“离开”事件。
-   **状态维护**: 我们需要一个数据结构来维护当前扫描线位置上，y 轴各个区间的“被覆盖层数”。当进入一个禁区矩形 $[x_s, x_e] \times [y_s, y_e]$ 时，在 $x_s$ 处，我们将 y 轴上 $[y_s, y_e]$ 区间的覆盖层数加 1。在 $x_e+1$ 处，我们再将它减 1。
-   **线段树**: 这个数据结构，用线段树来实现再合适不过了！我们可以建一棵关于 $y_0$ 坐标范围 $[0, d-1]$ 的线段树。每个节点维护其对应 y 区间内的 min_coverage` (最小覆盖层数) 和一个 `lazy_tag 用于区间更新。

**算法流程**:
1.  **预处理**: 遍历所有 $n$ 个陷阱。对每个陷阱，计算出其禁区 $F_{x,i}$ 和 $F_{y,i}$。它们可能是 1 到 2 个区间。将这些禁区矩形拆分成扫描线事件。一个矩形 $[x_s, x_e] \times [y_s, y_e]$ 会产生两个事件：
    -   在 $x_s$ 处，对 y 区间 $[y_s, y_e]$ 执行 +1` 操作。
    -   在 $x_e+1$ 处，对 y 区间 $[y_s, y_e]$ 执行 `-1` 操作。
    将所有事件按 x 坐标存起来。
2.  **初始化**: 建立一棵覆盖 y 轴 $[0, d-1]$ 的线段树，所有位置的覆盖层数初始为 0。
3.  **扫描**: 按顺序遍历 $x_0$ 从 $0$ 到 $d-1$。
    a. 在处理 $x_0$ 处的事件之前，先检查线段树的根节点。如果根节点的 `min_coverage` 为 0，说明在当前 $x_0$ 这一列，至少有一个 $y_0$ 是安全的（没有被任何禁区覆盖）！我们就找到了答案！通过一次查询（从根节点往下走，专挑 `min_coverage 为 0 的孩子），就能找到一个具体的安全 $y_0$。输出 "YES" 和 $(x_0, y_0)$，然后程序结束。
    b. 处理所有在当前 $x_0$ 发生的事件，更新线段树。
4.  **结束**: 如果扫描线从 $0$ 扫到 $d-1$ 都没找到安全点，那说明整个 $d \times d$ 网格都被禁区覆盖了。输出 "NO"。

好啦，思路就是这样，是不是感觉清晰多啦？接下来就让我们用代码把它实现出来吧！ヾ(≧▽≦*)o

## 代码实现

``cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 定义一个扫描线事件
struct Event {
    int y_start, y_end; // 事件影响的y坐标范围
    int type;           // 事件类型: 1 表示增加覆盖, -1 表示减少覆盖
};

// 线段树节点
struct Node {
    int min_coverage; // 区间内最小覆盖层数
    int lazy_tag;     // 懒标记
};

vector<Node> seg_tree;
vector<vector<Event>> events;
int D;

void push_up(int u) {
    seg_tree[u].min_coverage = min(seg_tree[u * 2].min_coverage, seg_tree[u * 2 + 1].min_coverage);
}

void apply_tag(int u, int tag) {
    seg_tree[u].min_coverage += tag;
    seg_tree[u].lazy_tag += tag;
}

void push_down(int u) {
    if (seg_tree[u].lazy_tag != 0) {
        apply_tag(u * 2, seg_tree[u].lazy_tag);
        apply_tag(u * 2 + 1, seg_tree[u].lazy_tag);
        seg_tree[u].lazy_tag = 0;
    }
}

void build(int u, int l, int r) {
    seg_tree[u] = {0, 0};
    if (l == r) {
        return;
    }
    int mid = l + (r - l) / 2;
    build(u * 2, l, mid);
    build(u * 2 + 1, mid + 1, r);
}

// 区间更新
void update(int u, int l, int r, int ql, int qr, int type) {
    if (ql > qr) return; // 无效区间
    if (ql <= l && r <= qr) {
        apply_tag(u, type);
        return;
    }
    push_down(u);
    int mid = l + (r - l) / 2;
    if (ql <= mid) {
        update(u * 2, l, mid, ql, qr, type);
    }
    if (qr > mid) {
        update(u * 2 + 1, mid + 1, r, ql, qr, type);
    }
    push_up(u);
}

// 查询第一个覆盖层数为0的y坐标
int find_safe_y(int u, int l, int r) {
    if (seg_tree[u].min_coverage > 0) {
        return -1; // 此区间内没有安全点
    }
    if (l == r) {
        return l;
    }
    push_down(u);
    int mid = l + (r - l) / 2;
    if (seg_tree[u * 2].min_coverage == 0) {
        return find_safe_y(u * 2, l, mid);
    } else {
        return find_safe_y(u * 2 + 1, mid + 1, r);
    }
}

// 计算模d下的区间，并返回一个或两个区间对
void get_mod_intervals(long long c1, long long c2, int d, vector<pair<int, int>>& intervals) {
    long long L = c1;
    long long R = c2 - 1;
    if (L > R) return;

    if (R - L + 1 >= d) {
        intervals.push_back({0, d - 1});
        return;
    }

    // 使用一个大的d的倍数作为偏移，优雅地处理负数
    long long offset = (long long)d * (2e9 / d + 1);
    int start_mod = (L % d + d) % d;
    int end_mod = (R % d + d) % d;

    if (start_mod <= end_mod) {
        intervals.push_back({start_mod, end_mod});
    } else {
        intervals.push_back({start_mod, d - 1});
        intervals.push_back({0, end_mod});
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n >> D;

    events.resize(D + 1);

    for (int i = 0; i < n; ++i) {
        long long x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;

        vector<pair<int, int>> x_intervals, y_intervals;
        get_mod_intervals(x1, x2, D, x_intervals);
        get_mod_intervals(y1, y2, D, y_intervals);

        for (const auto& x_int : x_intervals) {
            for (const auto& y_int : y_intervals) {
                events[x_int.first].push_back({y_int.first, y_int.second, 1});
                if (x_int.second + 1 < D) {
                    events[x_int.second + 1].push_back({y_int.first, y_int.second, -1});
                }
            }
        }
    }

    seg_tree.resize(D * 4);
    build(1, 0, D - 1);

    for (int x0 = 0; x0 < D; ++x0) {
        for (const auto& ev : events[x0]) {
            update(1, 0, D - 1, ev.y_start, ev.y_end, ev.type);
        }

        if (seg_tree[1].min_coverage == 0) {
            int y0 = find_safe_y(1, 0, D - 1);
            cout << "YES" << endl;
            cout << x0 << " " << y0 << endl;
            return 0;
        }
    }

    cout << "NO" << endl;

    return 0;
}
``

## 复杂度分析

- **时间复杂度**: $O((n+d) \log d)$
    - 预处理阶段，我们遍历 $n$ 个陷阱。每个陷阱最多产生 $2 \times 2=4$ 个矩形禁区，从而产生 $O(1)$ 个扫描线事件。总共有 $O(n)$ 个事件。这个阶段的复杂度是 $O(n)$。
    - 扫描线从 $x_0=0$ 扫到 $d-1$。总共 $d$ 步。
    - 在每一步 $x_0$，我们处理该位置的事件。总事件数是 $O(n)$，每个事件触发一次线段树的区间更新，复杂度为 $O(\log d)$。
    - 在每一步，我们还检查全局最小覆盖，这只是 $O(1)$ 的操作（查询根节点）。如果找到解，再花 $O(\log d)$ 寻找具体 $y_0$。
    - 所以总的时间复杂度是 $O(d \cdot (\text{检查}) + n \cdot (\text{更新})) = O(d + n \log d)$。更精确地，是 $O(d \log d + n \log d) = O((n+d)\log d)$，因为每步检查后可能要查询。

- **空间复杂度**: $O(n+d)$
    - 存储扫描线事件的 events` 数组需要 $O(n)$ 空间，因为总事件数是 $O(n)$。
    - 线段树需要 $O(d)$ 的空间。
    - 所以总空间复杂度为 $O(n+d)$。

## 知识点总结

这道题是多种算法思想的美妙结合，喵~

1.  **周期性与模运算**: 这是解题的突破口！通过发现兔子移动的周期性，我们将一个无限问题转化为了一个在有限 $d \times d$ 网格上的问题。在处理坐标相关问题时，取模思想是非常有用的工具。
2.  **扫描线算法 (Sweep Line)**: 这是解决一类几何问题（如矩形并、覆盖问题）的经典范式。通过将静态的二维问题转化为动态的一维问题，大大简化了问题的处理。
3.  **线段树**: 作为扫描线算法的得力助手，线段树能够高效地维护一维区间上的信息（本题中是“覆盖层数”），支持快速的区间更新和查询。
4.  **问题转化**: 能够将原问题“寻找安全初始点”一步步转化为“判断 $d \times d$ 网格上是否存在未被矩形并集覆盖的点”，是解决复杂问题的核心能力。

希望这篇题解能帮助到各位主人！如果还有不明白的地方，随时可以来问本猫娘哦~ 喵~ (ฅ^•ﻌ•^ฅ)