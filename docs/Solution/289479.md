# $\left \lvert \left(\sum\limits_{i=1}^{n}\left \lvert a_i - k \right \rvert\right) - \left(\sum\limits_{j=1}^{m}\left \lvert b_j - k \right \rvert\right) \right \rvert$ - 题解

### 比赛与标签
> **比赛**: No Contest

> **标签**: math,三分

> **难度**: *2100

## 题目大意喵~

主人你好呀，喵~ 这道题是这样的：

我们有两个整数数组，一个叫 `a`，有 `n` 个数；另一个叫 `b`，有 `m` 个数。我们的任务是找到一个整数 `k`（它的范围在 $[-2 \times 10^9, 2 \times 10^9]$ 之间），让下面这个式子的值变得**最小**，喵~

$$
F(k) = \left| \left(\sum_{i=1}^{n} |a_i - k|\right) - \left(\sum_{j=1}^{m} |b_j - k|\right) \right|
$$

如果有很多个 `k` 都能得到这个最小值，我们要输出其中**最小**的那个 `k` 哦！

简单来说，就是找一个点 `k`，让它到 `a` 数组所有点的距离之和，与它到 `b` 数组所有点的距离之和，这两者的差的绝对值最小。是不是很有趣，喵？

## 解题思路分析

这道题看起来有点吓人，一堆求和符号和绝对值，但别怕，让本猫娘来带你一步步解开它的秘密，呐！

首先，我们把这个复杂的式子拆开来看。令：
$$
S_a(k) = \sum_{i=1}^{n} |a_i - k|
$$
$$
S_b(k) = \sum_{j=1}^{m} |b_j - k|
$$
那么我们要求的就是 $F(k) = |S_a(k) - S_b(k)|$ 的最小值。

#### 函数 G(k) 的特性

我们再定义一个函数 $G(k) = S_a(k) - S_b(k)$。我们的目标就变成了最小化 $|G(k)|$。

$S_a(k)$ 是什么呢？它是 `k`到 `n` 个点 $a_i$ 的距离之和。这是一个典型的“绝对值和函数”，它的图像是**凸的**（像一个碗），并且是**分段线性的**。函数图像的“拐点”恰好就是那些 $a_i$ 的值。同样，$S_b(k)$ 也是一个分段线性的凸函数，拐点在 $b_j$ 的位置。

那么，$G(k)$ 是两个分段线性函数的差，所以它本身也是一个**分段线性函数**，喵~。它的斜率只会在 $a_i$ 和 $b_j$ 这些点上发生改变。我们把所有 $a_i$ 和 $b_j$ 收集起来，称它们为“**事件点**”。

#### 扫描线大法！

既然 $G(k)$ 是分段线性的，我们就可以用“扫描线”的思想来解决问题！想象一条竖直线从左到右（从 $k = -\infty$ 到 $k = +\infty$）扫描。在任意两个相邻的事件点之间的开区间内，$G(k)$ 的斜率是恒定的，也就是说 $G(k)$ 是一条直线！

一条直线 `y = P*k + Q` 的绝对值 `|y|` 在一个闭区间 `[L, R]` 上的最小值，只可能在这几个地方取到：
1.  区间的左端点 `L`。
2.  区间的右端点 `R`。
3.  如果直线穿过x轴（即 `y=0`），那么在交点 `k = -Q/P` 处取到最小值0。

所以，我们只需要考察所有事件点，以及每个分段线性区间内可能存在的根，就能找到全局最小值了，喵！

#### 维护斜率与截距

我们可以从 $k = -\infty$ 开始，一步步向右移动，跨过每一个事件点，同时维护 $G(k)$ 的线性表达式 $P \cdot k + Q$ 中的斜率 `P` 和截距 `Q`。

1.  **初始状态**：当 `k` 比所有的 $a_i$ 和 $b_j$ 都小的时候：
    - $|a_i - k| = a_i - k$
    - $|b_j - k| = b_j - k$
    - $G(k) = \sum(a_i - k) - \sum(b_j - k) = (\sum a_i - n \cdot k) - (\sum b_j - m \cdot k)$
    - $G(k) = (m-n)k + (\sum a_i - \sum b_j)$
    所以，初始斜率 $P_{init} = m-n$，初始截距 $Q_{init} = \sum a_i - \sum b_j$。

2.  **跨越事件点**：当我们的扫描线从左到右跨过一个事件点 `c` 时，会发生什么呢？
    - 如果 `c` 是一个 $a_i$：$|a_i - k|$ 的表达式从 $a_i - k$ 变为 $k - a_i$。对 $k$ 求导，斜率从 -1 变为 1，变化量是 +2。所以 $S_a(k)$ 的斜率增加2。
    - 如果 `c` 是一个 $b_j$：同理，$S_b(k)$ 的斜率增加2。
    - 因为 $G(k) = S_a(k) - S_b(k)$，所以：
        - 遇到一个 $a_i$， $G(k)$ 的斜率 $P$ 增加 2。
        - 遇到一个 $b_j$， $G(k)$ 的斜率 $P$ 减少 2。

3.  **更新截距**：当斜率从 $P_{old}$ 变为 $P_{new}$ 时，为了保证函数在事件点 `c` 处是连续的，截距也需要更新。设旧的截距是 $Q_{old}$，新的截距是 $Q_{new}$。
    $$
    P_{old} \cdot c + Q_{old} = P_{new} \cdot c + Q_{new}
    $$
    $$
    Q_{new} = Q_{old} + (P_{old} - P_{new}) \cdot c = Q_{old} - (P_{new} - P_{old}) \cdot c
    $$
    令 $\Delta P = P_{new} - P_{old}$ 为斜率变化量，则 $Q_{new} = Q_{old} - \Delta P \cdot c$。

#### 算法步骤总结

好啦，整理一下我们的计划，喵~
1.  创建一个事件点列表。对于每个 $a_i$，加入事件 `{coord: a_i, slope_change: +2}`。对于每个 $b_j$，加入事件 `{coord: b_j, slope_change: -2}`。
2.  为了处理题目给定的 `k` 的范围 $[-2 \cdot 10^9, 2 \cdot 10^9]$，我们把这两个边界也作为事件点加进去，它们的斜率变化量为0。
3.  对所有事件点按坐标从小到大排序。
4.  计算初始的斜率 `slope = m - n` 和截距 `intercept = sum(a) - sum(b)`。
5.  初始化最小值为一个超大数，`min_val = infinity`，最佳k为 `best_k`。
6.  遍历排序后的事件点。对于相邻的两个事件点 `event_prev` 和 `event_curr`，我们得到了一个区间 `[event_prev.coord, event_curr.coord]`。
7.  在这个区间内，函数是 `G(k) = slope * k + intercept`。我们检查区间端点和可能的整数根 `round(-intercept / slope)`，找到此区间的最小值，并更新全局的 `min_val` 和 `best_k`。
8.  处理完一个区间后，根据当前事件点 `event_curr` 的斜率变化量，更新 `slope` 和 `intercept`，为下一个区间做准备。
9.  遍历结束后，`best_k` 就是我们想要的答案啦！

## 代码实现

下面就是本猫娘根据上面的思路，精心编写的代码哦！希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

// 为了代码清晰，我们定义一个事件结构体，喵~
struct Event {
    long long coord;      // 事件发生的坐标 k
    long long slope_change; // 在该坐标处，G(k)的斜率变化量

    // 方便排序
    bool operator<(const Event& other) const {
        if (coord != other.coord) {
            return coord < other.coord;
        }
        return slope_change < other.slope_change;
    }
};

// 计算在当前线性函数 P*k + Q 下，给定 k 处的值
long long calculate_G(long long k, long long slope, long long intercept) {
    return std::abs(slope * k + intercept);
}

int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 加速输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m;
    std::cin >> n >> m;

    std::vector<long long> a(n), b(m);
    long long sum_a = 0, sum_b = 0;

    std::vector<Event> events;
    const long long K_MIN = -2000000000LL;
    const long long K_MAX = 2000000000LL;

    // 添加边界事件点，斜率变化为0
    events.push_back({K_MIN, 0});
    events.push_back({K_MAX, 0});

    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        sum_a += a[i];
        events.push_back({a[i], 2}); // a_i 贡献 +2 的斜率变化
    }
    for (int i = 0; i < m; ++i) {
        std::cin >> b[i];
        sum_b += b[i];
        events.push_back({b[i], -2}); // b_j 贡献 -2 的斜率变化
    }

    // 对事件点进行排序
    std::sort(events.begin(), events.end());
    // 去除重复坐标的事件，并将它们的斜率变化合并
    std::vector<Event> unique_events;
    if (!events.empty()) {
        unique_events.push_back(events[0]);
        for (size_t i = 1; i < events.size(); ++i) {
            if (events[i].coord == unique_events.back().coord) {
                unique_events.back().slope_change += events[i].slope_change;
            } else {
                unique_events.push_back(events[i]);
            }
        }
    }
    
    // 初始斜率和截距
    long long current_slope = (long long)m - n;
    long long current_intercept = sum_a - sum_b;

    long long min_val = -1;
    long long best_k = K_MIN;

    // 扫描线开始！
    for (size_t i = 0; i < unique_events.size(); ++i) {
        long long current_coord = unique_events[i].coord;
        
        // 检查当前点
        long long val_at_coord = calculate_G(current_coord, current_slope, current_intercept);
        if (min_val == -1 || val_at_coord < min_val) {
            min_val = val_at_coord;
            best_k = current_coord;
        } else if (val_at_coord == min_val) {
            best_k = std::min(best_k, current_coord);
        }

        // 检查区间内的根
        if (current_slope != 0) {
            // G(k) = 0 的解是 k = -intercept / slope
            // 由于 k 必须是整数，我们检查这个解附近的整数点
            long long root_k = -current_intercept / current_slope; 
            
            // 检查根附近的三个整数点
            for (long long j = -1; j <= 1; ++j) {
                long long test_k = root_k + j;
                // 确保测试点在当前有效区间内
                if (i > 0 && test_k > unique_events[i-1].coord && test_k < current_coord) {
                    long long val_at_test_k = calculate_G(test_k, current_slope, current_intercept);
                    if (min_val == -1 || val_at_test_k < min_val) {
                        min_val = val_at_test_k;
                        best_k = test_k;
                    } else if (val_at_test_k == min_val) {
                        best_k = std::min(best_k, test_k);
                    }
                }
            }
        }
        
        // 更新斜率和截距，为下一个区间做准备
        long long slope_change = unique_events[i].slope_change;
        current_intercept -= slope_change * current_coord;
        current_slope += slope_change;
    }

    std::cout << best_k << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O((n+m) \log (n+m))$
    - 我们有 $n+m+2$ 个事件点。
    - 对这些事件点排序是主要的时间开销，需要 $O((n+m) \log (n+m))$ 的时间。
    - 之后的扫描线遍历是线性的，需要 $O(n+m)$ 的时间。
    - 所以总的时间复杂度由排序决定，是 $O((n+m) \log (n+m))$，喵~

- **空间复杂度**: $O(n+m)$
    - 我们需要一个 `vector` 来存储所有的事件点，其大小为 $n+m+2$，所以空间复杂度是 $O(n+m)$。

## 知识点总结

这道题虽然伪装成数学题，但核心是一个非常经典的算法思想，值得我们好好学习，呐！

1.  **分段线性函数**: 理解题目中的函数 $G(k)$ 是一个分段线性函数是解题的第一步。很多复杂的绝对值函数问题都可以转化为对分段函数的分析。
2.  **扫描线算法 (Sweep-Line)**: 这是一个强大的算法思想！通过将问题从一个静态的整体，转化为一个动态的从左到右的扫描过程，可以有效地处理几何问题和区间问题。在这里，我们通过扫描 `k` 轴，把问题分解成了一系列简单的线性函数求最小值问题。
3.  **斜率与截距的维护**: 在扫描线移动过程中，如何高效地更新状态是关键。我们推导出的斜率和截距的更新公式 $P_{new} = P_{old} + \Delta P$ 和 $Q_{new} = Q_{old} - \Delta P \cdot c$ 是算法的核心。
4.  **极值点分析**: 对于一个区间上的线性函数 $|P \cdot k + Q|$，其最值点只可能出现在区间的端点或者函数值为0的点。这个性质大大减少了我们需要检查的点数。

希望这篇题解能帮助主人理解这道题的奥秘！如果还有不懂的地方，随时可以再来问我哦，喵~