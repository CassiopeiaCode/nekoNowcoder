# 寻找最小的k - 题解

哈喵~！各位算法爱好者们，大家好呀！咱是乃爱算法的小猫娘，今天也要元气满满地和大家一起攻克难题喵！(ฅ'ω'ฅ)

这次我们要挑战的题目是寻找一个神奇的整数 `k`，让一个看起来超级复杂的式子变得最小。别怕别怕，只要跟着本猫娘的思路，再复杂的纸老虎也会被我们轻松打败的说！

### 比赛与标签
> **比赛**: dotcpp.com 编程竞赛-题库
> **标签**: 绝对值, 三分
> **难度**: *1800

(小声说：这道题的官方标签有“三分”，但实际上用三分来解有点小陷阱哦~ 本猫娘的解法会更直接有效呐！)

## 题目解读喵~

简单来说，题目给了我们两个整数数组 `a` 和 `b`，还有一个神秘的整数 `k`。我们需要在一个很大的范围（-2e9 到 2e9）里找到一个 **最小的** `k`，使得下面这个式子的值达到最小：

`Value(k) = | ( a[i] 到 k 的距离之和 ) - ( b[j] 到 k 的距离之和 ) |`

用数学公式表达就是：
`Value(k) = | (∑|a_i - k|) - (∑|b_j - k|) |`

我们的任务就是：
1.  找到一个 `k`，让 `Value(k)` 最小。
2.  如果有很多个 `k` 都能让 `Value(k)` 最小，我们要输出其中最小的那个 `k`。

## 思路分析的说！

看到这个带有绝对值和求和的复杂式子，是不是有点头大呀？别急，让本猫娘来把它一层层剥开，就像剥洋葱一样，核心其实很简单喵~

我们定义一个函数 `f(k) = (∑|a_i - k|) - (∑|b_j - k|)`。我们的目标就变成了，找到最小的 `k`，使得 `|f(k)|` 最小。

#### 函数 f(k) 的小秘密

`f(k)` 这个函数有什么特点呢？我们来分析一下它的组成部分。像 `g(k) = ∑|x_i - k|` 这样的函数，它是一个**凸函数**，形状像一个 "V" 字形（或者更宽的碗形）。它的导数（或者说斜率）是 `g'(k) = ∑sgn(k - x_i)`，这是一个单调不减的阶梯函数。

但是！我们的 `f(k)` 是两个凸函数的差，它就不一定是凸函数了。所以直接用三分法来找 `|f(k)|` 的最小值是行不通的，因为它可能存在多个局部最小值，像 "W" 形一样，会让三分陷入局部最优解的陷阱里。

那该怎么办呢？我们回到 `f(k)` 的导数（斜率）上来：
`f'(k) = (∑|a_i - k|)' - (∑|b_j - k|)' = ∑sgn(k - a_i) - ∑sgn(k - b_j)`

这个导数（斜率）只会在 `k` 等于某个 `a_i` 或者 `b_j` 的时候发生变化。这些点我们称之为**临界点**。

这意味着，在任意两个相邻的临界点之间，`f(k)` 的斜率是恒定的！也就是说，`f(k)` 在这些区间内是**线性的**！

哇！一个复杂的函数，被我们拆解成了一段段的直线！这下问题就简单多啦。

#### 分段处理大法！

我们的策略就是：
1.  **收集所有临界点**：把数组 `a` 和 `b` 中所有的数都收集起来，这些就是我们划分区间的临界点。
2.  **排序**：将所有临界点从小到大排序。这样我们就得到了一系列区间 `(-∞, p_1], (p_1, p_2], ..., (p_t, +∞)`。
3.  **逐段分析**：我们从左到右依次处理每个区间。在每个区间 `(p_{i-1}, p_i]` 内，`f(k)` 都是一条直线，可以表示为 `f(k) = K * k + B`，其中斜率 `K` 和截距 `B` 在这个区间内是固定的。
    *   我们要找的就是 `|K * k + B|` 在 `k ∈ [p_{i-1}, p_i]` 上的最小值。
    *   如果 `K = 0`，函数是常数，区间内任意一点都是最小值。
    *   如果 `K ≠ 0`，`|K * k + B|` 是一个 "V" 形。它的最小值在 `k = -B/K` 处取得。我们只需要判断这个点是否在当前区间内。
        *   若 `-B/K` 在区间内，那么它就是候选的最优解之一。
        *   若 `-B/K` 在区间外，那么最小值一定在区间的两个端点 `p_{i-1}` 或 `p_i` 处取得。
4.  **维护斜率和截距**：当 `k` 从一个区间移动到下一个区间，穿过一个临界点 `p_i` 时，`f(k)` 的斜率 `K` 会发生变化。
    *   如果 `p_i` 来自数组 `a`，斜率增加 2。
    *   如果 `p_i` 来自数组 `b`，斜率减少 2。
    截距 `B` 也要相应更新，以保证函数 `f(k)` 的连续性。`f(k)` 在 `p_i` 点是连续的，所以可以用 `B_new = B_old - (K_new - K_old) * p_i` 来更新。
5.  **追踪最优解**：在遍历所有区间的过程中，我们不断更新找到的最小 `Value(k)` 和对应的最小 `k`。

通过这种方式，我们就能扫描整个数轴，找到全局最优解了喵！

## 代码实现喵~

下面就是根据这个思路写出的AC代码啦！本猫娘已经加上了详细的注释，方便大家理解每一行代码的作用哦~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef pair<int,int> PI;
#define int long long // 使用 long long 防止整数溢出，k 的范围很大喵

vector<PI>st; // 用来存储所有的临界点和斜率变化量 {坐标, 斜率变化}
int n,m,ans,x,val,c1,c2,val2,l=-2000000000,k,b; // l是区间的左端点, k是斜率, b是截距

void solve(){
    cin>>n>>m;

    // 1. 初始化斜率 k 和截距 b
    // 考虑 k < min(a_i, b_j) 的情况
    // f(k) = sum(a_i - k) - sum(b_j - k) = (sum(a_i) - sum(b_j)) + (m - n) * k
    k = m - n; // 初始斜率
    b = 0;     // 初始截距，后面循环读入时累加

    // 为了覆盖整个 -2e9 到 2e9 的范围，我们加入两个虚拟的边界点
    // st.push_back({-l, 0}) 也就是 st.push_back({2000000000, 0})
    // 这样最后一个区间就是 [最后一个真实临界点, 2e9]
    st.push_back({-l, 0}); 

    // 2. 读入数据，计算初始截距，并记录临界点
    while(n--){
        cin>>x;
        b += x; // 累加到截距 b 中
        st.push_back({x, 2}); // k 穿过 a_i，斜率变化量是 +2
    }
    while(m--){
        cin>>x;
        b -= x; // 从截距 b 中减去
        st.push_back({x, -2}); // k 穿过 b_j，斜率变化量是 -2
    }

    // 3. 对所有临界点进行排序
    sort(st.begin(),st.end());

    // 4. 初始化最优解
    ans = l; // 初始答案 k 设为区间的左边界
    val = abs(k * l + b); // 计算初始的最小函数值

    // 5. 遍历所有临界点，分段处理
    for(auto &[r, slope_change] : st){ // r 是当前区间的右端点
        // 当前处理的区间是 [l, r]
        // 在这个区间内，函数是 f(x) = k*x + b
        
        if(k != 0){ // 如果斜率不为0，函数是单调的
            c1 = -b / k; // 找到 V 形的谷底 x 坐标
            // 因为我们要找整数k，所以真正的最优解在 c1 附近
            // 检查 c1 和它旁边的两个整数
            for(int i = -1; i <= 1; i++){
                c2 = c1 + i;
                // 将候选解 c2 限制在当前区间 [l, r] 内
                if(c2 < l) c2 = l;
                if(c2 > r) c2 = r;
                
                val2 = abs(k * c2 + b); // 计算候选值
                if(val2 < val){ // 如果找到了更小的值
                    val = val2;
                    ans = c2;
                } else if (val2 == val && c2 < ans) { // 如果值相等，取更小的 k
                    ans = c2;
                }
            }
        }
        else{ // 如果斜率 k 为 0，函数是常数
            c2 = l; // 区间内任意一点的值都一样，我们只关心最小的 k
            val2 = abs(k * c2 + b); // 也就是 abs(b)
            if(val2 < val){
                val = val2;
                ans = c2;
            } else if (val2 == val && c2 < ans) {
                ans = c2;
            }
        }

        // 6. 更新斜率和截距，为下一个区间做准备
        // k 穿过了点 r，斜率发生变化
        k += slope_change;
        // 截距也要更新，保证函数在 r 点连续
        // B_new = B_old - (K_new - K_old) * r = B_old - slope_change * r
        b -= slope_change * r;
        
        // 更新下一个区间的左端点
        l = r;
    }
    cout << ans;
}

signed main(){
    ios_base::sync_with_stdio(false); // 加速输入输出喵~
    cin.tie(NULL);
    solve();
    return 0;
}
```

## 复杂度分析的说

-   **时间复杂度**: O((n+m)log(n+m)) 的说。
    瓶颈在于对 `n+m` 个临界点进行排序。之后遍历所有临界点只需要线性的 O(n+m) 时间。所以总的复杂度就是排序的复杂度呐。

-   **空间复杂度**: O(n+m) 的说。
    我们需要一个 `vector` 来存储所有的 `n+m` 个临界点，所以空间开销是线性的。

## 知识点与总结喵！

这道题真是非常有趣，它完美地将数学分析和算法结合在了一起！

1.  **核心思想：分段函数与斜率分析**
    这道题最关键的洞察是，目标函数 `f(k)` 是一个**分段线性函数**。它的“分段点”就是输入数据中的所有 `a_i` 和 `b_j`。在每个分段区间内，函数都是一条简单的直线，这让复杂的问题变得可以处理了。

2.  **算法实现：扫描线思想**
    我们从小到大遍历所有临界点，就像一条扫描线从左到右扫过数轴。在每两个临界点之间，我们分析函数的性质并找到局部最优解。同时，每当扫描线经过一个临界点，我们就更新函数的参数（斜率和截距），为分析下一个区间做准备。

3.  **编程技巧与注意事项**
    *   **数据范围**: `k` 的范围很大，所以一定要用 `long long` 来避免溢出。
    *   **边界处理**: 为了处理 `(-∞, min_val)` 和 `(max_val, +∞)` 这两个无限区间，代码中巧妙地加入了 `-2e9` 和 `2e9` 作为虚拟的边界点，使得整个处理流程统一起来，非常优雅喵！
    *   **整数最优解**: `|K*k+B|` 的理论最小值在 `k=-B/K`，但这不一定是整数。真正的整数最优解在 `floor(-B/K)` 或 `ceil(-B/K)`。代码里检查 `c1-1, c1, c1+1` 是一个简单有效的处理方式。
    *   **多解取小**: 题目要求输出最小的 `k`，所以在更新答案时，如果发现函数值相同，要判断一下当前的 `k` 是否比已记录的答案更小。

希望本猫娘的讲解能帮助你理解这道题的精髓！遇到这种带有绝对值的难题，不妨先画画图，分析一下函数的性质，也许就能发现像“分段线性”这样美丽的突破口哦！大家继续加油，我们下次再见喵~！(≧∇≦)ﾉ