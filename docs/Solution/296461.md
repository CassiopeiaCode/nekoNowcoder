# D-Zeeman's Number - 题解

### 比赛与标签
> **比赛**: 赛码 D-Zeeman's Number
> **标签**: NTT, DP
> **难度**: *2500

## 题目大意喵~
主人有一个长度为 `n` 的数组 `a`，其中有些位置是 `-1`（表示待定），有些是 `0` 到 `k-1` 之间的整数。同时，对于每个位置 `i`，都有一个可以替换的数字集合 `S_i`。

我们可以对数组 `a` 进行重新赋值：
1.  如果 `a[i]` 本来就是 `-1`，我们可以从集合 `S_i` 中任选一个数填进去，这个操作是**免费**的哦！
2.  如果 `a[i]` 原本有值，我们也可以从集合 `S_i` 中任选一个数替换它，但这次需要花费 **1** 的代价。

我们的目标是，在**总花费不超过 1** 的前提下，通过这些操作得到一个新的数组 `a'`。然后，对这个新数组 `a'` 进行一个神奇的 `f(a')` 变换，这个变换会得到一个 `0` 到 `k-1` 之间的最终数字。

题目要求我们计算，对于每一个可能的最终数字 `x` (从 `0` 到 `k-1`)，有多少种不同的赋值方案可以得到它？

这个 `f(a)` 函数看起来很复杂，它会把数组所有元素的和变成一个 k 进制数，然后对这个新的数位数组递归调用 `f`，直到数组长度为 1。听起来就头大，对吧？别怕，这里面有捷径可走哦！

## 解题思路详解，快跟上喵！

### 关键的第一步：看穿 `f(a)` 的真面目！
那个递归函数 `f(a)` 看起来超级唬人，但其实它是一个非常经典的概念——**k进制下的数根（Digital Root）**！

一个重要的数学性质是：一个数 `N` 和它在 `k` 进制下所有数位的和，它们除以 `(k-1)` 的余数是相同的。也就是说 `N ≡ sum_of_digits_k(N) (mod k-1)`。

`f(a)` 的过程就是不断地求和、转换、再求和……这不就是在反复利用上面这个性质嘛！所以，无论这个过程多么曲折，最终得到的那个唯一的数字 `x`，一定和最初数组 `a'` 所有元素的总和 `S` 满足：
`S ≡ x (mod k-1)`

但是有两个特殊的小猫腻需要注意：
1.  如果 `S = 0`，那么最终结果 `x` 就是 `0`。
2.  如果 `S > 0` 且 `S ≡ 0 (mod k-1)`，那么最终结果 `x` 是 `k-1`。（因为数根的结果通常是 `1` 到 `k-1`）
3.  对于其他情况，`x = S % (k-1)`，如果余数是0就看作`k-1`，但这里我们直接用 `S ≡ x (mod k-1)` 就好，因为`x`的范围是`0`到`k-1`。

所以，问题被我们简化成了：**求花费不超过1的方案数，使得新数组 `a'` 的元素总和模 `(k-1)` 等于某个目标值 `t`。**

### 第二步：用多项式来计数，NTT登场！
这种“求和模M等于T的方案数”的问题，简直是为**多项式乘法（卷积）**量身定做的！我们可以用 **NTT (快速数论变换)** 来加速这个过程。

我们可以为每个位置 `i` 的选择构造一个多项式 `P_i(x)`。多项式中 `x^j` 项的系数，表示为位置 `i` 选择一个值 `v`，使得 `v % (k-1) == j` 的方案数。

把所有位置的 `P_i(x)` 乘起来，得到的大多项式 `Result(x) = P_1(x) * P_2(x) * ... * P_n(x)` 中，`x^t` 项的系数，就是所有元素之和模 `(k-1)` 等于 `t` 的总方案数！

### 第三步：分情况讨论，成本计算要精细！
我们的总花费不能超过 1，所以可以分成两种情况来计算：

**情况一：花费为 0**
这意味着，所有 `a[i] != -1` 的位置都不能动，我们只能填写那些 `a[i] == -1` 的位置。
-   对于 `a[i] == -1` 的位置，它的选择多项式是 `P_i(x) = Σ_{v ∈ S_i} x^(v % (k-1))`。
-   对于 `a[i] != -1` 的位置，它的值是固定的 `a[i]`，贡献是 `x^(a[i] % (k-1))`。

我们先把所有 `a[i] == -1` 的位置对应的多项式用 NTT 全部乘起来，得到一个基础多项式 `DP_base(x)`。
然后，计算所有 `a[i] != -1` 的位置的初始值之和 `S_fixed`。
最后，将 `DP_base(x)` 的系数进行循环位移，`Ans_0[t] = DP_base[(t - S_fixed % (k-1) + k-1) % (k-1)]`。这就是花费为 0 的方案数啦！

**情况二：花费为 1**
这意味着，我们选择**恰好一个** `a[j] != -1` 的位置 `j` 进行修改，把它从 `a[j]` 换成 `S_j` 中的某个数。其他 `a[i] != -1` 的位置保持不变，所有 `a[i] == -1` 的位置照常填写。
-   我们可以遍历每一个 `a[j] != -1` 的位置 `j` 作为那个被修改的位置。
-   对于这个 `j`，它的选择多-   项式变成了 `Q_j(x) = Σ_{v ∈ S_j} x^(v % (k-1))`。
-   其他 `a[i] == -1` 的位置贡献还是 `DP_base(x)`。
-   其他 `a[i] != -1 (i≠j)` 的位置贡献是固定的，它们的和是 `S_fixed - a[j]`。
-   所以，对于固定的 `j`，方案数的多项式是 `DP_base(x) * Q_j(x)`，再进行循环位移。

我们把所有可能的 `j` 的方案数加起来，就是总花费为 1 的方案数了。

### 第四步：处理特殊的 `0` 和 `k-1`
我们用 NTT 算出来的 `ans[t]` 是 `sum(a') % (k-1) == t` 的方案数。
-   `ans[1]` 到 `ans[k-2]` 就是最终答案。
-   `ans[0]` 包含了 `sum(a') = 0` 和 `sum(a') > 0` 且 `sum(a') % (k-1) == 0` 两种情况。
-   `sum(a') = 0` 对应最终结果 `0`。
-   `sum(a') > 0` 且 `sum(a') % (k-1) == 0` 对应最终结果 `k-1`。

所以，我们需要单独计算出 `sum(a') = 0` 的方案数，记为 `zero_count`。
-   最终答案中，`x=0` 的方案数就是 `zero_count`。
-   最终答案中，`x=k-1` 的方案数是 `ans[0] - zero_count`。

计算 `zero_count` 是一个简单的分类讨论，具体可以看代码里的 `get()` 函数，它很清晰地实现了这个逻辑哦！

## 代码实现喵！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
using namespace std;
 
#define ll long long
#define ull unsigned long long
#define i128 __int128
 
ll read()
{
    ll x = 0; bool f = false; char c = getchar();
    while(c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while(c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c & 15), c = getchar();
    return f ? -x : x;
}
 
const ll mod = 998244353, G = 3;
const int N = 8e3 + 5;
const ll inv2 = (mod + 1) / 2;
int n, K, a[N];
vector<int> S[N];
 
// NTT模板，用来做多项式乘法（卷积）
namespace poly_NTT
{
    ll g[2][N], t1[N], t2[N], jc[N], inv[N];
    int n, L, R[N];
 
    ll qpow(ll a,  ll b, ll mod)
    {
        ll ans = 1;
        while(b)
        {
            if(b & 1) ans = ans * a % mod;
            b >>= 1;
            a = a * a % mod;
        }
        return ans;
    }
 
    void init(int A, int B)
    {
        for(n = 1, L = 0; n < A + B; n <<= 1, ++L);
        g[1][0] = g[0][0] = 1, g[0][1] = qpow(G, (mod - 1) / n, mod);
        g[1][1] = qpow(qpow(G, mod - 2, mod), (mod - 1) / n, mod);
        for(int i = 2; i < n; ++i)
        {
            g[0][i] = g[0][i - 1] * g[0][1] % mod;
            g[1][i] = g[1][i - 1] * g[1][1] % mod;
        }
        for(int i = 0; i < n; ++i) R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
    }
 
    void NTT(ll *a, int n, int type)
    {
        for(int i = 0; i < n; ++i) if(R[i] > i) swap(a[R[i]], a[i]);
        for(int t = n >> 1, d = 1; d < n; d <<= 1, t >>= 1)
            for(int i = 0; i < n; i += (d << 1))
                for(int j = 0; j < d; ++j)
                {
                    ll temp = g[type][t * j] * a[i + j + d] % mod;
                    a[i + j + d] = (a[i + j] - temp + mod) % mod;
                    a[i + j] = (a[i + j] + temp) % mod;
                }
        if(type == 1)
        {
            ll temp = qpow(n, mod - 2, mod);
            for(int i = 0; i < n; ++i) a[i] = a[i] * temp % mod;
        }
    }
    void mul(ll *a, int A, ll *b, int B, ll *ans)
    {
        init(A, B);
        for(int i = 0; i < A; ++i) t1[i] = a[i];
        for(int i = 0; i < B; ++i) t2[i] = b[i];
        for(int i = 0; i < n; ++i) ans[i] = 0;
        NTT(t1, n, 0), NTT(t2, n, 0);
        for(int i = 0; i < n; ++i) ans[i] = t1[i] * t2[i] % mod;
        NTT(ans, n, 1);
        for(int i = 0; i < n; ++i) t1[i] = t2[i] = 0;
    }
}
 
ll qpow(ll a, ll b, ll mod)
{
    ll ans = 1;
    while(b)
    {
        if(b & 1) ans = ans * a % mod;
        b >>= 1;
        a = a * a % mod;
    }
    return ans;
}
 
void add(ll &x, ll y){ x = (x + y >= mod) ? (x + y - mod) : (x + y); }
 
ll dp[N], t1[N], t2[N];
 
// 特殊处理函数，计算总和为0的方案数（花费<=1）
ll get()
{
    bool f = 1, g = 1;
    // f: 所有非-1的数是否都为0
    // g: 所有-1的位置，其S集合里是否都包含0
    for(int i = 1; i <= n; ++i)
    {
        if(a[i] != -1) f &= (a[i] == 0);
        else g &= (find(S[i].begin(), S[i].end(), 0) != S[i].end());
    }
    
    // Case 1: 所有非-1的数都是0，且所有-1的位置都能填0
    if(f & g)
    {
        int cnt = 0;
        // 统计有多少个非-1的位置，它们的S集合里也包含0
        // 这些位置可以作为花费1的修改点（从0改成0）
        for(int i = 1; i <= n; ++i)
            if(a[i] != -1)
                cnt += (find(S[i].begin(), S[i].end(), 0) != S[i].end());
        // 1是花费0的方案，cnt是花费1的方案
        return cnt + 1;
    }
    // Case 2: 并非所有非-1的数都是0，但所有-1的位置都能填0
    else if(g)
    {
        int cnt = 0;
        // 必须通过1次花费，把某个非0数改成0，才能使总和为0
        for(int i = 1; i <= n; ++i)
            if(a[i] != -1)
            {
                if(a[i] != 0)
                {
                    ++cnt;
                    // 如果这个非0数不能被改成0，则此路不通
                    if(find(S[i].begin(), S[i].end(), 0) == S[i].end()) return 0;
                }
            }
        // 必须恰好有1个这样的非0数可以被修改
        return (cnt == 1);
    }
    // 其他情况不可能使总和为0
    else return 0;
}
 
ll ans[N];
 
void solve()
{
    n = read(), K = read();
    for(int i = 1; i <= n; ++i) a[i] = read();
    for(int i = 1; i <= n; ++i)
    {
        int c = read();
        S[i].resize(c, 0);
        for(int j = 0; j < c; ++j) S[i][j] = read();   
    }
    
    // dp[j]表示当前元素和模(K-1)为j的方案数
    dp[0] = 1; // 初始多项式是1，即x^0

    // 1. 计算所有 a[i] == -1 的位置贡献的卷积
    for(int i = 1; i <= n; ++i)
    {
        if(a[i] != -1) continue; // 只处理-1的位置
        for(int j = 0; j < K - 1; ++j) t1[j] = 0;
        for(auto x : S[i]) ++t1[x % (K - 1)]; // 构造当前位置的多项式
        poly_NTT::mul(dp, K - 1, t1, K - 1, t2); // 乘到dp里
        // 处理循环卷积，把超出K-1的部分加回到前面
        for(int j = K - 1; j < K + K - 2; ++j) add(t2[j - K + 1], t2[j]);
        for(int j = 0; j < K - 1; ++j) dp[j] = t2[j];
    }
    
    // 2. 计算花费为0的方案数
    ll sum = 0;
    for(int i = 1; i <= n; ++i) if(a[i] != -1) sum += a[i];
    sum %= (K - 1); // 计算固定值的总和模(K-1)
    
    // 将dp的结果循环位移sum，加入最终答案
    for(int i = 0; i < K - 1; ++i) add(ans[(i + sum) % (K - 1)], dp[i]);
    
    // 3. 计算花费为1的方案数
    for(int i = 1; i <= n; ++i)
    {
        if(a[i] == -1) continue; // 遍历每个可以被修改的非-1位置
        for(int j = 0; j < (K - 1); ++j) t1[j] = 0;
        
        // 构造修改位置i的贡献多项式，并预先处理好位移
        // (sum - a[i]) 是其他固定值的和，x是新值
        for(auto x : S[i]) ++t1[(sum - a[i] + x + (K - 1) + (K - 1)) % (K - 1)];
        
        // 乘以-1位置的总贡献dp
        poly_NTT::mul(dp, K - 1, t1, K - 1, t2);
        for(int j = K - 1; j < K + K - 2; ++j) add(t2[j - K + 1], t2[j]);
        
        // 累加到最终答案
        for(int j = 0; j < K - 1; ++j) add(ans[j], t2[j]);
    }
    
    // 4. 处理特殊情况 0 和 k-1
    ll zero = get(); // 计算总和为0的方案数
    ans[K - 1] = (ans[0] - zero + mod) % mod; // ans[0]里包含了sum=0和sum>0且%(K-1)=0的情况
    ans[0] = zero % mod; // sum=0的情况单独赋值
    
    for(int i = 0; i < K; ++i) printf("%lld ", ans[i]);
}
 
int main()
{
    int T = 1;
    while(T--) solve();
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(N * K log K) 的说。我们最多会进行 `N` 次多项式乘法（对于每个 `-1` 的位置一次，对于每个非 `-1` 的位置在计算花费为1时也需要一次）。每次乘法是基于长度为 `K-1` 的多项式，使用 NTT 的时间是 `O(K log K)`。所以总时间就是 `O(N * K log K)` 啦。
- **空间复杂度**: O(K) 的说。我们主要需要空间来存储多项式的系数，包括 `dp` 数组和 NTT 用的临时数组，大小都和 `K` 相关。

## 知识点与总结，喵~
这道题真是一次有趣的冒险！它教会了我们：

1.  **洞察本质**: 面对复杂的题目描述，特别是递归定义，要敢于去寻找它背后的数学模型。本题的 `f(a)` 就是一个伪装起来的**数根**问题，看穿这一点是解题的关键！
2.  **多项式计数**: "和的模"、"组合计数"这类问题，是**生成函数**和**多项式卷积**大显身手的地方。当数据范围允许时，NTT 是实现卷积的强大武器。
3.  **分类讨论**: "花费不超过1" 这种限制条件，常常引导我们进行分类讨论（花费=0，花费=1）。把复杂问题拆解成几个简单的小问题，是解题的常用策略。
4.  **边界处理**: 一定要小心 `0` 和 `k-1` 这种模运算下的特殊值。它们的定义可能和普遍规律不同，需要单独拿出来分析和处理。

希望这次的题解能帮到大家！以后遇到类似的问题，也要像小猫一样，用敏锐的直觉发现问题核心，然后勇敢地解决它哦！加油，你们都是最棒的，喵！ (ฅ'ω'ฅ)