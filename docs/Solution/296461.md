# Zeeman 的 k 进制难题 - 题解

### 比赛与标签
> **比赛**: 暂无

> **标签**: dp, fft, ntt, 多项式

> **难度**: *2500

## 题目大意喵~

主人，这道题是这样的呐~

Zeeman桑有一个长度为 $n$ 的整数数组 $a = \{a_1, a_2, \dots, a_n\}$，其中每个元素 $a_i$ 的值都在 $[-1, k-1)$ 的范围内。同时，还有 $n$ 个整数集合 $S_1, S_2, \dots, S_n$。

对于数组中的每个位置 $i$，我们可以进行一次修改操作：将 $a_i$ 的值改成集合 $S_i$ 中的任意一个元素。这次修改的**花费**是根据 $a_i$ 的初始值决定的：
- 如果初始 $a_i = -1$，那么这次修改花费为 0。
- 如果初始 $a_i \neq -1$，那么这次修改花费为 1。

接下来，题目定义了一个非常有趣的函数 $f(b)$，它作用于一个整数数组 $b$。这个函数会不断地把数组所有元素的和，转换成 $k$ 进制下的数位数组，再求和，再转换……直到数组里只剩下一个数为止。这个数就是 $f(b)$ 的结果。

我们的任务是，对于每一个可能的最终结果 $x$（从 $0$ 到 $k-1$），计算有多少种修改方案，能够使得新数组 $a'$ 经过 $f(a')$ 的计算后，最终结果是 $x$，并且总花费**不超过 1**。

也就是说，我们要么不花钱（只修改 $a_i = -1$ 的位置），要么只花 1 块钱（修改一个 $a_i \neq -1$ 的位置，同时可以任意修改所有 $a_i = -1$ 的位置）。

答案需要对 $998244353$ 取模哦，喵~

## 解题思路分析

这道题看起来有点复杂，特别是那个递归定义的函数 $f(b)$，让人头晕晕的呢。但是别怕，让本猫娘来把它一层层剥开，看看里面到底藏着什么秘密，喵~

### 关键洞察：$f(b)$ 的本质

函数 $f(b)$ 的过程是：求和 $\rightarrow$ 转 $k$ 进制 $\rightarrow$ 新数组 $\rightarrow$ 求和 ...
这让本猫娘想到了一个熟悉的概念——**数根**（Digital Root）！

在十进制中，一个数和它的各位数字之和模 9 是同余的。这个性质可以推广到任意进制。对于一个正整数 $N$，它在 $k$ 进制下的各位数字之和为 $S_d$，那么我们有：
$$
N \equiv S_d \pmod{k-1}
$$
函数 $f(b)$ 的过程，就是不断地用各位数字之和来替代原来的和。这意味着，在每一步迭代中，数组元素的和模 $(k-1)$ 的值是不变的！

设我们修改后的数组是 $a'$，它的元素总和是 $S' = \sum_{i=1}^n a'_i$。
那么，经过 $f$ 函数的反复折腾，最终得到的那个唯一的数字 $x$，和最初的总和 $S'$ 有着非常密切的关系：

1.  **如果 $S' = 0$**：那么求和一直是 0，最终结果就是 $0$。
2.  **如果 $S' > 0$ 且 $S' \pmod{k-1} \neq 0$**：那么这个过程最终会收敛到 $S' \pmod{k-1}$。也就是说，最终结果是 $S' \pmod{k-1}$。
3.  **如果 $S' > 0$ 且 $S' \pmod{k-1} = 0$**：这个过程最终会收敛到 $k-1$。（比如 $k=10$，一个数是 9 的倍数，它的数根就是 9）。

哇！这样一来，问题就从一个复杂的递归过程，简化成了计算修改后数组总和 $S'$ 的问题了！我们的目标变成了：
- **求结果为 $x \in [1, k-2]$ 的方案数**：等价于求 $S' > 0$ 且 $S' \equiv x \pmod{k-1}$ 的方案数。
- **求结果为 $k-1$ 的方案数**：等价于求 $S' > 0$ 且 $S' \equiv 0 \pmod{k-1}$ 的方案数。
- **求结果为 $0$ 的方案数**：等价于求 $S' = 0$ 的方案数。

### 使用生成函数（多项式）来计数

对于这种“从一堆集合里各选一个数，求总和满足某种条件的方案数”的问题，生成函数（多项式）是我们的好朋友，喵~

我们可以用一个多项式的**指数**来表示我们选择的数值，用**系数**来表示方案数。
因为我们只关心总和模 $(k-1)$ 的结果，所以我们可以让多项式的指数也对 $(k-1)$ 取模。

对于数组的第 $i$ 个位置，它的选择方案可以表示成一个多项式 $P_i(z)$。我们把所有位置的 $P_i(z)$ 乘起来，得到的总多项式 $P_{total}(z) = \prod_{i=1}^n P_i(z)$ 中，$z^r$ 的系数就代表了总和模 $(k-1)$ 为 $r$ 的总方案数。

#### 花费为 0 的情况

花费为 0 时，我们只能修改那些 $a_i = -1$ 的位置（我们称它们为“自由位”），而 $a_i \neq -1$ 的位置（“固定位”）不能动。

-   对于自由位 $j$（$a_j = -1$），我们可以从 $S_j$ 中任选一个数。它对应的多项式是 $Q_j(z) = \sum_{v \in S_j} z^{v \pmod{k-1}}$。
-   对于固定位 $i$（$a_i \neq -1$），选择是唯一的，就是 $a_i$。它对应的多项式是 $z^{a_i \pmod{k-1}}$。

把它们全部乘起来，得到花费为 0 的总方案多项式：
$$
Ans_0(z) = \left( \prod_{j \text{ is free}} Q_j(z) \right) \cdot \left( \prod_{i \text{ is fixed}} z^{a_i \pmod{k-1}} \right)
$$
令 $DP_{free}(z) = \prod_{j \text{ is free}} Q_j(z)$，以及 $s_{fix} = \left(\sum_{i \text{ is fixed}} a_i\right) \pmod{k-1}$。
那么 $Ans_0(z) = DP_{free}(z) \cdot z^{s_{fix}}$。

$DP_{free}(z)$ 可以通过一个循环和多次多项式乘法来计算。每次乘法，我们都可以用 **NTT (快速数论变换)** 来加速，将 $O(K^2)$ 的朴素乘法优化到 $O(K \log K)$，其中 $K = k-1$ 是多项式的度数。

#### 花费为 1 的情况

花费为 1 时，我们需要恰好选择一个固定位 $p$ 进行修改，把它从 $a_p$ 改成 $S_p$ 中的某个值 $v$。其他固定位不变，所有自由位照常任选。

对于每个固定的 $p$，它贡献的方案多项式是 $\sum_{v \in S_p} z^{v \pmod{k-1}} = Q_p(z)$。
而其他固定位 $i \neq p$ 的贡献仍然是 $z^{a_i \pmod{k-1}}$。
自由位的总贡献还是 $DP_{free}(z)$。

所以，选择修改固定位 $p$ 的方案多项式是：
$$
Ans_{1,p}(z) = DP_{free}(z) \cdot Q_p(z) \cdot \left( \prod_{i \text{ is fixed}, i \neq p} z^{a_i \pmod{k-1}} \right)
$$
把所有可能的 $p$ 的贡献加起来，就是总的花费为 1 的方案多项式 $Ans_1(z) = \sum_{p \text{ is fixed}} Ans_{1,p}(z)$。
整理一下可以得到：
$$
Ans_1(z) = DP_{free}(z) \cdot z^{s_{fix}} \cdot \left( \sum_{p \text{ is fixed}} Q_p(z) \cdot z^{-a_p \pmod{k-1}} \right)
$$

#### 合并计算

总方案数（花费 $\le 1$）对应的多项式就是 $Ans(z) = Ans_0(z) + Ans_1(z)$。
$$
Ans(z) = DP_{free}(z) \cdot z^{s_{fix}} \cdot \left( 1 + \sum_{p \text{ is fixed}} Q_p(z) \cdot z^{-a_p \pmod{k-1}} \right)
$$
我们可以先计算出括号里的那个大大的求和多项式，然后再和 $DP_{free}(z)$ 等做乘法，这样更高效！

### 特殊情况：结果为 0

结果为 0 的情况必须单独处理，因为它要求总和 $S'$ 必须**严格等于** 0。由于所有可选值都是非负的，这要求我们选出的每一个 $a'_i$ 都必须是 0。

- **花费 0**：所有固定位 $a_i$ 必须本身就是 0。所有自由位 $j$ 必须从 $S_j$ 中选择 0（所以 $S_j$ 必须包含 0）。如果满足这些条件，就有 1 种方案。
- **花费 1**：选择一个固定位 $p$ 修改。为了让总和为 0，修改后所有数都得是 0。这意味着：
    1.  所有其他的固定位 $a_i (i \neq p)$ 必须是 0。
    2.  被修改的 $a_p$ 本身也必须是 0。
    3.  修改的目标值 $v$ 必须是 0，且 $0 \in S_p$。
    4.  所有自由位 $j$ 必须能选出 0（即 $0 \in S_j$）。
    满足这些苛刻条件的每个固定位 $p$ 都贡献 1 种方案。

所以，我们可以写一个函数来专门计算得到总和为 0 的方案数，记为 `zero_count`。

### 最终的算法步骤

1.  **预处理**：把数组 $a$ 分为固定位和自由位。
2.  **计算自由位多项式**：初始化一个结果多项式 `dp(z) = 1`。遍历所有自由位 $j$，为每个 $S_j$ 生成多项式 $Q_j(z)$，然后用 NTT 将 `dp(z)` 与 $Q_j(z)$ 相乘，更新 `dp(z)`。最终得到 $DP_{free}(z)$。
3.  **计算固定位贡献**：
    a. 计算固定位初始总和模 $(k-1)$ 的值 $s_{fix}$。
    b. 计算花费为 0 的方案多项式 $Ans_0(z) = DP_{free}(z) \cdot z^{s_{fix}}$。（这是一个简单的系数循环移位）
    c. 计算花费为 1 的那个大求和多项式 $C_1(z) = \sum_{p \text{ is fixed}} Q_p(z) \cdot z^{-a_p \pmod{k-1}}$。
    d. 计算花费为 1 的方案多项式 $Ans_1(z) = DP_{free}(z) \cdot z^{s_{fix}} \cdot C_1(z)$。（需要一次 NTT 乘法）
4.  **合并结果**：总方案多项式 $Ans(z) = Ans_0(z) + Ans_1(z)$。
5.  **处理特殊情况**：调用一个函数计算 `zero_count`。
6.  **输出答案**：
    - 对于 $x=0$，答案是 `zero_count`。
    - 对于 $x \in [1, k-2]$，答案是 $Ans(z)$ 中 $z^x$ 的系数。
    - 对于 $x=k-1$，答案是 $Ans(z)$ 中 $z^0$ 的系数减去 `zero_count`（因为 $S'=0$ 的情况也被算在了 $S' \equiv 0 \pmod{k-1}$ 里，需要排除）。

好啦，思路清晰了，接下来就是愉快的敲代码时间啦，喵~

## 代码实现

这是本猫娘根据上面的思路，重新编写的香喷喷的代码哦~ 每一步都有详细的注释，希望能帮助主人更好地理解！

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

const int MOD = 998244353;
const int NTT_G = 3;

// 快速幂，喵~
long long power(long long base, long long exp) {
    long long res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// NTT 模板，用于多项式乘法
namespace Poly {
    vector<long long> roots, rev;
    int ntt_limit;

    void precompute_ntt(int limit) {
        ntt_limit = limit;
        rev.assign(limit, 0);
        roots.assign(limit, 0);
        int log_limit = 0;
        while ((1 << log_limit) < limit) {
            log_limit++;
        }
        for (int i = 0; i < limit; i++) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (log_limit - 1));
        }
        long long g = power(NTT_G, (MOD - 1) / limit);
        roots[0] = 1;
        for (int i = 1; i < limit; i++) {
            roots[i] = (roots[i - 1] * g) % MOD;
        }
    }

    void ntt(vector<long long>& a, bool invert) {
        int n = a.size();
        for (int i = 0; i < n; i++) {
            if (i < rev[i]) {
                swap(a[i], a[rev[i]]);
            }
        }
        for (int len = 2; len <= n; len <<= 1) {
            int step = ntt_limit / len;
            for (int i = 0; i < n; i += len) {
                for (int j = 0; j < len / 2; j++) {
                    long long u = a[i + j];
                    long long v = (a[i + j + len / 2] * (invert ? roots[ntt_limit - j * step] : roots[j * step])) % MOD;
                    a[i + j] = (u + v) % MOD;
                    a[i + j + len / 2] = (u - v + MOD) % MOD;
                }
            }
        }
        if (invert) {
            long long inv_n = power(n, MOD - 2);
            for (int i = 0; i < n; i++) {
                a[i] = (a[i] * inv_n) % MOD;
            }
        }
    }

    vector<long long> multiply(vector<long long> a, vector<long long> b) {
        int deg_a = a.size() - 1;
        int deg_b = b.size() - 1;
        int limit = 1;
        while (limit < deg_a + deg_b + 1) {
            limit <<= 1;
        }
        a.resize(limit, 0);
        b.resize(limit, 0);
        
        precompute_ntt(limit);
        ntt(a, false);
        ntt(b, false);
        
        for (int i = 0; i < limit; i++) {
            a[i] = (a[i] * b[i]) % MOD;
        }
        
        ntt(a, true);
        a.resize(deg_a + deg_b + 1);
        return a;
    }
}

// 辅助函数，让多项式系数在 K-1 域上循环
void wrap_around(vector<long long>& p, int K_minus_1) {
    if (p.size() <= K_minus_1) return;
    for (int i = K_minus_1; i < p.size(); ++i) {
        p[i % K_minus_1] = (p[i % K_minus_1] + p[i]) % MOD;
    }
    p.resize(K_minus_1);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, k;
    cin >> n >> k;

    vector<int> a(n);
    vector<vector<int>> S(n);
    vector<bool> is_free(n);
    long long fixed_sum_mod = 0;

    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        is_free[i] = (a[i] == -1);
    }
    for (int i = 0; i < n; ++i) {
        int c;
        cin >> c;
        S[i].resize(c);
        for (int j = 0; j < c; ++j) {
            cin >> S[i][j];
        }
    }

    if (k == 1) {
        // k=1 是个超级特殊情况，模 k-1 没有意义。
        // 结果只能是 0，要求总和也为 0。
        long long zero_count = 0;
        // Cost 0: all a_i must be 0, all chosen from S_j must be 0
        bool cost0_possible = true;
        for(int i=0; i<n; ++i) {
            if(!is_free[i] && a[i] != 0) cost0_possible = false;
            bool can_choose_0 = false;
            for(int v : S[i]) if(v==0) can_choose_0 = true;
            if(is_free[i] && !can_choose_0) cost0_possible = false;
        }
        if(cost0_possible) zero_count = 1;
        // Cost 1: one a_p != -1 is modified. To get sum 0, all must be 0.
        // This implies original a had only one non-zero at a_p, and a_p is changed to 0.
        // This is complex. But with k=1, a_i must be -1 or 0.
        // So a_p must be 0, changed to 0. This is counted in cost 0.
        // The problem statement says -1 <= a_i < k, so a_i can only be -1 or 0.
        // All a_i in fixed set must be 0. We can "change" a_i=0 to 0 from S_i.
        long long cost1_count = 0;
        if(cost0_possible) {
            for(int i=0; i<n; ++i) {
                if(!is_free[i]) { // a[i] must be 0
                    bool can_choose_0 = false;
                    for(int v : S[i]) if(v==0) can_choose_0 = true;
                    if(can_choose_0) cost1_count++;
                }
            }
        }
        cout << (zero_count + cost1_count) % MOD << endl;
        return 0;
    }

    int K_minus_1 = k - 1;

    // 1. 计算自由位贡献的多项式 dp_free
    vector<long long> dp_free(1, 1); // dp_free(z) = 1
    for (int i = 0; i < n; ++i) {
        if (is_free[i]) {
            vector<long long> q_i(K_minus_1, 0);
            for (int val : S[i]) {
                q_i[val % K_minus_1]++;
            }
            dp_free = Poly::multiply(dp_free, q_i);
            wrap_around(dp_free, K_minus_1);
        }
    }
    
    // 2. 计算花费 <= 1 的总方案数多项式
    vector<long long> ans_poly(K_minus_1, 0);

    // 2a. 计算固定位的初始和
    for (int i = 0; i < n; ++i) {
        if (!is_free[i]) {
            fixed_sum_mod = (fixed_sum_mod + a[i]) % K_minus_1;
        }
    }

    // 2b. 加上花费为 0 的方案
    vector<long long> ans0 = dp_free;
    vector<long long> temp_ans0(K_minus_1, 0);
    for(int i = 0; i < K_minus_1; ++i) {
        temp_ans0[(i + fixed_sum_mod) % K_minus_1] = ans0[i];
    }
    for(int i = 0; i < K_minus_1; ++i) {
        ans_poly[i] = (ans_poly[i] + temp_ans0[i]) % MOD;
    }

    // 2c. 加上花费为 1 的方案
    vector<long long> c1_sum(K_minus_1, 0);
    for (int i = 0; i < n; ++i) {
        if (!is_free[i]) {
            vector<long long> q_i(K_minus_1, 0);
            for (int val : S[i]) {
                q_i[val % K_minus_1]++;
            }
            long long inv_a_mod = (K_minus_1 - (a[i] % K_minus_1)) % K_minus_1;
            for (int j = 0; j < K_minus_1; ++j) {
                c1_sum[(j + inv_a_mod) % K_minus_1] = (c1_sum[(j + inv_a_mod) % K_minus_1] + q_i[j]) % MOD;
            }
        }
    }

    vector<long long> ans1_factor = Poly::multiply(dp_free, c1_sum);
    wrap_around(ans1_factor, K_minus_1);

    vector<long long> temp_ans1(K_minus_1, 0);
    for (int i = 0; i < K_minus_1; ++i) {
        temp_ans1[(i + fixed_sum_mod) % K_minus_1] = ans1_factor[i];
    }
    for(int i = 0; i < K_minus_1; ++i) {
        ans_poly[i] = (ans_poly[i] + temp_ans1[i]) % MOD;
    }

    // 3. 计算结果为 0 的特殊情况
    long long zero_count = 0;
    bool can_free_be_zero = true;
    for (int i = 0; i < n; ++i) {
        if (is_free[i]) {
            bool has_zero = false;
            for (int val : S[i]) {
                if (val == 0) {
                    has_zero = true;
                    break;
                }
            }
            if (!has_zero) {
                can_free_be_zero = false;
                break;
            }
        }
    }

    if (can_free_be_zero) {
        bool fixed_are_all_zero = true;
        for (int i = 0; i < n; ++i) {
            if (!is_free[i] && a[i] != 0) {
                fixed_are_all_zero = false;
                break;
            }
        }

        if (fixed_are_all_zero) {
            // Cost 0: 1 way
            zero_count = 1;
            // Cost 1: for each fixed pos, change 0 to 0
            for (int i = 0; i < n; ++i) {
                if (!is_free[i]) {
                    for (int val : S[i]) {
                        if (val == 0) {
                            zero_count = (zero_count + 1) % MOD;
                            break;
                        }
                    }
                }
            }
        } else { // Exactly one fixed pos non-zero, say a_p, and must be changed to 0
            int non_zero_count = 0;
            int non_zero_idx = -1;
            for (int i = 0; i < n; i++) {
                if (!is_free[i] && a[i] != 0) {
                    non_zero_count++;
                    non_zero_idx = i;
                }
            }
            if (non_zero_count == 1) {
                bool can_change_to_zero = false;
                for (int val : S[non_zero_idx]) {
                    if (val == 0) {
                        can_change_to_zero = true;
                        break;
                    }
                }
                if (can_change_to_zero) {
                    zero_count = 1;
                }
            }
        }
    }

    // 4. 输出最终答案
    vector<long long> final_ans(k);
    final_ans[0] = zero_count;
    for (int x = 1; x < k - 1; ++x) {
        final_ans[x] = ans_poly[x];
    }
    if (k > 1) {
        final_ans[k - 1] = (ans_poly[0] - zero_count + MOD) % MOD;
    }

    for (int i = 0; i < k; ++i) {
        cout << final_ans[i] << (i == k - 1 ? "" : " ");
    }
    cout << endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N \cdot K \log K)$，其中 $N$ 是数组长度，$K$ 是进制。
    -   主要的计算瓶颈在于计算 `dp_free` 多项式。我们对 $N$ 个位置中的自由位（最坏情况下有 $N$ 个）进行遍历，每次都进行一次大小为 $O(K)$ 的多项式乘法。使用 NTT，每次乘法的时间复杂度是 $O(K \log K)$。
    -   计算花费为 1 的部分，也涉及到几次 NTT 乘法，但总的来说，复杂度仍然由上述循环主导。

-   **空间复杂度**: $O(K)$。
    -   我们需要存储几个大小为 $O(K)$ 的多项式（`dp_free`, `ans_poly` 等）。NTT 过程中需要一些辅助空间，大小也和多项式的度数（即 $K$）相关。

## 知识点总结

这真是一道融合了多种思想的有趣题目呀，喵~

1.  **数论洞察 (Number Theory)**: 解题的第一步，也是最关键的一步，是看穿函数 $f(b)$ 的本质，发现它与数根和模 $(k-1)$ 同余性质的关联。这大大简化了问题。
2.  **生成函数/多项式 (Generating Functions)**: 这是组合计数问题的强大工具。将问题转化为多项式乘法，是解决这类问题的经典思路。
3.  **快速数论变换 (NTT)**: 当我们需要进行多项式乘法（卷积），而系数又需要在一个大质数下取模时，NTT 就是不二之选。它是本题得以在规定时间内运行的核心算法。
4.  **动态规划思想 (Dynamic Programming)**: `dp_free` 的计算过程，实际上是一个 DP。`dp[i]` 表示考虑前 $i$ 个自由位时，不同余数的方案数多项式。每一步都是在前一步的基础上，乘上新的选择多项式。
5.  **细致的分类讨论**: 对于总和为 0 这种边界情况，需要特别小心地单独分析，确保没有重复计算或遗漏。

希望这篇题解能帮助主人攻克这道题，如果还有不明白的地方，随时可以再来问我哦，喵~ >w<