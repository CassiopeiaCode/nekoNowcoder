# 最大化不互质区间划分 - 题解

### 比赛与标签
> **比赛**: 小白入门赛
> **标签**: dp, 数学, gcd
> **难度**: *1900

## 题目大意喵~
主人，你好呀！(ฅ'ω'ฅ) 这道题是想让我们来玩一个分割游戏哦~

我们拿到一个有 `n` 个整数的数组 `a`。需要把它从头到尾切成很多段，目标是让段的数量 `k` 尽可能地多！但是呢，切分的时候要遵守一些规矩哦：

1.  **无缝衔接**: 切出来的所有段必须正好覆盖从 `1` 到 `n` 的整个数组，不能有空隙也不能重叠。
2.  **长度要求**: 每一段的长度都必须大于等于 2。一个数自己是成不了段的，太孤单了啦！
3.  **最重要的规矩 (不互质伙伴)**: 在任何一段里面，随便挑一个数，它都必须能在**这一段内**找到**至少一个**别的小伙伴，使得它和这个小伙伴的最大公约数（GCD）大于 1（也就是不互质）。每个数都不能是孤立的！

我们的任务就是找出能满足这些条件的最大段数 `k`。如果无论怎么切都无法满足，就只好输出 `-1` 啦。

## 解题思路的探索之旅~
喵~ 看到“最大化”和“划分”这样的字眼，聪明的猫娘我呀，DNA 就动了！这通常是在暗示我们使用**动态规划 (Dynamic Programming)** 呐。

### Step 1: DP状态的定义
很自然地，我们可以这样想：
`dp[i]` 表示：将数组的前 `i` 个元素 `a[1...i]` 按照规则进行划分，能够得到的最大段数是多少。
我们的最终目标就是求解 `dp[n]`！

### Step 2: DP的转移方程
为了求出 `dp[i]`，我们可以考虑前 `i` 个元素的最后一段是怎么形成的。假设最后一段是从下标 `j` 开始，到下标 `i` 结束，也就是区间 `[j, i]`。

如果区间 `[j, i]` 本身是一个**满足所有规则的有效段**，那么我们就可以从一个已经解决的子问题 `dp[j-1]` 转移过来。也就是说，我们把前 `j-1` 个元素划分成 `dp[j-1]` 段，然后把 `[j, i]` 作为新的一段加上去。

这样，`dp[i]` 的值就可以通过遍历所有可能的起点 `j` (其中 `1 <= j < i`) 来更新了：
`dp[i] = max(dp[i], dp[j-1] + 1)`  (前提是 `[j, i]` 是一个有效段)

### Step 3: 如何快速判断一个区间 `[j, i]` 是否有效？
这才是这道题的核心难点喵！如果每次都暴力去检查，那也太慢了。
一个区间 `[j, i]` 是有效的，需要满足两个条件：
1.  长度 `i - j + 1 >= 2`。
2.  对于区间里**每一个**元素 `a_k` (`j <= k <= i`)，都存在另一个元素 `a_p` (`j <= p <= i`, `p != k`) 使得 `gcd(a_k, a_p) > 1`。

这个“每一个”就很麻烦。但是我们可以换个角度想，对于一个元素 `a_k`，它的“不互质伙伴”可能在它的左边，也可能在它的右边。只要在区间 `[j, i]` 里至少有一个就行。

这启发我们进行**预处理**！我们可以提前帮每个数字找到它的小伙伴在哪里，的说。

我们创建两个辅助数组：
- `h[k]`: 记录与 `a_k` 不互质的、下标**大于** `k` 的**最近**的那个元素下标。也就是 `a_k` 的“最近右伙伴”。
- `q[k]`: 记录与 `a_k` 不互质的、下标**小于** `k` 的**最远**的那个元素下标。也就是 `a_k` 的“最远左伙伴”。

这两个数组可以通过 `O(N^2)` 的双重循环和 `gcd` 计算来预处理好。

有了这两个数组，判断区间 `[j, i]` 的有效性就清晰多啦！
对于区间 `[j, i]` 中的任意一个元素 `a_k`：
- 如果它的“最近右伙伴”也在这段里 (即 `h[k] <= i`)，那 `a_k` 就满足条件了，耶！
- 如果它的“最近右伙伴”在段的外面 (即 `h[k] > i`)，那它就必须在段内找到一个“左伙伴”。为了让它能找到，它的“最远左伙伴” `q[k]` 就必须大于等于段的起始点 `j` (即 `q[k] >= j`)。

所以，一个区间 `[j, i]` 是有效的，当且仅当对于所有 `k` in `[j, i]`，都满足 `h[k] <= i` 或 `q[k] >= j`。

### Step 4: 优雅地实现DP转移
在计算 `dp[i]` 时，我们从 `j = i` 向 `1` 遍历。`j` 在这里有两个身份：一个是作为当前考虑的元素，另一个是作为潜在的段 `[j, i]` 的起点。

我们用一个变量 `l` 来记录从 `i` 遍历到 `j` 的过程中，所有需要“左伙伴”的元素，它们所需要的最靠左的伙伴位置。
- 我们从 `j = i` 开始倒着走。
- 对于每个 `j`，如果 `a[j]` 的“右伙伴”在 `i` 的外面 (`h[j] > i`)，说明 `a[j]` 需要一个“左伙伴”。为了满足它，段的左边界不能超过 `q[j]`。我们就更新 `l = min(l, q[j])`。
- 如果 `a[j]` 的“右伙伴”就在 `i` 的里面或就是 `i` (`h[j] <= i`)，这说明 `a[j]` 这个元素自己是满足条件的！此刻，我们可以尝试把 `j` 当做新分段的起点。
    - 此时 `l` 记录了 `[j+1, i]` 区间里所有元素对左边界的要求。
    - 只要 `l >= j`，就说明 `[j+1, i]` 里的所有元素都可以在 `[j, i]` 这个区间里找到伙伴。
    - `a[j]` 自己也满足条件。
    - 于是，整个区间 `[j, i]` 就是一个有效的段啦！我们就可以进行DP转移：`dp[i] = max(dp[i], dp[j-1] + 1)`。

这个实现方式非常巧妙，将检查和转移结合在了一起，喵~

## 代码实现喵~
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 2e3 + 10;
int a[N], dp[N], q[N], h[N];

// 计算最大公约数的函数，喵~
int gcd(int x, int y) {
    return x == 0 ? y : gcd(y % x, x);
}

void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    // 初始化dp为-1，表示不可达状态
    memset(dp, -1, sizeof dp);
    // q数组初始化为0
    memset(q, 0, sizeof q);
    // h数组初始化为一个很大的值
    memset(h, 0x3f, sizeof h);

    // O(N^2) 预处理，找到每个数的最远左伙伴(q)和最近右伙伴(h)
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (gcd(a[i], a[j]) != 1) {
                // q[j] 记录对于 j 来说，小于 j 且不互质的最大的 i
                q[j] = max(q[j], i);
                // h[i] 记录对于 i 来说，大于 i 且不互质的最小的 j
                h[i] = min(h[i], j);
            }
        }
    }

    // DP开始！dp[0] = 0 是我们的起点，表示空数组可以分成0段
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        // l 记录了从 i 到 j+1 的元素中，需要向左找伙伴时，最远的那个要求
        int l = 1e9; 
        // 从 i 倒着枚举，j 是当前考察的元素，也可能是新分段的起点
        for (int j = i; j >= 1; j--) {
            // 如果 a[j] 的最近右伙伴在 i 的外面，说明它必须向左找
            if (h[j] > i) {
                // 更新 l，记录下对左边界最苛刻的要求
                l = min(l, q[j]);
            } else { // a[j] 的最近右伙伴在 [j+1, i] 内，a[j] 本身是满足条件的
                // 这时，我们检查 [j, i] 是否能成为一个有效的段
                // l >= j 保证了 [j+1, i] 区间里的所有元素都能在 [j, i] 内找到伙伴
                // dp[j-1] != -1 保证了前面的部分是可划分的
                if (l >= j && dp[j - 1] != -1) {
                    // 找到了一个有效的划分方案，更新dp[i]
                    dp[i] = max(dp[i], dp[j - 1] + 1);
                }
            }
        }
    }
    
    // dp[n] 就是我们最终的答案啦！
    cout << dp[n] << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int t = 1;
    //cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(N^2) 的说。
  - 预处理 `q` 和 `h` 数组需要两层循环，其中还调用了 `gcd`，复杂度是 O(N^2 * logA)，其中 A 是数组中的最大值。
  - 动态规划部分也是两层循环，`i` 从 `1`到 `n`，`j` 从 `i` 到 `1`，所以是 O(N^2)。
  - 总的来说，时间复杂度就是 O(N^2) 级别，对于 N=2000 的数据是完全可以接受的！
- **空间复杂度**: O(N) 的说。
  - 我们用了 `a`, `dp`, `q`, `h` 这几个数组，它们的空间都和 `N` 成正比，所以空间复杂度是 O(N)。

## 知识点与总结喵~
这道题真是一次有趣的冒险呢！它把好几种知识点巧妙地融合在了一起：

1.  **动态规划 (DP)**: 这是解题的核心框架。`dp[i]` 表示前 `i` 个元素的最优解，通过枚举最后一段的起点 `j` 来进行状态转移，是序列DP的经典思路。
2.  **数论 (GCD)**: 题目的核心约束条件就是围绕最大公约数（不互质）来定义的，这是解题的出发点。
3.  **预处理思想**: 为了避免在DP转移中进行重复和耗时的计算，我们提前把“伙伴关系”（`q` 和 `h` 数组）处理好。这是“空间换时间”的典型应用，大大提高了算法效率。
4.  **巧妙的循环逻辑**: DP转移中的倒序循环以及对变量 `l` 的维护，是一个非常精妙的设计。它把对整个区间的检查，转化为了在单次循环中的常数时间更新和判断，值得我们好好学习和体会！

希望这篇题解能帮助到你，主人！如果还有不懂的地方，随时可以再来问我哦~ 一起加油，变得更强吧！喵~ (｡>∀<｡)