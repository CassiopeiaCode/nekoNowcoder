# 小灰灰的电脑资源管理 - 题解

### 比赛与标签
> **比赛**: [暂无信息]
> **标签**: [暂无信息]
> **难度**: [暂无信息]

## 题目大意喵~
各位主人，晚上好喵~！这道题是关于小灰灰和小蓝的资源管理故事哦。

是这样的呐：
小灰灰有 `n` 种电脑资源，第 `i` 种的数量是 `a_i`。
小蓝会提出 `m` 个请求，每个请求 `i` 都需要从第 `l_i` 种到第 `r_i` 种资源各 `c_i` 份。

如果一个请求到来时，任何一种它需要的资源数量不够了，电脑就会卡死，呜...
现在小蓝可以买一个配件来升级电脑！一共有 `q` 种配件可以选，每种配件 `i` 都能给第 `ql_i` 到 `qr_i` 种资源统一增加 `x_i` 份。

我们的任务就是，对于每一种配件，如果小蓝买了它，那么她会在第几次请求时导致电脑卡死呢？如果所有请求都能成功，就告诉小蓝 `-1` 吧！

## 解题思路的说
这道题看起来好复杂呀，要对 `q` 个独立的配件情况分别计算，如果每次都从头模拟一遍，`O(q * m * n)` 的复杂度肯定会让电脑真的卡死的说！所以，我们需要更聪明的办法喵~

### 核心思想：从“单次请求”到“全局状态”的转变
一个请求会失败，是因为某个区间的资源不够了。但换个角度想，整个过程（比如前 `k` 个请求）能成功，需要满足什么条件呢？

它需要满足：对于 **所有** 的资源 `j`，它的 **总供应量** 必须 **大于等于** 前 `k` 个请求对它的 **总需求量**。

- **总供应量** = 初始量 `a_j` + 配件增加的量 `d` (如果 `j` 在配件影响范围内)
- **总需求量** = 所有影响到资源 `j` 的前 `k` 个请求所需要的数量之和。

我们定义一个 “净赤字” `U_k[j]`，表示处理完前 `k` 个请求后，第 `j` 种资源的需求量超出初始供应量的部分：
`U_k[j] = (前 k 个请求对 j 的总需求) - a_j`

有了这个定义，对于一个能提供 `d` 份额外资源的配件（作用于 `[ql, qr]`），前 `k` 个请求能成功的条件就变成了：
1.  对于配件 **范围外** 的资源 `j` (`j < ql` 或 `j > qr`)，它们的赤字不能大于0，因为没有额外资源补充。即 `U_k[j] <= 0`。
2.  对于配件 **范围内** 的资源 `j` (`ql <= j <= qr`)，它们的赤字不能超过配件提供的额外量 `d`。即 `U_k[j] <= d`。

这三个条件必须同时满足，前 `k` 个请求才能全部成功！

### 离线处理与预计算
因为所有 `q` 个查询都是独立的，我们可以先“离线”处理所有 `m` 个请求，把每个阶段 `k` 的一些关键信息预计算出来，然后再一口气回答所有查询，这样就快多啦！

我们用一棵 **线段树** 来维护 `U_k[j]` 的值。线段树需要支持 **区间加法**（一个请求来了，对应区间的 `U` 值都加上 `c`）和 **区间最大值查询**。

初始时，线段树里每个位置 `j` 的值设为 `-a_j`。然后，我们按顺序处理 `m` 个请求：
对于第 `k` 个请求 `(l_k, r_k, c_k)`，我们在线段树上对区间 `[l_k, r_k]` 统一加上 `c_k`。这样，处理完第 `k` 个请求后，线段树里存的就是 `U_k[j]` 的值啦！

在处理每个请求 `k` 的同时，我们计算并记录三个关键信息，用于后续的快速查询：
1.  `bb[k] = max(U_k[j])` for `j` from `1` to `n`： 整个资源条的最大赤字。
2.  `cc[k]`：记录一个边界 `por`。`por` 是最小的下标，使得前缀 `[1, por-1]` 的资源赤字 `max(U_k[j]) <= 0`。也就是说，`[1, por-1]` 这个前缀是“健康”的。如果某个查询的配件范围 `[ql, qr]` 的左边界 `ql` 在一个“不健康”的前缀里，就可能失败。
3.  `dd[k]`：记录一个边界 `nol`。`nol` 是最大的下标，使得后缀 `[nol+1, n]` 的资源赤字 `max(U_k[j]) <= 0`。也就是说，`[nol+1, n]` 这个后缀是“健康”的。

`U_k[j]` 随着 `k` 的增加是只增不减的，所以我们预计算出的 `bb`, `cc`, `dd` 数组也都具有单调性。这真是个好消息喵！这意味着我们可以用 **二分查找**（在C++里就是 `upper_bound`）来快速定位第一个不满足条件的 `k`。

### 回答查询
预计算完成后，对于每个查询 `(ql, qr, d)`，我们来找它最早会在第几步卡死：
1.  **配件范围内的赤字**：`max_{j \in [ql, qr]} U_k[j] > d`。这个条件可以被 `bb[k] > d` 所覆盖。我们用 `upper_bound(bb, d)` 找到第一个满足 `bb[k] > d` 的 `k`。
2.  **配件范围左侧的赤字**：`max_{j < ql} U_k[j] > 0`。这等价于“健康”前缀的边界 `por_k` 小于 `ql`。我们用 `upper_bound(cc, -ql)` 找到第一个满足此条件的 `k`。
3.  **配件范围右侧的赤字**：`max_{j > qr} U_k[j] > 0`。这等价于“健康”后缀的边界 `nol_k` 小于 `qr`。不对，是 `nol_k` 必须大于等于 `qr` 才能保证 `[qr+1, n]` 这个后缀是健康的，所以失败条件是 `nol_k < qr`。嗯，仔细推导后，应该是 `nol_k > qr`，所以用 `upper_bound(dd, qr)` 找第一个满足条件的 `k`。

把这三个检查中找到的最小的 `k`，就是这个配件下电脑第一次卡死的时间点啦！如果都找不到，说明全程畅通无阻，输出 `-1` 就好啦！

## 代码实现的喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
#define int long long // 使用 long long 防止数值溢出，喵~
#define db long double
#define yes cout << "Yes\n"
#define no cout << "No\n"
#define pll pair<long long,long long>
using namespace std;
int n, m, q, k;
const int N = 1e6 + 10;
const int mod = 998244353;
 
// 这是我们的线段树喵！用来维护区间赤字的最大值
namespace seg_tree {
    struct node {
        int tag, max; // tag是懒标记, max是区间最大值
    }tr[N * 4];
 
    void push_up(int u) {
        tr[u].max = max(tr[u << 1].max, tr[u << 1 | 1].max);
    }
 
    void build(int u,int l, int r, vector<int> &aa) {
        if(l == r) {
            tr[u] = {0, aa[l]}; // 叶子节点初始化，值为 -a[i]
            return;
        }
        int mid = l + r >> 1;
        build(u << 1, l, mid, aa);
        build(u << 1 | 1, mid + 1, r, aa);
        push_up(u);
    }
 
    void push_down(int u, int l, int r) {
        if (tr[u].tag == 0) return; // 没有懒标记就不用下传啦
        int mid = l + r >> 1;
        tr[u << 1].tag += tr[u].tag;
        tr[u << 1 | 1].tag += tr[u].tag;
        tr[u << 1].max += tr[u].tag;
        tr[u << 1 | 1].max += tr[u].tag;
        tr[u].tag = 0; // 清除当前节点的懒标记
    }
 
    void modify(int u, int nowl, int nowr, int l, int r, int d) {
        if(nowl > r || nowr < l) return;
        if(nowl >= l && nowr <= r) { // 区间完全覆盖
            tr[u].max += d;
            tr[u].tag += d;
            return;
        }
        push_down(u, nowl, nowr); // 下传懒标记
        int mid = nowl + nowr >> 1;
        modify(u << 1, nowl, mid, l, r, d);
        modify(u << 1 | 1, mid + 1, nowr, l, r, d);
        push_up(u);
    }
 
    int querymax(int u, int nowl, int nowr, int l, int r) {
         if(nowl > r || nowr < l) return -1e18; // 返回一个极小值，不影响max结果
        if(nowl >= l && nowr <= r) {
            return tr[u].max;
        }
        push_down(u, nowl, nowr);
        int mid = nowl + nowr >> 1;
        return max(querymax(u << 1, nowl, mid, l, r), querymax(u << 1 | 1, mid + 1, nowr, l, r));
    }
}
 
void solve() {
    cin >> n >> m >> q;
    vector<int> aa(n + 1);
    for(int i = 1; i <= n; i ++) {
        cin >> aa[i];
        aa[i] = -aa[i]; // 初始化为赤字，即 -初始资源
    }
    seg_tree::build(1, 1, n, aa); // 建树
    
    // 预计算三个关键数组
    vector<int> bb(m + 1); // bb[k]: 全局最大赤字
    vector<int> cc(m + 1); // cc[k]: "健康"前缀的边界 por_k (存为-por_k)
    vector<int> dd(m + 1); // dd[k]: "健康"后缀的边界 nol_k
    
    int por = n + 1; // "健康"前缀的起始边界
    int nol = 0;     // "健康"后缀的起始边界

    for(int i = 1, l, r, c; i <= m; i ++) {
        cin >> l >> r >> c;
        // 处理第i个请求，更新赤字
        seg_tree::modify(1, 1, n, l, r, c);
        
        // 1. 计算全局最大赤字 bb[i]
        bb[i] = seg_tree::querymax(1, 1, n, 1, n);

        // 2. 计算"健康"前缀边界 por
        // por 是最小的下标，使得前缀 [1, por-1] 的赤字<=0
        while(por > 1) {
            int ck = seg_tree::querymax(1, 1, n, 1, por - 1);
            if(ck > 0) por --; // 如果前缀[1, por-1]不健康(有赤字)，则边界左移
            else break;
        }
        cc[i] = -por; // 存为负数，方便后续二分查找

        // 3. 计算"健康"后缀边界 nol
        // nol 是最大的下标，使得后缀 [nol+1, n] 的赤字<=0
        while(nol < n) {
            int ck = seg_tree::querymax(1, 1, n, nol + 1, n);
            if(ck > 0) nol ++; // 如果后缀[nol+1, n]不健康，则边界右移
            else break;
        }
        dd[i] = nol;
    }

    // 回答q个查询
    for(int i = 1, l, r, d; i <= q; i ++) {
        cin >> l >> r >> d; // 配件范围[l, r], 增加量d
        int ans = -1;

        // 查找第一个不满足条件的请求k
        // 1. 检查全局赤字是否超过 d
        auto h1 = upper_bound(bb.begin() + 1, bb.end(), d);
        if(h1 != bb.end()) ans = h1 - bb.begin();

        // 2. 检查配件范围左侧是否出现赤字
        // 找到第一个k，使得 por_k < l => -por_k > -l
        auto h2 = upper_bound(cc.begin() + 1, cc.end(), -l);
        if(h2 != cc.end()) {
            int anss = h2 - cc.begin();
            ans = ans == -1 ? anss : min(ans, anss);
        }

        // 3. 检查配件范围右侧是否出现赤字
        // 找到第一个k，使得 nol_k < r (推导后是 nol_k > r)
        auto h3 = upper_bound(dd.begin() + 1, dd.end(), r);
        if(h3 != dd.end()) {
            int anss = h3 - dd.begin();
            ans = ans == -1 ? anss : min(ans, anss);
        }
        cout << ans << '\n';
    }
}
 
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int _ = 1;
    // cin >> _;
    while(_ --) solve();
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O((m+n) log n + q log m) 的说。
  - **预计算阶段**: 我们循环 `m` 次。
    - 每次循环中，线段树修改是 `O(log n)`。
    - `por` 和 `nol` 的 `while` 循环看起来吓人，但 `por` 指针只会从 `n+1` 向左移动，`nol` 指针只会从 `0` 向右移动，它们在整个 `m` 次循环中总共移动的距离是 `O(n)`。每次移动内部有一次线段树查询 `O(log n)`。所以这两个 `while` 循环的总复杂度是 `O(n log n)`。
    - 因此预计算总共是 `O(m log n + n log n)`。
  - **查询阶段**: 有 `q` 个查询，每个查询做三次 `upper_bound`，每次耗时 `O(log m)`。总共是 `O(q log m)`。
  - 两部分加起来就是 `O((m+n) log n + q log m)`，非常高效呐！

- **空间复杂度**: O(n + m) 的说。
  - 线段树需要 `O(4n)` 的空间。
  - 三个预计算数组 `bb, cc, dd` 需要 `O(m)` 的空间。
  - 合计 `O(n + m)`。

## 知识点与总结喵~
这道题是一道非常精彩的数据结构题，融合了多种算法思想，值得好好回味喵！

1.  **核心思想 - 离线处理**: 面对多个独立的查询，优先考虑是否可以离线处理，通过预计算来加速查询。这是解决此类问题的金钥匙！
2.  **关键转化 - 问题建模**: 最重要的突破口在于将“某个请求失败”的局部条件，转化为“前k个请求全部成功”的全局状态条件。这个视角转换让问题变得清晰，并暴露了单调性。
3.  **数据结构 - 线段树**: 线段树是处理区间问题的强大工具。本题中，它完美地胜任了“区间增加”和“区间最大值查询”的任务，是实现我们思路的基石。
4.  **算法技巧 - 单调性与二分**: 发现了问题状态随时间（请求数k）的单调性后，就可以利用二分查找（`upper_bound`）将查询的复杂度从线性降低到对数级别。

希望这篇题解能帮助到各位主人！编程的世界就像一个大宝藏，只要我们用心探索，总能发现闪闪发光的思路和技巧。一起加油吧，喵~！