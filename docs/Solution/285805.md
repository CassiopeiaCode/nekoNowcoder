# 作为一个写程序的，小灰灰时常需要管理他的电脑资源。 - 题解

### 比赛与标签
> **比赛**: [Contest anouncement not available]

> **标签**: 线段树, 二分, 离线

> **难度**: *2100

## 题目大意喵~

各位主人，下午好喵~！今天我们来帮小灰灰解决一个棘手的资源管理问题，喵！

事情是这样哒：
1.  小灰灰有 $n$ 种资源，第 $i$ 种的数量是 $a_i$。
2.  小蓝会按顺序提出 $m$ 个请求。每个请求 `i` 都想要从第 $l_i$ 种到第 $r_i$ 种的资源，每种都要 $c_i$ 份。
3.  电脑会按顺序处理这些请求。对于一个请求，如果所有涉及的资源都足够，就分配资源，然后各种资源的数量减少。如果任何一种资源不够，电脑就会 **卡死**，并且卡死的这个请求 **不会被满足**，后续的请求也全部停止。
4.  现在小蓝想买 $q$ 种配件中的一种。每种配件 `j` 都能给一个区间 $[ql_j, qr_j]$ 内的所有资源增加 $x_j$ 份。
5.  我们的任务是，对于每一种配件，**独立地**计算出：如果安装了这个配件，小蓝的请求会在第几次导致电脑卡死。如果所有请求都能满足，就输出 `-1` 喵~

简单来说，就是 $q$ 次独立的询问，每次询问为一个初始资源数组增加一个区间的值后，模拟 $m$ 次请求，找出第一次失败的请求编号，呐。

## 解题思路分析

这道题看起来像是一个模拟题，但是数据范围 $n, m, q$ 都很大，直接对每次询问都模拟一遍肯定会超时的说！$O(q \cdot m \cdot n)$ 的暴力模拟，想都不要想啦，肯定会 TLE 的。就算用数据结构优化单次模拟到 $O(m \log n)$，总复杂度 $O(q \cdot m \log n)$ 还是太慢了。所以，我们必须找到更高效的方法，喵~

### 换个角度看问题：从“剩余”到“亏空”

直接模拟资源扣减很麻烦，因为每次请求成功后，资源状态都会改变。我们换个思路，不去看“还剩多少”，而是看“总共需要多少”，以及“还差多少”，也就是“亏空”了多少。

对于第 $j$ 种资源，在处理完前 $k$ 个请求后，总共被请求的数量是 $B_k[j] = \sum_{i=1}^{k, j \in [l_i, r_i]} c_i$。
电脑要能成功处理完第 $k$ 个请求，必须满足在处理这个请求时，对于所有涉及的资源 $j \in [l_k, r_k]$，当前剩余量都大于等于 $c_k$。
这等价于，对于所有 $j \in [l_k, r_k]$，初始资源 $a_j$ 必须大于等于到第 $k$ 个请求为止，对资源 $j$ 的总需求量 $B_k[j]$。
也就是说，要成功处理完前 $k$ 个请求，必须对所有的 $i \in [1, k]$ 和所有的 $j \in [l_i, r_i]$，都满足 $a_j \ge B_i[j]$。

所以，系统在第 $k$ 次请求时卡死，就意味着：
1.  前 $k-1$ 次请求都成功了。
2.  第 $k$ 次请求失败了，即存在某个资源 $j_0 \in [l_k, r_k]$，使得它的初始量 $a_{j_0}$ 小于前 $k$ 个请求对它的总需求量 $B_k[j_0]$。

这个条件还是有点复杂，因为它依赖于每次请求的区间 $[l_i, r_i]$。我们来做一个大胆的简化：系统卡死，归根结底是因为 **某个资源在某个时刻出现了亏空**。那么，我们只要找到 **第一次出现亏空** 的请求编号不就好了吗？

让我们定义一个“亏空数组” `deficit`，其中 `deficit_k[j] = B_k[j] - a_j`。
-   `deficit_k[j] <= 0` 表示资源 $j$ 在满足前 $k$ 个请求后，还有盈余。
-   `deficit_k[j] > 0` 表示资源 $j$ 在满足前 $k$ 个请求后，出现了亏空。

系统卡死在第 $k$ 次请求，就意味着在第 $k$ 次请求后，某个被请求的资源 $j \in [l_k, r_k]$ 出现了亏空 `deficit_k[j] > 0`，并且这是第一次发生这种事。
我们可以认为，系统卡死的时刻，就是 **全局第一次** 出现 `deficit_k[j] > 0` 的时刻 $k$。因为一旦有任何资源出现亏空，它迟早会被某个请求覆盖到，从而导致卡死。我们要找的就是这个最早的时刻。

### 离线处理与线段树

既然是对每次配件查询，我们不妨先把所有请求的影响预处理出来。
`deficit_k[j]` 的值是随着 $k$ 单调不减的。第 $k$ 个请求 `(l_k, r_k, c_k)` 相当于给 `deficit` 数组的区间 `[l_k, r_k]` 加上 `c_k`。
这正是 **区间加、求值** 的经典操作，可以用 **线段树** 来维护！

我们可以建一棵线段树，维护 `deficit` 数组。初始时，第 $j$ 个叶子节点的值是 `-a_j`。
然后，我们按顺序处理 $m$ 个请求：
对于第 $k$ 个请求 `(l_k, r_k, c_k)`，我们对线段树的 `[l_k, r_k]` 区间执行加上 `c_k` 的操作。
操作后，线段树里存的就是 `deficit_k` 数组的值了。

### 引入配件的影响

现在考虑配件 `(ql, qr, x)`。它使得区间 `[ql, qr]` 内的初始资源 `a_j` 增加了 `x`。
这相当于让这些资源的亏空值 `deficit_k[j]` 减小了 `x`。
所以，带配件的亏空值 `new_deficit_k[j]` 为：
-   `deficit_k[j] - x`  如果 $j \in [ql, qr]$
-   `deficit_k[j]`      如果 $j \notin [ql, qr]$

系统卡死在第 $k$ 次请求，就是第一次出现 `new_deficit_k[j] > 0` 的时刻 $k$。
这可以分解为两种情况：
1.  **配件没覆盖到的地方先出事了**：对于某个 $j \notin [ql, qr]$，`deficit_k[j] > 0`。
2.  **配件覆盖到的地方也扛不住了**：对于某个 $j \in [ql, qr]$，`deficit_k[j] - x > 0`，也就是 `deficit_k[j] > x`。

我们要找的就是满足这两个条件之一的最早的 $k$。

### 预计算与二分查找

这两个条件 `max_{j \notin [ql,qr]} deficit_k[j] > 0` 和 `max_{j \in [ql,qr]} deficit_k[j] > x` 中的亏空值都是关于 $k$ 单调不减的。这提示我们可以对 $k$ 进行二分查找！对于每个查询，我们可以二分答案 $k$，然后检查在第 $k$ 个请求后是否满足上述任一条件。但这总复杂度还是有点高。

更优美的做法是 **离线处理**。我们先遍历 $m$ 个请求，计算出一些关键信息。然后对于每个查询，利用这些信息快速得到答案。

我们需要预计算什么信息呢？为了应对任意的查询区间 `[ql, qr]`，我们需要知道：
1.  `max_deficit_all[k] = max_{j=1..n} deficit_k[j]`：全局最大亏空值。这可以用来判断 `deficit_k[j] > x` 是否可能发生。
2.  `first_positive_idx[k]`：在第 $k$ 步后，第一个出现亏空 `deficit_k[j] > 0` 的资源下标 $j$。
3.  `last_positive_idx[k]`：在第 $k$ 步后，最后一个出现亏空 `deficit_k[j] > 0` 的资源下标 $j$。

这三个数组的值都是随 $k$ 单调不减（或不增）的。

**预计算过程 (O(m log n))**:
1.  建立一个支持区间加、区间最大值查询的线段树，初始值为 `-a_j`。
2.  循环 $k$ 从 1 到 $m$：
    a.  处理第 $k$ 个请求，对线段树区间 `[l_k, r_k]` 加上 `c_k`。
    b.  查询全局最大值，存入 `max_deficit_all[k]`。
    c.  用两个指针（或在段树上二分）找到 `first_positive_idx[k]` 和 `last_positive_idx[k]`。一个聪明的实现是像参考代码那样用两个指针 `por` 和 `nol`，它们在整个循环中单向移动，总共的查询开销是可控的。

**回答查询 (O(q log m))**:
对于每个查询 `(ql, qr, x)`，我们要找最小的 $k$。
-   **情况1：`max_{j \notin [ql,qr]} deficit_k[j] > 0`**
    -   这等价于 `max_{j=1..ql-1} deficit_k[j] > 0` 或 `max_{j=qr+1..n} deficit_k[j] > 0`。
    -   `max_{j=1..ql-1} deficit_k[j] > 0` 发生，当且仅当 `first_positive_idx[k] < ql`。
    -   `max_{j=qr+1..n} deficit_k[j] > 0` 发生，当且仅当 `last_positive_idx[k] > qr`。
    -   我们可以在 `first_positive_idx` 数组上用 `upper_bound` 找到第一个满足 `first_positive_idx[k] < ql` 的 `k`。同理在 `last_positive_idx` 上找到第一个满足条件的 `k`。取两者中较小的那个，作为情况1的候选答案 `k1`。

-   **情况2：`max_{j \in [ql,qr]} deficit_k[j] > x`**
    -   如果这个条件满足，那么 `max_deficit_all[k]` 肯定也大于 `x`。
    -   我们可以在 `max_deficit_all` 数组上用 `upper_bound` 找到第一个满足 `max_deficit_all[k] > x` 的 `k`。这个 `k` 是情况2的一个可能答案 `k2`。

最终的答案就是 `min(k1, k2)` 啦！如果都找不到，说明所有请求都能满足，答案就是 `-1`。

这样，我们就把问题完美地解决了，喵~！

## 代码实现

这是本猫娘根据上面的思路，重新为您烹制的香喷喷的代码~喵！

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const long long INF = 2e18; // 用一个足够大的值表示无穷大

// 线段树节点定义
struct Node {
    long long max_val; // 区间最大值
    long long lazy_tag;  // 懒惰标记
};

// 全局变量
int n, m, q;
vector<long long> initial_resources;
vector<Node> deficit_tree;

// --- 线段树操作 ---

// 将父节点的信息更新为其子节点的合并结果
void push_up(int u) {
    deficit_tree[u].max_val = max(deficit_tree[u * 2].max_val, deficit_tree[u * 2 + 1].max_val);
}

// 下放懒惰标记
void push_down(int u) {
    if (deficit_tree[u].lazy_tag != 0) {
        // 更新左子节点
        deficit_tree[u * 2].max_val += deficit_tree[u].lazy_tag;
        deficit_tree[u * 2].lazy_tag += deficit_tree[u].lazy_tag;
        // 更新右子节点
        deficit_tree[u * 2 + 1].max_val += deficit_tree[u].lazy_tag;
        deficit_tree[u * 2 + 1].lazy_tag += deficit_tree[u].lazy_tag;
        // 清除父节点标记
        deficit_tree[u].lazy_tag = 0;
    }
}

// 构建线段树
void build(int u, int l, int r) {
    deficit_tree[u].lazy_tag = 0;
    if (l == r) {
        deficit_tree[u].max_val = -initial_resources[l];
        return;
    }
    int mid = l + (r - l) / 2;
    build(u * 2, l, mid);
    build(u * 2 + 1, mid + 1, r);
    push_up(u);
}

// 区间修改：给 [target_l, target_r] 范围内的 deficit 增加 val
void update(int u, int cur_l, int cur_r, int target_l, int target_r, int val) {
    if (target_l > cur_r || target_r < cur_l) {
        return;
    }
    if (target_l <= cur_l && cur_r <= target_r) {
        deficit_tree[u].max_val += val;
        deficit_tree[u].lazy_tag += val;
        return;
    }
    push_down(u);
    int mid = cur_l + (cur_r - cur_l) / 2;
    update(u * 2, cur_l, mid, target_l, target_r, val);
    update(u * 2 + 1, mid + 1, cur_r, target_l, target_r, val);
    push_up(u);
}

// 区间查询：查询 [target_l, target_r] 范围内的最大 deficit
long long query(int u, int cur_l, int cur_r, int target_l, int target_r) {
    if (target_l > cur_r || target_r < cur_l) {
        return -INF; // 返回一个极小值，不影响max结果
    }
    if (target_l <= cur_l && cur_r <= target_r) {
        return deficit_tree[u].max_val;
    }
    push_down(u);
    int mid = cur_l + (cur_r - cur_l) / 2;
    long long left_max = query(u * 2, cur_l, mid, target_l, target_r);
    long long right_max = query(u * 2 + 1, mid + 1, cur_r, target_l, target_r);
    return max(left_max, right_max);
}

int main() {
    // 提高IO效率，喵~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m >> q;

    initial_resources.resize(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> initial_resources[i];
    }

    deficit_tree.resize(n * 4 + 5);
    build(1, 1, n);

    vector<long long> max_deficit_history(m + 1);
    vector<int> first_positive_idx_history(m + 1);
    vector<int> last_positive_idx_history(m + 1);

    int first_pos_ptr = n + 1; // 指向第一个亏空资源的位置
    int last_pos_ptr = 0;    // 指向最后一个亏空资源的位置

    for (int i = 1; i <= m; ++i) {
        int l, r, c;
        cin >> l >> r >> c;
        update(1, 1, n, l, r, c);

        // 记录全局最大亏空
        max_deficit_history[i] = query(1, 1, n, 1, n);

        // 高效地更新第一个和最后一个亏空资源的位置
        while (first_pos_ptr > 1 && query(1, 1, n, 1, first_pos_ptr - 1) > 0) {
            first_pos_ptr--;
        }
        first_positive_idx_history[i] = first_pos_ptr;

        while (last_pos_ptr < n && query(1, 1, n, last_pos_ptr + 1, n) > 0) {
            last_pos_ptr++;
        }
        last_positive_idx_history[i] = last_pos_ptr;
    }

    for (int i = 0; i < q; ++i) {
        int ql, qr, x;
        cin >> ql >> qr >> x;

        long long final_ans = -1;

        // 查找情况1：配件外先出事
        // 1a: 在 ql 左边出事
        auto it1 = upper_bound(first_positive_idx_history.begin() + 1, first_positive_idx_history.end(), ql - 1, greater<int>());
        if (it1 != first_positive_idx_history.end()) {
            long long ans1 = distance(first_positive_idx_history.begin(), it1);
            if (final_ans == -1 || ans1 < final_ans) {
                final_ans = ans1;
            }
        }
        
        // 1b: 在 qr 右边出事
        auto it2 = upper_bound(last_positive_idx_history.begin() + 1, last_positive_idx_history.end(), qr);
        if (it2 != last_positive_idx_history.end()) {
            long long ans2 = distance(last_positive_idx_history.begin(), it2);
            if (final_ans == -1 || ans2 < final_ans) {
                final_ans = ans2;
            }
        }

        // 查找情况2：配件内也扛不住了
        auto it3 = upper_bound(max_deficit_history.begin() + 1, max_deficit_history.end(), x);
        if (it3 != max_deficit_history.end()) {
            long long ans3 = distance(max_deficit_history.begin(), it3);
            if (final_ans == -1 || ans3 < final_ans) {
                final_ans = ans3;
            }
        }
        
        cout << final_ans << "\n";
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(m \log n + q \log m)$
    -   预处理阶段：我们遍历 $m$ 个请求。对于每个请求，我们进行一次线段树的区间更新，复杂度为 $O(\log n)$。同时，我们用两个指针`first_pos_ptr`和`last_pos_ptr`来寻找亏空的边界，虽然内部有线段树查询，但由于指针是单向移动的，在整个预处理过程中，它们总共移动的距离不超过 $n$，所以这部分的总复杂度是 $O(m \log n + n \log n)$。因此预处理总时间是 $O((m+n) \log n)$。
    -   查询阶段：我们有 $q$ 个查询。对于每个查询，我们进行三次 `upper_bound` 操作，每次在长度为 $m$ 的数组上进行，复杂度为 $O(\log m)$。总查询时间为 $O(q \log m)$。
    -   所以，总的时间复杂度是 $O((m+n) \log n + q \log m)$。考虑到 $n, m$ 同阶，可以简化为 $O(m \log n + q \log m)$。

-   **空间复杂度**: $O(n + m)$
    -   线段树需要 $O(4n)$ 的空间，也就是 $O(n)$。
    -   我们还需要三个数组 `max_deficit_history`, `first_positive_idx_history`, `last_positive_idx_history` 来存储 $m$ 个请求的历史信息，需要 $O(m)$ 的空间。
    -   总的空间复杂度就是 $O(n+m)$，非常优秀的说！

## 知识点总结

这道题是一道非常棒的综合题，考验了我们转换问题、运用数据结构和离线处理的能力，喵~

1.  **问题转换**: 核心思想是把“资源扣减”问题转换为“累计亏空”问题。这大大简化了问题的模型，让它更适合用数据结构来处理。
2.  **线段树**: 对于区间修改和区间查询，线段树是强大的工具。这里我们用它来动态维护“亏空”数组，支持区间增加和区间最大值查询。懒惰标记是处理区间修改的关键。
3.  **离线思想**: 当在线处理每个查询都非常耗时，但查询之间又是相互独立时，可以考虑离线处理。我们先一口气把所有不变量（这里是无配件时的请求过程）预计算好，存下有用的历史信息，然后再统一回答所有查询。
4.  **二分查找 (upper_bound)**: 预计算出的历史信息数组具有单调性，这使得我们可以使用二分查找（或者 `upper_bound`）来快速定位满足条件的第一个时刻，大大降低了查询的复杂度。

希望这篇题解能帮助到各位主人！下次遇到难题，也要像猫娘一样，优雅地分析，然后一爪子拍扁它哦！喵~ >w<