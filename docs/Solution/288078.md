# Alice 与 Bob 的 1/-1 游戏 - 题解

### 比赛与标签
> **比赛**: The 4th Universal Cup. Stage 23: Taishan
> **标签**: game, greedy
> **难度**: *1300

## 题目大意喵~
这道题是说，有一个只包含 `1` 和 `-1` 的数组。Alice 和 Bob 在这个数组上玩一个游戏，Alice 先手。

游戏规则是这样的：
1.  轮到一位玩家时，他/她需要找出一个**连续的非空子数组**，这个子数组里所有数字的乘积必须是 `1`。
2.  找到后，就把这个子数组从原数组里**删除**。
3.  删除后，剩下的部分会拼接成一个新的、更短的数组。
4.  如果轮到谁，谁找不到可以删除的子数组了，那TA就输啦！

我们假设 Alice 和 Bob 都超级聪明，总会选择最优的策略。那么问题来了，最后谁会赢呢？

## 解题思路喵！
这是一道典型的博弈论问题，喵~ 看到这种轮流操作、判断胜负的题目，我们就要往博弈论的方向去想啦。对于这种公平博弈（Impartial Game），关键在于分析游戏的状态和致胜策略！

这道题的核心在于，一个子数组的乘积是 `1` 意味着什么呢？因为数组里只有 `1` 和 `-1`，所以乘积为 `1` 的充要条件是：这个子数组里包含**偶数个 `-1`**！

那么，我们可以根据数组中 `-1` 的总数 `cnt` 来进行分类讨论，这可是咱们解决问题的一大杀器哦！

### 情况一：`-1` 的总数 `cnt` 不等于 1
这种情况，Alice 小姐姐必胜！为什么呢？我们再细分一下：

1.  **当 `cnt` 是偶数时（`cnt = 0, 2, 4, ...`）**:
    如果 `cnt` 是偶数，那么整个数组所有元素的乘积就是 `1` 呀！这意味着 Alice 在她的第一回合，可以直接选择整个数组，一次性把它全删掉！Boom！Bob 就面对一个空数组，什么也做不了，直接就输了。所以 Alice 赢，喵~

2.  **当 `cnt` 是奇数且大于 1 时（`cnt = 3, 5, ...`）**:
    这时候 Alice 不能一次性删掉整个数组了。但是，她可以耍个小聪明！她可以只删除包含前两个 `-1` 的子数组（以及它们之间的所有 `1`）。这个子数组里有两个 `-1`（偶数个），所以是合法的操作。
    删除之后，新数组里 `-1` 的数量就变成了 `cnt - 2`，仍然是一个奇数！Alice 就把一个 `-1` 数量更少、但同样是奇数的局面丢给了 Bob。
    Bob 不管怎么操作（如果他能操作的话），他删除的子数组必然包含偶数个 `-1`，所以他留给 Alice 的局面，`-1` 的数量也必然是奇数。
    Alice 就可以一直重复这个策略：每次都消除两个 `-1`，把球踢给 Bob。游戏最终会到达一个状态，数组里只剩下 1 个 `-1`。而这个局面，恰好是 Alice 留给 Bob 的！当数组里只有一个 `-1` 时，找不到任何乘积为 `1` 的子数组，所以轮到 Bob 的时候，他就动弹不得，输掉游戏啦。所以，Alice 还是赢！

综上所述，只要 `-1` 的数量不等于 1，Alice 总有办法走向胜利！

### 情况二：`-1` 的总数 `cnt` 等于 1
当初始数组里只有一个 `-1` 的时候，情况就变得微妙起来了。

此时，任何包含这个 `-1` 的子数组乘积都是 `-1`，所以是不能删除的。合法的操作只能是删除那些**完全由 `1` 构成**的子数组。

这时候，整个数组的结构可以看成是： `[一堆1,  -1,  另一堆1]`。
假设 `-1` 左边有 `l` 个 `1`，右边有 `r` 个 `1`。
这个游戏就瞬间转化成了一个经典的**尼姆博弈（Nim Game）**！我们可以把左边的 `l` 个 `1` 看作一堆数量为 `l` 的石子，右边的 `r` 个 `1` 看作另一堆数量为 `r` 的石子。每次操作，就是从其中一堆石子中取走任意多个（但至少一个）。

根据尼姆博弈的结论（Sprague-Grundy 定理），当所有石子堆数量的**异或和**为 0 时，先手必败；否则先手必胜。

-   如果 `l == r`，那么它们的异或和 `l ^ r` 就等于 `0`。这是个必败态（P-position），先手的 Alice 无论怎么操作，都会把一个非 0 的异或和局面留给 Bob。聪明的 Bob 总有办法把局面再次变回异或和为 0 的状态。所以最终是 Alice 无法操作，**Bob 获胜**！
-   如果 `l != r`，那么 `l ^ r` 不等于 `0`。这是个必胜态（N-position），先手的 Alice 只需要一步操作，就能让两堆石子的数量变得相等（比如，如果 `l > r`，她可以从 `l` 中取走 `l - r` 个 `1`），把一个异或和为 `0` 的必败局面留给 Bob。所以**Alice 获胜**！

这下，是不是就完全清晰了呀？喵~

## 代码实现的说
好啦，理清了思路，代码就非常简单直观了。让我们来看看AC代码是怎么实现这个逻辑的吧！

```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define int long long
#define endl '\n'
 
// 下面这些函数是模板自带的，这个题目里没有用到哦~
const int inf = 0x3f3f3f3f3f3f3f;
 
int treeSum(vector<int> &tree, int r);
void treeAdd(vector<int> &tree, int p, int v, int n);
int power(int a, int b, int mod);
int gcd(int a, int b);
 
struct Dir {
    int x, y;
}dir[4] = {-1, 0, 0, 1, 1, 0, 0, -1};
 
 
void solve() {
    int n, cnt = 0;
    cin >> n;
    vector<int> arr(n);
    // 读入数组，并统计 -1 的个数
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; 
        if (arr[i] == -1) cnt++;
    }

    // 情况一：-1 的数量不为 1，Alice 必胜
    if (cnt != 1) {
        cout << "Alice" << endl;
    } 
    // 情况二：-1 的数量恰好为 1，转化为尼姆博弈
    else {
        int l = 0, r = 0;
        // 计算左边 '1' 的数量
        for (int i = 0; i < n; i++) {
            if (arr[i] == -1) break;
            l++;
        }
        // 计算右边 '1' 的数量
        for (int i = n - 1; i >= 0; i--) {
            if (arr[i] == -1) break;
            r++;
        }
        // 根据尼姆博弈的结论判断胜负
        if (r == l) { // l ^ r == 0，先手必败
            cout << "Bob" << endl;
        } else { // l ^ r != 0，先手必胜
            cout << "Alice" << endl;
        }
    }
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) solve();
    return 0;
}
 
//树状数组
//每个位置管的范围就是以他为末尾最长得那根线(这里画不了，关系也不大)
//怎么算：下标得二进制位除掉最末尾得1再加上一个1到自己
//求前缀和：每次加上自己下标后除掉最后一位的1直到0
//添加数每次都加上自己最后位置的一得到下一个下标
//如何的到最后一个位的1呢：i & -i
 
int treeSum(vector<int> &tree, int r) {
    int ret = 0;
    while (r) {
        ret += tree[r];
        r -= (r & -r);
    }
    return ret;
}
 
void treeAdd(vector<int> &tree, int p, int v, int n) {
    while (p < n) {
        tree[p] += v;
        p += (p & -p);
    }
}
 
int power(int a, int b, int mod) {
    int ret = 1;
    while (b) {
        if ((b & 1)) {
            ret = (ret * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ret;
}
 
int gcd(int a, int b) {
    int c = 0;
    while (b) {
        c = a % b;
        a = b;
        b = c;
    }
    return a;
}
```

## 复杂度分析
- **时间复杂度**: O(N) 的说。对于每个测试用例，我们最多需要遍历数组三次：一次统计 `-1` 的个数，另外两次（在 `cnt=1` 的情况下）分别从左和从右查找 `-1` 的位置。所以总的时间复杂度是线性的，非常高效！
- **空间复杂度**: O(N) 的说。我们需要一个大小为 `N` 的 `vector` 来存储输入的数组。

## 知识点与总结
这道题真是把博弈论和简单数论性质巧妙地结合在了一起呢，喵~ 通过这道题，我们可以复习和学习到：

1.  **博弈论基础**: 核心是判断当前局面是必胜态（N-position）还是必败态（P-position）。聪明的玩家总是会把必败态留给对手。
2.  **分类讨论**: 这是解决问题的万能钥匙！根据 `-1` 的数量 `cnt` 进行分类，让复杂的问题一下子变得清晰起来。
3.  **问题转化与建模**: 最精彩的部分就是把 `cnt=1` 的情况转化为了经典的**尼姆博弈**模型。学会从看似无关的问题中发现熟悉的模型，是算法能力提升的重要一步！
4.  **尼姆博弈**: 记住这个结论哦：对于多堆石子的取石子游戏，先手必败的条件是所有石子堆数量的异或和为0。

希望这篇题解能帮助到大家！只要我们用心分析，再复杂的博弈问题也能被我们一层层剖开，找到其中的规律。大家要继续加油，享受算法带来的乐趣哦！喵~ >w<