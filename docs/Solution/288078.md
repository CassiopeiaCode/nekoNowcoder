# Alice 和 Bob 的 1 与 -1 数组游戏 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供, 喵~]

> **标签**: 博弈论, 分类讨论, 思维

> **难度**: *1500

## 题目大意喵~

主人你好呀~ 这是一道关于 Alice 和 Bob 玩游戏的问题，喵！

游戏是在一个只包含 `1` 和 `-1` 的数组上进行的。规则是这样的：
1.  Alice 先手，两人轮流操作。
2.  每一次操作，玩家需要选择一个**非空**的**连续子数组**，这个子数组里所有数字的乘积必须是 `1`。
3.  然后，把这个选中的子数组从原数组中“咻”地一下删掉。剩下的部分会拼接成一个新的数组。
4.  如果轮到某个玩家时，她/他找不到任何可以删除的子数组了，那这位玩家就输掉游戏啦。

题目问我们，假设 Alice 和 Bob 都超级聪明，采用最优策略，最后谁会赢呢？

举个栗子：如果数组是 `[1, -1, -1, 1]`。
- 乘积为 `1` 的子数组有 `[1]` (第一个), `[-1, -1]`, `[1]` (最后一个), `[1, -1, -1, 1]` 等。
- Alice 可以选择删除 `[-1, -1]`，数组就变成了 `[1, 1]`。
- 接下来轮到 Bob，他可以删除 `[1]`，数组变成 `[1]`。
- 轮到 Alice，她删除 `[1]`，数组变空。
- Bob 面对空数组，没有非空子数组可以选，所以 Bob 输了，Alice 获胜！耶~

## 解题思路分析

这道题看起来像是一个复杂的博弈论问题，但只要我们抓住关键点，就能把它一层层剥开，就像猫咪玩毛线球一样，喵~

### 关键洞察：什么决定了乘积？

一个子数组的乘积是 `1` 还是 `-1`，完全取决于它里面有多少个 `-1`。
- 如果子数组里有 **偶数** 个 `-1`，那么它们的乘积就是 `1`。
- 如果子数组里有 **奇数** 个 `-1`，那么它们的乘积就是 `-1`。

所以，游戏的核心操作就是：**删除一个包含偶数个 `-1` 的连续子数组**。

### 游戏何时结束？

玩家输掉游戏的条件是“无法操作”。这意味着，当前数组中**所有**的非空连续子数组，它们的乘积都是 `-1`。

我们来想一下，什么样的数组会满足这个条件呢？
- 如果数组里有 `1`，比如 `[..., 1, ...]`，那么 `[1]` 本身就是一个乘积为 `1` 的子数组，可以被删除。所以，无法操作的数组里一定没有 `1`。
- 那么数组里就只剩下 `-1` 了。如果数组是 `[-1, -1]`，乘积是 `1`，可以删除。
- 只有当数组里只剩下一个孤零零的 `-1`，也就是 `[-1]` 的时候，任何子数组（也就是它自己）的乘积都是 `-1`，玩家才真的无法操作。

所以，**最终的必败态就是数组只剩下 `[-1]`**。游戏的本质就是，双方都想避免自己最后面对 `[-1]` 这个局面。

### 分类讨论大法好！

让我们根据数组中 `-1` 的数量（我们叫它 `neg_count` 吧）来分析，喵~

#### 情况一：`-1` 的数量 `neg_count` 是偶数

如果 `neg_count` 是偶数（包括 0），那么整个数组所有元素的乘积就是 `1`。
Alice 作为先手，她可以第一步就直接选中整个数组，然后“哗啦”一下全部删除！
数组变空了，轮到 Bob 操作。Bob 面对一个空荡荡的数组，什么也做不了，所以 Bob 输了。
这种情况下，Alice 必胜！

#### 情况二：`-1` 的数量 `neg_count` 是奇数

当 `neg_count` 是奇数时，事情就变得有趣起来了。
首先，Alice 不能一次性删除整个数组，因为总乘积是 `-1`。
注意到，每次操作我们都删除偶数个 `-1`（0个，2个，4个...）。这意味着，一个奇数的 `neg_count` 减去一个偶数，结果永远是奇数！**所以，`-1` 的数量奇偶性在整个游戏过程中是不变的。**

游戏既然一定会结束，而 `neg_count` 始终是奇数，那么最终的局面一定是 `neg_count=1` 的某个状态。而我们已经知道，`[-1]` 是最终的必败态。

**子情况 2.1：`neg_count >= 3`**

如果一开始 `-1` 的数量是奇数且大于等于 3，Alice 总能找到办法把局面简化。
比如数组是 `[..., -1, ..., -1, ..., -1, ...]`。Alice 可以选中从第一个 `-1` 到第二个 `-1` 的这一段子数组。这个子数组里有两个 `-1`（是偶数哦），所以乘积为 `1`，可以删除！
删除后，`neg_count` 减少了 2，但仍然是奇数。Alice 可以一直用这种策略，每次都丢给 Bob 一个 `neg_count` 更小但仍然是奇数的局面。最终，Alice 可以制造一个 `neg_count = 1` 的局面给 Bob。所以，只要 `neg_count >= 3`，Alice 就能掌控局势，**Alice 必胜**！

**子情况 2.2：`neg_count == 1`**

这是最特殊、也是唯一可能让 Bob 赢的情况！
此时，数组的形态是 `[1, 1, ..., -1, ..., 1, 1]`。
唯一的那个 `-1` 是无法被包含在任何可删除的子数组里的（因为它自己会让乘积变 `-1`）。所以，玩家们只能删除 `-1` 左边或者右边的 `1`。

这下，游戏就变成了在 `-1` 两边的两堆 `1` 上玩消除游戏了。
- 设 `-1` 左边有 `L` 个 `1`。
- 设 `-1` 右边有 `R` 个 `1`。

这就像是两个独立的游戏，Alice 每次可以选择在左边的一堆 `1` 中删除一小段，或者在右边的一堆 `1` 中删除一小段。

- **如果 `L == R`**：
  这是一个完全对称的局面！Bob 可以采取“模仿棋”策略。
  无论 Alice 在左边（或右边）做什么操作，Bob 就在另一边做完全一样的操作。
  比如，Alice 从左边 `L` 个 `1` 中删除了中间的 3 个，Bob 就从右边 `R` 个 `1` 中也删除中间的 3 个。这样，Bob 每一步走完，两边的 `1` 堆数量和形态都保持一致。
  最终，一定是 Alice 先把一边的 `1` 全部拿完。然后 Bob 顺势拿完另一边。最后，轮到 Alice 时，数组只剩下 `[-1]`，Alice 输了。
  所以，当 `L == R` 时，**Bob 必胜**！

- **如果 `L != R`**：
  局面不对称了，先手的 Alice 就有了优势！
  假设 `L > R`。Alice 可以在左边 `L` 个 `1` 中，通过一次操作，让左边的 `1` 数量也变成 `R`。比如，她可以把左边最开始的 `L-R` 个 `1` 一次性删掉。
  这样操作后，`L` 和 `R` 就相等了，轮到 Bob 操作。现在 Bob 面临一个对称的局面，而他又是先手。根据上面的分析，后手（也就是 Alice）有了必胜策略。
  所以，当 `L != R` 时，**Alice 必勝**！

### 总结一下思路

1.  数一下数组里 `-1` 的个数 `neg_count`。
2.  如果 `neg_count` 是偶数，Alice 赢。
3.  如果 `neg_count` 是奇数：
    -   如果 `neg_count >= 3`，Alice 赢。
    -   如果 `neg_count == 1`，就看 `-1` 两边的 `1` 的数量 `L` 和 `R`。
        -   如果 `L == R`，Bob 赢。
        -   如果 `L != R`，Alice 赢。

把这些情况合并起来，我们发现，Bob 只有在 `neg_count == 1` 且 `L == R` 这个极其苛刻的条件下才能赢。其他所有情况都是 Alice 赢！

## 代码实现

这是本猫娘根据上面的思路，为你重写的清晰易懂的代码哦，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>

// 用一个函数把逻辑包起来，这样主函数会很干净呐
void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    int neg_one_count = 0;
    int neg_one_pos = -1; // 记录唯一一个-1的位置

    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        if (a[i] == -1) {
            neg_one_count++;
            neg_one_pos = i;
        }
    }

    // Bob 只有在一种情况下能赢，我们先判断这种情况
    // 条件1: 数组里有且仅有一个 -1
    if (neg_one_count == 1) {
        // 条件2: -1 两边的 '1' 的数量相等
        int left_ones = neg_one_pos; // 左边的 '1' 的数量就是 -1 的索引
        int right_ones = n - 1 - neg_one_pos; // 右边的 '1' 的数量是...
        
        if (left_ones == right_ones) {
            std::cout << "Bob" << std::endl;
            return; // Bob赢了，这局结束啦
        }
    }

    // 在所有其他情况下，都是 Alice 赢！
    // 包含了 neg_one_count 是偶数、neg_one_count >= 3 是奇数、
    // 以及 neg_one_count == 1 但左右不相等的情况。
    std::cout << "Alice" << std::endl;
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N)$
  对于每组测试数据，我们只需要遍历一次数组来统计 `-1` 的数量和位置。这是一个线性的过程，所以时间复杂度是 $O(N)$，其中 $N$ 是数组的长度。跑起来飞快，喵~

- **空间复杂度**: $O(N)$
  我们用了一个 `vector` 来存储输入的数组，需要 $O(N)$ 的空间。如果只考虑额外空间，我们只用了几个变量 (`neg_one_count`, `neg_one_pos` 等)，所以额外空间复杂度是 $O(1)$。

## 知识点总结

这道题虽然是博弈论，但并没有用到特别高深的 SG 函数之类的东西，而是考察了我们对游戏核心规则的理解和分类讨论的能力。

1.  **抓住不变量**: 游戏过程中，`-1` 数量的奇偶性是不变的。这是解题的一个重要突破口。
2.  **分析终局状态**: 找到游戏的必败态（这里是 `[-1]`），然后思考如何才能避免进入这个状态。
3.  **对称性思想**: 在处理 `neg_count == 1` 的情况时，`L == R` 的对称性是判断胜负的关键。后手方可以通过“模仿”来维持对称，从而获胜。这是博弈论中一个很经典的思想！
4.  **化繁为简**: 把一个复杂的游戏规则（删除子数组），转化为一个更简单的模型（分析 `-1` 的数量和分布），是解决问题的核心技巧。

希望这篇题解能帮到你，如果还有问题，随时可以再来问本猫娘哦！喵~