# 一个关于函数 f(i) 和 g(i) 的求和问题 - 题解

### 比赛与标签
> **比赛**: 喵~ 这道题好像没有在特定的比赛里出现过哦。
> **标签**: 喵~ 也没有找到官方标签，不过本喵觉得可以贴上 `数学` `组合计数` `位运算` `数论` 这些标签！
> **难度**: 喵~ 难度评分也是野生的，不过对于掌握了相关知识点的主人来说，应该不算太难吧？大概是 `*2000` 左右的难度？

## 题目大意喵~

主人你好呀！这道题是这样的：

首先，我们定义了两个有趣的函数，呐：
1.  $g(i) = i \oplus (i-1)$，这里的 $\oplus$ 是按位异或操作。
2.  $f(i)$ 是 $g(i)$ 这个数字在二进制表示下，数字 '1' 的个数（也就是 `popcount`）。

然后呢，题目需要我们计算两个非常长的和式，并且结果要对一个整数 $p$ 取模。这两个和式分别是：

1.  第一个和式 $S_1$：
    $$
    S_1 = \left(\sum_{i=1}^{2^n-1} \binom{n}{f(i)}\right) \pmod p
    $$
2.  第二个和式 $S_2$：
    $$
    S_2 = \left(\sum_{i=1}^{2^n-1} f(i) \cdot g(i) \cdot \binom{n}{f(i)}\right) \pmod p
    $$

输入会给我们多组测试数据，每组数据包含一个可能会非常大的整数 $n$ 和一个模数 $p$。我们要为每一组输入，都计算出 $S_1$ 和 $S_2$ 的值，喵~

## 解题思路分析

这道题看起来好多数学公式，有点吓人对不对？别怕别怕，让本喵带你一步步拆解它，你会发现它其实是一只很可爱的纸老虎哦！

### Step 1: 揭开 g(i) 和 f(i) 的神秘面纱！喵~

我们先来研究一下 $g(i) = i \oplus (i-1)$ 这个函数。直接看可能没什么头绪，我们来找几个例子看看规律，呐：

-   $i=6$: 二进制是 $(110)_2$。$i-1=5$，二进制是 $(101)_2$。
    $g(6) = (110)_2 \oplus (101)_2 = (011)_2 = 3$。
-   $i=8$: 二进制是 $(1000)_2$。$i-1=7$，二进制是 $(0111)_2$。
    $g(8) = (1000)_2 \oplus (0111)_2 = (1111)_2 = 15$。

咦？是不是发现了什么？$i-1$ 这个操作，在二进制下，会把 $i$ 最右边的那个 '1'（我们叫它最低有效位, LSB）变成 '0'，并且把这个 '1' 右边的所有 '0' 都变成 '1'。而 LSB 左边的位都不变。

当 $i$ 和 $i-1$ 进行异或时：
-   LSB 左边的位因为完全相同，异或结果都是 '0'。
-   LSB 那一位，$i$ 是 '1'，$i-1$ 是 '0'，异或结果是 '1'。
-   LSB 右边的位，$i$ 都是 '0'，$i-1$ 都是 '1'，异或结果都是 '1'。

所以，$g(i)$ 的结果总是一个形如 `...0011...1` 的二进制数！它的值是 $2^{k+1}-1$，其中 $k$ 是 $i$ 的 LSB 所在的位置（从0开始数）。

那么，$f(i)$ 就是 $g(i)$ 中 '1' 的个数，也就是 $k+1$ 啦！
所以我们得到了一个超级重要的结论：
**$f(i) = (\text{i 的最低有效位的位置}) + 1$**。

### Step 2: 给求和式变个身！（分类讨论大法）

既然 $f(i)$ 的值只和 $i$ 的最低有效位有关，那我们就可以把求和项按照 $f(i)$ 的值来分类呀！

$f(i)$ 的值可以取 $1, 2, \dots, n$。
-   当 $f(i)=v$ (其中 $v \in [1, n]$) 时，意味着 $i$ 的最低有效位在第 $v-1$ 位。
-   这等价于 $i$ 可以被 $2^{v-1}$ 整除，但不能被 $2^v$ 整除。
-   也就是说，$i$ 的形式必须是 `(一个奇数) * 2^(v-1)`。

那么，在 $[1, 2^n-1]$ 这个区间里，有多少个这样的 $i$ 呢？
$i = k \cdot 2^{v-1} < 2^n$，其中 $k$ 是奇数。
这意味着 $k < 2^{n-(v-1)} = 2^{n-v+1}$。
在 $[1, 2^{n-v+1}-1]$ 这个范围内，奇数的个数是 $2^{n-v+1} / 2 = 2^{n-v}$ 个。

所以，对于任意一个 $v \in [1, n]$，使得 $f(i)=v$ 的 $i$ 的个数，正好是 $2^{n-v}$ 个！

### Step 3: 计算第一个和式 S₁ (二项式定理登场！)

现在我们可以重写 $S_1$ 的求和式了：
$$
S_1 = \sum_{v=1}^{n} (\text{f(i)=v 的 i 的个数}) \cdot \binom{n}{v} = \sum_{v=1}^{n} 2^{n-v} \binom{n}{v}
$$
这个式子是不是很眼熟？让本喵提醒你一下二项式定理：
$$
(x+y)^n = \sum_{v=0}^{n} \binom{n}{v} x^{n-v} y^v
$$
如果我们取 $x=2, y=1$，那么：
$$
(2+1)^n = 3^n = \sum_{v=0}^{n} \binom{n}{v} 2^{n-v} 1^v = \binom{n}{0}2^n + \sum_{v=1}^{n} \binom{n}{v} 2^{n-v}
$$
看！我们要求的和式几乎就是 $3^n$ 了，只是少了一个 $v=0$ 的项。
$v=0$ 的项是 $\binom{n}{0}2^{n-0}1^0 = 1 \cdot 2^n \cdot 1 = 2^n$。
所以，我们要求的 $S_1$ 就是：
$$
S_1 = 3^n - 2^n
$$
搞定一个！是不是很简单，喵~

### Step 4: 挑战第二个和式 S₂ (组合恒等式的力量！)

对于 $S_2$，我们用同样的思路。当 $f(i)=v$ 时，我们有：
-   $f(i) = v$
-   $g(i) = 2^{v}-1$
-   这样的 $i$ 有 $2^{n-v}$ 个。

所以 $S_2$ 可以写成：
$$
S_2 = \sum_{v=1}^{n} 2^{n-v} \cdot \left( v \cdot (2^v-1) \cdot \binom{n}{v} \right)
$$
把括号展开，变成两个和式相减：
$$
S_2 = \sum_{v=1}^{n} v \binom{n}{v} 2^{n-v} 2^v - \sum_{v=1}^{n} v \binom{n}{v} 2^{n-v}
$$
$$
S_2 = \left( 2^n \sum_{v=1}^{n} v \binom{n}{v} \right) - \left( \sum_{v=1}^{n} v \binom{n}{v} 2^{n-v} \right)
$$
这里我们要用一个神奇的组合恒等式：$v \binom{n}{v} = n \binom{n-1}{v-1}$。
（推导：$v \frac{n!}{v!(n-v)!} = \frac{n!}{(v-1)!(n-v)!} = n \frac{(n-1)!}{(v-1)!(n-1-(v-1))!} = n\binom{n-1}{v-1}$）

**我们来分别计算两个部分：**

**第一部分**: $2^n \sum_{v=1}^{n} v \binom{n}{v} = 2^n \sum_{v=1}^{n} n \binom{n-1}{v-1}$
令 $j=v-1$，换元后得到 $2^n \cdot n \sum_{j=0}^{n-1} \binom{n-1}{j}$。
而 $\sum_{j=0}^{n-1} \binom{n-1}{j} = (1+1)^{n-1} = 2^{n-1}$。
所以第一部分等于 $2^n \cdot n \cdot 2^{n-1} = n \cdot 2^{2n-1}$。

**第二部分**: $\sum_{v=1}^{n} v \binom{n}{v} 2^{n-v} = \sum_{v=1}^{n} n \binom{n-1}{v-1} 2^{n-v}$
令 $j=v-1$, $v=j+1$，换元后得到 $n \sum_{j=0}^{n-1} \binom{n-1}{j} 2^{n-(j+1)} = n \sum_{j=0}^{n-1} \binom{n-1}{j} 2^{n-1-j}$。
这又是一个二项式展开！它是 $n \cdot (2+1)^{n-1} = n \cdot 3^{n-1}$。

**最后合体！**
$$
S_2 = n \cdot 2^{2n-1} - n \cdot 3^{n-1} = n(2^{2n-1} - 3^{n-1})
$$
第二个也搞定啦！太棒了主人！

## 代码实现

现在我们有了最终的公式，就可以写代码了。因为 $n$ 很大，所以计算 $a^n$ 这种操作需要用「快速幂」算法来加速，不然会超时的说。

```cpp
#include <iostream>

// 为了处理大数字，我们用 long long，喵~
using ll = long long;

// 这是一个快速幂模板，用于计算 (base^exp) % mod
// 它可以高效地处理非常大的指数 exp
// 本喵在这里用了 __int128 来防止中间结果溢出，这是一种好习惯哦！
ll power(ll base, ll exp, ll mod) {
    ll res = 1;
    base %= mod;
    while (exp > 0) {
        // 如果指数是奇数，我们就把当前的 base 乘到结果里
        if (exp % 2 == 1) {
            res = static_cast<ll>((__int128)res * base % mod);
        }
        // 然后我们把 base 平方，指数减半
        base = static_cast<ll>((__int128)base * base % mod);
        exp /= 2;
    }
    return res;
}

// 解决单个测试用例的函数
void solve() {
    ll n, p;
    std::cin >> n >> p;

    // --- 计算第一个和式 S1 ---
    // 公式是 S1 = (3^n - 2^n) mod p
    ll term_3_pow_n = power(3, n, p);
    ll term_2_pow_n = power(2, n, p);
    // 减法取模要小心负数，所以加上 p 再取模
    ll ans1 = (term_3_pow_n - term_2_pow_n + p) % p;

    // --- 计算第二个和式 S2 ---
    // 公式是 S2 = n * (2^(2n-1) - 3^(n-1)) mod p
    ll n_mod_p = n % p;

    // 计算 2^(2n-1) mod p
    // 题目保证 i 从 1 开始，所以 n >= 1，2*n-1 >= 1
    ll term1_s2 = power(2, 2 * n - 1, p);
    
    // 计算 3^(n-1) mod p
    // 当 n=1 时，n-1=0，power(3, 0, p) 会正确返回 1
    ll term2_s2 = power(3, n - 1, p);

    // 组合 S2 的各个部分
    ll factor_s2 = (term1_s2 - term2_s2 + p) % p;
    ll ans2 = (n_mod_p * factor_s2) % p;

    std::cout << ans1 << " " << ans2 << "\n";
}

int main() {
    // 使用快速 I/O，让程序跑得更快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int T;
    std::cin >> T;
    while (T--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: 对于每个测试用例，我们调用了 `power` 函数常数次。快速幂函数 `power(base, exp, mod)` 的时间复杂度是 $O(\log(\text{exp}))$。在这里，指数最大是 $2n-1$ 级别，所以单次计算的时间复杂度是 $O(\log n)$。如果有 $T$ 组测试数据，总时间复杂度就是 $O(T \log n)$，非常快，喵~
-   **空间复杂度**: 我们在计算过程中只使用了几个变量来存储中间结果，没有使用额外的数组或容器。所以空间复杂度是 $O(1)$，非常节省空间的说！

## 知识点总结

这道题虽然看起来复杂，但其实是把几个核心知识点巧妙地结合在了一起，主人你看：

1.  **位运算 (Bitwise Operations)**: 理解 $i \oplus (i-1)$ 的性质是解题的第一步，也是最关键的洞察！
2.  **组合计数 (Combinatorics)**: 将求和问题转化为分类计数问题，是简化问题的核心思想。
3.  **二项式定理**: 它是我们推导最终公式的利器，看到 $\sum \binom{n}{k}$ 这种形式就要想到它！
4.  **组合恒等式**: $k \binom{n}{k} = n \binom{n-1}{k-1}$ 这个恒等式在处理带有系数的组合求和时特别有用。
5.  **数论 (Number Theory)**: 快速幂是处理大指数模幂问题的标准算法，是每个ACMer都必须掌握的技能哦！

通过这道题，我们把这些知识点串起来练习了一遍，是不是收获满满呢？主人真棒！继续加油哦，喵~