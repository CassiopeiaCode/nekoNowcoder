# 最大比值环覆盖 - 题解

### 比赛与标签
> **比赛**: No Contest

> **标签**: 0-1分数规划, 二分, KM算法, 图论, 二分图最大权完美匹配

> **难度**: \*3000

## 题目大意喵~

米娜桑，扣んにちわ喵~！今天我们遇到的这道题是这样的：

我们拿到了一张有 $n$ 个点和 $m$ 条边的有向图。图上的每一条边都带着两个可爱的权值，分别是 $a_i$ 和 $b_i$。

我们的任务是，要从这张图中选出一些边，组成若干个环。这些环必须满足一个非常严格的条件：图中的每一个点，都必须**恰好**属于其中一个环。也就是说，我们要把所有的点都用不相交的环给串起来！

在选定了这些环（也就是确定了边集 $E$）之后，我们需要计算一个比值：所有被选中边的 $a$ 权值之和，除以它们 $b$ 权值之和，也就是 $\frac{\sum_{i \in E}a_i}{\sum_{i \in E}b_i}$。我们的目标，就是让这个比值最大化！

最后，只要我们的答案和标准答案的误差在 $10^{-4}$ 以内，就算是通过啦。题目保证一定有解，所以不用担心找不到环的情况哦，喵~

## 解题思路分析

这道题看起来有点复杂，一个图论问题，还套上了一个分数形式的目标函数。别担心，就让本猫娘一步步带你解开它的神秘面纱吧！

#### 步骤一：理解“每个点恰好处于一个环上”

这个条件是解题的关键入口哦！想象一下，如果每个点都恰好在一个环里，这意味着什么呢？
对于图中的任意一个点 $u$，它必须有一条出边指向环上的下一个点，也必须有一条入边从环上的上一个点指向它。也就是说，在我们选出的边集 $E$ 中，每个点的入度和出度都**恰好为 1**。

一个所有点入度和出度都为1的有向图，它的结构必然是若干个不相交的环的并集。这正好就是题目要求我们构造的形态！

那么，如何找到这样一个“每个点出度恰好为1”的边集呢？我们可以把它转换成一个更经典的问题——**二分图完美匹配**！

我们可以构建一个二分图。左边有 $n$ 个点（我们叫它们 $U$ 部），代表所有点的“出发”身份。右边也有 $n$ 个点（我们叫它们 $V$ 部），代表所有点的“到达”身份。
对于原图中的每一条有向边 $u \to v$，我们就在二分图的左部点 $u$ 和右部点 $v$ 之间连一条边。

现在，如果我们在个二分图中找到了一个**完美匹配**，这意味着：
1.  左边的每个点 $u \in U$ 都恰好与右边的一个点 $v \in V$ 匹配。这对应于在原图中为每个点 $u$ 选择了一条出边 $u \to v$。
2.  右边的每个点 $v \in V$ 也都恰好与左边的一个点 $u \in U$ 匹配。这对应于在原图中每个点 $v$ 都被一条入边 $u \to v$ 指向。

看吧！一个完美匹配就完美地对应了题目要求的环覆盖结构！问题就从“找环覆盖”变成了“找完美匹配”，是不是清晰多啦？

#### 步骤二：处理分数形式的目标函数（0-1分数规划）

现在我们的目标是，在所有可能的完美匹配中，找到一个匹配 $E$，使得比值 $\lambda = \frac{\sum_{i \in E}a_i}{\sum_{i \in E}b_i}$ 最大。

这种形式的目标函数，我们可以用一种叫做 **0-1分数规划** 的经典技巧来处理。我们来对这个比值进行二分答案！

假设我们想知道，最终答案能否**不小于**某个我们猜的数值 $k$。也就是说，是否存在一个完美匹配 $E$ 使得：
$$
\frac{\sum_{i \in E}a_i}{\sum_{i \in E}b_i} \ge k
$$
因为题目保证有解，且 $b_i$ 应该都是正的（通常是这样，否则问题会变得奇怪），我们可以把分母乘过去：
$$
\sum_{i \in E}a_i \ge k \cdot \sum_{i \in E}b_i
$$
移项一下，就得到：
$$
\sum_{i \in E}a_i - k \cdot \sum_{i \in E}b_i \ge 0
$$
$$
\sum_{i \in E}(a_i - k \cdot b_i) \ge 0
$$
这个式子给了我们一个绝妙的提示！对于我们猜的每一个 $k$，我们可以给二分图中的每一条边 $(u,v)$ 赋予一个新的权值 $w_i = a_i - k \cdot b_i$。然后，我们去寻找一个完美匹配，使得这个匹配的**总权值之和最大**。

-   如果这个最大权值和 $\ge 0$，说明存在一个匹配能让比值至少为 $k$。那么真正的答案 $\lambda^*$ 可能等于 $k$，也可能比 $k$ 更大。所以我们应该尝试更大的 $k$，即 `left = k`。
-   如果这个最大权值和 $< 0$，说明对于任何一个完美匹配，它的比值都无法达到 $k$。那我们猜的 $k$ 太大了，应该猜小一点，即 `right = k。

这个判断逻辑满足单调性，所以我们可以愉快地用二分搜索来逼近最终的答案 $\lambda^*$！

#### 步骤三：求解最大权完美匹配（KM算法）

现在，二分搜索的 check 函数内部，我们需要解决一个核心子问题：在一个带权二分图中，找到一个完美匹配，使得边权之和最大。

这就是**最大权完美匹配**问题，可以用经典的 **Kuhn-Munkres (KM) 算法** 来高效解决！

KM算法的核心思想是这样的，喵~
1.  **顶标 (Labels)**: 它为二分图的每个点都设置一个“期望值”，我们称为顶标。对于左部的点 $u_i$，顶标是 $lx_i$；对于右部的点 $v_j$，顶标是 $ly_j$。这些顶标在任何时候都满足 $lx_i + ly_j \ge \text{weight}(i, j)$。
2.  **相等子图 (Equality Subgraph)**: 我们只考虑那些满足 $lx_i + ly_j = \text{weight}(i, j)$ 的边 $(i,j)$。由这些边组成的图，我们称为相等子图。
3.  **寻找增广路**: 算法尝试在当前的相等子图中为尚未匹配的左部点寻找一个匹配（即寻找增广路）。
4.  **调整顶标**: 如果在当前的相等子图中找不到增广路了，说明当前的相等子图还不够“丰富”。这时，KM算法会以一种非常巧妙的方式去修改所有点的顶标，使得在不破坏 $lx_i + ly_j \ge \text{weight}(i, j)$ 的前提下，有新的边能够加入到相等子图中。
5.  **重复**: 不断重复步骤3和4，直到所有左部点都找到匹配，形成完美匹配为止。

通过这个过程，KM算法最终找到的完美匹配一定是最大权的！它的复杂度通常是 $O(N^3)$，对于本题 $N=300$ 的数据范围来说是完全可以接受的。

总结一下我们的完整攻略：
1.  使用**二分法**来搜索答案比值 $\lambda$。
2.  在二分的 check(\lambda) 函数中，为二分图的每条边 $(u, v)$ 计算新权值 $w = a_{uv} - \lambda \cdot b_{uv}$。
3.  使用 **KM 算法**求出该带权二分图的最大权完美匹配的总权值。
4.  根据总权值是否大于等于0来调整二分搜索的范围。
5.  二分结束后，left` (或者 `right`) 就是我们要求的答案啦！

## 代码实现

下面是本猫娘根据上面的思路，精心为你准备的一份代码，注释很详细的哦，希望能帮你理解！

```cpp
#include <iostream>
#include <vector>
#include <iomanip>
#include <cmath>
#include <algorithm>

using namespace std;

const double INF = 1e18; // 使用一个足够大的数表示无穷大
const double EPS = 1e-7; // 二分精度

int n, m;

struct Edge {
    int u, v, a, b;
};
vector<Edge> edges;

// KM算法求解最大权完美匹配
namespace KM {
    vector<vector<double>> weight;
    vector<double> lx, ly; // 顶标
    vector<int> match_y;   // 右部点的匹配对象
    vector<double> slack;  // slack[j] = min(lx[i] + ly[j] - w[i][j])
    vector<bool> vis_x, vis_y; // 访问标记

    // 尝试为左部点u寻找匹配
    bool dfs(int u) {
        vis_x[u] = true;
        for (int v = 1; v <= n; ++v) {
            if (vis_y[v]) continue;
            
            double gap = lx[u] + ly[v] - weight[u][v];
            
            if (abs(gap) < EPS) { // 在相等子图中
                vis_y[v] = true;
                if (match_y[v] == -1 || dfs(match_y[v])) {
                    match_y[v] = u;
                    return true;
                }
            } else { // 不在相等子图，更新slack值
                slack[v] = min(slack[v], gap);
            }
        }
        return false;
    }

    double solve() {
        // 初始化
        weight.assign(n + 1, vector<double>(n + 1, -INF));
        for (const auto& edge : edges) {
            // 注意这里可能会有重边，取权值最大的
            weight[edge.u][edge.v] = max(weight[edge.u][edge.v], (double)edge.a - (double)edge.b * mid_val);
        }

        lx.assign(n + 1, -INF);
        ly.assign(n + 1, 0);
        match_y.assign(n + 1, -1);

        // 初始化lx顶标
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                lx[i] = max(lx[i], weight[i][j]);
            }
        }

        // 为每个左部点寻找匹配
        for (int i = 1; i <= n; ++i) {
            while (true) {
                vis_x.assign(n + 1, false);
                vis_y.assign(n + 1, false);
                slack.assign(n + 1, INF);
                
                if (dfs(i)) break; // 找到了增广路，当前点匹配成功

                // 未找到增广路，需要调整顶标
                double d = INF;
                for (int j = 1; j <= n; ++j) {
                    if (!vis_y[j]) {
                        d = min(d, slack[j]);
                    }
                }

                for (int j = 1; j <= n; ++j) {
                    if (vis_x[j]) lx[j] -= d;
                    if (vis_y[j]) ly[j] += d;
                }
            }
        }

        double max_weight_sum = 0;
        for (int i = 1; i <= n; ++i) {
            if (match_y[i] != -1) {
                // 检查权值是否有效，避免-INF的干扰
                if(weight[match_y[i]][i] > -INF/2) {
                    max_weight_sum += weight[match_y[i]][i];
                }
            }
        }
        return max_weight_sum;
    }
    
    // 全局变量，用于在KM内部获取二分中的mid值
    double mid_val;
}

// check函数，判断是否存在比值为mid的解
bool check(double mid) {
    KM::mid_val = mid;
    return KM::solve() >= 0;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m;
    edges.resize(m);
    for (int i = 0; i < m; ++i) {
        cin >> edges[i].u >> edges[i].v >> edges[i].a >> edges[i].b;
    }

    double l = 0, r = 2e5; // 设置一个足够大的上界
    // 进行足够次数的二分来保证精度
    for(int i = 0; i < 100; ++i) {
        double mid = l + (r - l) / 2;
        if (check(mid)) {
            l = mid;
        } else {
            r = mid;
        }
    }

    cout << fixed << setprecision(10) << l << endl;

    return 0;
}
``

## 复杂度分析

-   **时间复杂度**: $O(\text{iterations} \cdot N^3)$
    我们的算法外层是一个二分搜索。为了达到 $10^{-4}$ 的精度，进行100次二分是绰绰有余的。在二分搜索的每一次check中，我们都需要运行一次KM算法来求解最大权完美匹配。经典的KM算法实现（如此处使用的DFS版本配合顶标调整）的时间复杂度是 $O(N^3)$，其中 $N$ 是二分图一侧的点的数量。所以总的时间复杂度就是二分次数乘以KM算法的复杂度，即 $O(100 \cdot N^3)$。

-   **空间复杂度**: $O(N^2)$
    我们需要存储二分图的邻接矩阵（或者说权值矩阵），这需要 $O(N^2)$ 的空间。KM算法本身也需要一些辅助数组，如顶标lx`, `ly`，匹配数组`match_y`，`slack`数组以及访问标记数组，它们的大小都是 $O(N)$。因此，总的空间复杂度由权值矩阵决定，为 $O(N^2)$。

## 知识点总结

这真是一道非常有趣的题目，融合了多个算法知识点，做完之后一定收获满满，喵！

1.  **模型转换能力**: 将“每个点恰好在一个环上”这个约束，巧妙地转化为“二分图完美匹配”问题，是解题的第一步，也是最关键的一步。
2.  **0-1分数规划**: 遇到形如最大化或最小化 $\frac{\sum a_i}{\sum b_i}$ 的问题，要立刻想到这是分数规划的经典模型，并熟练运用二分答案将其转化为判定性问题。
3.  **最大权完美匹配**: 这是二分图匹配问题中的一个核心算法。**Kuhn-Munkres (KM) 算法**是解决该问题的标准方法。理解其基于顶标和相等子图的核心思想非常重要。
4.  **二分搜索**: 不仅能用在有序数组上，还能用在像本题这样具有单调性的答案判定问题上，是解决最优化问题的强大武器。

通过这道题，我们把图论、最优化和算法设计技巧串联了起来。是不是感觉自己的算法武器库又变强了呀？继续加油，你超棒的，喵~！