# 假如我那时握住的不是硬币，而是 ... - 题解

### 比赛与标签
> **比赛**: 喵~ 这道题的侧边栏信息好像被淘气的妖精藏起来了，找不到比赛信息呢。
> **标签**: 同样地，标签信息也神秘失踪了喵~
> **难度**: 难度评分也...不见了踪影！不过没关系，只要我们一起努力，任何难题都能解决的说！

## 题目大意喵~

好久不见呀，指挥官！今天我们来玩一个有趣的游戏，喵~

Rikka 和 Yuuta 在玩抛硬币。这枚硬币有点特别，它正面朝上（Rikka 获胜）的概率是 $p$，反面朝上（Yuuta 获胜）的概率是 $1-p$。

游戏会一直进行下去，直到出现一个**连续的时间段**，在这个时间段里，某个人比另一个人多赢了整整 $n$ 场。一旦这个条件达成，那个人就赢得了整场游戏，游戏结束！

比如说，如果 $n=3$，游戏过程是“反反正正反正正”。在第7回合结束时，我们看从第3回合到第7回合这个时间段（“正正反正正”），Rikka赢了4次，Yuuta赢了1次，Rikka比Yuuta多赢了 $4-1=3$ 次。所以，Rikka 在此刻赢得游戏！

我们的任务是，计算出我们这边（Rikka）最终获胜的总概率是多少，喵~

## 解题思路分析

这道题的核心是一个非常经典的概率模型——**随机游走 (Random Walk)**，只不过带有一点点小变化，让它变得更加有趣了呢，喵~

首先，我们来把问题数学化一下。设一个变量 $S_k$ 表示在第 $k$ 局游戏后，“Rikka的获胜次数”减去“Yuuta的获胜次数”。
- 游戏开始前，谁都没赢，所以 $S_0 = 0$。
- Rikka 赢一局，这个差值就加 1，即 $S_k = S_{k-1} + 1$，发生概率为 $p$。
- Yuuta 赢一局，这个差值就减 1，即 $S_k = S_{k-1} - 1$，发生概率为 $q = 1-p$。

接下来，我们来理解胜利条件：“在任意一个时间段 $[i, j]$ 内，某人比另一个人多获胜 $n$ 次”。
这等价于在第 $j$ 回合结束时，存在一个 $i$ ($1 \le i \le j$)，使得从第 $i$ 回合到第 $j$ 回合的净胜场为 $n$ 或 $-n$。
用我们的 $S_k$ 来表示，就是存在 $i, j$（$0 \le i < j$）使得 $S_j - S_i = n$（Rikka 赢）或者 $S_j - S_i = -n$（Yuuta 赢）。

这个条件还可以进一步转换。想象一下 $S_k$ 值的变化曲线，它忽上忽下。Rikka 要赢，意味着曲线在某处要比它之前到过的**任意**一个点高出 $n$。Yuuta 要赢，则是曲线在某处要比它之前到过的**任意**一个点低 $n$。
这等价于，在游戏历史中，达到的最大值 $M_k = \max_{0 \le i \le k} S_i$ 和最小值 $m_k = \min_{0 \le i \le k} S_i$ 的差第一次达到 $n$ 时，游戏就结束了。
即，游戏在时刻 $T$ 结束，其中 $T = \min\{k \mid M_k - m_k = n\}$。
如果结束时 $S_T - m_T = n$，就是 Rikka 赢；如果 $M_T - S_T = n$，就是 Yuuta 赢。

喵~ 这道题的数学推导有点小复杂呢，它涉及到了随机游走理论中的一些进阶结论。直接从头推导出来需要不少高深的数学工具，对于我们猫娘来说，有点头秃喵~

不过幸运的是，前人已经为我们铺好了路！对于这种类型的随机游走问题，Rikka 获胜的概率有一个非常优美的公式。
我们定义一个比值 $s = \frac{q}{p} = \frac{1-p}{p}$。

- **特殊情况**: 当 $p = q = 1/2$ 时，硬币是公平的。那么 $s=1$。这种情况下，Rikka 和 Yuuta 的获胜机会显然是均等的，所以 Rikka 获胜的概率是 $1/2$。

- **一般情况**: 当 $p \neq q$ 时 ($s \neq 1$)，Rikka 获胜的概率 $P_R$ 可以通过下面这个神奇的公式计算：
$$
P_R = \frac{n s^{n+1} - (n+1)s^n + 1}{(s^{n+1}-1)(s^n-1)}
$$
这个公式看起来有点吓人，但它把一个动态的概率过程变成了一个静态的代数计算，非常强大！

我们的任务就是用代码实现这个公式的计算。因为题目涉及模运算，我们需要用到**快速幂**来计算 $s^n$ 和 $s^{n+1}$，并用**费马小定理**求**模逆元**来处理除法。

公式的代数变形：为了方便编程，我们可以把公式变形成这样：
$$
P_R = \frac{n s^n (s-1)}{(s^{n+1}-1)(s^n-1)} - \frac{1}{s^{n+1}-1}
$$
这两种形式是等价的，指挥官可以自己推导一下试试看哦，很有趣的喵~ 参考代码用的就是这种变形。不过我更喜欢第一种形式，因为它把分子和分母分开计算，逻辑更清晰！

所以我们的解题步骤就是：
1.  读入 $n$ 和 $p$。
2.  计算 $q = 1-p$。
3.  处理一些边缘情况，比如 $p=0$ (Rikka 必败) 或 $p=1$ (Rikka 必胜)。
4.  计算比值 $s = q \cdot p^{-1} \pmod{MOD}$。
5.  如果 $s=1$，输出 $1/2$ 的模逆元。
6.  否则，代入公式，使用快速幂和模逆元计算出最终的概率值。

搞定！是不是感觉清晰多了？我们这就去写代码吧，喵~

## 代码实现

```cpp
#include <iostream>

// 为了避免整数溢出，我们统一使用 long long，喵~
using ll = long long;

// 这是题目要求的模数，一个很大的质数
const int MOD = 998244353;

// 快速幂函数，用来计算 (base^exp) % MOD
// 它的速度像猫咪冲刺一样快，喵！
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模逆元函数，基于费马小定理
// inv(a) = a^(MOD-2) % MOD
// 在模算术里，除以一个数等于乘以它的逆元，这是个小魔法哦！
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// 解决单个测试用例的主函数，喵~
void solve() {
    ll n, p_val;
    std::cin >> n >> p_val;

    // Rikka 在一局中获胜的概率
    ll p = p_val;
    // Yuuta 在一局中获胜的概率
    ll q = (1 - p + MOD) % MOD;

    // 处理一些极端情况，让程序更健壮
    if (p == 0) { // Rikka 永远赢不了单局，所以总概率是 0
        std::cout << 0 << "\n";
        return;
    }
    if (q == 0) { // Rikka 总能赢下每一局，n 局后必胜，总概率是 1
        std::cout << 1 << "\n";
        return;
    }
    
    // 计算关键比值 s = q/p
    ll s = (q * modInverse(p)) % MOD;

    // 特殊情况：p = q，此时 s = 1
    // 游戏是公平的，Rikka 获胜概率为 1/2
    if (s == 1) {
        std::cout << modInverse(2) << "\n";
        return;
    }

    // 接下来，就是实现我们找到的那个神奇公式啦！
    // P_R = (n * s^(n+1) - (n+1) * s^n + 1) / ((s^(n+1) - 1) * (s^n - 1))
    
    // 先用快速幂计算我们需要的 s 的次方
    ll s_pow_n = power(s, n);
    ll s_pow_n_plus_1 = (s_pow_n * s) % MOD;

    // 计算分子: n * s^(n+1) - (n+1) * s^n + 1
    ll term1_num = (n % MOD * s_pow_n_plus_1) % MOD;
    ll term2_num = ((n + 1) % MOD * s_pow_n) % MOD;
    ll numerator = (term1_num - term2_num + 1 + MOD) % MOD;

    // 计算分母: (s^(n+1) - 1) * (s^n - 1)
    ll term1_den = (s_pow_n_plus_1 - 1 + MOD) % MOD;
    ll term2_den = (s_pow_n - 1 + MOD) % MOD;
    ll denominator = (term1_den * term2_den) % MOD;

    // 最终答案就是 分子 / 分母 (在模意义下)
    ll result = (numerator * modInverse(denominator)) % MOD;

    std::cout << result << "\n";
}

int main() {
    // 使用快速 I/O，让我们的程序跑得飞快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: 对于每一个测试用例，我们的计算主要消耗在快速幂函数 `power` 上。计算 $s^n$ 和 $s^{n+1}$ 的时间复杂度都是 $O(\log n)$。其他都是常数时间的模乘法和加减法。所以，每个测试用例的总时间复杂度是 $O(\log n)$，非常高效！
- **空间复杂度**: 我们只使用了几个变量来存储中间结果，没有使用任何与 $n$ 大小相关的数组或容器。所以空间复杂度是 $O(1)$，非常节省内存呢，喵~

## 知识点总结

这道题虽然看起来很深奥，但它教会了我们几个宝贵的知识点，呐：

1.  **模型识别**: 能将题目描述转化为熟悉的数学模型（如随机游走）是解题的关键第一步。
2.  **善用结论**: 在算法竞赛中，有些问题会基于一些已知的数学或理论结果。当直接推导非常困难时，知道并能够应用这些结论会为你节省大量时间。
3.  **模运算**: 在处理需要精确计算但数值可能很大的问题时，模运算是必备技能。特别是**快速幂**和**模逆元**（基于费马小定理或扩展欧几里得算法），是指挥官工具箱里必须有的利器！
4.  **代码实现**: 将复杂的数学公式转化为清晰、正确的代码是一项重要的工程能力。注意处理边界情况（如 $p=0, p=1, p=1/2$），能让你的代码更加完美。

希望这篇题解能帮到你，指挥官！下次再一起挑战难题吧，喵~！