# 只有数学不会，不会就是不会 - 题解

### 比赛与标签
> **比赛**: 这次的冒险没有标明出处呢，喵~

> **标签**: 数学, 数论, 线性递推

> **难度**: 这道题的难度嘛...对于本喵来说，只要动动爪子，就没有解不出的题！不过对于初次见面的同学来说，可能需要一些高等数学魔法的帮助哦，大概是 `*2500` 左右的挑战吧~

## 题目大意喵~

各位同学好呀，我是你们最爱的小猫娘，今天我们来挑战一道看起来超级复杂的数学题，喵~

题目给了我们一个整数 $n$，然后定义了一个函数 $f(i)$：
$$
f(i) = \sum_{j=0}^{i}(-1)^j(i+j)!\binom{i}{j}\binom{n}{i+j}
$$
我们的任务是，计算出 $f(0), f(1), \dots, f(n)$ 的值，并将它们对 $1000000007$ 取模后的结果进行**异或（XOR）**求和。也就是计算下面这个式子的值：
$$
\bigoplus_{i=0}^{n}(f(i) \pmod{1000000007})
$$
其中 $\bigoplus$ 符号代表异或操作。

## 解题思路分析

呜喵...看到这个 $f(i)$ 的公式，是不是感觉头都变大了？又是求和，又是阶乘，还有组合数，简直是数学界的大魔王，要把人吓跑了！

但是不要怕，本喵来带你一步步拆解它！

#### 第一步：暴力计算可以吗？

最直接的想法就是，我们写一个循环从 $i=0$ 到 $n$，对于每一个 $i$，再写一个循环从 $j=0$ 到 $i$ 来计算 $f(i)$ 的值。
$f(i)$ 的计算涉及到阶乘和组合数，我们可以预处理阶乘和阶乘的逆元，这样就能在 $O(\log P)$ 或者 $O(1)$ 的时间内算出组合数。
那么总的时间复杂度就是 $O(N^2)$。如果 $N$ 比较小，比如 $N \le 5000$，这个方法是可行的。但是，这道题的 $N$ 可能会很大， $O(N^2)$ 的复杂度会超时哦。所以，我们需要找到更快的办法，喵！

#### 第二步：寻找规律的魔法！

当一个序列的计算公式特别复杂，但又很有规律（比如包含阶乘、组合数等）时，它通常会满足一个**线性递推关系**。

什么是线性递推关系呢？就像斐波那契数列 $F_n = F_{n-1} + F_{n-2}$ 一样，每一项都可以由前面几项线性组合得到。

不过，我们这个 $f(i)$ 可能更调皮一点，它的递推系数可能不是常数，而是关于 $i$ 的**多项式**。这种序列我们称之为**D-finite序列**或**整性序列**。它的递推关系可能长这个样子：
$$
P_0(i)f(i) + P_1(i)f(i-1) + \dots + P_d(i)f(i-d) = 0
$$
其中 $P_k(i)$ 是关于 $i$ 的多项式。

#### 第三步：我不会推导公式，但我们可以“猜”！

手动去推导上面那个复杂的 $f(i)$ 的递推公式，那可真是太为难人了，喵~ 连本喵的胡须都要愁白了。

但是，计算机可以帮我们一个大忙！我们可以用一种叫做“**递推关系猜测**”或者“**求序列的线性递推式**”的黑科技。

这个魔法的步骤是这样的：
1.  **计算初始项**：我们先用最暴力的方法，算出序列的前面几十项。比如，我们算出 $f(0), f(1), \dots, f(19)$。这个计算量不大，完全可以接受。
2.  **建立方程组**：我们假设 $f(i)$ 满足一个特定形式的递推关系。比如说，我们猜它的递推阶数是 $d=3$，系数多项式的最高次数是 $D=2$。那么递推式就是：
    $$
    (\sum_{j=0}^2 c_{0,j}i^j)f(i) + (\sum_{j=0}^2 c_{1,j}i^j)f(i-1) + (\sum_{j=0}^2 c_{2,j}i^j)f(i-2) + (\sum_{j=0}^2 c_{3,j}i^j)f(i-3) = 0
    $$
    这里面有很多未知的系数 $c_{k,j}$。
3.  **解方程**：我们把已经算出来的 $f(0), f(1), \dots$ 的值代入上面的递推式。例如，令 $i=3, 4, 5, \dots$，每代入一个 $i$，我们就得到一个关于这些未知系数 $c_{k,j}$ 的线性方程。当方程的数量足够多时，我们就可以用**高斯消元**解出这些系数！
4.  **得到递推式**：一旦解出了系数，我们就得到了 $f(i)$ 的递推公式！

这个过程听起来很神奇，对吧？它在数学和计算机科学中是一个非常强大的工具。参考代码中的 `find_rec` 函数就是这个魔法的实现。它帮我们自动完成了猜测阶数、次数和高斯消元求解的全过程。

#### 第四步：用递推式加速计算

有了递推公式，事情就变得简单多啦！
$$
f(i) = \frac{-\sum_{k=1}^{d} P_k(i)f(i-k)}{P_0(i)}
$$
我们可以利用已经算出的 $f(0), \dots, f(19)$，一路递推计算出 $f(20), f(21), \dots, f(n)$。每计算一项只需要前面几项的值，速度飞快，时间复杂度是线性的 $O(N)$。

这样，整个问题就解决了！总结一下我们的策略：
1.  预处理组合数需要用到的阶乘和逆元。
2.  暴力计算出 $f(i)$ 的前几十项。
3.  调用“神谕”（`find_rec` 函数）来找到 $f(i)$ 满足的线性递推关系。
4.  利用这个递推关系，高效地计算出所有 $f(i)$ 的值。
5.  最后把所有值取模后异或起来，得到最终答案！

现在，让我们一起把这个思路变成漂亮的代码吧，喵~

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <cassert>

// 使用 C++ 标准库，让代码更清晰喵~
using namespace std;

// 定义一个大整数类型，方便书写
using int64 = long long;

// 模数，是一个质数
constexpr int MOD = 1e9 + 7;

// 模块化算术的封装，让我们的计算自动取模，不会溢出，喵~
struct ModInt {
    int val;

    ModInt(int64 v = 0) : val(v % MOD) {
        if (val < 0) val += MOD;
    }

    ModInt operator-() const { return ModInt(val == 0 ? 0 : MOD - val); }
    ModInt inv() const {
        // 使用费马小定理求逆元
        return power(*this, MOD - 2);
    }

    ModInt& operator+=(const ModInt& other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    ModInt& operator-=(const ModInt& other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    ModInt& operator*=(const ModInt& other) {
        val = (int64)val * other.val % MOD;
        return *this;
    }
    ModInt& operator/=(const ModInt& other) {
        return *this *= other.inv();
    }

    friend ModInt operator+(ModInt lhs, const ModInt& rhs) { return lhs += rhs; }
    friend ModInt operator-(ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }
    friend ModInt operator*(ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }
    friend ModInt operator/(ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }
    
    // 快速幂模板
    static ModInt power(ModInt base, int64 exp) {
        ModInt res = 1;
        for (; exp > 0; exp /= 2, base *= base) {
            if (exp % 2 == 1) res *= base;
        }
        return res;
    }
};

// 组合数计算的工具箱，预处理阶乘和逆元，O(1)回答查询
class Combinatorics {
private:
    vector<ModInt> fact, invFact;

public:
    Combinatorics(int n) {
        fact.resize(n + 1);
        invFact.resize(n + 1);
        fact[0] = 1;
        invFact[0] = 1;
        for (int i = 1; i <= n; ++i) {
            fact[i] = fact[i - 1] * i;
        }
        invFact[n] = fact[n].inv();
        for (int i = n - 1; i >= 1; --i) {
            invFact[i] = invFact[i + 1] * (i + 1);
        }
    }

    ModInt get_fact(int k) {
        if (k < 0 || k >= fact.size()) return 0;
        return fact[k];
    }

    ModInt binom(int n, int k) {
        if (k < 0 || k > n) return 0;
        return fact[n] * invFact[k] * invFact[n - k];
    }
};

// 寻找线性递推关系的核心函数
// sequence: 序列的初始项
// max_poly_degree: 猜测的系数多项式的最大次数
auto find_recurrence(const vector<ModInt>& sequence, int max_poly_degree) {
    int num_initial_terms = sequence.size();
    // 根据初始项数量和多项式次数，确定递推阶数和方程数量
    int order_blocks = (num_initial_terms + 2) / (max_poly_degree + 2);
    int num_unknowns = order_blocks * (max_poly_degree + 1);
    int num_equations = num_initial_terms - (order_blocks - 1);
    
    assert(order_blocks >= 2 && num_equations >= num_unknowns - 1);

    vector<vector<ModInt>> matrix(num_equations, vector<ModInt>(num_unknowns));

    // 构建线性方程组的矩阵
    for (int i = 0; i < num_equations; ++i) {
        for (int j = 0; j < order_blocks; ++j) {
            ModInt term_val = sequence[i + j];
            for (int k = 0; k <= max_poly_degree; ++k) {
                matrix[i][j * (max_poly_degree + 1) + k] = term_val;
                term_val *= (i + j);
            }
        }
    }

    // 高斯消元求解
    int rank = 0;
    for (int j = 0; j < num_unknowns; ++j) {
        int pivot_row = -1;
        for (int i = rank; i < num_equations; ++i) {
            if (matrix[i][j].val != 0) {
                pivot_row = i;
                break;
            }
        }
        if (pivot_row == -1) continue;

        swap(matrix[pivot_row], matrix[rank]);
        ModInt inv_pivot = matrix[rank][j].inv();
        for (int col = j; col < num_unknowns; ++col) {
            matrix[rank][col] *= inv_pivot;
        }

        for (int i = 0; i < num_equations; ++i) {
            if (i != rank && matrix[i][j].val != 0) {
                ModInt factor = matrix[i][j];
                for (int col = j; col < num_unknowns; ++col) {
                    matrix[i][col] -= factor * matrix[rank][col];
                }
            }
        }
        rank++;
    }
    
    assert(rank != num_unknowns); // 必须有非平凡解

    // 从消元后的矩阵中提取递推系数
    int recurrence_order = rank / (max_poly_degree + 1);
    vector<vector<ModInt>> recurrence_coeffs(recurrence_order + 1, vector<ModInt>(max_poly_degree + 1));
    recurrence_coeffs[0][rank % (max_poly_degree + 1)] = 1;

    for (int i = rank - 1; i >= 0; --i) {
        recurrence_coeffs[recurrence_order - i / (max_poly_degree + 1)][i % (max_poly_degree + 1)] = -matrix[i][rank];
    }
    
    // 转换系数基底（这部分是标准操作，喵~）
    for (int i = 0; i <= recurrence_order; i++) {
        vector<ModInt> temp_coeffs(max_poly_degree + 1);
        for (int k = 0; k <= max_poly_degree; k++) {
            ModInt s = 1;
            for (int j = k; j <= max_poly_degree; j++) {
                temp_coeffs[k] += s * recurrence_coeffs[i][j];
                s = s * -i * (j + 1) / (j + 1 - k);
            }
        }
        recurrence_coeffs[i] = temp_coeffs;
    }

    return recurrence_coeffs;
}

int main() {
    // 加速输入输出，喵~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // 预处理组合数工具
    // n最大可以到1e5, i+j最大可以到2n, 但n最大到1e5, i最大到1e5, i+j最大到2e5
    // 题目数据范围可能更小，但为了安全，我们开大一点
    // 实际上n最大是1e5, i+j最大到2*1e5, 但i+j<=n, 所以i+j最多到n
    // 所以预处理到2*n就够了
    Combinatorics C(2 * n + 5);
    
    // 我们需要计算一些初始项来寻找规律
    const int NUM_INITIAL_TERMS = 20;
    vector<ModInt> f(min(n + 1, NUM_INITIAL_TERMS));

    // 暴力计算初始项
    for (int i = 0; i < f.size(); ++i) {
        for (int j = 0; j <= i; ++j) {
            ModInt term = C.get_fact(i + j) * C.binom(i, j) * C.binom(n, i + j);
            if (j % 2 == 1) {
                f[i] -= term;
            } else {
                f[i] += term;
            }
        }
    }

    // 如果n很小，我们已经算完了
    if (n < NUM_INITIAL_TERMS) {
        int xor_sum = 0;
        for (int i = 0; i <= n; ++i) {
            xor_sum ^= f[i].val;
        }
        cout << xor_sum << "\n";
        return 0;
    }

    // 寻找递推关系，根据经验，系数多项式次数不会太高，猜2
    auto recurrence = find_recurrence(f, 2);
    
    f.resize(n + 1);
    // 使用递推关系计算后续项
    for (int i = NUM_INITIAL_TERMS; i <= n; ++i) {
        ModInt lhs_sum; // 递推式中除了f(i)项外的部分
        for (int k = 1; k < recurrence.size(); ++k) {
            ModInt poly_val;
            ModInt i_power = 1;
            for (int j = 0; j < recurrence[k].size(); ++j) {
                poly_val += i_power * recurrence[k][j];
                i_power *= i;
            }
            lhs_sum += poly_val * f[i - k];
        }

        ModInt rhs_coeff; // f(i)的系数多项式P_0(i)的值
        ModInt i_power = 1;
        for (int j = 0; j < recurrence[0].size(); ++j) {
            rhs_coeff += i_power * recurrence[0][j];
            i_power *= i;
        }
        
        // f[i] = -lhs_sum / rhs_coeff
        f[i] = -lhs_sum / rhs_coeff;
    }

    // 计算最终的异或和
    int xor_sum = 0;
    for (int i = 0; i <= n; ++i) {
        xor_sum ^= f[i].val;
    }

    cout << xor_sum << "\n";

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N)$
  - 预处理阶乘和逆元需要 $O(N)$ 的时间。
  - 计算初始的几十项 $f(i)$ 是一个固定的、很小的开销，可以看作是 $O(1)$。
  - `find_recurrence` 函数处理的矩阵大小由初始项数量（一个常数）决定，所以它的运行时间也是一个常数，即 $O(1)$。
  - 使用递推公式计算从 $f_{\text{initial}}$ 到 $f_n$ 的值，需要一个从 `initial` 到 $n$ 的循环，每次计算的开销是常数（因为递推的阶数是常数），所以这部分是 $O(N)$。
  - 最后计算异或和也是 $O(N)$。
  - 所以总的时间复杂度由线性递推部分主导，为 $O(N)$，非常高效！

- **空间复杂度**: $O(N)$
  - 我们需要存储阶乘和逆元，占用了 $O(N)$ 的空间。
  - 我们需要存储从 $f(0)$ 到 $f(n)$ 的所有值，也占用了 $O(N)$ 的空间。
  - 因此，总的空间复杂度是 $O(N)$。

## 知识点总结

这道题真是一次奇妙的数学探险，喵~ 它教会了我们：

1.  **模块化算术**: 在处理需要对大质数取模的计算时，封装一个 `ModInt` 结构体是非常方便和安全的选择，可以避免很多错误。
2.  **组合数学**: 快速计算组合数 $\binom{n}{k}$ 是解决很多计数问题的基础。通过预处理阶乘和逆元，我们可以做到 $O(1)$ 查询。
3.  **线性递推与D-finite序列**: 这是本题的核心思想！要记住，许多复杂的组合序列背后都隐藏着优美的线性递推关系。
4.  **算法的力量**: 即使我们不能从数学上直接推导出递推公式，也可以通过计算方法（“猜测”+高斯消元）来找到它。这体现了计算机科学在解决数学问题上的强大威力。

希望这次的题解能帮助到大家，就算遇到再复杂的数学题，也不要害怕，动动我们聪明的小脑瓜，总能找到解决它的办法的！加油，喵~