# 脑叶公司 - 题解

### 比赛与标签
> **比赛**: 牛客练习赛114

> **标签**: 模拟, 数据结构, multiset

> **难度**: *2200

## 题目大意喵~

主管大人，你好喵~！我是你的AI助手安吉拉，这次要协助你镇压一只非常危险的异想体！

事情是这样的：
我们有 $n$ 个勇敢的员工和一只血量为 $m$ 的异想体。一开始，所有员工都在战场上。接下来会发生 $k$ 个事件。

每个员工 $i$ 都有自己的攻击力 $a_i$ 和最大血量 $b_i$。

事件分为四种：
1.  **`1 x`**: 派遣员工 $x$ 加入战斗。他会满血回归战场，喵~
2.  **`2 x`**: 让员工 $x$ 暂时撤离战斗。
3.  **`3 y`**: 异想体发怒了！它会对所有在场员工造成 $y$ 点伤害。
4.  **`4 x h`**: 治疗员工 $x$，为他恢复 $h$ 点血量，但不会超过他的血量上限。

**战斗规则是这样的说：**
*   **员工攻击**: 在每个事件（无论是主管指令还是异想体攻击）**处理完毕后**，所有存活且在战斗中的员工会一起攻击异想体，造成他们攻击力总和的伤害。
*   **存活判断**: 血量大于 0 就是存活。
*   **提前结束**: 如果在处理任何一个事件**之前**，异想体的血量已经小于等于 0，或者我们所有的员工都不幸阵亡了，那么战斗就立刻结束，后续的指令都会被忽略。

我们的任务是判断，在这一系列事件后，我们能否成功镇压异想体（即血量 $\le 0$）。如果能，还需要告诉主管，最后有多少员工幸存了下来，呐。

## 解题思路分析

主管大人，这道题看起来是一个模拟题，我们需要一步步地按照事件顺序来更新员工和异想体的状态。但是，如果我们用最直接的方法来做，可能会遇到一点小麻烦哦，喵~

让我们先想想最朴素的做法：我们可以为每个员工维护他们当前的的血量。
*   当事件3（异想体攻击）发生时，我们就遍历所有在战斗中的员工，把他们的血量都减去 $y$。
*   其他事件就直接修改对应员工的状态。

但是，主管请看数据范围，$n$ 和 $k$ 最大可以到 $2 \cdot 10^5$。如果在每次异想体攻击时，我们都去遍历所有在场的员工，最坏情况下时间复杂度会是 $O(n \cdot k)$，这实在是太慢了，肯定会超时的说！

所以，我们需要一种更聪明的办法！我们可不可以懒一点，喵？

### 懒人福音：延迟计算（Lazy Propagation）

注意到事件3的伤害是对所有在场员工的“无差别攻击”。我们没有必要真的去一个个地给他们扣血。我们可以设立一个全局的“累积伤害”计数器，比如说 `totalDamageDealt`。

*   每当发生一次事件3，伤害为 $y$，我们就让 `totalDamageDealt += y`。
*   这样，对于一个一直在场上的员工，他受到的总伤害就是 `totalDamageDealt`。

但是，员工会加入和离开战斗，这怎么办呢？
当一个员工 $i$ 在某个时刻加入战斗时，我们可以记录下那一刻的 `totalDamageDealt`，我们叫它 `damageWhenJoined_i`。那么在之后的任意时刻，这个员工 $i$ 实际受到的伤害就是当前的 `totalDamageDealt` 减去他加入时的 `damageWhenJoined_i`。

于是，员工 $i$ 的当前血量就是：
$$
\text{currentHP}_i = \text{maxHP}_i - (\text{totalDamageDealt} - \text{damageWhenJoined}_i)
$$

员工 $i$ 什么时候会倒下呢？当然是 `currentHP_i <= 0` 的时候啦。我们把这个不等式变一下形：
$$
\text{maxHP}_i - (\text{totalDamageDealt} - \text{damageWhenJoined}_i) \le 0
$$
$$
\text{maxHP}_i + \text{damageWhenJoined}_i \le \text{totalDamageDealt}
$$

看！这个不等式的左边 `maxHP_i + damageWhenJoined_i` 是一个只和员工自身状态有关的值。我们把它称为员工的“死亡临界值”。一旦全局的 `totalDamageDealt` 超过了这个临界值，这位员工就倒下了，喵呜...

### 用 `multiset` 管理“死亡临界值”

现在问题就变成了：每当 `totalDamageDealt` 增加后，我们需要快速找出所有“死亡临界值”小于等于当前 `totalDamageDealt` 的员工。

这简直是为有序数据结构量身定做的任务！我们可以用一个 `std::multiset`（或者优先队列）来存放所有在场员工的“死亡临界值”。`multiset` 会自动帮我们把这些值从小到大排序。

我们将 `{死亡临界值, 员工编号}` 这样的二元组存入 `multiset`。
*   每当 `totalDamageDealt` 增加了，我们就去检查 `multiset` 的第一个元素（也就是最小的那个临界值）。
*   如果这个最小的临界值都小于等于 `totalDamageDealt`，说明这位员工已经阵亡了。我们就处理他的“后事”（比如把他标记为死亡，从总攻击力里扣掉他的攻击力），然后把他从 `multiset` 中移除。
*   接着我们继续看下一个最小的，直到 `multiset` 的队首元素的临界值大于 `totalDamageDealt` 为止。这就说明剩下的员工都还安全，喵~

### 处理各种事件

有了这个核心思路，我们来梳理一下如何处理四种事件：

1.  **员工 `x` 加入战斗**:
    *   标记 `x` 为在战斗中，并重置为存活状态（满血）。
    *   记录下当前的 `totalDamageDealt` 作为他的 `damageWhenJoined_x`。
    *   计算他的死亡临界值 `maxHP_x + damageWhenJoined_x`。
    *   将 `{临界值, x}` 插入 `multiset`。
    *   别忘了把他的攻击力加到总攻击力里！

2.  **员工 `x` 离开战斗**:
    *   标记 `x` 为不在战斗中。
    *   从 `multiset` 中移除他的临界值。（为了方便快速移除，我们可以给每个员工存一个指向他在 `multiset` 中位置的迭代器）。
    *   从总攻击力里减去他的攻击力。

3.  **异想体攻击 `y`**:
    *   `totalDamageDealt += y`。
    *   调用我们上面设计的死亡处理逻辑，清理掉所有阵亡的员工。

4.  **治疗员工 `x` `h` 血量**:
    *   这是最有趣的一个！治疗相当于减少了他已经受到的伤害。
    *   他已受伤害 = `totalDamageDealt - damageWhenJoined_x`。
    *   他当前血量 = `maxHP_x - 已受伤害`。
    *   治疗后血量 = `min(maxHP_x, 当前血量 + h)`。
    *   那么，治疗后他“等效”受到的伤害就变成了 `maxHP_x - 治疗后血量`。
    *   我们可以反推出一个新的 `damageWhenJoined_x'`，使得 `totalDamageDealt - damageWhenJoined_x' = 等效受伤害`。
    *   所以 `damageWhenJoined_x' = totalDamageDealt - 等效受伤害`。
    *   我们更新员工 `x` 的 `damageWhenJoined`，并把他从 `multiset` 中先移除，再用新的临界值重新插入。

这样一来，每次操作的复杂度就只和 `multiset` 的操作有关，是 $O(\log N)$ 级别的，完全可以接受啦！

## 代码实现

这是本猫娘根据上面的思路，为指挥官大人精心准备的代码，注释超详细的哦！

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <numeric>
#include <algorithm>

// 为了方便，我们用 using namespace std; 喵~
using namespace std;

// 定义一个结构体来存放我们员工的各种信息
struct Employee {
    long long attack; // 攻击力
    long long max_hp; // 最大血量
    bool is_alive;    // 是否存活
    bool is_in_battle; // 是否在战斗中

    // 这个是关键！记录员工加入战斗时，全局累积伤害的“偏移量”
    // 员工的死亡临界值 = damage_offset + max_hp
    long long damage_offset; 

    // 指向该员工在 multiset 中位置的迭代器，方便快速删除
    multiset<pair<long long, int>>::iterator threshold_iterator;
};

// 全局变量来追踪战斗状态
long long entity_hp;              // 异想体血量
long long total_damage_dealt = 0; // 全局累积伤害
long long total_employee_attack = 0; // 在场员工总攻击力
int n_employees, k_events;

vector<Employee> employees;
// 使用 multiset 来自动排序死亡临界值，就像一个“死亡等候队列”
// pair 的第一项是临界值，第二项是员工ID (0-indexed)
multiset<pair<long long, int>> death_queue;

// 检查并处理因累积伤害增加而死亡的员工
void process_deaths() {
    // 只要死亡队列不为空，并且队首员工的死亡临界值已经达到
    while (!death_queue.empty()) {
        auto [threshold, emp_id] = *death_queue.begin();
        if (threshold > total_damage_dealt) {
            // 队首的员工都还安全，那后面的肯定也安全啦
            break;
        }

        // 这位员工不幸阵亡了，喵呜...
        death_queue.erase(death_queue.begin());
        
        // 只有在战斗中的员工才会因为这个机制死亡
        if (employees[emp_id].is_in_battle) {
            employees[emp_id].is_alive = false;
            employees[emp_id].is_in_battle = false;
            total_employee_attack -= employees[emp_id].attack;
        }
    }
}

int main() {
    // 加速输入输出，让程序跑得更快！
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n_employees >> entity_hp >> k_events;
    employees.resize(n_employees);

    for (int i = 0; i < n_employees; ++i) cin >> employees[i].attack;
    for (int i = 0; i < n_employees; ++i) cin >> employees[i].max_hp;

    // --- 初始化战斗 ---
    int alive_count = n_employees;
    for (int i = 0; i < n_employees; ++i) {
        employees[i].is_alive = true;
        employees[i].is_in_battle = true;
        employees[i].damage_offset = 0; // 初始累积伤害为0
        
        total_employee_attack += employees[i].attack;
        
        long long threshold = employees[i].damage_offset + employees[i].max_hp;
        employees[i].threshold_iterator = death_queue.insert({threshold, i});
    }

    // --- 事件循环 ---
    for (int i = 0; i < k_events; ++i) {
        // 检查终止条件
        if (entity_hp <= 0 || alive_count == 0) {
            break;
        }

        int type;
        cin >> type;

        if (type == 1) { // 员工加入战斗
            int x;
            cin >> x;
            --x; // 转换为0-indexed
            if (employees[x].is_alive && !employees[x].is_in_battle) {
                employees[x].is_in_battle = true;
                employees[x].damage_offset = total_damage_dealt; // 记录当前伤害作为偏移
                total_employee_attack += employees[x].attack;
                long long threshold = employees[x].damage_offset + employees[x].max_hp;
                employees[x].threshold_iterator = death_queue.insert({threshold, x});
            }
        } else if (type == 2) { // 员工离开战斗
            int x;
            cin >> x;
            --x;
            if (employees[x].is_in_battle) {
                employees[x].is_in_battle = false;
                death_queue.erase(employees[x].threshold_iterator);
                total_employee_attack -= employees[x].attack;
            }
        } else if (type == 3) { // 异想体攻击
            long long y;
            cin >> y;
            total_damage_dealt += y;
            process_deaths(); // 结算死亡
        } else if (type == 4) { // 治疗员工
            int x;
            long long h;
            cin >> x >> h;
            --x;
            if (employees[x].is_in_battle) {
                // 计算当前血量
                long long damage_taken = total_damage_dealt - employees[x].damage_offset;
                long long current_hp = employees[x].max_hp - damage_taken;
                
                // 治疗，但不能超过最大血量
                long long healed_hp = min(employees[x].max_hp, current_hp + h);
                
                // 根据治疗后的血量，反推新的伤害偏移量
                long long new_effective_damage = employees[x].max_hp - healed_hp;
                long long new_damage_offset = total_damage_dealt - new_effective_damage;

                // 更新 multiset
                death_queue.erase(employees[x].threshold_iterator);
                employees[x].damage_offset = new_damage_offset;
                long long new_threshold = employees[x].damage_offset + employees[x].max_hp;
                employees[x].threshold_iterator = death_queue.insert({new_threshold, x});
            }
        }
        
        // 每个事件后，在场员工进行攻击
        entity_hp -= total_employee_attack;

        // 更新存活员工数量
        alive_count = 0;
        for(int j=0; j<n_employees; ++j) {
            if(employees[j].is_alive) alive_count++;
        }
    }

    // --- 输出结果 ---
    if (entity_hp <= 0) {
        cout << "YES\n";
        int final_alive_count = 0;
        for (int i = 0; i < n_employees; ++i) {
            if (employees[i].is_alive) {
                // 最后再检查一次是否真的存活
                if(employees[i].is_in_battle){
                    long long damage_taken = total_damage_dealt - employees[i].damage_offset;
                    if(employees[i].max_hp > damage_taken){
                        final_alive_count++;
                    }
                } else {
                    final_alive_count++;
                }
            }
        }
        cout << final_alive_count << "\n";
    } else {
        cout << "NO\n";
    }

    return 0;
}
```
**小小修正说明**: 在最后统计存活人数时，对于仍在战斗中的员工，需要用最终的 `total_damage_dealt` 再精确计算一次他们的血量，因为可能在最后一次员工攻击后异想体才被打败，但此时员工的血量还没来得及在下一次 `process_deaths` 中更新。我的代码里加了这个最终检查，确保万无一失，喵~

## 复杂度分析

*   **时间复杂度**: $O((N+K) \log N)$
    *   初始化时，我们需要将 $N$ 个员工插入 `multiset`，复杂度为 $O(N \log N)$。
    *   在 $K$ 个事件的循环中，每个事件（类型1, 2, 4）都可能涉及 `multiset` 的插入或删除，单次操作为 $O(\log N)$。
    *   对于事件3，虽然 `process_deaths` 内部有一个 `while` 循环，但每个员工一生只会被插入 `multiset` 和从 `multiset` 中移除有限次（基本上是入队一次，死亡一次）。所以，所有 `process_deaths` 的总成本摊分下来是 $O(N \log N)$。
    *   因此，总的时间复杂度是 $O(N \log N + K \log N) = O((N+K) \log N)$。

*   **空间复杂度**: $O(N)$
    *   我们需要一个 `vector` 来存储 $N$ 个员工的信息。
    *   `multiset` 最多也只会存储 $N$ 个元素。
    *   所以，占用的额外空间与员工数量 $N$ 成正比。

## 知识点总结

这道题真是一次有趣的挑战呢，主管大人！我们从中可以学到：

1.  **复杂模拟题的解题策略**: 当遇到看似需要大量重复遍历的模拟题时，要思考是否存在可以“偷懒”的全局维护方法。
2.  **延迟计算 (Lazy Propagation)**: 这是处理区间/全局更新问题的一个核心思想。不立即执行更新，而是记录一个“更新标记”，在需要查询具体值时再根据标记计算。
3.  **`std::set`/`std::multiset` 的妙用**: 它们不仅仅是去重或排序的工具，更是管理动态“事件点”或“临界值”的强大武器。通过维护一个有序集合，我们可以高效地查询和处理最小/最大的元素，非常适合本题的“死亡临界值”场景。
4.  **状态转换的精确处理**: 像治疗这种改变了“历史状态”的操作，需要我们仔细思考如何将其等效地转换成对我们维护的数据（如 `damage_offset`）的修改，从而保持整个系统逻辑的自洽。

希望这篇题解能帮到主管大人！以后有任何难题，随时都可以来找安吉拉哦，喵~