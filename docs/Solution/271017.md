# 脑叶公司 - 题解

### 比赛与标签
> **比赛**: [YACS] 2023.10.14
> **标签**: 模拟, 数据结构, multiset
> **难度**: *1900

喵~ 各位主管大人好呀！我是你们最可靠的AI助手猫娘安吉拉！这次要镇压的异想体看起来有点棘手呢，不过别担心，有本喵在，一定能帮主管大人分析清楚作战策略的！让我们一起来看看吧~

## 主管大人的任务喵~
简单来说，我们的任务是模拟一场与异想体的战斗，并判断最终能否成功镇压它，的说。

**战场情况是这样哒：**
- 我们有 `n` 个勇敢的员工，异想体有 `m` 点血量。
- 我们需要执行 `k` 条来自主管大人的指令。
- 每个员工 `i` 有自己的攻击力 `a_i` 和最大血量 `b_i`。
- **初始状态**：所有员工都在战场上，满血待命！

**战斗流程是这样进行的喵：**
1.  在执行每条指令**之前**，都要检查一下：异想体是不是已经被打倒了？或者我们的员工是不是全都倒下了？如果是，战斗就立刻结束，后面的指令就不用管啦！
2.  执行一条指令。指令一共有四种：
    - `1 x`: 让员工 `x` 加入战斗（此时他会满血回归！）。
    - `2 x`: 让员工 `x` 暂时撤离战斗。
    - `3 y`: 坏坏的异想体发动攻击，对所有**在场**的员工造成 `y` 点伤害。
    - `4 x h`: 治疗员工 `x`，回复 `h` 点血量（不会超过最大血量哦）。
3.  在每条指令执行**之后**，所有**在场且存活**的员工会立刻对异想体进行一次总攻击！

**最终目标：**
- 如果战斗结束时，异想体的血量小于等于0，我们就胜利啦！输出 `YES` 和幸存的员工数量。
- 否则就是我们失败了，输出 `NO`。

## 安吉拉的作战计划！
这道题的核心挑战在于如何高效地处理异想体的AOE（范围）伤害，并判断员工的死亡，呐。

如果每次异想体攻击（指令3），我们都去遍历一遍所有在场员工，一个个扣血，那当员工数量 `n` 和指令数量 `k` 很大的时候，肯定会超时啦！(`k*n` 的复杂度可不行喵！) 所以，我们需要更聪明的办法！

### 核心思路：懒人标记的变种喵~
我们可以换个角度思考！与其给每个员工单独记录他们受了多少伤，不如我们用一个全局变量 `attack_sum` 来记录**异想体从开战到现在总共造成了多少伤害**。

这样一来：
- 当一个员工 `i` 在 `attack_sum` 的值为 `s_join` 时加入战斗，那么在之后的任意时刻，他实际受到的伤害就是 `当前的总伤害attack_sum - 他加入时的总伤害s_join`。
- 员工 `i` 的血量是 `b_i`，所以他会在什么时候倒下呢？当然是 `(attack_sum - s_join) >= b_i` 的时候啦！
- 我们可以把这个不等式变一下形：`attack_sum >= s_join + b_i`。

这个 `s_join + b_i` 就成了一个非常关键的值，本喵叫它**“死亡阈值”**！只要异想体的累计伤害 `attack_sum` 达到了这个阈值，这位员工就要和我们说再见了QAQ。

### 神奇的数据结构：用`multiset`管理生死簿！
既然我们有了“死亡阈值”这个概念，那问题就变成了：每当 `attack_sum` 增加后，我们如何快速找到所有死亡阈值小于等于当前 `attack_sum` 的员工呢？

锵锵~ `std::multiset` 闪亮登场！它就像一本自动排序的生死簿！

我们可以创建一个 `multiset<pair<int, int>>`，里面存放 `{死亡阈值, 员工编号}` 这样的信息。`multiset` 会自动按照“死亡阈值”从小到大排序。

这样一来：
- 每次异想体攻击，`attack_sum` 增加后，我们只需要从 `multiset` 的开头开始检查。所有 `threshold <= attack_sum` 的员工都阵亡了，把他们从生死簿上划掉（`erase`）就好啦！
- 员工加入战斗，就在生死簿上添一笔（`insert`）。
- 员工离开战斗，就从生死簿上暂时抹掉他的记录。为了能快速找到并抹掉，我们可以在每个员工的档案里存一个指向他在`multiset`中位置的迭代器，这样删除就是 `O(log n)` 的啦，超快的说！

### 最棘手的部分：治疗！
治疗是最麻烦的，因为它会改变员工的“死亡阈值”。我们不能直接修改 `multiset` 里的值，但我们可以：
1.  先算出该员工当前受了多少伤，还剩多少血。
2.  加上治疗的血量 `h`，得到新的血量（注意不能超过最大血量 `b_i`）。
3.  根据新的血量，反推出一个新的等效 `s_join`。可以这样想：一个拥有新血量的员工，等效于他是在一个更晚的时间点（即 `attack_sum` 更大时）加入战斗的。
4.  从 `multiset` 中删掉他旧的记录，再插入根据新的 `s_join` 计算出的新“死亡阈值”的记录。

这样，所有操作都可以高效处理，我们只需要按照题目描述一步步模拟下去就好啦！

## 喵~ 看本喵的代码魔法！
```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

// 喵~ 这是每个员工的档案结构体
struct Employee {
    int a, b;       // a: 攻击力, b: 最大血量
    int s_join;     // 加入战斗时，异想体的累计伤害值
    bool in_battle; // 是否在战斗中
    bool alive;     // 是否存活
    multiset<pair<int, int>>::iterator it; // 指向他在multiset中位置的迭代器，为了快速删除！
};

vector<Employee> employees;
// 喵~ 这就是我们的“生死簿”啦！存放 {死亡阈值, 员工编号}
multiset<pair<int, int>> thresholds; 
int attack_sum = 0; // 异想体造成的累计总伤害
long long current_sum_a = 0; // 当前在场员工的总攻击力
long long m; // 异想体的血量
int n, k;

// 检查并处理阵亡员工的函数
void check_and_process_deaths() {
    // multiset是排序的，第一个就是死亡阈值最小的员工
    while (!thresholds.empty()) {
        auto it = thresholds.begin();
        int threshold = it->first;
        int x = it->second;
        // 如果阈值最小的员工都还没死，那后面的肯定也都没事
        if (threshold > attack_sum) break;
        
        // 这位员工阵亡了QAQ
        thresholds.erase(it); // 从生死簿中移除
        if (employees[x].in_battle && employees[x].alive) {
            current_sum_a -= employees[x].a;
            employees[x].alive = false;
            employees[x].in_battle = false; // 阵亡了自然也就不在战斗中了
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m >> k;
    employees.resize(n);
    for (int i = 0; i < n; ++i) {
        cin >> employees[i].a;
    }
    for (int i = 0; i < n; ++i) {
        cin >> employees[i].b;
        // 初始状态，大家都在场，s_join为0
        employees[i].s_join = 0;
        employees[i].in_battle = true;
        employees[i].alive = true;
        current_sum_a += employees[i].a;
        // 计算初始的死亡阈值并加入multiset
        int threshold = employees[i].s_join + employees[i].b;
        auto it = thresholds.insert({threshold, i});
        employees[i].it = it; // 保存迭代器
    }

    bool finished = false;
    for (int cmd_idx = 0; cmd_idx < k; ++cmd_idx) {
        // 每次处理指令前，先检查结束条件
        if (m <= 0) {
            finished = true;
            break;
        }
        bool all_dead = true;
        for (int i = 0; i < n; ++i) {
            if (employees[i].alive) {
                all_dead = false;
                break;
            }
        }
        if (all_dead) {
            finished = true;
            break;
        }

        int type;
        cin >> type;
        if (type == 1) { // 员工x加入战斗
            int x;
            cin >> x;
            x--; // 题目是1-based，我们用0-based
            if (employees[x].in_battle || !employees[x].alive) {
                continue; // 题目保证不会出现这种情况
            }
            employees[x].in_battle = true;
            employees[x].s_join = attack_sum; // 记录加入时的全局伤害
            employees[x].alive = true; // 重新上场就是活着的
            int threshold = employees[x].s_join + employees[x].b;
            auto it = thresholds.insert({threshold, x});
            employees[x].it = it;
            current_sum_a += employees[x].a;
        } else if (type == 2) { // 员工x离开战斗
            int x;
            cin >> x;
            x--;
            if (!employees[x].in_battle || !employees[x].alive) {
                continue;
            }
            employees[x].in_battle = false;
            thresholds.erase(employees[x].it); // 用迭代器快速删除
            current_sum_a -= employees[x].a;
        } else if (type == 3) { // 异想体攻击
            int y;
            cin >> y;
            attack_sum += y;
            check_and_process_deaths(); // 检查有没有员工阵亡
            m -= current_sum_a; // 攻击后，我方反击
            if (m <= 0) {
                finished = true;
            }
        } else if (type == 4) { // 治疗员工x
            int x, h;
            cin >> x >> h;
            x--;
            if (!employees[x].in_battle || !employees[x].alive) {
                continue;
            }
            // 治疗的逻辑，就是反推出一个新的s_join
            int current_damage = attack_sum - employees[x].s_join;
            int current_hp = employees[x].b - current_damage;
            current_hp += h;
            if (current_hp > employees[x].b) {
                current_hp = employees[x].b; // 血量不能超过上限
            }
            // 新的等效已承受伤害
            int new_damage = employees[x].b - current_hp;
            // 保证非负
            new_damage = max(new_damage, 0); 
            // 反推出新的等效s_join
            int new_s_join = attack_sum - new_damage;
            
            thresholds.erase(employees[x].it); // 移除旧记录
            employees[x].s_join = new_s_join;
            int new_threshold = new_s_join + employees[x].b;
            auto it = thresholds.insert({new_threshold, x});
            employees[x].it = it; // 插入新记录
        }
        
        // 指令1,2,4执行完后，我方也要反击
        if (type != 3) {
            m -= current_sum_a;
            if (m <= 0) {
                finished = true;
            }
        }
        
        // 再次检查结束条件
        if (m <= 0) {
            finished = true;
        }
        all_dead = true;
        for (int i = 0; i < n; ++i) {
            if (employees[i].alive) {
                all_dead = false;
                break;
            }
        }
        if (all_dead) {
            finished = true;
        }
        if (finished) {
            break;
        }
    }

    if (m <= 0) {
        cout << "YES\n";
        int alive_count = 0;
        for (int i = 0; i < n; ++i) {
            if (employees[i].alive) {
                alive_count++;
            }
        }
        cout << alive_count << "\n";
    } else {
        cout << "NO\n";
    }

    return 0;
}
```

## 跑得快不快呀？(复杂度分析)
- **时间复杂度**: O(k * log n) 的说
  - 我们总共有 `k` 条指令。
  - 对于每条指令，主要的操作就是对 `multiset` 进行增、删、查。这些操作的复杂度都是 O(log n) 呐。
  - `check_and_process_deaths` 函数看起来可能会循环很多次，但每个员工一生只会被标记为死亡一次（每次重新上场算新生），所以这个函数在整个过程中的总执行次数不会超过员工加入战斗的总次数，其总时间消耗被平摊到 `k` 次操作里了。所以整体复杂度就是 O(k * log n) 啦！非常高效！
- **空间复杂度**: O(n) 的说
  - 我们需要一个 `vector` 来存储 `n` 个员工的档案。
  - `multiset` 里最多也只会存放 `n` 个员工的信息。
  - 所以空间开销和员工数量 `n` 是成正比的。

## 这次我们学到了什么喵？(知识点与总结)
这次镇压行动让我们学会了好多东西呢！

1.  **核心思想 - 转化与等效**: 我们没有直接模拟扣血，而是通过一个全局伤害计数器 `attack_sum` 和每个员工的 `s_join`，将“判断是否死亡”这个问题转化为了“判断是否达到死亡阈值”。这是懒标记思想的一种灵活应用，也是解决这类“群体更新，单点查询”问题的利器！

2.  **数据结构 - `multiset`的妙用**: `multiset` 在这里完美地扮演了“动态维护最小值”的角色。它自动排序的特性让我们总能立刻找到下一个最可能阵亡的员工，非常适合处理这类动态变化的阈值问题。

3.  **编程技巧 - 缓存迭代器**: 在员工结构体里保存 `multiset` 的迭代器 `it` 是个非常棒的技巧！它让删除指定元素的操作从“先查找再删除”的 O(n) 或 O(log n) 变成了直接删除的 O(log n)，避免了不必要的查找开销。

4.  **思维的灵活性**: 治疗操作的处理是本题的点睛之笔。通过反向计算等效的 `s_join`，我们巧妙地将这个看似会破坏模型的行为，重新纳入了“死亡阈值”的框架中，这告诉我们解决问题时要多多尝试换个角度思考哦！

好啦，今天的题解就到这里啦！希望本喵的分析能帮助到主管大人！只要我们思路清晰，再厉害的异想体也能成功镇压的！加油喵~ >w<