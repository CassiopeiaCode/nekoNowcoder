# Wakey Wakey - 题解

### 标签与难度
> **标签**: 思维题, 构造, 组合计数, 脑筋急转弯, 入门

> **难度**: 900

## 题目大意喵~

各位算法大师们，下午好喵~！今天我们来看一道名为 "Wakey Wakey" 的可爱题目！

题目的意思是这样哒：
1.  首先，定义了一个叫做**绝对众数**的东西。在一个序列里，如果某个数字出现的次数**严格大于**序列长度的一半，那它就是这个序列的绝对众数。比如说，在 `[1, 2, 1, 3, 1]` 这个长度为 5 的序列里，`1` 出现了 3 次，因为 $3 > 5/2 = 2.5$，所以 `1` 就是绝对众数。但是 `[1, 2, 1, 2, 3]` 就没有绝对众数啦。

2.  接着，定义了一种**好的序列**。如果一个序列的**任意一个连续子区间**都存在绝对众数，那么这个序列就是“好的”。

我们的任务就是：给定序列的长度 $n$ 和序列中每个数可以取的范围 $[1, m]$，计算一共有多少种不同的“好的序列”？最后结果要对一个质数 $p$ 取模，喵~

## 解题思路分析

喵哈哈~ 这道题看起来好像要用什么高深的动态规划或者数据结构，对吧？但其实，它是一只伪装成大老虎的温柔小猫咪哦！只要我们从最简单的情况入手，就能发现它的秘密啦！

一个序列是“好的”，意味着它的**所有**子区间都要满足条件。这个“所有”就是解题的关键所在，它是一个非常强的约束条件！当一个条件对所有情况都成立时，我们通常可以找一个最苛刻、最简单的特例来分析，如果连这个特例都能满足，那问题就简单多啦。

那么，对于一个序列，什么样的子区间是最简单、最具有约束性的呢？当然是长度最短的那些啦！

#### 1. 考虑长度为 1 的子区间

任何长度为 1 的子区间，比如 `[a_i]`，它本身就是自己的绝对众数，因为它的出现次数是 1，而 $1 > 1/2$。所以，长度为 1 的子区间总是满足条件的，这个对我们没什么帮助，喵~

#### 2. 考虑长度为 2 的子区间！

这才是关键的一步！我们来看看任意一个长度为 2 的子区间，比如序列中相邻的两个元素 `[a_i, a_{i+1}]`。

这个子区间的长度是 2。要让它存在绝对众数，那个数出现的次数必须严格大于 $2/2 = 1$，也就是说，至少要出现 2 次。

在一个只有两个元素的区间里，要让某个数出现 2 次，那这两个元素必须得是同一个数呀！也就是说，必须满足 $a_i = a_{i+1}$。

因为题目要求**任意**子区间都满足条件，所以这个结论必须对序列中**所有**相邻的元素都成立。
也就是说：
- `[a_1, a_2]` 这个子区间要求 $a_1 = a_2$。
- `[a_2, a_3]` 这个子区间要求 $a_2 = a_3$。
- ...
- `[a_{n-1}, a_n]` 这个子区间要求 $a_{n-1} = a_n$。

把这些条件串起来，我们就能得出一个惊人的结论：
$$
a_1 = a_2 = a_3 = \dots = a_n
$$
原来，一个序列要想成为“好的序列”（当 $n>1$ 时），它的所有元素都必须是相同的！

#### 3. 验证我们的猜想

我们已经推断出，一个“好的序列”的所有元素都必须相同。那么反过来，一个所有元素都相同的序列，它一定是“好的”吗？

假设有一个序列 $A = (k, k, k, \dots, k)$，长度为 $n$。我们随便取一个它的子区间，设长度为 $L$。这个子区间里全都是 $k$，`k` 出现了 $L$ 次。因为 $L$ 总是严格大于 $L/2$（只要 $L \ge 1$），所以 $k$ 永远是这个子区间的绝对众数。
所以，我们的猜想是正确的！

#### 4. 特殊情况 n=1

当 $n=1$ 时，序列只有一个元素 `[a_1]`。它唯一的子区间就是它自己，我们已经分析过，这种情况总是满足条件的。所以任何长度为 1 的序列都是“好的”。

#### 5. 最终结论

综合一下：
- 如果 $n=1$，任何长度为 1 的序列都是“好的”。
- 如果 $n>1$，只有所有元素都相同的序列才是“好的”。

咦？这两种情况的结论不是一样的嘛！无论 $n$ 是多少，一个序列是“好的”当且仅当它的所有元素都相同。

那么，要构造一个这样的序列，我们只需要决定这个公共的元素是什么就好啦。题目说元素的值域是 $[1, m]$，所以这个公共元素可以是从 1 到 $m$ 的任意一个整数。

所以，可能的“好的序列”有：
- $(1, 1, \dots, 1)$
- $(2, 2, \dots, 2)$
- ...
- $(m, m, \dots, m)$

总共有 $m$ 种方案！题目中的 $n$ 和 $p$（除了用于取模）其实都是烟雾弹呢，喵~

所以，答案就是 $m \pmod p$。

## 代码实现

这是我根据上面的思路，全新编写的代码哦！逻辑非常清晰，希望能帮到你，喵~

```cpp
#include <iostream>

// 为了让代码更清晰，我们把每个测试用例的逻辑封装成一个函数
void solve() {
    long long n, m, p;
    // 读入序列长度 n，值域 m 和模数 p
    std::cin >> n >> m >> p;

    // 根据我们的分析，一个序列是“好的”，当且仅当它的所有元素都相等。
    // 这样的序列只由这个公共元素决定。
    // 公共元素可以取 1, 2, ..., m，共 m 种选择。
    // 因此，总方案数就是 m。
    // 题目要求对 p 取模。
    // 注意，n 的值对方案数没有影响。

    long long result = m % p;
    std::cout << result << std::endl;
}

int main() {
    // 设置cin和cout，让输入输出更快一些，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t; // 测试用例的数量
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(T)$
  对于每个测试用例，我们只进行了几次读写和一次取模运算，这些都是常数时间的操作。如果有 $T$ 个测试用例，总时间复杂度就是 $O(T)$，非常快！

- **空间复杂度**: $O(1)$
  我们在每个测试用例中只使用了几个变量来存储 $n, m, p$ 等，没有使用任何随输入规模增大的额外空间，所以空间复杂度是 $O(1)$。

## 知识点总结

这道题虽然披着组合计数的外衣，但核心是一个**思维题**。它教会了我们一个重要的解题技巧：

当一个问题包含一个**全称量词**（比如“对于**所有**子区间”、“对于**任意**元素”）时，可以尝试从最简单、最受限制的特例入手。通过分析这些特例，我们往往能发现问题的本质，从而大大简化问题。

在本题中，这个特例就是**长度为 2 的子区间**。正是对它的分析，让我们直接破解了“好的序列”的结构之谜。

所以，下次遇到看起来很复杂的题目，不妨先静下心来，找找看有没有这样的小小突破口吧！加油哦，你一定可以的，喵~！