# 绝对众数 - 题解

### 比赛与标签
> **比赛**: 暂无信息
> **标签**: 暂无信息
> **难度**: 暂无信息

## 题目大意喵~
主人 sama，欢迎来到我的题解小屋呐~ 这道题目是关于一个叫做“好的序列”的东西的说！

首先，题目定义了什么是**绝对众数**：在一个数列里，如果某个数字出现的次数**严格大于**数列长度的一半，那它就是这个数列的绝对众数啦！

然后，又定义了什么是**好的序列**：如果一个序列的**任意一个连续子区间**，都存在一个绝对众数，那么这个序列就是“好的”。

我们的任务就是，给定序列的长度 `n` 和序列中数字的取值范围 `1 ~ m`，计算出一共有多少种不同的“好的序列”方案。最后结果要对一个质数 `p` 取模哦~

## 解题思路喵！
呐，主人，这个问题看起来好像很复杂的样子，要检查一个序列的 *所有* 子区间，感觉会很麻烦呢！(๑•́ ₃ •̀๑) 但是别怕，我们来找找突破口喵~

这种要求对“所有子区间”都成立的题目，通常都有一个很强的隐藏性质。我们可以从最短、最简单的子区间入手，看看能发现什么秘密！

长度为 1 的子区间 `[a_i]` 肯定满足条件啦，因为唯一的那个数字 `a_i` 出现了 1 次，严格大于区间长度 1 的一半（也就是 0.5），所以它自己就是绝对众数。

那么，我们来考虑一下**长度为 2** 的子区间，比如 `[a_i, a_{i+1}]`。
这个区间的长度是 2。根据定义，它的绝对众数出现的次数必须严格大于 `2 / 2 = 1` 次，也就是说，至少要出现 2 次才行！
在一个只有两个元素的区间里，要有一个数出现 2 次，那只有一种可能，就是这两个数必须是相等的呀！也就是 `a_i = a_{i+1}`。

这个结论太关键了！因为题目要求**所有**子区间都要满足条件，所以这个结论必须对**所有相邻**的两个数都成立。
也就是说：
`a[1]` 必须等于 `a[2]`
`a[2]` 必须等于 `a[3]`
...
`a[n-1]` 必须等于 `a[n]`

通过这个简单的推理，我们得出了一个惊人的结论：**一个序列是“好的序列”，当且仅当这个序列里所有的元素都完全相同！** 比如 `[c, c, c, ..., c]` 这样的形式。

我们来验证一下这个结论对不对。如果一个序列所有元素都是 `c`，那么它的任何一个子区间也必然全都是 `c`。在这个子区间里，`c` 的出现次数就是区间的长度，这当然严格大于区间长度的一半啦！所以我们的结论是正确的，喵~

问题一下子就变得超级简单了！我们只需要计算有多少种“所有元素都相同”的序列。
序列的长度是 `n`，元素的取值范围是 `1` 到 `m`。
我们可以让序列的所有元素都等于 `1`，得到 `[1, 1, ..., 1]`。
也可以让它们都等于 `2`，得到 `[2, 2, ..., 2]`。
...
一直到都等于 `m`，得到 `[m, m, ..., m]`。

总共有多少种选择呢？很明显，就是 `m` 种啦！

所以，无论 `n` 是多少（只要 `n >= 1`），满足条件的“好的序列”都只有 `m` 种。
最后，根据题目要求对 `p` 取模，答案就是 `m % p`。

## 代码实现喵~
```cpp
#include<bits/stdc++.h>
using namespace std;

// 当 n > 1 时，我们考察任意一个长度为 2 的子区间 [a_i, a_{i+1}]。
// 它的绝对众数出现次数必须严格大于 2/2 = 1，这意味着必须有某个数出现至少 2 次。
// 在这个区间里，只有 a_i 和 a_{i+1} 两个数，所以唯一的可能性就是 a_i == a_{i+1}。
// 因为这个条件对所有相邻的元素都成立，所以整个序列的所有数字必须都相等！
//
// 当 n == 1 时，序列 [a_1] 只有一个子区间，就是它本身。
// a_1 出现 1 次，大于长度 1 的一半 (0.5)，满足条件。
// 所以任何长度为 1 的序列都是好的，这也符合“所有元素都相等”的结论。
//
// 综上所述，一个序列是“好的”，当且仅当所有元素都相等。
// 元素的取值范围是 1 到 m，所以我们有 m 种选择（全选1，或全选2，...，或全选m）。
// 因此，方案数就是 m。

int main(){
    int t, n, m, p;
    // t 是测试用例的数量
    cin >> t;
    for(int i = 0; i < t; i++){
        // n 是序列长度, m 是数值范围, p 是模数
        cin >> n >> m >> p;
        
        // 根据我们的推导，答案就是 m，与 n 无关。
        // 最后对 p 取模即可。
        cout << m % p << endl;
    }
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(T) 的说。这里 `T` 是测试用例的数量。对于每一个测试用例，我们都只进行了常数时间的读入和输出操作，所以总的时间复杂度和测试用例的数量成正比。
- **空间复杂度**: O(1) 的说。我们只使用了几个变量来存储输入的 `t, n, m, p`，没有使用额外的数组或者数据结构，所以空间消耗是常数级别的。

## 知识点与总结喵~
这道题虽然看起来有点唬人，但其实是个可爱的纸老虎呢！它教会了我们一个重要的解题技巧：

1.  **从最简情况入手**：当题目条件非常强（比如“对所有子区间都成立”）时，尝试分析最小、最简单的实例（比如长度为2的子区间），往往能发现问题的突破口。
2.  **化繁为简**：通过严谨的推理，我们将一个看似复杂的组合计数问题，转化成了一个非常简单的计数问题。这是算法竞赛中非常核心的一种思维方式哦！
3.  **识别无关变量**：在分析之后，我们发现序列的长度 `n` 对最终的答案没有影响（只要 `n>=1`）。在解题时要敢于相信自己的推论，不要被输入中所有变量都迷惑啦。

希望这篇题解能帮助到主人 sama！下次遇到类似的题目，也要像小猫咪一样，敏锐地抓住问题的关键点哦！加油喵~ (ฅ'ω'ฅ)