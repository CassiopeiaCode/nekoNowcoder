# 好的序列 - 题解

### 比赛与标签
> **比赛**: 信息未提供

> **标签**: 思维, 计数

> **难度**: *800

## 题目大意喵~

主人你好呀，这道题是关于一种叫做“好的序列”的计数问题，喵~

首先，题目定义了一个概念叫**绝对众数**：在一个数字集合里，如果某个数字的出现次数**严格大于**总数的一半，那它就是这个集合的绝对众数。比如说，在 `[1, 2, 1, 1, 3]` 这个长度为5的集合里，`1` 出现了3次，因为 $3 > 5/2 = 2.5$，所以 `1` 就是绝对众数。但是在 `[1, 2, 1, 3, 4]` 里，`1` 出现了2次，不满足 $2 > 5/2$，所以这个集合没有绝对众数哦。

然后，题目又定义了什么是**好的序列**：一个序列被称为“好的”，当且仅当它的**任意一个连续子区间**都存在绝对众数。

我们的任务就是：给定序列的长度 $n$ 和序列中每个数可以取的范围 $[1, m]$，计算一共有多少种不同的“好的序列”。最后结果要对一个质数 $p$ 取模，呐。

举个例子：如果 $n=3, m=2$，序列 `[1, 1, 1]` 就是一个好的序列。它的子区间有 `[1]`, `[1]`, `[1]`, `[1, 1]`, `[1, 1]`, `[1, 1, 1]`。它们各自的绝对众数都是 `1`。但是 `[1, 2, 1]` 就不是好的序列，因为它的子区间 `[1, 2] 就没有绝对众数呢。

## 解题思路分析

这道题的限制条件看起来非常强呢，喵~ 它要求**所有**的子区间都满足条件。当一个条件对“所有”子集/子区间生效时，我们通常可以从最小、最简单的子情况入手，看看能发现什么规律！

我们来考虑一个长度为 $n$ 的序列 $A = [a_1, a_2, \dots, a_n]$。

1.  **最短的子区间：长度为 1**
    任何一个长度为 1 的子区间，比如 $[a_i]$，它本身就是唯一的元素，出现了 1 次。因为 $1 > 1/2$，所以 $a_i$ 永远是这个子区间的绝对众数。这个条件对我们没有任何帮助，太宽松啦。

2.  **再短一点的子区间：长度为 2**
    这才是关键所在，喵！让我们看看任意一个相邻的对，比如子区间 $[a_i, a_{i+1}]$。这个子区间的长度是 2。
    要让它存在绝对众数，那么某个数的出现次数必须严格大于 $2/2 = 1$。也就是说，至少要出现 2 次。
    在这个只有两个元素的区间里，要让一个数出现 2 次，那这两个元素必须是相同的呀！所以，我们得出了一个惊人的结论：
    $$
    a_i = a_{i+1}
    $$
    这个结论必须对所有 $i$ (从 $1$ 到 $n-1$) 都成立，因为题目要求**任意**子区间都满足条件，当然也包括了所有长度为 2 的子区间。

3.  **推广到整个序列**
    既然我们知道了 $a_1$ 必须等于 $a_2$ (来自区间 $[a_1, a_2]$)，$a_2$ 必须等于 $a_3$ (来自区间 $[a_2, a_3]$)，以此类推，直到 $a_{n-1}$ 必须等于 $a_n$ (来自区间 $[a_{n-1}, a_n]$)，那么通过传递性，我们就能得到：
    $$
    a_1 = a_2 = a_3 = \dots = a_n
    $$
    这意味着，一个序列要想成为“好的序列”，它内部的所有元素都必须是相同的！比如说 [c, c, c, ..., c]` 这种形式。

4.  **验证我们的猜想**
    如果一个序列所有元素都相同，比如都是 $c$，那它是不是“好的序列”呢？
    我们取它的任意一个子区间，这个子区间的所有元素也必然都是 $c$。假设子区间长度为 $L$，那么 $c$ 在其中出现了 $L$ 次。
    绝对众数的条件是出现次数 > $L/2$。
    这里 $c$ 出现了 $L$ 次，而 $L > L/2$ (只要 $L>0$ 就成立)。所以，条件满足！
    这说明我们的猜想是正确的！一个序列是“好的”，当且仅当它的所有元素都相同。

5.  **特殊情况：$n=1$**
    如果序列长度 $n=1$，比如 $[a_1]$。它唯一的子区间就是它自己。我们已经分析过，长度为 1 的区间总是有绝对众数的。所以任何长度为 1 的序列都是“好的”。

6.  **开始计数！**
    - 当 $n > 1$ 时，好的序列必须是 `[c, c, ..., c] 的形式。我们可以选择的数字 $c$ 的范围是 $1 \sim m$。所以，我们可以让所有元素都是 1，或者都是 2，...，或者都是 $m$。总共有 $m$ 种选择，也就对应了 $m$ 个好的序列。
    - 当 $n = 1$ 时，任何序列 [c] 都是好的。$c$ 的取值范围是 $1 \sim m$。所以也有 $m$ 种选择，对应 $m$ 个好的序列。

综上所述，无论 $n$ 是多少（只要 $n \ge 1$），满足条件的“好的序列”的数量都正好是 $m$ 种！

所以，这道题的答案就是 $m$。因为要对 $p$ 取模，所以最终答案是 $m \pmod p$。是不是感觉一下子清晰起来了，喵~

## 代码实现

这是本猫娘根据上面的思路，全新编写的代码哦！逻辑非常简单，希望能帮到你，喵~

``cpp
#include <iostream>

// 为了让代码更清晰，我们把每个测试用例的处理逻辑放到一个函数里
void solve() {
    // 使用 long long 是个好习惯，可以避免一些不必要的整数溢出问题，喵~
    long long n, m, p;
    std::cin >> n >> m >> p;

    // 根据我们的分析，无论 n 是多少，
    // “好的序列”的数量都等于可选数字的种类数 m。
    // 比如，序列可以是 [1, 1, ..., 1], [2, 2, ..., 2], ..., [m, m, ..., m]。
    // 总共有 m 种这样的序列。
    
    // 题目要求结果对 p 取模。
    long long ans = m % p;
    
    std::cout << ans << std::endl;
}

int main() {
    // 为了更快的输入输出，可以加上这两行
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t; // 测试用例的数量
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(T)$
  对于每个测试用例，我们只执行了常数次的读写和取模操作，所以每个测试用例的时间复杂度是 $O(1)$。总共有 $T$ 个测试用例，所以总时间复杂度是 $O(T)$，非常快呢！

- **空间复杂度**: $O(1)$
  我们在解决每个测试用例时，只使用了几个变量来存储 $n, m, p$ 和答案，没有使用任何随输入规模增大的额外空间。所以空间复杂度是 $O(1)$，非常节省内存的说。

## 知识点总结

这道题虽然看起来有点唬人，但其实是个可爱的纸老虎，喵~ 我们可以从中学到：

1.  **从最简情况入手**：当一个问题的约束条件非常强（比如“对所有子区间”），尝试分析最小、最简单的子情况（比如长度为 2 的子区间）往往能找到突破口。
2.  **局部性质推导全局性质**：我们从“任意相邻两元素必须相等”这个局部性质，推导出了“整个序列所有元素必须相等”的全局性质。这是一种很重要的思维方式。
3.  **化繁为简**：通过逻辑推导，我们把一个复杂的组合计数问题，简化成了一个非常简单的计数问题。找到问题的本质是解题的关键！

希望这篇题解能帮助到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，喵~