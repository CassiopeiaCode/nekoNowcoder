# 占星 - 题解

### 标签与难度
> **标签**: 组合数学, 计算几何, 数论, 模运算, 快速幂, 贪心
> **难度**: 2000

## 题目大意喵~

nya-ha~！各位看过来喵~！伟大的占星术士莫娜小姐姐遇到了点小麻烦，需要我们帮忙的说！

是这样的：她有一个 $n$ 边的凸多边形星盘。为了占卜得更准，她本来想把星盘上**所有**的对角线都画出来。但因为摩拉（就是钱啦！）不够，她必须少画 $k$ 条对角线。

现在莫娜想知道，为了让划分出的区域数量**最多**，她该选择不画哪 $k$ 条对角线呢？以及，这个最多的区域数量是多少呢？

因为 $n$ 可能会非常非常大，所以结果需要对 $10^9 + 7$ 取模哦！

## 解题思路分析

主人，这个问题看起来是要我们在星盘上画画然后数格子呢，喵~ 但直接数肯定是不行的，这里面可藏着有趣的数学小秘密哦！让本猫娘来一步步带你解开它吧！

### Step 1: 如果摩拉管够，能画多少个区域？ (k=0 的情况)

我们先来解决一个理想情况：假如莫娜的摩拉是无限的，她画上了所有的对角线，最多能把星盘分成多少个区域呢？

这是一个经典的组合几何问题，有一个非常优美的公式，喵~
$$
\text{区域数量} = 1 + D + I
$$
这里的 $D$ 是对角线的总数，$I$ 是星盘内部对角线的交点总数。

这个公式可以这样理解，喵：
1.  最开始，没有画任何对角线时，整个多边形是 **1** 个区域。
2.  每画一条对角线，它自身会把一个区域分成两个，区域数+1。所以画完所有 $D$ 条对角线，至少会增加 $D$ 个区域。
3.  此外，如果一条新的对角线穿过了已经存在的交点，它每穿过一个交点，就会多分割出一个区域。所以，总共会因为交点多出 $I$ 个区域。

所以，我们只需要求出 $D$ 和 $I$ 就好啦！

*   **对角线数量 (D)**:
    一个 $n$ 边形有 $n$ 个顶点。任意两个顶点可以连成一条线段，总共有 $\binom{n}{2}$ 条。但这其中包含了 $n$ 条边，所以对角线数量是：
    $$
    D = \binom{n}{2} - n = \frac{n(n-1)}{2} - n = \frac{n(n-3)}{2}
    $$

*   **交点数量 (I)**:
    星盘内部的每一个交点，都是由两条不同的对角线相交产生的。这两条对角线又是由四个不同的顶点确定的。反过来说，只要我们在 $n$ 个顶点中任意选择四个，这四个顶点有且仅有一种方式可以连接成两条在内部相交的对角线。所以，交点的数量就等于从 $n$ 个顶点中选出 4 个的组合数：
    $$
    I = \binom{n}{4} = \frac{n(n-1)(n-2)(n-3)}{24}
    $$
    （这里我们遵循题目的一个隐含假设：没有三条或更多对角线交于同一点）

好啦，把它们代入公式，所有对角线都画上时，区域总数 $R_{\text{max}}$ 就是：
$$
R_{\text{max}}(n) = 1 + \frac{n(n-3)}{2} + \frac{n(n-1)(n-2)(n-3)}{24}
$$

### Step 2: 怎么搞破坏才能损失最小？ (k>0 的情况)

现在莫娜要少画 $k$ 条对角线了。为了让最终区域数最多，我们得反过来想：应该选择移除哪 $k$ 条对角线，才能让**损失的区域数量最少**，对吧？

从我们的公式 $R = 1 + D + I$ 出发，每移除一条对角线 $d$，对角线总数 $D$ 会减 1。同时，这条对角线上的所有交点也跟着消失了，这会导致交点总数 $I$ 减少。

移除一条对角线 $d$ 所损失的区域数，等于 $1 + (\text{它与其他对角线的交点数})$。

所以，我们的贪心策略就很明确了：**优先移除那些与其他对角线交点最少的对角线**！

### Step 3: 找到那些“最不重要”的对角线

哪种对角线的交点最少呢？直觉上，肯定是连接“相邻”顶点的“最短”的对角线啦，喵~

我们来量化一下。一条连接顶点 $v_i$ 和 $v_j$ 的对角线，它把其他 $n-2$ 个顶点分成了两组。假设一组有 $p$ 个顶点，另一组有 $q$ 个顶点（$p+q=n-2$）。那么，这条对角线的交点数就是 $p \times q$。

为了让 $p \times q$ 最小，我们应该让 $p$ 和 $q$ 的值差距尽可能大。对于对角线来说，$p$ 至少是 1。所以最优选择是 $p=1, q=n-3$。
这种情况对应的就是连接 $v_i$ 和 $v_{i+2}$ 的对角线（也就是跳过一个顶点）。这种“最短”的对角线，交点数最少，为 $1 \times (n-3) = n-3$。

所以，我们的最佳策略就是优先移除这些“最短”的对角线！

### Step 4: 精确计算损失了多少区域

好！我们已经确定了要移除的目标：从 $n$ 条“最短”对角线里选 $k$ 条。但事情还没完哦，移除多条对角线时，它们之间可能会有“联动效应”。

我们知道，总损失 = $k + I_{\text{lost}}$，其中 $I_{\text{lost}}$ 是因为移除了这 $k$ 条对角线而消失的交点总数。
根据容斥原理，$I_{\text{lost}} = (\text{这k条线各自的交点数之和}) - (\text{它们内部互相之间的交点数})$。

为了让总损失最小，我们不仅要选交点数少的对角线，还要让它们**内部互相之间的交点数最多**！这样减去的部分就最大，净损失就最小了，喵~

那么，哪些“最短”对角线互相之间有交点呢？
一条对角线 $(v_i, v_{i+2})$ 只会和它的“邻居” $(v_{i-1}, v_{i+1})$ 和 $(v_{i+1}, v_{i+3})$ 相交。
所以，为了最大化内部交点，我们应该选择**连续的 $k$ 条**“最短”对角线来移除！例如 $(v_1, v_3), (v_2, v_4), \dots, (v_k, v_{k+2})$。

现在我们来分情况计算总损失：

1.  **当 $1 \le k < n$ 时**:
    我们移除的 $k$ 条连续的最短对角线形成了一条“链”，它们之间有 $k-1$ 个交点。
    *   $k$ 条线各自的交点数之和 = $k \times (n-3)$
    *   它们内部的交点数 = $k-1$
    *   $I_{\text{lost}} = k(n-3) - (k-1)$
    *   总损失 = $k + I_{\text{lost}} = k + k(n-3) - (k-1) = k(n-3) + 1$

2.  **当 $k=n$ 时**:
    我们移除了所有 $n$ 条最短对角线。它们形成了一个“环”，例如 $(v_1,v_3)$ 和 $(v_n, v_2)$ 也会相交。所以它们内部有 $n$ 个交点。
    *   $n$ 条线各自的交点数之和 = $n \times (n-3)$
    *   它们内部的交点数 = $n$
    *   $I_{\text{lost}} = n(n-3) - n$
    *   总损失 = $n + I_{\text{lost}} = n + n(n-3) - n = n(n-3)$

（题目给的样例和代码实现都暗示我们只用考虑 $k \le n$ 的情况，更复杂的情况就不需要我们这只小猫咪操心啦~）

### Step 5: 最终答案！

把所有东西整合起来，最终的区域数量就是：
$$
\text{最终区域数} = R_{\text{max}}(n) - \text{损失}(k)
$$
其中 $R_{\text{max}}(n)$ 和 $\text{损失}(k)$ 的公式我们都已经推导出来啦！剩下的就是用代码实现，并且注意在计算过程中处理好模运算就大功告成啦，喵~

## 代码实现

这是本猫娘根据上面的思路，为你精心准备的一份代码哦！注释超详细的，快来看看吧~

```cpp
#include <iostream>

// 使用 long long 来防止中间计算过程溢出喵
using ll = long long;

// 模数 P
const int P = 1000000007;

// 快速幂函数，用来计算 a^b % P，处理模逆元时会用到
ll power(ll base, ll exp) {
    ll res = 1;
    base %= P;
    while (exp > 0) {
        if (exp % 2 == 1) {
            res = res * base % P;
        }
        base = base * base % P;
        exp /= 2;
    }
    return res;
}

// 模逆元函数，根据费马小定理，a^(P-2) 是 a 在模 P 下的逆元
ll modInverse(ll n) {
    return power(n, P - 2);
}

// 组合数 C(n, k) % P 的一个特化版本，这里我们只需要 C(n,4) 和 C(n,2)
// 为了防止 n 过大导致 TLE，我们直接计算 N(N-1)...(N-k+1) * (k!)^-1
ll nCr_mod_p(ll n_val, int r) {
    if (r < 0 || r > n_val) {
        return 0;
    }
    if (r == 0 || r == n_val) {
        return 1;
    }
    if (r > n_val / 2) {
        r = n_val - r;
    }

    // 我们只需要 C(n,2), C(n,3), C(n,4)
    // C(n,2) = n(n-1)/2
    // C(n,3) = n(n-1)(n-2)/6
    // C(n,4) = n(n-1)(n-2)(n-3)/24
    
    ll n = n_val % P;
    if (r == 2) {
        ll num = n * (n - 1 + P) % P;
        ll den_inv = modInverse(2);
        return num * den_inv % P;
    }
    if (r == 4) {
        ll num = n * (n - 1 + P) % P * (n - 2 + P) % P * (n - 3 + P) % P;
        ll den_inv = modInverse(24);
        return num * den_inv % P;
    }
    
    // 其他情况本题用不到
    return 0;
}


int main() {
    // 使用 stdio 可能会快一点点哦
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    ll n, k;
    std::cin >> n >> k;

    // 如果 n < 3，无法构成多边形，对角线为0，区域为1
    if (n < 3) {
        std::cout << 1 << std::endl;
        return 0;
    }

    // Step 1: 计算 R_max(n) = 1 + C(n,2)-n + C(n,4)
    // C(n,2)-n 就是对角线数量 n(n-3)/2
    ll N = n % P;
    ll diagonals = (N * (N - 3 + P)) % P * modInverse(2) % P;
    ll intersections = nCr_mod_p(n, 4);
    ll max_regions = (1 + diagonals + intersections) % P;

    // Step 2: 计算损失
    ll loss = 0;
    if (k > 0) {
        if (k < n) {
            // 当 1 <= k < n 时，损失 = k(n-3) + 1
            ll term1 = (k % P * (N - 3 + P)) % P;
            loss = (term1 + 1) % P;
        } else if (k == n) {
            // 当 k = n 时，损失 = n(n-3)
            loss = (N * (N - 3 + P)) % P;
        }
        // 如果 k > n，题目没有明确说明，但根据已有信息，我们只处理 k <= n 的情况
        // 如果 k > n, 比如 k = n+1, 我们移除了所有 n 条最短对角线后，
        // 还要移除一条次短的。这会让逻辑复杂很多，通常这类题目会避免这种情况。
    }

    // Step 3: 计算最终结果
    ll final_regions = (max_regions - loss + P) % P;

    std::cout << final_regions << std::endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(\log P)$
    我们的计算主要包括几次模乘法和几次模逆元运算。模逆元是通过快速幂计算的，其时间复杂度是 $O(\log P)$。因为 $P$ 是一个常数，所以总的时间复杂度可以看作是 $O(1)$ 的，非常快哦，喵~

-   **空间复杂度**: $O(1)$
    我们只使用了几个变量来存储中间结果，没有使用任何与输入 $n$ 大小相关的数组或数据结构，所以空间是恒定的。

## 知识点总结

这道题真是一次有趣的智力挑战呢！它融合了好几个知识点：

1.  **组合几何**: 核心是凸多边形对角线划分区域的公式 $R = 1 + D + I$。记住这个公式，以后遇到类似问题就能迎刃而解啦！
2.  **组合数学**: 计算对角线数 $D$ 和交点数 $I$ 时，用到了组合数 $\binom{n}{k}$ 的思想。
3.  **贪心思想**: 为了最小化损失，我们贪心地选择移除“最不重要”的对角线。分析哪种对角线“最不重要”是解题的关键一步。
4.  **数论与模运算**: 因为 $n$ 很大，所有计算都必须在模 $P$ 的意义下进行。这要求我们熟练掌握模加、减、乘，以及通过费马小定理和快速幂求解模逆元。
5.  **容斥原理**: 在计算移除多条对角线造成的总损失时，我们隐式地使用了容斥原理来处理重叠的交点，这是一个非常强大的计数工具，喵~

希望这篇题解能帮到你哦，主人！如果还有不懂的地方，随时可以再来问我，喵~ >w<