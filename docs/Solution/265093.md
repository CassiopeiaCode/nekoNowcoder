# 给定一个长度为 n 的正整数数组 a 和一个正整数 k。 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供]

> **标签**: 数据结构, 线段树

> **难度**: *2400

## 题目大意喵~

主人你好呀，喵~ 来看这道有趣的题目！(ฅ'ω'ฅ)

题目给了我们一个长度为 $n$ 的正整数数组 $a$ 和一个正整数 $k$。接下来会有 $q$ 次操作，分为两种：

1.  **修改操作 `1 i x`**: 把数组 $a$ 中第 $i$ 个位置的数改成 $x$。
2.  **查询操作 `2 l r`**: 问在数组 $a$ 的区间 $[l, r]$ 内，存不存在一个**长度大于等于2**的连续子数组，它的中位数正好是 $k$ 呢？如果存在就回答 "YES"，否则回答 "NO"。

题目还贴心地解释了中位数的定义：对于一个长度为 $m$ 的数组，把它从小到大排好序，排在第 $\lfloor \frac{m+1}{2} \rfloor$ 个位置的数就是它的中位数啦。

## 解题思路分析

喵~ 这道题看起来又是修改又是查询的，而且还和“中位数”这个有点绕的概念搅在一起，是不是感觉有点头大呀？别怕别怕，让本猫娘带你一步步把它分解成可爱的小猫咪！

#### 步骤一：转化“中位数”条件

首先，我们来研究一下“一个子数组的中位数是 $k$”这个核心条件。这到底意味着什么呢？

根据中位数的定义，一个子数组 $b$ 的中位数是 $k$，必须满足两个前提：
1.  数字 $k$ 必须在子数组 $b$ 中出现过。
2.  在排好序的 $b$ 中，第 $\lfloor \frac{|b|+1}{2} \rfloor$ 个元素是 $k$。

第二个条件有点抽象，我们来把它变得更具体一点。如果排在中间位置的数是 $k$，那就说明，在这个子数组里，小于 $k$ 的数的数量，一定没有大于或等于 $k$ 的数的数量多。

更精确地说，是**大于或等于 $k$ 的数的数量必须严格大于小于 $k$ 的数的数量**。
即 `count(x >= k) > count(x < k)`。

为什么是这样呢？我们可以简单验证一下：
- 设子数组长度为 $m$，count(x >= k) 为 $N_{\ge}$，count(x < k) 为 $N_{<}$。则 $m = N_{\ge} + N_{<}$。
- 如果 $N_{\ge} > N_{<}$，那么 $N_{\ge} \ge N_{<} + 1$。
- 在排序后，前 $N_{<}$ 个数都小于 $k$，第 $N_{<} + 1$ 个数必然大于等于 $k$。
- 中位数的位置是 $p = \lfloor \frac{m+1}{2} \rfloor = \lfloor \frac{N_{\ge} + N_{<} + 1}{2} \rfloor$。
- 因为 $N_{\ge} \ge N_{<} + 1$，所以 $N_{\ge} + N_{<} + 1 \ge (N_{<} + 1) + N_{<} + 1 = 2N_{<} + 2$。
- 于是 $\frac{N_{\ge} + N_{<} + 1}{2} \ge N_{<} + 1$，所以 $p \ge N_{<} + 1$。
- 这意味着中位数的位置落在了大于等于 $k$ 的数当中。再加上第一个条件（子数组中必须有 $k$），就能保证中位数是 $k$ 啦！

#### 步骤二：神奇的数值转化

现在，我们的查询条件变成了：
在区间 $[l, r]$ 中，是否存在一个子数组 $[i, j]$（$l \le i \le j \le r$，且 $j-i+1 \ge 2$），满足：
1.  $a[i..j]$ 中至少有一个 $k$。
2.  在 $a[i..j]$ 中，`count(x >= k) > count(x < k)`。

这个大小比较还是有点麻烦，我们来施展一个魔法，把数组 $a$ 变成一个只包含 $1$ 和 $-1$ 的新数组 $w$：
- 如果 $a_p \ge k$，我们就令 $w_p = 1$。
- 如果 $a_p < k$，我们就令 $w_p = -1$。

这样一来，`count(x >= k) > count(x < k)` 这个条件就等价于子数组对应 $w$ 数组的**区间和大于0**（也就是 $\sum_{p=i}^{j} w_p \ge 1$）。

太棒了！问题被我们简化成了：
**在区间 $[l, r]$ 中，是否存在一个长度至少为2的子数组 $[i, j]$，它既包含至少一个值为 $k$ 的原始元素，其对应的 $w$ 数组的和又大于等于1？**

#### 步骤三：请出我们的好朋友——线段树！

这个问题涉及到单点修改和区间查询，这可是线段树最擅长的工作了，喵！

我们需要设计一个线段树，每个节点维护其对应区间的一些信息，并且这些信息能够被快速地合并。

那么，一个节点需要维护哪些信息呢？
为了判断一个区间内是否存在满足条件的子数组，我们需要考虑三种情况：
1.  满足条件的子数组完全在左子区间内。
2.  满足条件的子数组完全在右子区间内。
3.  满足条件的子数组跨越了左右子区间的边界。

这就启发了我们需要在节点中存储什么信息：
- `found_solution`: 一个布尔值，表示当前区间内是否**已经**找到了一个满足条件的子数组。
- `has_k`: 一个布尔值，表示当前区间是否含有原始值为 $k$ 的元素。
- `total_sum`: 当前区间的 $w$ 数组的和。
- **前缀信息**: 为了处理跨越边界的情况，我们需要知道从区间左端点开始的所有前缀的信息。具体来说，是前缀和的最大值。但别忘了，我们还需要满足“包含 $k$”的条件！所以我们要分别记录：
    - `max_prefix_sum[0]`: 不包含 $k$ 的前缀的最大和。
    - `max_prefix_sum[1]`: 包含 $k$ 的前缀的最大和。
- **后缀信息**: 同理，我们也需要记录后缀的信息：
    - `max_suffix_sum[0]`: 不包含 $k$ 的后缀的最大和。
    - `max_suffix_sum[1]`: 包含 $k$ 的后缀的最大和。

有了这些信息，我们就可以定义如何合并两个子节点（`left` 和 `right`）的信息了：
- `merged.found_solution`: `left.found_solution` 或 `right.found_solution` 或 **跨界组合成功**。
- `merged.has_k`: `left.has_k` 或 `right.has_k`。
- `merged.total_sum`: `left.total_sum + right.total_sum`。
- `merged.max_prefix_sum`: 新的前缀可以是 `left` 的前缀，也可以是整个 `left` 加上 `right` 的一个前缀。我们需要更新 `with_k` 和 `without_k` 两种情况。
- `merged.max_suffix_sum`: 对称地，新的后缀可以是 `right` 的后缀，也可以是 `left` 的一个后缀加上整个 `right`。
- **跨界组合**: 这是最关键的一步！一个 `left` 的后缀和一个 `right` 的前缀可以组成一个新的子数组。我们遍历所有组合（`left`后缀带不带k，`right`前缀带不带k），只要有一种组合能满足“包含k”且“和大于等于1”，我们就成功找到了一个解，可以将 `merged.found_solution` 设为 `true`！

这样，每次修改，我们更新线段树上的一个叶子节点，然后逐层向上合并信息。每次查询，我们查询指定区间的合并后信息，检查它的 `found_solution` 标志位就可以啦！

## 代码实现

这是本猫娘根据上面的思路，精心为你重构的一份代码，注释超详细的哦，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 定义一个足够小的数，表示某个状态不存在
const int INF = 1e9;

// k 是全局的，方便在结构体内部访问
int K_VAL;

// 线段树节点结构体
struct Node {
    // found_solution: 区间内是否已存在满足条件的子数组 (len>=2, has_k, sum>=1)
    bool found_solution;
    // has_k: 区间内是否存在值为 k 的元素
    bool has_k;
    // total_sum: 区间内所有元素的权重和
    int total_sum;
    // max_prefix_sum[0]: 不含k的前缀最大和
    // max_prefix_sum[1]: 包含k的前缀最大和
    int max_prefix_sum[2];
    // max_suffix_sum[0]: 不含k的后缀最大和
    // max_suffix_sum[1]: 包含k的后缀最大和
    int max_suffix_sum[2];

    // 默认构造函数
    Node() : found_solution(false), has_k(false), total_sum(0) {
        max_prefix_sum[0] = max_prefix_sum[1] = -INF;
        max_suffix_sum[0] = max_suffix_sum[1] = -INF;
    }
};

// 合并两个子节点信息的函数
Node merge(const Node& left, const Node& right) {
    Node res;

    // 1. 合并基本信息
    res.total_sum = left.total_sum + right.total_sum;
    res.has_k = left.has_k || right.has_k;
    res.found_solution = left.found_solution || right.found_solution;

    // 如果已经找到解，就没必要再计算跨界情况了
    if (res.found_solution) {
        return res;
    }

    // 2. 检查跨界组合是否能产生解
    // 左边后缀 + 右边前缀
    // ls_has_k: 左后缀是否含k (0:不含, 1:含)
    // rp_has_k: 右前缀是否含k (0:不含, 1:含)
    for (int ls_has_k = 0; ls_has_k < 2; ++ls_has_k) {
        for (int rp_has_k = 0; rp_has_k < 2; ++rp_has_k) {
            if (left.max_suffix_sum[ls_has_k] > -INF && right.max_prefix_sum[rp_has_k] > -INF) {
                // 组合后的子数组必须包含k，并且权重和>=1
                if ((ls_has_k || rp_has_k) && (left.max_suffix_sum[ls_has_k] + right.max_prefix_sum[rp_has_k] >= 1)) {
                    res.found_solution = true;
                    // 找到一个解就足够了，可以提前返回
                    return res;
                }
            }
        }
    }
    
    // 3. 更新新节点的前缀信息
    res.max_prefix_sum[0] = left.max_prefix_sum[0];
    res.max_prefix_sum[1] = left.max_prefix_sum[1];
    // 考虑 `整个左区间 + 右区间的前缀` 的组合
    if (right.max_prefix_sum[0] > -INF) { // 右边前缀不含k
        int new_sum = left.total_sum + right.max_prefix_sum[0];
        res.max_prefix_sum[left.has_k] = max(res.max_prefix_sum[left.has_k], new_sum);
    }
    if (right.max_prefix_sum[1] > -INF) { // 右边前缀含k
        int new_sum = left.total_sum + right.max_prefix_sum[1];
        res.max_prefix_sum[1] = max(res.max_prefix_sum[1], new_sum); // 组合后一定含k
    }

    // 4. 更新新节点的后缀信息 (与前缀对称)
    res.max_suffix_sum[0] = right.max_suffix_sum[0];
    res.max_suffix_sum[1] = right.max_suffix_sum[1];
    // 考虑 `左区间的后缀 + 整个右区间` 的组合
    if (left.max_suffix_sum[0] > -INF) { // 左边后缀不含k
        int new_sum = left.max_suffix_sum[0] + right.total_sum;
        res.max_suffix_sum[right.has_k] = max(res.max_suffix_sum[right.has_k], new_sum);
    }
    if (left.max_suffix_sum[1] > -INF) { // 左边后缀含k
        int new_sum = left.max_suffix_sum[1] + right.total_sum;
        res.max_suffix_sum[1] = max(res.max_suffix_sum[1], new_sum); // 组合后一定含k
    }

    return res;
}

vector<int> a;
vector<Node> tree;

// 根据原始值val构建叶子节点
void build_leaf(int u, int val) {
    tree[u] = Node();
    tree[u].total_sum = (val >= K_VAL) ? 1 : -1;
    tree[u].has_k = (val == K_VAL);
    // 单个元素长度为1，不满足 len>=2，所以 found_solution 为 false
    // 但它本身可以作为前缀/后缀
    tree[u].max_prefix_sum[tree[u].has_k] = tree[u].total_sum;
    tree[u].max_suffix_sum[tree[u].has_k] = tree[u].total_sum;
}

void build(int u, int l, int r) {
    if (l == r) {
        build_leaf(u, a[l]);
        return;
    }
    int mid = l + (r - l) / 2;
    build(u * 2, l, mid);
    build(u * 2 + 1, mid + 1, r);
    tree[u] = merge(tree[u * 2], tree[u * 2 + 1]);
}

void modify(int u, int l, int r, int pos, int val) {
    if (l == r) {
        build_leaf(u, val);
        return;
    }
    int mid = l + (r - l) / 2;
    if (pos <= mid) {
        modify(u * 2, l, mid, pos, val);
    } else {
        modify(u * 2 + 1, mid + 1, r, pos, val);
    }
    tree[u] = merge(tree[u * 2], tree[u * 2 + 1]);
}

Node query(int u, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) {
        return tree[u];
    }
    int mid = l + (r - l) / 2;
    if (qr <= mid) {
        return query(u * 2, l, mid, ql, qr);
    }
    if (ql > mid) {
        return query(u * 2 + 1, mid + 1, r, ql, qr);
    }
    // 查询区间跨越了 mid, 需要合并左右两边的结果
    return merge(query(u * 2, l, mid, ql, qr), query(u * 2 + 1, mid + 1, r, ql, qr));
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, q;
    cin >> n >> K_VAL >> q;

    a.resize(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    tree.resize(4 * n);
    build(1, 1, n);

    while (q--) {
        int type, p1, p2;
        cin >> type >> p1 >> p2;
        if (type == 1) {
            modify(1, 1, n, p1, p2);
        } else {
            if (p1 > p2) { // 处理 l > r 的特殊情况
                cout << "NO\n";
                continue;
            }
            Node result = query(1, 1, n, p1, p2);
            if (result.found_solution) {
                cout << "YES\n";
            } else {
                cout << "NO\n";
            }
        }
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N + Q \log N)$
  - 建树的过程需要访问每个叶子节点一次，总时间复杂度是 $O(N)$。
  - 每次修改或查询操作，我们都从根节点开始，沿着一条路径走到叶子节点或相应的区间，树的高度是 $O(\log N)$，每个节点的合并操作是常数时间 $O(1)$。所以单次操作的复杂度是 $O(\log N)$。
  - 总共有 $Q$ 次查询，所以总时间复杂度是 $O(N + Q \log N)$，跑得飞快哦！

- **空间复杂度**: $O(N)$
  - 我们用了一个线段树来存储信息，线段树需要的节点数量大约是 $4N$，所以空间复杂度是 $O(N)$。

## 知识点总结

这道题真是一次有趣的冒险，我们来总结一下旅途中的收获吧，喵~

1.  **问题转化**: 核心技巧！将复杂的“中位数”定义转化为更简单的“区间和”问题。这是解决很多数据结构题目的第一步，也是最重要的一步。
2.  **线段树设计**: 面对复杂的区间查询，线段树是我们的得力助手。关键在于如何设计节点 `Node` 所需维护的信息，以及如何定义 `merge` 函数来合并这些信息。
3.  **处理“必须包含”类约束**: 像本题中“子数组必须包含 $k$”这样的约束，一个常见的处理模式是在节点中维护两种状态：`with_k` 和 `without_k`。这样在合并时就能清晰地处理所有情况。
4.  **关注细节**: 不要忘记题目中的小细节，比如本题的“长度大于等于2”。这个条件在我们的设计中通过叶子节点的 `found_solution` 初始为 `false` 而被巧妙地处理了。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来找我哦！一起加油，攻克更多的算法难题吧！喵~ ( V●ω●V )