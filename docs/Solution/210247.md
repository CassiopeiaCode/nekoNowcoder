# China's cinemas are reopening - 题解

### 比赛与标签
> **比赛**: The 2020 ICPC Asia Shanghai Regional Contest
> **标签**: dynamic programming, bitmask
> **难度**: *2600

## 题目大意喵~

你好呀，未来的算法大师！本喵今天带来了一道关于电影院座位安排的有趣问题，喵~

是这样的：有一个 $n$ 行 $m$ 列的电影院。为了保持社交距离，任何两个人都不能坐在相邻的座位上。两个座位 $(x_1, y_1)$ 和 $(x_2, y_2)$ 如果满足曼哈顿距离 $|x_1 - x_2| + |y_1 - y_2| = 1$，就被认为是相邻的。

观众们会一个接一个地来买票，并且他们可以自己选择任何**有效**的座位。一个座位是有效的，当且仅当它没有被占据，并且它的上、下、左、右四个邻座也都没有被占据。当影院里再也没有有效的座位时，售票就会停止。

作为电影院老板，我们想知道在**最坏的情况**下，最少能卖出多少张票。所谓最坏情况，就是指观众们总是做出一种选择，使得售票能最快结束（也就是最终售出的票数最少）。我们需要求出这个最少的票数，并打印出一种达到此最少票数的座位方案，喵~

## 解题思路分析

这道题初看之下，可能会觉得有点像博弈论，因为观众的选择会影响最终结果。但仔细思考一下，"最坏情况" 指的是所有可能的购票顺序中，导致最终售票数最少的那一种。这其实是在问我们：如何用最少的人，占据整个电影院，使得所有剩下的空位都与某一个占据的座位相邻？

这，其实是一个经典的图论问题——在网格图上寻找**最小支配集 (Minimum Dominating Set)**！一个支配集是指图中一个顶点的子集 $D$，使得图中每一个不在 $D$ 中的顶点都至少与 $D$ 中一个顶点相邻。我们要找的就是这个集合大小的最小值。

最小支配集问题在一般图上是 NP-难的，听起来就好可怕对不对？但是不要怕，喵~ 对于我们这个 $n \times m$ 的网格图，并且题目给的 $m$ (列数) 通常不会太大（根据经验一般在 15 以内），这就给了我们使用**状压DP (Profile DP)** 的机会！

我们可以逐行进行动态规划。`dp[i][S]` 表示处理完前 `i` 行，且第 `i` 行的状态为 `S` 时，所需要的最少人数。这里的状态 `S` 需要包含足够的信息，来帮助我们决策第 `i+1` 行。

#### 状态定义

既然是状压DP，关键就是如何定义状态 `S`。对于第 `i` 行的每一个座位，它最终的状态无非是“有人”或“无人”。但“无人”的座位还需要区分它是否已经被“支配”（即旁边已经有人了）。所以，对于第 `i` 行的每个座位，它和上下两行之间的关系，可以归结为三种情况：

1.  **被占据 (`*`)**: 这个座位上安排了一个人。
2.  **空闲但已被支配 (`.`)**: 这个座位是空的，但它已经被第 `i` 行或第 `i-1` 行的人所支配。
3.  **空闲且未被支配 (`?`)**: 这个座位是空的，并且它必须由第 `i+1` 行的人来支配。

所以，我们可以用一个三进制数来表示一整行的状态。`dp[i][mask]` 就表示处理到第 `i` 行，其状态为 `mask` 时，前 `i` 行安排的最少人数。

为了方便地处理行与行之间的依赖关系，我们可以把状态 `mask` 设计得更精巧一些。一个状态可以是一个包含三个信息的结构体 `(book, pre, next)`：

*   `book`: 一个 `m` 位的二进制数，`book[j] = 1` 表示第 `j` 列的座位被占据。
*   `pre`: 一个 `m` 位的二进制数，`pre[j] = 1` 表示第 `j` 列的座位是空的，且需要被 **上一行** 的人支配。
*   `next`: 一个 `m` 位的二进制数，`next[j] = 1` 表示第 `j` 列的座位是空的，且需要被 **下一行** 的人支配。

#### 状态生成

一个有效的单行状态 `(book, pre, next)` 必须满足一些内部约束，这些约束是最小化人数的关键：
1.  `book` 中不能有相邻的 `1`。因为两个人不能坐在一起。
2.  `pre` 中不能有相邻的 `1`。如果两个相邻的空位都需要被上一行支配，说明它们在当前行和上一行都没有找到支配者，这是不优的。我们可以通过在其中一个位置放人来同时支配它们俩。
3.  `next` 中也不能有相邻的 `1`，理由同上。
4.  一个座位不可能同时在 `book`, `pre`, `next` 中。它们共同构成了这一行的所有座位。具体来说，`book`、`pre` 和 `next` 的按位或 (`|`) 操作结果中，任意两位都不能同时为 `1`。
5.  所有被 `book` 中的人支配的空位，不能出现在 `pre` 或 `next` 中，因为它们已经被支配了。

我们可以通过深度优先搜索（DFS）预处理出对于给定的 `m`，所有满足这些条件的有效状态。

#### 状态转移

现在到了最激动人心的部分——状态转移，喵！假设我们已经计算出了 `dp[i-1]` 的所有值，现在要计算 `dp[i][state_curr]`。我们需要遍历所有可能的上一行状态 `state_prev`。

从 `state_prev` 转移到 `state_curr` 是合法的，当且仅当：
1.  **垂直方向不能有人相邻**: `(state_prev.book & state_curr.book) == 0`。
2.  **满足上一行的支配需求**: 上一行中所有需要被下一行（也就是第 `i` 行）支配的座位（由 `state_prev.next` 记录），都必须被当前行的人（`state_curr.book`）所支配。即 `(state_prev.next & state_curr.book) == state_prev.next`。
3.  **满足当前行的支配需求**: 当前行中所有需要被上一行（也就是第 `i-1` 行）支配的座位（由 `state_curr.pre` 记录），都必须被上一行的人（`state_prev.book`）所支配。即 `(state_curr.pre & state_prev.book) == state_curr.pre`。

如果转移合法，我们就可以更新 `dp` 值了：
$$
dp[i][\text{curr\_idx}] = \min(dp[i][\text{curr\_idx}], dp[i-1][\text{prev\_idx}] + \text{cost}(\text{state\_curr}))
$$
其中 `cost` 就是 `state_curr.book` 中 `1` 的数量（即当前行新安排的人数）。

#### 初始化与最终答案

*   **初始化 `dp[1]`**: 对于第一行（`i=1`），它没有上一行。所以只有那些 `pre` 为 `0` 的状态是合法的初始状态。`dp[1][k] = cost(state_k)` 当 `state_k.pre == 0`。
*   **最终答案**: 当我们计算到第 `n` 行时，它不能再对下一行（第 `n+1` 行）有支配需求了。所以，最终的答案就是 `min(dp[n][k])`，其中 `state_k.next == 0`。

为了输出方案，我们还需要一个 `path[i][k]` 数组来记录 `dp[i][k]` 是从哪个上一行状态转移过来的。最后从最优的结束状态回溯即可。

因为题目会有多组测试数据，但 `m` 的范围不大，我们可以对每个 `m` 单独进行一次预处理和DP，将不同 `n` 的询问一次性解决，这样效率更高哦！

## 代码实现

这只小猫娘已经把思路整理好，并且爪子痒痒地写下了一份清晰的代码，希望能帮助你理解，喵~

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using namespace std;

// 状态结构体，描述一行的配置
struct State {
    int book; // 人的位置 (bitmask)
    int pre;  // 需要被上一行支配的位置
    int next; // 需要被下一行支配的位置
    int cost; // 这一行的人数
    int id;   // 状态的唯一ID
};

// 存储每个宽度m的预计算结果
vector<State> states[16];
vector<vector<int>> transitions[16];
vector<vector<int>> dp_values[16];
vector<vector<int>> dp_paths[16];

// 检查一个mask中是否有相邻的1
bool has_adjacent_ones(int mask) {
    return (mask & (mask << 1)) != 0;
}

// 预处理函数，为指定的宽度m生成状态和转移关系
void precompute_for_m(int m) {
    if (!states[m].empty()) return; // 已经计算过了

    int state_id_counter = 0;
    int full_mask = (1 << m) - 1;

    // 1. 生成所有有效的单行状态
    vector<int> valid_books;
    for (int book = 0; book <= full_mask; ++book) {
        if (!has_adjacent_ones(book)) {
            valid_books.push_back(book);
        }
    }

    for (int book : valid_books) {
        int covered_by_book = book | (book << 1) | (book >> 1);
        int uncovered_mask = full_mask & ~covered_by_book;

        // 遍历uncovered_mask的所有子集作为pre
        for (int pre = uncovered_mask; ; pre = (pre - 1) & uncovered_mask) {
            if (!has_adjacent_ones(pre)) {
                int next = uncovered_mask & ~pre;
                if (!has_adjacent_ones(next)) {
                    states[m].push_back({book, pre, next, __builtin_popcount(book), state_id_counter++});
                }
            }
            if (pre == 0) break;
        }
    }

    // 2. 计算状态之间的转移关系
    int num_states = states[m].size();
    transitions[m].resize(num_states);
    for (int i = 0; i < num_states; ++i) {
        for (int j = 0; j < num_states; ++j) {
            const auto& prev_state = states[m][i];
            const auto& curr_state = states[m][j];

            // 检查转移合法性
            bool is_compatible = true;
            // 1. 垂直方向不能有人相邻
            if ((prev_state.book & curr_state.book) != 0) is_compatible = false;
            // 2. 上一行的需求必须被满足
            if ((prev_state.next & curr_state.book) != prev_state.next) is_compatible = false;
            // 3. 当前行的需求必须被满足
            if ((curr_state.pre & prev_state.book) != curr_state.pre) is_compatible = false;

            if (is_compatible) {
                transitions[m][i].push_back(j);
            }
        }
    }
}

// 解决一个具体的查询
pair<int, string> solve(int n, int m) {
    precompute_for_m(m);

    int num_states = states[m].size();
    int current_max_n = dp_values[m].empty() ? 0 : dp_values[m].size() - 1;

    if (n > current_max_n) {
        dp_values[m].resize(n + 1, vector<int>(num_states, 1e9));
        dp_paths[m].resize(n + 1, vector<int>(num_states, -1));

        if (current_max_n == 0) {
            // 初始化DP
            for (int i = 0; i < num_states; ++i) {
                if (states[m][i].pre == 0) {
                    dp_values[m][1][i] = states[m][i].cost;
                }
            }
            current_max_n = 1;
        }
        
        // 递推计算DP
        for (int i = current_max_n; i < n; ++i) {
            for (int prev_s_idx = 0; prev_s_idx < num_states; ++prev_s_idx) {
                if (dp_values[m][i][prev_s_idx] >= 1e9) continue;
                for (int curr_s_idx : transitions[m][prev_s_idx]) {
                    int new_cost = dp_values[m][i][prev_s_idx] + states[m][curr_s_idx].cost;
                    if (new_cost < dp_values[m][i + 1][curr_s_idx]) {
                        dp_values[m][i + 1][curr_s_idx] = new_cost;
                        dp_paths[m][i + 1][curr_s_idx] = prev_s_idx;
                    }
                }
            }
        }
    }

    // 寻找最终答案
    int min_tickets = 1e9;
    int final_state_idx = -1;
    for (int i = 0; i < num_states; ++i) {
        if (states[m][i].next == 0) {
            if (dp_values[m][n][i] < min_tickets) {
                min_tickets = dp_values[m][n][i];
                final_state_idx = i;
            }
        }
    }

    // 回溯路径，生成座位图
    string result_grid = "";
    vector<string> grid_rows;
    int current_state_idx = final_state_idx;
    for (int i = n; i >= 1; --i) {
        string row_str(m, '.');
        int book_mask = states[m][current_state_idx].book;
        for (int j = 0; j < m; ++j) {
            if ((book_mask >> j) & 1) {
                row_str[j] = '*';
            }
        }
        grid_rows.push_back(row_str);
        if (i > 1) {
            current_state_idx = dp_paths[m][i][current_state_idx];
        }
    }
    reverse(grid_rows.begin(), grid_rows.end());
    for(const auto& row : grid_rows) {
        result_grid += row + "\n";
    }

    return {min_tickets, result_grid};
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int T;
    cin >> T;
    vector<tuple<int, int, int>> queries;
    for (int i = 1; i <= T; ++i) {
        int n, m;
        cin >> n >> m;
        queries.emplace_back(i, n, m);
    }
    
    vector<pair<int, string>> results(T + 1);
    for (const auto& q : queries) {
        int case_num, n, m;
        tie(case_num, n, m) = q;
        results[case_num] = solve(n, m);
    }

    for (int i = 1; i <= T; ++i) {
        cout << "Case #" << i << ": " << results[i].first << "\n";
        cout << results[i].second;
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: 设 `S(m)` 为宽度为 `m` 时的状态总数。
    - 预处理状态和转移：生成状态的复杂度与 `S(m)` 成正比。计算所有转移关系的复杂度是 $O(S(m)^2)$。
    - DP计算：对于每个查询 `(n, m)`，我们需要计算 `n` 行。每行需要遍历所有状态和它们的转移。设平均每个状态的转移数为 T(m)，则DP部分的复杂度为 $O(n \times S(m) \times T(m))$。由于 T(m) 远小于 `S(m)`，可以近似看作 $O(n \times S(m)^2)$ 的上界。
    - `S(m)` 的增长速度很快，但对于 `m <= 15`，`S(m)` 在几千的量级，这个复杂度是可以接受的。

- **空间复杂度**: $O(n \times S(m) + S(m)^2)$。
    - `dp_values` 和 `dp_paths` 数组占 $O(n \times S(m))$。
    - `transitions` 邻接表最坏情况下占 $O(S(m)^2)$。
    - `states` 数组占 $O(S(m))$。

## 知识点总结

这道题是状压DP的一个绝佳应用范例，喵~ 从中我们可以学到：
1.  **问题转化**: 能够识别出问题的本质是图论中的最小支配集问题。
2.  **状压DP建模**: 当问题的一个维度很小时（比如网格图的宽度 `m`），可以考虑使用状压DP。
3.  **精巧的状态设计**: 状态需要包含足够的信息来进行转移。本题中的三元组 `(book, pre, next)` 是一个非常巧妙的设计，清晰地描述了行与行之间的支配关系。
4.  **预处理与递推**: 将复杂的逻辑（如状态生成、转移关系计算）进行预处理，可以使DP的核心循环变得简洁明了。
5.  **优化技巧**: 对于多组测试数据，将相同 `m` 的询问一起处理，复用DP计算结果，可以大大提高效率。

希望这篇题解能让你对状压DP有更深的理解！如果还有不明白的地方，随时可以来问本喵哦，喵~