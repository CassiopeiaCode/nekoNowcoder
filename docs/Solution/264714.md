# B-取数 - 题解

### 比赛与标签
> **比赛**: 牛客挑战赛71

> **标签**: 概率, 期望, 费马小定理, 逆元, 数学

> **难度**: *1494

## 题目大意喵~

主人你好呀，这道题是这样的喵~

我们有一个装满数字的数组 `a`，它有 `n` 个元素。还有一个空空的数组 `b`。

接下来我们要进行 `k` 次操作。每一次操作，我们都会从数组 `a` 中随机（等概率）地拿走一个数字，然后把它放进数组 `b` 里。

题目要求我们对每一个 `k`（从 1 到 `n`），都计算出经过 `k` 次操作后，数组 `b` 中所有数字之和的期望值是多少。因为答案可能会很大，所以要对 998244353 取模哦，喵~

举个栗子：如果 `a = [10, 20]`，`n = 2`。
*   当 `k = 1` 时，我们从 `a` 中取一个数。可能取到 10（概率 1/2），也可能取到 20（概率 1/2）。所以 `b 的和的期望是 $10 \times \frac{1}{2} + 20 \times \frac{1}{2} = 15$。
*   当 k = 2` 时，我们把 `a` 的所有数都取出来了，`b` 就是 `[10, 20]` 或者 `[20, 10]`，和总是 30。所以期望就是 30。

## 解题思路分析

这道题看起来和概率期望有关，可能会有点绕，但别担心，跟着本猫娘的思路，一步一步就能解开谜题啦，喵！

解决期望问题，有一个超级好用的法宝叫做**期望的线性性质**！它的意思是：**“和的期望”等于“期望的和”**。

也就是说，我们想求数组 `b` 的总和的期望，可以把它拆解成求 `b 中每一个可能出现的元素的期望贡献，然后再把它们加起来！

$$
E[\text{b 的和}] = \sum_{i=1}^{n} E[\text{a}_i \text{ 对 b 的贡献}]
$$

那么，对于原数组 a` 中的任意一个元素 $a_i$，它对 `b` 的和的贡献是多少呢？
这个贡献有两种情况：
1.  如果 $a_i$ 在 `k` 次操作后被移到了数组 `b` 中，那么它的贡献就是 $a_i$。
2.  如果 $a_i$ 还在数组 `a` 中，那它对 `b 的和的贡献就是 0。

所以，$a_i$ 的期望贡献就是：
$$
E[a_i \text{ 的贡献}] = a_i \times P(a_i \text{ 在 k 次操作后被移入 b}) + 0 \times P(a_i \text{ 还在 a 中})
$$
$$
E[a_i \text{ 的贡献}] = a_i \times P(a_i \text{ 在 k 次操作后被移入 b})
$$

好！现在问题的关键就变成了：**在 k` 次操作后，元素 $a_i$ 被移入数组 `b` 的概率是多少呢？**

让我们来挠挠头，仔细想一下~
在第 1 次操作时，数组 `a` 中有 `n` 个数，`a_i 被选中的概率是 $\frac{1}{n}$。
在第 2 次操作时，a_i 要被选中，前提是它在第 1 次没被选中。
*   第 1 次没被选中的概率是 $\frac{n-1}{n}$。
*   然后在剩下的 n-1` 个数中，`a_i 被选中的概率是 $\frac{1}{n-1}$。
*   所以，a_i 在第 2 次操作时被选中的概率是 $\frac{n-1}{n} \times \frac{1}{n-1} = \frac{1}{n}$。

喵喵！发现了吗？a_i` 在第 `j` 次操作时被选中的概率，就是它在前 `j-1` 次都没被选中，然后在第 `j 次被选中的概率。
$$
P(a_i \text{在第 j 次被选中}) = \frac{n-1}{n} \times \frac{n-2}{n-1} \times \dots \times \frac{n-j+1}{n-j+2} \times \frac{1}{n-j+1}
$$
这个式子看起来很吓人，但实际上前面的项都可以消掉，最后只剩下 $\frac{1}{n}$！

所以，对于任意一次操作（第1次、第2次、...、第n次），任何一个特定的元素 $a_i$ 被选中的概率都是 $\frac{1}{n}$。这其实很符合直觉，因为每次选择都是公平的嘛！

那么，在 k` 次操作中，$a_i$ 被移入 `b`，就意味着它在第 1 次、或第 2 次、...、或第 `k` 次被选中。这些事件是互不相容的（一个数不能被选中两次）。
所以，`a_i` 在 `k 次操作内被选中的总概率就是：
$$
P(a_i \text{ 在 k 次内被选中}) = \sum_{j=1}^{k} P(a_i \text{ 在第 j 次被选中}) = \sum_{j=1}^{k} \frac{1}{n} = \frac{k}{n}
$$

哇！我们得到了一个超级简洁的结论！
现在可以回头计算期望啦~
$$
E[a_i \text{ 的贡献}] = a_i \times \frac{k}{n}
$$
那么，b` 的和的期望就是所有 `a_i 期望贡献的总和：
$$
E_k = \sum_{i=1}^{n} (a_i \times \frac{k}{n})
$$
我们可以把与 i 无关的项 $\frac{k}{n}$ 提到求和符号外面：
$$
E_k = \frac{k}{n} \times \sum_{i=1}^{n} a_i
$$

令 $S = \sum_{i=1}^{n} a_i$ 为数组 a` 的总和。那么对于每一个 `k，期望公式就是：
$$
E_k = \frac{k \times S}{n}
$$

因为题目要求对质数 998244353 取模，除法在模运算下要变成乘以它的**模逆元**。根据费马小定理，一个数 n` 在模 `MOD 下的逆元是 $n^{MOD-2} \pmod{MOD}$。

所以我们的最终计算步骤是：
1.  计算数组 a` 的总和 $S$。
2.  用快速幂计算 `n 的模逆元 $n^{-1} \equiv n^{MOD-2} \pmod{MOD}$。
3.  对于每个 $k = 1, 2, \dots, n$，计算 $E_k = (k \times S \times n^{-1}) \pmod{MOD}$。

这样就可以高效地解决问题啦，是不是很简单呢，喵~

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的一份代码哦！注释超详细的，快来看看吧~

``cpp
#include <iostream>
#include <vector>
#include <numeric>

// 定义一个猫娘喜欢的名字作为模数~
const long long MOD = 998244353;

// 快速幂函数，用来计算 (base^exp) % mod
// 这是计算模逆元的基础哦，喵~
long long power(long long base, long long exp) {
    long long res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) { // 如果指数是奇数
            res = (res * base) % MOD;
        }
        base = (base * base) % MOD; // 底数平方
        exp /= 2; // 指数减半
    }
    return res;
}

// 计算模逆元的函数
// 根据费马小定理，a 在模 p 下的逆元是 a^(p-2)
long long modInverse(long long n) {
    return power(n, MOD - 2);
}

int main() {
    // 加速输入输出，让程序跑得像小猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 用 long long 来存总和，防止溢出，喵~
    long long total_sum = 0;
    for (int i = 0; i < n; ++i) {
        long long val;
        std::cin >> val;
        total_sum = (total_sum + val) % MOD;
    }

    // 计算 n 的模逆元
    long long inv_n = modInverse(n);

    // E_k = (k * S) / n  (mod MOD)
    // 我们可以先计算出 S/n 的部分，也就是 S * inv_n
    long long base_expectation_part = (total_sum * inv_n) % MOD;

    // 循环计算并输出每个 k 的期望值
    for (int k = 1; k <= n; ++k) {
        // E_k = k * (S / n)
        long long current_expectation = (static_cast<long long>(k) * base_expectation_part) % MOD;
        // 为了防止负数结果，可以加上 MOD 再取模，虽然在这里不太可能发生
        current_expectation = (current_expectation + MOD) % MOD;
        std::cout << current_expectation << (k == n ? "" : " ");
    }
    std::cout << std::endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N)$
    *   我们首先需要 $O(N)$ 的时间来读取输入并计算数组 `a` 的总和 $S$。
    *   然后用快速幂计算 `n 的逆元，时间复杂度是 $O(\log MOD)$。
    *   最后，我们循环 n` 次，为每个 `k` 从 1 到 `n 计算期望值，这部分是 $O(N)$。
    *   所以总的时间复杂度是 $O(N + \log MOD)$，因为 N` 通常比 `log MOD` 大得多，所以可以简化为 $O(N)$，喵~

*   **空间复杂度**: $O(1)$
    *   在我的代码实现里，我没有把整个数组 `a` 存起来，而是在读入的时候直接累加求和。所以除了几个变量外，没有使用额外的与 `N` 相关的空间，非常节省内存呢！

## 知识点总结

这道题虽然是期望题，但核心是对问题进行简化和转化，最后变成了一个数学计算题。通过这道题，我们可以复习和学习到：

1.  **期望的线性性质**: 这是解决很多期望问题的关键钥匙！它允许我们将一个复杂问题的期望分解成许多简单子问题的期望之和。
2.  **概率计算**: 通过分析每一步操作，我们能推导出关键的概率 $P(a_i \text{ 在 k 次内被选中}) = k/n$。这个推导过程本身就是一种很好的逻辑训练。
3.  **模运算与模逆元**: 在算法竞赛中，当结果需要对一个大质数取模时，除法就要用乘以模逆元来代替。
4.  **费马小定理**: 这是计算模逆元的一个常用方法，当模数是质数时非常方便。
5.  **快速幂**: 高效计算 $a^b \pmod{m}$ 的算法，是数论问题中的基本工具。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，喵~！