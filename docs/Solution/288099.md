# 幻想地下大轨道网 - 题解

### 比赛与标签
> **比赛**: [信息未提供]

> **标签**: 构造, 回溯搜索, DFS, 图论, 并查集

> **难度**: *2400

## 题目大意喵~

你好呀，未来的算法大师！咱是小猫娘，最喜欢的就是和聪明的人类一起解决有趣的谜题了，喵~

这道题是说，幻想乡的大蜈蚣百百世想在一个 $n \times n$ 的网格上修建一条铁路。这个网格上密密麻麻地分布着 $n^2$ 个城市，每个城市的坐标都是整数对 $(i, j)$，其中 $1 \le i, j \le n$。

百百世的要求有点特别哦：
1.  她要修建一条**折线路径**，恰好经过所有 $n^2$ 个城市一次。这条路径由 $n^2-1$ 条线段首尾相连而成。
2.  每一条线段连接的两个城市之间，不能再有其他的城市了。也就是说，如果连接 $(x_1, y_1)$ 和 $(x_2, y_2)$，那么线段上不能有别的整数坐标点。
3.  最最重要的一点：这 $n^2-1$ 条线段的**斜率必须两两不同**！垂直的线段（$x$ 坐标相同）的斜率我们看作是 $+\infty$。

我们的任务就是判断是否存在这样一条神奇的铁路。如果存在，就输出 "Yes"，并给出一种可行的城市访问顺序；如果不存在，就输出 "No"，告诉百百世这个计划行不通呐。

## 解题思路分析

喵呜~ 这个问题看起来好复杂，要把几何、图论和组合计数搅在一起。不过别担心，跟着本猫娘的思路，一步一步把它解开！

### 关键约束的转化

首先，我们来分析一下百百世的两个核心要求，把它们翻译成我们熟悉的算法语言~

1.  **“线段上不能有其他城市”**: 这意味着什么呢？假设我们从城市 $(x_1, y_1)$ 连接到 $(x_2, y_2)$，位移向量是 $(\Delta x, \Delta y) = (x_2 - x_1, y_2 - y_1)$。如果 $|\Delta x|$ 和 $|\Delta y|$ 的最大公约数 $\text{gcd}(|\Delta x|, |\Delta y|) > 1$，那么在这条线段的中间，肯定会经过其他的整数坐标点。比如从 $(1,1)$ 到 $(3,3)$，位移是 $(2,2)$，$\text{gcd}(2,2)=2$，中间就经过了 $(2,2)$。所以，这个条件等价于：我们选用的每一段位移向量 $(\Delta x, \Delta y)$ 都必须是**互质**的，即 $\text{gcd}(|\Delta x|, |\Delta y|) = 1$。我们把这种向量叫做“**基元向量**”好了，喵~

2.  **“斜率两两不同”**: 斜率 $k = \frac{\Delta y}{\Delta x}$。不同的斜率就对应着不同的最简比值 $\frac{\Delta y'}{\Delta x'}$。这正好和我们的“基元向量”完美契合！每个唯一的基元向量 $(\Delta x, \Delta y)$（在约分和统一方向后）都代表一个独一无二的斜率。例如，向量 $(1, 2)$, $(2, 4)$ 斜率相同，但只有 $(1, 2)$ 是基元向量。向量 $(1, 2)$ 和 $(-1, -2)$ 斜率也相同，但 $(1, -2)$ 和 $(-1, 2)$ 的斜率就不同啦。

所以，我们的任务变成了：
> 在 $n \times n$ 的网格上，找到一个经过所有 $n^2$ 个点的路径。这条路径由 $n^2-1$ 条边组成，每条边的位移向量都是一个不同的“基元向量”。

### 从构造到搜索

直接构造出这样一条路径太困难了，就像蒙着眼睛走迷宫一样。但是，我们可以换个角度思考：我们不是要去走迷宫，而是要去**设计**这个迷宫！

我们的“建筑材料”就是所有可能的、合法的“基元向量”。我们先找出所有能在 $n \times n$ 网格里使用的基元向量，然后尝试用它们来“搭建”一条符合要求的路径。

这不就是一个经典的**搜索**问题嘛！我们可以用**回溯法 (Backtracking)** 来解决。

#### 1. 收集我们的“建筑材料”（生成基元向量）

首先，我们需要一个所有可用基元向量的列表。一个位移向量 $(\Delta x, \Delta y)$ 可以在 $n \times n$ 的网格中使用，只要 $|\Delta x| < n$ 且 $|\Delta y| < n$。
我们可以遍历所有可能的位移 `(dx, dy)` 其中 `0 <= dx < n`, `0 <= dy < n`，然后：
-   计算 `g = gcd(dx, dy)`。
-   得到基元向量 `(dx/g, dy/g)`。
-   为了涵盖所有方向，我们还需要考虑 `x` 坐标为负数的情况，所以 `(-dx/g, dy/g)` 也要加进去。
-   用一个 `std::set` 来存储这些基元向量，就可以自动去重，得到一个独一无二的向量列表啦。

#### 2. 聪明的搜索策略（带剪枝的回溯）

有了材料库，我们就可以开始搜索了。我们的目标是选择 $n^2-1$ 个不同的基元向量，并将它们首尾相连，形成一条贯穿所有 $n^2$ 个点的路径。

我们可以定义一个递归函数 `dfs(k, count)`，表示：
-   `k`: 当前我们正在考虑使用第 `k` 个基元向量。
-   `count`: 我们已经成功放置了 `count` 条线段。

在 `dfs(k, count)` 函数里，我们有两种选择：
-   **选择一：不使用第 k 个基元向量。** 直接调用 `dfs(k + 1, count)`，去考虑下一个。
-   **选择二：使用第 k 个基元向量。** 我们需要遍历网格上所有可能的起点，尝试放置这条线段。

但是，暴力尝试所有起点太慢了！我们需要一些**剪枝**技巧来提高效率，喵~

-   **路径约束**：一条路径上，除了起点和终点度数为1，其他所有点的度数都必须是2。所以，当我们尝试连接两个点 `u` 和 `v` 时，必须保证它们当前的度数都小于2。
-   **无环约束**：我们正在构建的是一条路径，不能形成环！这里就要请出我们的好朋友——**并查集 (Disjoint Set Union, DSU)** 了。每次想连接 `u` 和 `v` 之前，先检查它们是否已经在同一个连通分量里。如果 `find(u) == find(v)`，说明连接它们会形成环，这条路就不能走！
-   **启发式搜索顺序**：先用哪个基元向量来尝试呢？一个很好的策略是**先尝试最难满足的约束**。那些“长”的向量（比如位移是 `(n-1, n-2)`）在网格里能放置的位置很少。我们应该优先尝试它们。如果它们都放不进去，那我们就可以尽早地剪掉这个搜索分支，避免大量无效计算。所以，我们可以先对基元向量排个序，把可放置位置少的排在前面。一个向量 $(\Delta x, \Delta y)$ 的可放置位置数量是 $(n-|\Delta x|) \times (n-|\Delta y|)$。

#### 3. 终点与回溯

-   当 `count` 达到 $n^2-1$ 时，说明我们已经成功连接了所有点，形成了一条路径（因为并查集保证了连通性和无环性，所以它必然是一条链）。太棒了，找到解了！
-   如果在某一步，我们尝试了所有可能都无法继续下去，那就需要**回溯**。撤销上一步的操作（比如，在并查集和邻接表中删除那条边），然后返回上一层，尝试其他的可能性。

如果整个搜索过程结束了还没找到解，那就说明百百世的计划是不可行的，我们只好遗憾地告诉她 "No" 了。

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，加了很多注释，希望能帮助你理解，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <set>

// 使用一个结构体来表示点或向量，更清晰喵~
struct Point {
    int x, y;
    // 为了能放入 std::set，需要定义比较运算符
    bool operator<(const Point& other) const {
        if (x != other.x) return x < other.x;
        return y < other.y;
    }
};

// 全局变量，方便在DFS中使用
int n;
std::vector<Point> displacement_vectors; // 存储所有可用的基元向量
std::vector<std::vector<int>> adj; // 邻接表，存储构建的路径
std::vector<int> node_degree; // 记录每个点的度数

// 并查集(DSU)数据结构
struct DSU {
    std::vector<int> parent;
    DSU(int size) {
        parent.resize(size);
        std::iota(parent.begin(), parent.end(), 0); // 初始化，每个元素的父节点是自己
    }

    int find(int i) {
        if (parent[i] == i)
            return i;
        return parent[i] = find(parent[i]); // 路径压缩
    }

    void unite(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            parent[root_i] = root_j;
        }
    }
};

// 将二维坐标(0-indexed)转换为一维索引
int to_1d(int r, int c) {
    return r * n + c;
}

// 将一维索引转回二维坐标(0-indexed)
Point to_2d(int id) {
    return {id / n, id % n};
}

// 核心的回溯搜索函数
bool solve_dfs(int k, int edges_count, DSU& dsu) {
    // 终止条件：如果已经找到了 n*n-1 条边，说明成功了！
    if (edges_count == n * n - 1) {
        return true;
    }
    // 终止条件：如果所有向量都试完了还不够，说明此路不通
    if (k == displacement_vectors.size()) {
        return false;
    }

    // --- 决策1: 不使用当前的基元向量 displacement_vectors[k] ---
    if (solve_dfs(k + 1, edges_count, dsu)) {
        return true;
    }

    // --- 决策2: 尝试使用当前的基元向量 displacement_vectors[k] ---
    Point vec = displacement_vectors[k];
    
    // 遍历所有可能的起点 (r, c)
    for (int r = 0; r < n; ++r) {
        for (int c = 0; c < n; ++c) {
            int nr = r + vec.x;
            int nc = c + vec.y;

            // 检查终点是否在网格内
            if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                int u = to_1d(r, c);
                int v = to_1d(nr, nc);

                // 剪枝: 1. 度数不能超过2; 2. 不能形成环
                if (node_degree[u] < 2 && node_degree[v] < 2 && dsu.find(u) != dsu.find(v)) {
                    // 记录现场，准备回溯
                    int root_u_before = dsu.find(u);
                    int root_v_before = dsu.find(v);
                    
                    // 尝试连接
                    dsu.unite(u, v);
                    adj[u].push_back(v);
                    adj[v].push_back(u);
                    node_degree[u]++;
                    node_degree[v]++;

                    // 递归搜索
                    if (solve_dfs(k + 1, edges_count + 1, dsu)) {
                        return true;
                    }

                    // 回溯！恢复现场
                    dsu.parent[root_u_before] = root_u_before;
                    dsu.parent[root_v_before] = root_v_before;
                    adj[u].pop_back();
                    adj[v].pop_back();
                    node_degree[u]--;
                    node_degree[v]--;
                }
            }
        }
    }

    return false;
}


int main() {
    // 加速输入输出，是好习惯喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::cin >> n;

    if (n == 1) {
        std::cout << "Yes\n1 1\n";
        return 0;
    }

    // 1. 生成所有唯一的基元向量
    std::set<Point> unique_vectors;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i == 0 && j == 0) continue;
            int common_divisor = std::gcd(i, j);
            unique_vectors.insert({i / common_divisor, j / common_divisor});
            if (i != 0) { // 也加入x为负数的情况
                unique_vectors.insert({-i / common_divisor, j / common_divisor});
            }
        }
    }
    for (const auto& vec : unique_vectors) {
        displacement_vectors.push_back(vec);
    }
    
    // 2. 启发式排序：将“最难放”的向量排在前面
    std::sort(displacement_vectors.begin(), displacement_vectors.end(), [&](const Point& a, const Point& b) {
        long long placements_a = (long long)(n - std::abs(a.x)) * (n - std::abs(a.y));
        long long placements_b = (long long)(n - std::abs(b.x)) * (n - std::abs(b.y));
        return placements_a < placements_b;
    });

    // 3. 初始化并开始搜索
    int total_nodes = n * n;
    adj.resize(total_nodes);
    node_degree.assign(total_nodes, 0);
    DSU dsu(total_nodes);

    if (solve_dfs(0, 0, dsu)) {
        std::cout << "Yes\n";
        // 找到了路径，现在要把它打印出来
        // 路径的起点和终点度数都是1，我们随便找一个
        int start_node = -1;
        for (int i = 0; i < total_nodes; ++i) {
            if (node_degree[i] == 1) {
                start_node = i;
                break;
            }
        }

        // 从起点开始遍历路径
        int current = start_node;
        int prev = -1;
        for (int i = 0; i < total_nodes; ++i) {
            Point p = to_2d(current);
            std::cout << p.x + 1 << " " << p.y + 1 << "\n"; // 输出1-indexed坐标

            int next_node = -1;
            for (int neighbor : adj[current]) {
                if (neighbor != prev) {
                    next_node = neighbor;
                    break;
                }
            }
            prev = current;
            current = next_node;
        }
    } else {
        std::cout << "No\n";
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(\text{很大但能过})$
    这是一个回溯搜索算法，其理论上的最坏时间复杂度是指数级的，非常难以精确表示。它大致上与“从 $D$ 个向量中选出 $N^2-1$ 个，并为它们安排位置”的组合数量有关，其中 $D$ 是基元向量的总数。但是！由于我们使用了强大的剪枝（度数限制、DSU防环）和聪明的启发式排序，实际的搜索空间被大大削减了。对于这道题的 $n$ 的范围来说，这个算法是足够快的，喵~

-   **空间复杂度**: $O(N^2 + D)$
    我们需要存储 $N^2$ 个点的并查集、邻接表和度数信息，所以是 $O(N^2)$。此外，我们还需要存储所有 $D$ 个基元向量，所以总的空间复杂度是 $O(N^2+D)$。$D$ 的数量级也大约是 $O(N^2)$ 的，所以整体可以看作是 $O(N^2)$。

## 知识点总结

解决这道题就像是完成一个复杂的拼图，我们学到了很多有用的技巧呢！

1.  **问题转化**: 学会将抽象的几何约束（如“无中间点”、“斜率唯一”）转化为具体的数学和算法概念（“基元向量”）。
2.  **回溯搜索 (Backtracking)**: 当问题的解空间巨大，但可以通过一系列决策来构建时，回溯法是我们的有力武器。
3.  **剪枝与启发式**: 纯粹的回溯是不够的。有效的剪枝（如检查度数、用DSU防环）和聪明的启发式搜索顺序（先处理最受限制的元素）是决定算法能否在时限内跑完的关键！
4.  **并查集 (DSU)**: 在图的构建过程中，DSU是动态维护连通性和检测环的神器。
5.  **构造性问题思路**: 对于“是否存在并构造一个解”这类问题，如果直接构造没有头绪，可以尝试转化为搜索问题，让计算机的强大算力帮我们找到答案！

希望这篇题解能帮到你！继续努力，你一定能成为超厉害的算法大师的，加油喵~！