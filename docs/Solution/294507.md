# 一个关于Mex和函数F的求和问题 (困难版) - 题解

### 比赛与标签
> **比赛**: [待补充]

> **标签**: 数学, 贡献法, 数据结构, 预计算

> **难度**: ******

## 题目大意喵~

主人你好呀~！这道题是说，我们有一个从 $1$ 到 $n$ 的整数排列 $a$。我们需要计算一个特别的函数 $F(a)$ 的值，喵~

这个函数 $F(a)$ 的定义有点绕，我们一步步来看哦：

1.  首先，对于数组 $a$ 的任意一个连续子数组 $a_i, \dots, a_j$，我们定义 $\operatorname{mex}(i,j)$ 是这个子数组里**最小没有出现过**的正整数。比如说，如果子数组是 `{1, 3, 4}`，那没有出现的最小正整数就是 $2$，所以 $\operatorname{mex}$ 就是 $2$ 啦。

2.  接着，我们定义一个值 $t(i, j) = (\text{子数组长度}) \times \operatorname{mex}(i, j) = (j - i + 1) \times \operatorname{mex}(i, j)$。

3.  最后，我们要计算的函数 $F(a)$ 就是对所有可能的子数组，把 $t(i,j) \times 2^{t(i,j)}$ 这个值加起来，也就是：
    $$
    F(a) = \sum_{i=1}^{n} \sum_{j=i}^{n} t(i,j) \times 2^{t(i,j)}
    $$

这还没完呢！这道题是困难版，会有 $q$ 次独立的询问。每次询问会给你两个**数值** $x$ 和 $y$。你需要：
1.  想象一下把排列中数值为 $x$ 和 $y$ 的两个元素交换位置，得到一个新的排列 $a'$。
2.  计算出这个新排列对应的 $F(a')$ 的值。
3.  每次询问都是独立的，也就是说，下一次询问还是在最原始的排列 $a$ 上进行操作哦。

因为答案会很大，所以所有结果都要对 $998244353$ 取模，喵~

## 解题思路分析

呜喵... 这个 $F(a)$ 的公式看起来好复杂，直接暴力计算肯定是不行的。$n$ 和 $q$ 都很大，如果我们每次询问都遍历所有子数组来计算，一定会超时的说！所以，我们得想个更聪明的办法，呐。

### 核心思想：贡献法

直接枚举所有子数组 $(i, j)$ 来算 $t(i,j)$ 太慢了。不如换个角度想想？我们可以不枚举子数组，而是枚举 $\operatorname{mex}$ 的值！

$F(a)$ 的公式可以改写成这样：
$$
F(a) = \sum_{m=1}^{n+1} \left( \sum_{\substack{1 \le i \le j \le n \\ \operatorname{mex}(i,j) = m}} t(i,j) \times 2^{t(i,j)} \right)
$$
当一个子数组的 $\operatorname{mex}(i,j) = m$ 时，它的 $t(i,j)$ 就等于 $m \times (j-i+1)$。所以，对于一个固定的 $m$，它对总答案的贡献就是：
$$
C(m) = \sum_{\substack{1 \le i \le j \le n \\ \operatorname{mex}(i,j) = m}} m \cdot (j-i+1) \cdot 2^{m \cdot (j-i+1)}
$$
总答案 $F(a)$ 就是所有 $C(m)$ 的和：$F(a) = \sum_{m=1}^{n+1} C(m)$。

这样一来，问题就变成了：对于每个 $m$，如何快速计算出 $C(m)$ 呢？

### 计算特定 `mex` 的贡献 $C(m)$

要让一个子数组 $a[i \dots j]$ 的 $\operatorname{mex}$ 恰好为 $m$，必须满足两个条件：
1.  数字 $1, 2, \dots, m-1$ **全部**都出现在这个子数组里。
2.  数字 $m$ **不**出现在这个子数组里。

为了方便处理，我们先预处理一个 `pos` 数组，`pos[v]` 表示数值 `v` 在排列 `a` 中的位置（下标）。

*   **条件1**：为了包含所有 $1$ 到 $m-1$，子数组的左端点 $i$ 必须小于等于它们中位置最靠左的那个，右端点 $j$ 必须大于等于它们中位置最靠右的那个。我们记 $L_{m-1} = \min_{v=1}^{m-1} \operatorname{pos}[v]$ 和 $R_{m-1} = \max_{v=1}^{m-1} \operatorname{pos}[v]$。那么必须满足 $i \le L_{m-1}$ 且 $j \ge R_{m-1}$。

*   **条件2**：为了不包含 $m$，子数组的范围 $[i, j]$ 不能覆盖 $\operatorname{pos}[m]$。

有趣的是，$\operatorname{pos}[m]$ 一定不会在 $[L_{m-1}, R_{m-1}]$ 这个区间内。因为如果它在里面，就说明 $m$ 的位置在 $1, \dots, m-1$ 这些数的位置构成的区间里，这意味着 $m$ 也是 $1, \dots, m-1$ 中的一员，这显然是矛盾的嘛！

所以，$\operatorname{pos}[m]$ 要么在 $L_{m-1}$ 左边，要么在 $R_{m-1}$ 右边。这就把我们的问题分成了两种情况：

1.  **当 $\operatorname{pos}[m] < L_{m-1}$ 时**：
    合法的子数组范围必须是 $\operatorname{pos}[m] < i \le L_{m-1}$ 且 $R_{m-1} \le j \le n$。

2.  **当 $\operatorname{pos}[m] > R_{m-1}$ 时**：
    合法的子数组范围必须是 $1 \le i \le L_{m-1}$ 且 $R_{m-1} \le j < \operatorname{pos}[m]$。

这两种情况都形成了一个矩形的 $(i, j)$ 选择区域。我们需要对这个区域内的所有 $(i,j)$ 求和。这个和式是一个复杂的、带有幂函数的二重求和，但它是有规律的！

通过一连串可爱的数学推导（主要是等比数列和差比数列求和），我们可以得到一个计算这个矩形区域贡献的公式。这个推导有点复杂，但结论是，这个和可以由几个预计算好的级数和组合而成。具体的说，令 $q = 2^m$，我们需要求形如 $\sum (w+u+v)q^{w+u+v}$ 的和，可以分解成 $\sum q^u$, $\sum u q^u$ 等项的乘积。这些都可以用公式 $O(1)$ 算出来（在预处理之后）。

#### 特殊情况：$m=1$

当 $m=1$ 时，条件1（包含 $1, \dots, m-1$）是空集，自动满足。条件2是子数组不包含 $1$。
这意味着合法的子数组要么完全在 $\operatorname{pos}[1]$ 的左边，要么完全在右边。
*   左边区域：$1 \le i \le j < \operatorname{pos}[1]$，这是一个长度为 $\operatorname{pos}[1]-1$ 的连续段。
*   右边区域：$\operatorname{pos}[1] < i \le j \le n$，这是一个长度为 $n-\operatorname{pos}[1]$ 的连续段。

对于一个长度为 $K$ 的连续段，其所有子数组的贡献和为 $\sum_{len=1}^{K} (K-len+1) \cdot (1 \cdot len \cdot 2^{1 \cdot len})$。这个也可以通过预处理 $\sum k \cdot 2^k$ 和 $\sum k^2 \cdot 2^k$ 来快速计算。

### 处理询问

每次询问交换两个值 $x, y$ 的位置（假设 $x<y$），我们不需要重新计算整个 $F(a')$。我们只需要计算答案的变化量 $\Delta$。

哪些 $C(m)$ 的值会变呢？
*   当 $m \le x$ 时：$L_{m-1}, R_{m-1}$ 和 $\operatorname{pos}[m]$ 都不会因为 $x, y$ 的交换而改变。所以 $C(m)$ 不变。
*   当 $m > y$ 时：$L_{m-1}, R_{m-1}$ 依赖于 $\{ \operatorname{pos}[1], \dots, \operatorname{pos}[m-1] \}$ 这个**集合**。交换 $\operatorname{pos}[x]$ 和 $\operatorname{pos}[y]$ 后，这个集合本身没变，所以它的最小、最大值 $L_{m-1}, R_{m-1}$ 也不变。而 $\operatorname{pos}[m]$ 也没变。所以 $C(m)$ 也不变！
*   只有当 $x < m \le y$ 时，$C(m)$ 才可能改变。因为 $L_{m-1}, R_{m-1}$ 依赖的集合中包含了 $x$ 但不包含 $y$，交换后 $\operatorname{pos}[x]$ 变了，导致 $L_{m-1}, R_{m-1}$ 可能改变。另外，当 $m=x$ 或 $m=y$ 时，$\operatorname{pos}[m]$ 本身也变了。

所以，对于每个询问 $(x, y)$，我们只需要重新计算 $m \in [x, y]$ （或者说是 $m$ 从 $x$ 到 $y+1$，因为 $\operatorname{mex}$ 可以是 $y+1$）的贡献变化量。

1.  先计算出初始的总答案 $F_0 = \sum C(m)$，并把每个 $C(m)$ 存起来。
2.  对于询问 $(x, y)$，我们遍历 $m$ 从 $x$ 到 $y+1$：
    *   从总答案变化量 $\Delta$ 中减去旧的 $C(m)$。
    *   根据交换后的位置，计算出新的 $L'_{m-1}, R'_{m-1}, \operatorname{pos}'[m]$。
    *   计算出新的贡献 $C'(m)$。
    *   把新的 $C'(m)$ 加到 $\Delta$ 中。
3.  最终答案就是 $F_0 + \Delta$。

为了快速得到新的 $L'_{m-1}, R'_{m-1}$，我们可以预处理出前缀的最小/最大位置，以及**次小/次大**位置。这样如果原来的最小/最大值是 $\operatorname{pos}[x]$，我们就可以 $O(1)$ 找到新的最小/最大值啦。

还有一个小优化，喵~ 在遍历 $m$ 从 $x$ 到 $y+1$ 的过程中，如果某一步我们发现 $L'_{m-1}, R'_{m-1}$ 和旧的 $L_{m-1}, R_{m-1}$ 碰巧一样了，那么对于更大的 $m'$，它们的值也不会再变了，我们就可以提前结束循环！这让算法在实际中跑得飞快。

好啦，思路就是这样！预计算 + 贡献法 + 增量更新，完美~！

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦~ 每一步都有详细的注释，希望能帮到主人！

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

// 使用 long long 防止计算过程中溢出
using int64 = long long;

const int MOD = 998244353;
const int MAXN = 200005;

// 快速幂，喵~
int64 power(int64 base, int64 exp) {
    int64 res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 求逆元，费马小定理是我们的好朋友！
int64 modInverse(int64 n) {
    return power(n, MOD - 2);
}

// --- 全局预计算变量 ---
// p2[k] = 2^k
vector<int64> p2;
// inv_p2m1[k] = (2^k - 1)^(-1)
vector<int64> inv_p2m1;
// inv_p2m1_sq[k] = ((2^k - 1)^2)^(-1)
vector<int64> inv_p2m1_sq;

// sum_k_p2[k] = sum_{i=1 to k} i * 2^i
vector<int64> sum_k_p2;
// sum_k_sq_p2[k] = sum_{i=1 to k} i^2 * 2^i
vector<int64> sum_k_sq_p2;
// mex1_contrib_seg[k] = mex=1时，长度为k的连续段的贡献
vector<int64> mex1_contrib_seg;

// 预处理所有需要用到的值
void precompute(int n) {
    p2.resize(n + 2);
    inv_p2m1.resize(n + 2);
    inv_p2m1_sq.resize(n + 2);
    sum_k_p2.resize(n + 1);
    sum_k_sq_p2.resize(n + 1);
    mex1_contrib_seg.resize(n + 1);

    p2[0] = 1;
    for (int i = 1; i <= n + 1; ++i) {
        p2[i] = (p2[i - 1] * 2) % MOD;
    }

    for (int i = 1; i <= n + 1; ++i) {
        inv_p2m1[i] = modInverse((p2[i] + MOD - 1) % MOD);
        inv_p2m1_sq[i] = (inv_p2m1[i] * inv_p2m1[i]) % MOD;
    }
    
    // 预计算 sum i*2^i 和 sum i^2*2^i
    sum_k_p2[0] = 0;
    sum_k_sq_p2[0] = 0;
    for (int k = 1; k <= n; ++k) {
        sum_k_p2[k] = (sum_k_p2[k - 1] + k * p2[k]) % MOD;
        sum_k_sq_p2[k] = (sum_k_sq_p2[k - 1] + (int64)k * k % MOD * p2[k]) % MOD;
    }
    
    // 预计算 mex=1 时，长度为 len 的段的贡献
    for (int len = 1; len <= n; ++len) {
        int64 term1 = ((int64)(len + 1) * sum_k_p2[len]) % MOD;
        int64 term2 = sum_k_sq_p2[len];
        mex1_contrib_seg[len] = (term1 - term2 + MOD) % MOD;
    }
}

// 计算 arithmetico-geometric series: sum_{k=0 to len} k * q^k
int64 sum_k_q_k(int64 len, int64 q, int64 q_len_plus_1, int m) {
    int64 q_minus_1 = (q + MOD - 1) % MOD;
    int64 term1 = ((len + 1) % MOD * q_len_plus_1) % MOD;
    int64 term2 = (q * (q_len_plus_1 + MOD - 1)) % MOD * inv_p2m1[m] % MOD;
    int64 num = (term1 - term2 + MOD) % MOD;
    return (num * inv_p2m1[m]) % MOD;
}

// 计算一个特定 mex=m 的总贡献
int64 calculate_mex_contribution(int m, int L, int R, int pos_m, int n) {
    // 特殊情况: mex = 1
    if (m == 1) {
        int64 left_len = pos_m - 1;
        int64 right_len = n - pos_m;
        int64 res = 0;
        if (left_len > 0) res = (res + mex1_contrib_seg[left_len]) % MOD;
        if (right_len > 0) res = (res + mex1_contrib_seg[right_len]) % MOD;
        return res;
    }

    // L, R 是 {1..m-1} 的位置范围, pos_m 是 m 的位置
    // 如果 m 的位置在 {1..m-1} 的位置范围内，这是不可能的
    if (pos_m >= L && pos_m <= R) return 0;

    int64 q = p2[m];
    int64 w = R - L + 1;
    int64 A, B;

    if (pos_m < L) { // m 在左边
        A = L - pos_m - 1;
        B = n - R;
    } else { // m 在右边
        A = L - 1;
        B = pos_m - R - 1;
    }

    // 计算几何级数和: sum_{k=0 to len} q^k = (q^(len+1) - 1) / (q - 1)
    int64 q_A_plus_1 = power(q, A + 1);
    int64 q_B_plus_1 = power(q, B + 1);
    int64 sum_q_A = (q_A_plus_1 + MOD - 1) % MOD * inv_p2m1[m] % MOD;
    int64 sum_q_B = (q_B_plus_1 + MOD - 1) % MOD * inv_p2m1[m] % MOD;

    // 计算差比级数和: sum_{k=0 to len} k*q^k
    int64 sum_k_q_A = sum_k_q_k(A, q, q_A_plus_1, m);
    int64 sum_k_q_B = sum_k_q_k(B, q, q_B_plus_1, m);
    
    // 组合各项
    int64 term_w = (w % MOD * sum_q_A % MOD * sum_q_B) % MOD;
    int64 term_A = (sum_k_q_A * sum_q_B) % MOD;
    int64 term_B = (sum_q_A * sum_k_q_B) % MOD;
    
    int64 total_sum_part = (term_w + term_A + term_B) % MOD;
    int64 res = (m * power(q, w) % MOD * total_sum_part) % MOD;
    
    return res;
}

int main() {
    // 让输入输出更快一点，喵~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, q;
    cin >> n;

    vector<int> a(n + 1);
    vector<int> value_to_pos(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        value_to_pos[a[i]] = i;
    }

    precompute(n);

    // --- 预处理前缀最小/最大和次小/次大位置 ---
    const int INF = n + 1;
    vector<int> min_pos1(n + 2, INF), min_pos2(n + 2, INF);
    vector<int> max_pos1(n + 2, 0), max_pos2(n + 2, 0);

    min_pos1[0] = INF; max_pos1[0] = 0; // m=1时，{1..0}是空集
    for (int v = 1; v <= n; ++v) {
        int p = value_to_pos[v];
        min_pos1[v] = min_pos1[v - 1]; min_pos2[v] = min_pos2[v - 1];
        max_pos1[v] = max_pos1[v - 1]; max_pos2[v] = max_pos2[v - 1];
        
        if (p < min_pos1[v]) { min_pos2[v] = min_pos1[v]; min_pos1[v] = p; }
        else if (p < min_pos2[v]) { min_pos2[v] = p; }

        if (p > max_pos1[v]) { max_pos2[v] = max_pos1[v]; max_pos1[v] = p; }
        else if (p > max_pos2[v]) { max_pos2[v] = p; }
    }

    // --- 计算初始答案 F0 ---
    vector<int64> initial_contrib(n + 2);
    int64 F0 = 0;
    for (int m = 1; m <= n + 1; ++m) {
        int L, R, pos_m;
        if (m == 1) {
            L = INF; R = 0;
        } else {
            L = min_pos1[m - 1]; R = max_pos1[m - 1];
        }
        pos_m = (m <= n) ? value_to_pos[m] : INF; // mex=n+1时，n+1不在数组里
        
        initial_contrib[m] = calculate_mex_contribution(m, L, R, pos_m, n);
        F0 = (F0 + initial_contrib[m]) % MOD;
    }

    // --- 处理询问 ---
    cin >> q;
    while (q--) {
        int u, v;
        cin >> u >> v;

        if (u == v) {
            cout << F0 << "\n";
            continue;
        }
        if (u > v) swap(u, v);

        int pos_u = value_to_pos[u];
        int pos_v = value_to_pos[v];
        int64 delta = 0;
        
        // 只需更新 m 从 u 到 v+1 的贡献
        for (int m = u; m <= v + 1 && m <= n + 1; ++m) {
            delta = (delta - initial_contrib[m] + MOD) % MOD;

            int L_old = (m==1) ? INF : min_pos1[m-1];
            int R_old = (m==1) ? 0 : max_pos1[m-1];

            int L_new = L_old, R_new = R_old;
            // 更新 L, R
            if (m > u && m <= v) { // {1..m-1} 包含 u 但不包含 v
                if (L_old == pos_u) L_new = min(pos_v, min_pos2[m-1]);
                else L_new = min(L_old, pos_v);

                if (R_old == pos_u) R_new = max(pos_v, max_pos2[m-1]);
                else R_new = max(R_old, pos_v);
            }
            
            int pos_m_new;
            if (m == u) pos_m_new = pos_v;
            else if (m == v) pos_m_new = pos_u;
            else pos_m_new = (m <= n) ? value_to_pos[m] : INF;

            int64 new_contrib = calculate_mex_contribution(m, L_new, R_new, pos_m_new, n);
            delta = (delta + new_contrib) % MOD;
        }
        
        int64 final_ans = (F0 + delta + MOD) % MOD;
        cout << final_ans << "\n";
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N + Q \cdot (y-x))$。
  - **预计算**: 我们需要预处理幂、逆元、级数和、前缀最小/最大/次小/次大位置等。所有这些都可以在 $O(N)$ 的时间内完成，喵。
  - **初始计算**: 计算初始的 $F_0$ 需要遍历 $m$ 从 $1$ 到 $n+1$，每次计算是 $O(1)$ 的，所以总共是 $O(N)$。
  - **查询**: 对于每次查询 $(u, v)$，我们最坏情况下需要遍历 $m$ 从 $u$ 到 $v+1$。区间 $[u, v]$ 的长度最大可以是 $O(N)$。所以单次查询最坏是 $O(N)$，总查询时间是 $O(Q \cdot N)$。
  - **为什么能过呢？** 实际上，查询的循环中可以加入一个优化：如果某次更新后，新的 $L, R$ 和旧的 $L, R$ 相同了，那么对于更大的 $m$，它们也不会改变，可以直接 `break`。这使得在随机数据和大多数情况下，每次查询的平均更新次数远小于 $N$，接近于一个小的常数。所以，虽然最坏复杂度很高，但平均（摊还）复杂度是可以接受的，算法才能通过~

- **空间复杂度**: $O(N)$。
  - 我们需要存储排列 `a`、位置数组 `value_to_pos`，以及各种预计算的数组，它们的大小都和 $N$ 呈线性关系，所以空间复杂度是 $O(N)$ 的说。

## 知识点总结

这道题真是一次奇妙的冒险，喵~ 我们用到了好多有趣的工具呢！

1.  **贡献法**: 这是解决复杂求和问题的强大思想！当直接枚举求和项困难时，可以转换思路，去计算每个可能“组件”的贡献。在这里，我们计算了每个可能的 `mex` 值的贡献。
2.  **数学推导与级数求和**: 问题的核心在于推导出计算贡献的公式，这涉及到了等比数列求和 $\sum q^k$ 和差比数列求和 $\sum k \cdot q^k$。熟练掌握这些公式是解题的关键。
3.  **预计算/动态规划思想**: 很多看似复杂的值，比如前缀最小/最大位置，或者级数和，都可以通过 $O(N)$ 的预处理得到。这体现了用空间换时间的思想。
4.  **增量更新**: 对于有修改的查询，一个重要的技巧是不要从头计算，而是基于旧答案，只计算变化的部分。我们分析出只有特定范围的 `mex` 贡献会变，大大减少了计算量。

希望本猫娘的题解对你有帮助哦！继续加油，探索更多算法的奥秘吧，喵~ 🐾