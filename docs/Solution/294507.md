# mex - 题解

### 比赛与标签
> **比赛**: 「StOI-R2」Div.1
> **标签**: 数学, 数据结构, 分治, 逆元, 快速幂
> **难度**: *2800

## 题目大意喵~
主人，这道题是说，我们有一个从 1 到 n 的整数组成的排列 `a`。

首先，我们要理解几个概念呐：
1.  `mex(i, j)`：它指的是在子数组 `a[i...j]` 中，**最小的、没有出现过的正整数**。比如说，如果子数组是 `{2, 3, 5}`，那 `mex` 就是 `1`。如果子数组是 `{1, 3, 4}`，那 `mex` 就是 `2`。
2.  `t(i, j)`：这个值是子数组的**长度**乘以它的 `mex` 值，也就是 `(j - i + 1) * mex(i, j)`。
3.  `F(a)`：这是我们要计算的目标函数，它把所有可能的子数组 `a[i...j]` 的 `t(i, j)` 值都算出来，然后求和 `Σ (2^(t(i,j)) * t(i,j))`。

这道题是困难版本，和简单版的区别在于，它不是只算一次 `F(a)`。而是有 `q` 次独立的询问。每次询问会给出两个**值** `x` 和 `y`，我们需要：
1.  在**原始**排列中，找到值为 `x` 和 `y` 的元素，然后交换它们的位置。
2.  对这个**新的**排列，计算出 `F(a')` 的值。
3.  每次询问都是独立的，下一次询问还是在最开始的那个排列上进行操作。

最后结果要对 `998244353` 取模哦！

## 解题思路大解析喵！

这么大的数据量（`n, q` 都是 `2e5`），每次询问都暴力计算所有子数组肯定会超时的说！`O(q * n^2)` 的复杂度，想想都可怕喵 >.<。所以，我们必须找到更聪明的办法！

### 核心思想：贡献法

当一个求和公式特别复杂，直接遍历求和行不通时，我们可以换个角度思考，这就是“贡献法”的魅力所在喵！

我们不遍历所有的子数组 `[i, j]`，而是考虑每个可能的 `mex` 值对总答案 `F` 的贡献。`mex` 的值可以从 `1` 取到 `n+1`。
所以，我们的总和 `F(a)` 可以写成：
`F(a) = Σ_{m=1 to n+1} (所有 mex(i, j) = m 的子数组 [i, j] 的贡献之和)`

### `mex = m` 的贡献分析

好，那现在的问题就变成了：对于一个固定的 `m`，如何计算所有 `mex(i, j) = m` 的子数组的贡献总和呢？

一个子数组 `a[i...j]` 的 `mex` 等于 `m`，需要满足两个条件：
1.  子数组 `a[i...j]` 必须包含所有整数 `{1, 2, ..., m-1}`。
2.  子数组 `a[i...j]` **不能**包含整数 `m`。

为了方便处理，我们先预处理一个 `pos` 数组，`pos[v]` 记录数值 `v` 在排列 `a` 中的位置（下标）。

设 `L = min{pos[1], ..., pos[m-1]}`，`R = max{pos[1], ..., pos[m-1]}`。
要满足条件1，子数组 `a[i...j]` 必须完全覆盖住 `[L, R]` 这个区间，也就是说 `i ≤ L` 且 `j ≥ R`。

同时，要满足条件2，`pos[m]` 必须在区间 `[i, j]` 之外。

于是，我们就可以根据 `pos[m]` 和区间 `[L, R]` 的相对位置来计算贡献了。

#### 贡献公式的推导（数学能量注入！）

假设 `pos[m]` 在 `[L, R]` 之外（如果在里面，`mex` 就不可能是 `m`，贡献为0）。我们以 `pos[m] < L` 为例来推导。

此时，合法的 `i` 和 `j` 需要满足：`pos[m] < i ≤ L` 并且 `R ≤ j ≤ n`。
一个这样的子数组 `a[i...j]` 的长度是 `k = j - i + 1`，它的 `t` 值就是 `k * m`，对答案的贡献是 `t * 2^t = (k * m) * 2^(k * m)`。

我们把长度 `k` 拆解一下：
`k = (R - L + 1) + (L - i) + (j - R)`
`w = R - L + 1` 是核心区间的长度。
`l_extra = L - i` 是左边多出来的长度，范围是 `0` 到 `L - pos[m] - 1`。
`r_extra = j - R` 是右边多出来的长度，范围是 `0` 到 `n - R`。

设 `q = 2^m`，我们要计算的贡献和就是：
`Σ_{l_extra} Σ_{r_extra} m * (w + l_extra + r_extra) * q^(w + l_extra + r_extra)`

这个式子可以拆分成三项的和：
`m * q^w * [ w * (Σ q^l)(Σ q^r) + (Σ l*q^l)(Σ q^r) + (Σ q^l)(Σ r*q^r) ]`

这里的 `Σ q^l` 是等比数列求和，`Σ l*q^l` 是等比乘等差数列求和。它们都有固定的求和公式，我们可以预处理 `2` 的幂和模逆元来快速计算。代码中的 `contrib` 函数就是实现了这个复杂的数学公式，喵~

### 预处理是关键！

为了能快速计算贡献，我们需要一些预处理工作：
1.  `pos[v]`: 数值 `v` 的位置，`O(N)`。
2.  `pow2`, `inv1`, `inv2`: `2`的幂、`2^i-1` 的逆元等，用于贡献公式，`O(N log MOD)`。
3.  `S1`, `S2`: `Σ k*2^k` 和 `Σ k^2*2^k` 的前缀和，用于 `mex=1` 的特殊情况，`O(N)`。
4.  `mn1[v], mn2[v], mx1[v], mx2[v]`: 分别是数值 `1...v` 中，位置最小的两个和最大的两个。这个非常关键！有了它，我们就能在 `O(1)` 时间内知道任意 `m` 对应的 `L` 和 `R` (`L=mn1[m-1], R=mx1[m-1]`)。

### 处理查询：增量思想

我们先用上面的方法，计算出初始排列的答案 `F0`，并把每个 `mex=m` 的贡献 `orig[m]` 存起来。

当一个查询要求交换值 `x` 和 `y` (假设 `x < y`) 时，它们的旧位置是 `pos[x]` 和 `pos[y]`。
我们来分析一下，这个交换会影响哪些 `mex=m` 的贡献：
-   若 `m < x`：`{1...m-1}` 和 `m` 都不包含 `x, y`，`L, R, pos[m]` 都没变，贡献不变。
-   若 `m > y`：`{1...m-1}` 中同时包含了 `x, y`。交换它们的位置 `pos[x]` 和 `pos[y]`，但位置的集合没变，所以集合的最小/最大值 `L, R` 也不变。`pos[m]` 也没变。贡献不变。
-   若 `x ≤ m ≤ y`：这时 `m` 的贡献会发生变化！因为 `{1...m-1}` 中包含了 `x` 但不包含 `y`，交换后，`pos[x]` 这个位置被换成了 `pos[y]`，这会影响 `L` 和 `R` 的值。同时，如果 `m=x` 或 `m=y`，`pos[m]` 本身也变了。

所以，我们只需要重新计算 `m` 在 `[x, y]` 这个区间内的贡献！
对于每个受影响的 `m`，我们：
1.  计算出交换后新的 `L'` 和 `R'`。这就要用到我们预处理的 `mn2, mx2` 了。比如，如果原来的 `L` 就是 `pos[x]`，那么新的 `L'` 就是 `min(pos[y], mn2[m-1])`。
2.  计算出新的 `posm'`。
3.  用 `contrib` 函数算出新的贡献 `nw`。
4.  累加变化量 `delta += (nw - orig[m])`。

最后，本次查询的答案就是 `F0 + delta` 啦！

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
using int64 = long long;

// 快速幂函数，喵~
int64 mod_pow(int64 a, int64 e) {
    int64 r = 1;
    while (e) {
        if (e & 1) r = r * a % MOD;
        a = a * a % MOD;
        e >>= 1;
    }
    return r;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    if (!(cin >> n)) return 0;

    // a是排列，pos[v]记录数值v在a中的位置
    vector<int> a(n + 1), pos(n + 2);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        pos[a[i]] = i;
    }

    /* ---------- 预处理各种表，为计算做准备！ ---------- */
    // pow2[i] = 2^i
    vector<int64> pow2(n + 2);
    pow2[0] = 1;
    for (int i = 1; i <= n + 1; ++i) pow2[i] = pow2[i - 1] * 2 % MOD;

    // inv1[i] = (2^i - 1)^-1, inv2[i] = (2^i - 1)^-2
    vector<int64> inv1(n + 2), inv2(n + 2);
    for (int i = 1; i <= n + 1; ++i) {
        inv1[i] = mod_pow((pow2[i] + MOD - 1) % MOD, MOD - 2);
        inv2[i] = inv1[i] * inv1[i] % MOD;
    }

    // S1[k] = Σ_{i=1 to k} i*2^i, S2[k] = Σ_{i=1 to k} i^2*2^i
    vector<int64> S1(n + 2), S2(n + 2);
    for (int k = 1; k <= n; ++k) {
        S1[k] = (S1[k - 1] + (int64)k * pow2[k]) % MOD;
        S2[k] = (S2[k - 1] + (int64)k * k % MOD * pow2[k]) % MOD;
    }

    // seg[len] 是当mex=1时，一个长度为len的连续段的总贡献
    vector<int64> seg(n + 1);
    for (int len = 1; len <= n; ++len) {
        seg[len] = ((int64)(len + 1) * S1[len] - S2[len]) % MOD;
        if (seg[len] < 0) seg[len] += MOD;
    }

    /* ---------- 预处理1...v中位置的最小/最大值 ---------- */
    const int INF = n + 1;
    vector<int> mn1(n + 1, INF), mn2(n + 1, INF); // 最小和次小的位置
    vector<int> mx1(n + 1, 0), mx2(n + 1, 0);     // 最大和次大的位置
    for (int v = 1; v <= n; ++v) {
        int p = pos[v];
        // 继承前一个v-1的结果
        mn1[v] = mn1[v - 1]; mn2[v] = mn2[v - 1];
        mx1[v] = mx1[v - 1]; mx2[v] = mx2[v - 1];
        // 插入p，更新最小/最大值
        if (p < mn1[v]) { mn2[v] = mn1[v]; mn1[v] = p; }
        else if (p < mn2[v]) mn2[v] = p;

        if (p > mx1[v]) { mx2[v] = mx1[v]; mx1[v] = p; }
        else if (p > mx2[v]) mx2[v] = p;
    }

    /* ---------- 计算固定mex=m的贡献的函数 ---------- */
    auto contrib = [&](int m, int L, int R, int posm) -> int64 {
        if (L > R) { // 特殊情况: m=1, {1...m-1}是空集
            int64 res = (seg[posm - 1] + seg[n - posm]) % MOD;
            return res;
        }
        if (posm >= L && posm <= R) return 0; // pos[m]在[L,R]内，mex不可能是m
        
        int64 q = pow2[m];
        int64 w = R - L + 1;
        int64 A, B; // 左右可以扩展的长度
        if (posm < L) { A = L - posm - 1; B = n - R; }
        else          { A = L - 1;        B = posm - R - 1; }

        // 等比数列求和: Σ q^i
        int64 qA1 = mod_pow(q, A + 1);
        int64 qB1 = mod_pow(q, B + 1);
        int64 Sa0 = (qA1 + MOD - 1) % MOD * inv1[m] % MOD;
        int64 Sb0 = (qB1 + MOD - 1) % MOD * inv1[m] % MOD;

        // 等差乘等比数列求和: Σ i*q^i
        auto S1k = [&](int64 len, int64 qlen1) -> int64 {
            int64 num = ( ( (len + 1) % MOD) * qlen1 % MOD * ( (q + MOD - 1) % MOD ) % MOD
                        - q * ( (qlen1 + MOD - 1) % MOD ) % MOD + MOD ) % MOD;
            return num * inv2[m] % MOD;
        };
        int64 Sa1 = S1k(A, qA1);
        int64 Sb1 = S1k(B, qB1);

        // 套用我们推导的公式喵~
        int64 term = ( w % MOD * Sa0 % MOD * Sb0 % MOD
                     + Sa1 * Sb0 % MOD
                     + Sa0 * Sb1 % MOD ) % MOD;
        int64 res  = (int64)m * mod_pow(q, w) % MOD * term % MOD;
        return res;
    };

    // 计算初始排列的总答案 F0
    vector<int64> orig(n + 2);
    int64 F0 = 0;
    for (int m = 1; m <= n + 1; ++m) {
        int L, R, posm;
        if (m == 1) {
            L = n + 1; R = 0; posm = pos[1];
        } else if (m <= n) {
            L = mn1[m - 1]; R = mx1[m - 1]; posm = pos[m];
        } else { // m == n + 1
            L = mn1[n];  R = mx1[n];   posm = n + 1; // 虚拟位置
        }
        orig[m] = contrib(m, L, R, posm);
        F0 = (F0 + orig[m]) % MOD;
    }

    /* ---------- 回答查询 ---------- */
    int qn;  cin >> qn;
    while (qn--) {
        int x, y; cin >> x >> y; // 交换值为x和y的元素
        if (x == y) { cout << F0 << '\n'; continue; }
        if (x > y) swap(x, y);
        int px = pos[x], py = pos[y];
        int64 delta = 0; // 答案的变化量

        // 只用重新计算 m 在 [x, y] 区间的贡献
        for (int m = x; m <= y; ++m) {
            int64 old = orig[m]; // 旧的贡献

            int L, R, posm_new;
            if (m == 1) { // 这个分支在 m>=x>=1 时其实不会走到，但为了逻辑完整
                L = n + 1; R = 0;
            } else {
                // 计算交换后新的 L 和 R
                L = mn1[m - 1]; R = mx1[m - 1];
                int mn2v = mn2[m - 1], mx2v = mx2[m - 1];

                bool hasX = (x < m);
                // bool hasY = (y < m); // y < m 不可能，因为 m <= y

                if (hasX) { // {1...m-1}中包含x, 不包含y. pos[x]被换成了pos[y]
                    if (L == px)  L = min(py, mn2v);
                    else          L = min(L , py);
                    if (R == px)  R = max(py, mx2v);
                    else          R = max(R , py);
                }
            }
            
            // 计算交换后新的 posm
            if      (m == x) posm_new = py;
            else if (m == y) posm_new = px;
            else             posm_new = (m <= n ? pos[m] : n + 1);

            // 计算新贡献，累加差值
            int64 nw = contrib(m, L, R, posm_new);
            delta += nw - old;
            if (delta >= MOD) delta -= MOD;
            if (delta < 0)    delta += MOD;
        }
        int64 ans = F0 + delta;
        if (ans >= MOD) ans -= MOD;
        cout << ans << '\n';
    }
    return 0;
}
```

## 复杂度分析
-   **时间复杂度**: O(N log MOD + Σ|y_k - x_k|) 的说。
    -   预处理部分主要是求逆元和计算各种前缀信息，最耗时的是 `N` 次快速幂求逆元，为 `O(N log MOD)`。其他都是 `O(N)`。
    -   计算初始答案 `F0` 是 `O(N)`。
    -   对于每次查询 `(x, y)`，我们需要遍历 `m` 从 `x` 到 `y`，循环次数是 `|y-x|`。循环内部的操作都是 `O(1)`。所以一次查询是 `O(|y-x|)`。
    -   总时间就是预处理加上所有查询的时间。
-   **空间复杂度**: O(N) 的说。
    -   我们需要 `a`, `pos`, `pow2`, `inv`, `S1`, `S2`, `seg`, `mn/mx` 系列数组和 `orig` 数组来存储预处理信息和初始贡献，它们的大小都和 `N` 线性相关。

## 知识点与总结
这真是一道融合了多种思想的超棒题目呀！让咱来总结一下吧~

1.  **贡献法**: 解决复杂求和问题的万能钥匙！当直接求和行不通时，不妨换个角度，计算每个基本元素（这里是`mex`值）的贡献。
2.  **数学推导**: 算法竞赛不仅仅是敲代码，更是智慧的体操！本题的核心就是推导出 `mex=m` 的贡献公式，这需要扎实的等比数列和等差数列求和功底。
3.  **预处理与空间换时间**: 为了加速计算，我们预处理了大量信息（`pos`, `pow2`, `mn/mx`数组等）。这是用空间换取时间效率的经典策略。特别是 `mn1/mn2/mx1/mx2` 数组，它让我们能够 `O(1)` 更新 `L` 和 `R`，太巧妙了！
4.  **增量思想**: 对于带修改的查询问题，不要每次都从头计算！分析修改操作带来的影响，只更新受影响的部分，计算出答案的“变化量”（delta），是提高效率的关键。

希望这篇题解能帮助主人更好地理解这道题！如果还有不明白的地方，随时可以再来问咱哦！喵~ (ฅ'ω'ฅ)