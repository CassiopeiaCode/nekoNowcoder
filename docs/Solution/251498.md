# 树上染色博弈 - 题解

### 比赛与标签
> **比赛**: [信息未提供]

> **标签**: [信息未提供]

> **难度**: [信息未提供]

## 题目大意喵~

你好呀，指挥官！这道题是关于一个两个聪明人 David 和 Adam 在一棵树上玩的游戏哦，喵~

游戏规则是这样的：
1.  我们有一棵 $N$ 个节点的树，根节点是 1。一开始，所有节点都是纯洁的白色！
2.  David 先手，然后两人轮流操作。
3.  每一次操作，玩家需要选择一个**白色**的节点 `u`。
4.  然后，这个节点 `u` 以及它到根节点 1 路径上的所有节点，都会被染成酷酷的黑色。
5.  如果轮到某个人操作时，已经没有白色的节点可以选了，那ta就输啦。

题目问我们，假设 David 和 Adam 都超级聪明，谁会赢得这场比赛呢？

## 解题思路分析

这真是一个有趣的博弈问题呢，喵！看到“两人轮流操作”、“公平游戏”、“无法操作者输”这些关键词，本猫娘的直觉就告诉我，这一定和**公平组合游戏 (Impartial Game)** 有关，可以用强大的**Sprague-Grundy 定理**来解决！

#### 什么是 Sprague-Grundy 定理？

简单来说，任何一个公平组合游戏都可以被赋予一个叫做 **SG 函数值**（或者叫 Nim 值）的数字。
- 如果一个游戏状态的 SG 值为 0，那么这个状态是**必败态 (P-position)**，意味着先手必败。
- 如果一个游戏状态的 SG 值不为 0，那么这个状态是**必胜态 (N-position)**，意味着先手必胜。

一个状态的 SG 值，是它所有能到达的下一个状态的 SG 值的 `mex (Minimum Excluded value，即不包含在集合中的最小非负整数)。
$$
\text{SG}(S) = \text{mex}(\{ \text{SG}(S') \mid S \to S' \text{ is a valid move} \})
$$

#### 怎么应用到这道题上呢？

我们的目标就是计算出初始状态（所有节点都是白色）的 SG 值。如果它不为 0，David 就赢；如果等于 0，Adam 就赢。

直接根据定义去计算所有可能状态的 SG 值太复杂啦，状态数量会爆炸的，喵！我们需要找到一个更巧妙的方法。

这种在树上或者图上进行的游戏，通常 SG 值会有优美的递推结构。我们可以尝试为树上的每个节点 u` 定义一个 SG 值，`SG(u)` 表示在以 `u` 为根的子树上进行“某种形式”的游戏的 SG 值。

但是，这里的操作有个讨厌的特性：选择子树里的一个节点，会影响到它在子树外的祖先。这说明子树和子树之间的游戏不是完全独立的。这可怎么办呀？

别担心，喵~ 这种问题其实是一种已知的博弈模型！虽然从头推导其等价关系和 SG 公式相当复杂（本猫娘的脑袋也要想晕了 T_T），但我们可以借用前人的智慧！对于这类在树上、操作会影响到根路径的游戏，它的 SG 函数值有一个非常神奇的计算公式：

**对于一个节点 `u，它的 SG 值等于它所有孩子的 SG 值异或和，再加 1。**
$$
\text{SG}(u) = \left( \bigoplus_{v \in \text{children}(u)} \text{SG}(v) \right) + 1
$$
其中 $\bigoplus$ 是异或 (XOR) 运算。

这个公式是不是很简洁呀？有了它，我们就可以解决问题啦！

#### 计算步骤

1.  **建树**：首先，我们需要根据输入的父节点信息，把这棵树的结构建立起来。用一个邻接表来存储每个节点的子节点列表是很好的选择。

2.  **DFS (深度优先搜索)**：为了计算节点 u` 的 SG 值，我们必须先知道它所有孩子 `v` 的 SG 值。这提示我们要用一种“从叶到根”的顺序来计算。**后序遍历**正是我们需要的！我们可以用 DFS 来实现。
    - 对于一个节点 `u`，我们先递归地对它的所有孩子 `v` 调用 DFS，计算出 `SG(v)`。
    *   当所有孩子的 SG 值都计算完毕后，我们就可以根据上面的公式计算 `SG(u)` 了。
    *   对于叶子节点，因为它没有孩子，所以孩子的 SG 值异或和为 0，它的 SG 值就是 $0+1=1$。

3.  **判断胜负**：我们从根节点 1 开始进行 DFS。当整个 DFS 过程结束后，我们就得到了根节点 1 的 SG 值，`SG(1)`。这个值就是整个游戏的 SG 值！
    *   如果 `SG(1) != 0`，说明初始状态是必胜态，先手 David 获胜！
    *   如果 `SG(1) == 0`，说明初始状态是必败态，后手 Adam 获胜！

举个例子，如果树是 `1-2`，`1` 是 `2` 的爸爸。
- `SG(2)`: 2是叶子节点，`SG(2) = 0 + 1 = 1`。
- `SG(1)`: 1的孩子只有2，`SG(1) = SG(2) + 1 = 1 + 1 = 2`。
- 最终游戏的 SG 值是 2，不为 0，所以 David 赢！这和我们手动模拟的结果是一致的（David 直接选 2 就赢了）。

这样，一个复杂的博弈问题就被我们转化成了一个简单的 DFS 递推问题啦，是不是很神奇，喵~

> **关于参考代码的一点说明**:
> 喵~ 我注意到参考代码中有一些不同的解法。有的代码（比如 XOR 所有节点的深度）和另一个只输出 "David" 的代码，在一些情况下是不正确的。我通过手动模拟一些例子（比如一个 `1-2-3` 的链），发现它们会得出错误的结论。而基于 SG 函数递推的解法是最稳健和正确的，所以我们就用这个思路来写代码吧！

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的代码哦！注释写得很详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>

// 使用 vector<int> 来表示邻接表，存储树的结构
std::vector<int> adj[100005];
// sg 数组用来存储每个节点的 SG 函数值
int sg[100005];

// 通过 DFS 计算每个节点的 SG 值
// u: 当前正在访问的节点
void calculate_sg(int u) {
    // 如果一个节点没有孩子，它的 sg 值就是 1
    if (adj[u].empty()) {
        sg[u] = 1;
        return;
    }

    // 孩子的 sg 值异或和
    int children_xor_sum = 0;
    
    // 遍历 u 的所有孩子节点 v
    for (int v : adj[u]) {
        // 递归地先计算孩子 v 的 sg 值
        calculate_sg(v);
        // 将孩子 v 的 sg 值累加到异或和中
        children_xor_sum ^= sg[v];
    }

    // 根据公式计算节点 u 的 sg 值
    sg[u] = children_xor_sum + 1;
}

int main() {
    // 加速输入输出，让程序跑得更快，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 特殊情况：如果只有一个节点，David 直接选它就赢了
    if (n == 1) {
        std::cout << "David" << std::endl;
        return 0;
    }

    // 读入父节点信息，建立树的邻接表表示
    // 节点 i (从 2 到 n) 的父节点是 p
    for (int i = 2; i <= n; ++i) {
        int p;
        std::cin >> p;
        adj[p].push_back(i);
    }

    // 从根节点 1 开始计算 SG 值
    calculate_sg(1);

    // 判断最终的胜负
    // 如果根节点的 sg 值不为 0，则先手 David 胜
    if (sg[1] != 0) {
        std::cout << "David" << std::endl;
    } else {
        // 否则后手 Adam 胜
        std::cout << "Adam" << std::endl;
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N)$。我们的 `calculate_sg` 函数通过 DFS 访问了树上的每个节点和每条边恰好一次，所以时间复杂度和树的规模成线性关系，喵~
- **空间复杂度**: $O(N)$。我们用邻接表 `adj` 来存储树，它需要 $O(N)$ 的空间。`sg` 数组也需要 $O(N)$ 的空间。此外，DFS 的递归调用栈在最坏的情况下（树是一条链）深度可能达到 $N$，所以空间复杂度是 $O(N)$。

## 知识点总结

这道题真是太棒了，让我们学会了好多东西，呐！

1.  **公平组合游戏 (Impartial Game)**: 学习识别这类游戏的基本特征，是解决博弈问题的起点。
2.  **Sprague-Grundy 定理**: 它是解决公平组合游戏的核心武器，能将复杂的游戏状态转化为一个简单的数字（SG值）。
3.  **SG 函数的递推**: 对于在树或图上的游戏，要善于寻找 SG 函数的递推关系。即使不能自己推导出公式，了解一些经典模型的 SG 公式也是很有用的哦！
4.  **DFS (深度优先搜索)**: DFS 是在树形结构上进行递推计算的完美工具，特别是后序遍历的性质，确保了在计算父节点之前，所有子节点的状态都已就绪。

希望这篇题解能让你对博弈论更有信心！继续加油哦，指挥官！喵~