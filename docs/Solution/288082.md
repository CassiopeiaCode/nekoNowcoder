# N车问题与随机禁止区域 - 题解

### 比赛与标签
> **比赛**: [未提供]

> **标签**: [未提供]

> **难度**: [未提供]

## 题目大意喵~

各位Master，下午好喵~ 今天我们来解决一个有趣的棋盘问题！

题目是这样的：在一个 $n \times n$ 的棋盘上（这里的 $n$ 保证是偶数哦），我们要放置 $n$ 个象棋的“车”。放置的规则是，任何两个车都不能互相攻击，也就是说，每一行、每一列都只能有一个车，喵~

但是呢，事情没那么简单！棋盘上有一些“禁止区域”，我们不能在这些位置上放车。这些禁止区域是这么产生的：

1.  设 $m = n/2$。
2.  我们先生成一个包含数字 $1, 2, \ldots, m$ 的排列 $p$。比如当 $n=6, m=3$ 时，一个可能的排列是 $p = (2, 3, 1)$。
3.  然后，我们把这个排列 $p$ 完全打乱，得到一个随机排列。
4.  对于打乱后的排列 $p$，我们从 $i=1$ 到 $m$ 遍历，对每一个 $i$ 和对应的 $p_i$，在棋盘上标记三个禁止格点：
    *   $(2 \times p_i - 1, 2 \times i - 1)$
    *   $(2 \times p_i, 2 \times i - 1)$
    *   $(2 \times p_i, 2 \times i)$

因为生成的排列 $p$ 是随机的，所以禁止区域的位置也是随机的。我们的任务是，计算在所有可能的随机棋盘下，放置 $n$ 个不互相攻击的车的**方案数的期望值**。

最后，要把这个期望值对 $998244353$ 取模后输出，喵~

## 解题思路分析

这道题看起来好复杂呀，又是随机又是期望的，但别怕，跟着我的猫爪印一步步来，就能找到线索啦！

### 第一步：将期望问题转化为计数问题

期望问题的经典处理方式是利用**期望的线性性**。

一个放置方案，就是找一个排列 $\sigma$，把车放在 $(i, \sigma_i)$ 的位置上，$i=1, \ldots, n$。总共有 $n!$ 种这样的放置方案。

对于一个特定的放置方案 $\sigma$ 和一个特定的禁止区域生成排列 $p$，我们说这个方案是**可行**的，当且仅当它没有用到任何被 $p$ 禁止的格子。

我们要求的是可行方案数的期望值。设 $X$ 是可行方案数，它是一个随机变量，依赖于随机的排列 $p$。
$$
E[X] = \sum_{\text{所有排列 } p} P(p) \cdot (\text{在 } p \text{ 下的可行方案数})
$$
由于排列 $p$ 是完全随机的，共 $m!$ 种，每种出现的概率都是 $1/m!$。

这个公式直接计算太麻烦了。我们换个角度。让 $I_\sigma$ 作为一个指示变量，如果方案 $\sigma$ 在随机的 $p$ 下是可行的，则 $I_\sigma=1$，否则为 $0$。那么总方案数 $X = \sum_{\sigma} I_\sigma$。

根据期望的线性性：
$$
E[X] = E[\sum_{\sigma} I_\sigma] = \sum_{\sigma} E[I_\sigma]
$$
而 $E[I_\sigma]$ 就是方案 $\sigma$ 可行的概率 $P(\sigma \text{ is valid})$。所以：
$$
E[X] = \sum_{\text{所有 } n! \text{ 种方案 } \sigma} P(\sigma \text{ is valid})
$$
这个看起来还是很难，因为每个 $\sigma$ 的可行概率可能不同。

### 第二步：容斥原理登场！

当遇到“不能放在某些位置”的计数问题时，**容斥原理**是我们的好朋友！

对于一个**固定**的禁止区域棋盘 $B$，放置 $n$ 个不互相攻击的车且不碰到 $B$ 中任何格子的方案数，可以用容斥原理计算。令 $c_k(B)$ 表示在 $B$ 中放置 $k$ 个不互相攻击的车的方案数。那么，总方案数是：
$$
\text{方案数} = \sum_{k=0}^{n} (-1)^k c_k(B) (n-k)!
$$
我们的棋盘 $B$ 是由随机排列 $p$ 生成的，记为 $B(p)$。所以我们要求的是上面这个式子的期望值：
$$
E[\text{方案数}] = E\left[\sum_{k=0}^{n} (-1)^k c_k(B(p)) (n-k)!\right]
$$
再次利用期望的线性性，我们可以把期望算子放进求和里：
$$
E[\text{方案数}] = \sum_{k=0}^{n} (-1)^k E[c_k(B(p))] (n-k)!
$$
现在，核心问题就变成了计算 $E[c_k]$，也就是在随机生成的禁止区域上，放置 $k$ 个不互相攻击的车的方案数的期望值。

### 第三步：神奇的棋盘结构与 rook 多项式

$E[c_k]$ 到底是什么呢？这就要仔细观察禁止区域的生成方式了。

我们把 $n \times n$ 的棋盘想象成一个 $m \times m$ 的大棋盘，每个大格子是一个 $2 \times 2$ 的小区块。
*   **列区块** $i$：包含第 $2i-1$ 列和第 $2i$ 列。
*   **行区块** $j$：包含第 $2j-1$ 行和第 $2j$ 行。

排列 $p$ 的作用是，对于每个**列区块** $i$，它会指定一个**行区块** $p_i$，然后在这个行区块和列区块交叉的 $2 \times 2$ 区域里，禁止掉3个格子。具体来说，在由行区块 $p_i$ 和列区块 $i$ 构成的 $2 \times 2$ 子棋盘中，只有 $(2p_i-1, 2i)$ 这个格子是**不被**禁止的。

关键的“喵点”来了！因为 $p$ 是一个**排列**，所以每个行区块 $j$ 也只会被一个**唯一**的列区块 $i=p^{-1}(j)$ "配对" 来生成禁止格。

这意味着，如果我们按**行区块**来观察，每个行区块 $j$ 里的禁止格都集中在唯一的列区块 $p^{-1}(j)$ 中。不同的行区块里的禁止格，它们所在的列区块也一定不同。

这意味着什么呢？整个棋盘的禁止区域 $B(p)$ 可以被分解成 $m$ 个**互不相干**的小区域！每个小区域 $B'_j$ 是第 $j$ 个行区块里的所有禁止格。因为它们行不同、列也不同，所以在计算放置 $k$ 个不互相攻击的车时，它们是独立的！

这种情况下，组合数学里有一个强大的工具叫做**rook多项式**，$R(x, B) = \sum_{k \ge 0} c_k(B) x^k$。它的一个重要性质是，如果棋盘 $B$ 可以分解成互不相干的子棋盘 $B_1, B_2, \ldots, B_m$，那么 $R(x, B) = R(x, B_1) \cdot R(x, B_2) \cdots R(x, B_m)$。

我们的每个小区域 $B'_j$ 都是由3个禁止格组成的，位于行区块 $j$ 和某个列区块 $i$。这3个格子的 rook 多项式是多少呢？
*   $c_0=1$ (不放车)
*   $c_1=3$ (放1个车，有3个位置可选)
*   $c_2=1$ (放2个不攻击的车，只能是 $(2j-1, 2i-1)$ 和 $(2j, 2i)$)
*   $c_k=0$ for $k>2$.

所以，每个小区域的 rook 多项式都是 $1 + 3x + 1x^2$。

最神奇的地方是，这个多项式**与 $p$ 的具体值无关**！不管列区块 $i$ 是哪个，这3个格子的相对位置关系和它们的 rook 多项式都是一样的。

因此，对于**任何**一个随机排列 $p$，整个禁止区域的 rook 多项式都是：
$$
R(x, B(p)) = (1+3x+x^2)^m
$$
这意味着 $c_k(B(p))$ 的值对于任何 $p$ 都是一样的！所以 $E[c_k]$ 就等于任意一个 $c_k(B(p))$，也就是 $(1+3x+x^2)^m$ 中 $x^k$ 的系数！

### 第四步：最终的计算

我们把这个结论代回第二步的公式里。设 $B_k$ 是 $(1+3x+x^2)^m$ 中 $x^k$ 的系数，那么 $E[c_k] = B_k$。
最终的答案就是：
$$
\text{答案} = \sum_{k=0}^{n} (-1)^k B_k (n-k)! \pmod{998244353}
$$
现在问题就变成了一个纯粹的计算问题啦：
1.  **计算多项式幂**：我们需要计算 $P(x) = (1+3x+x^2)^m$ 的所有系数 $B_k$。直接乘太慢了，要用**多项式快速幂**。每次多项式乘法通过**NTT (数论变换)** 来加速，它是一种在模意义下的快速傅里叶变换。
2.  **预处理阶乘**：我们需要 $(n-k)!$ 的值，可以预先计算出 $0!$ 到 $n!$ 的所有值。
3.  **求和**：拿到系数 $B_k$ 和阶乘后，就可以遍历 $k$ 从 $0$ 到 $n$ 计算总和了。

整个算法的流程就清晰啦，喵~

## 代码实现

这是本猫娘根据上面的思路，重新为您烹制的代码佳肴~ 注释超详细的哦！

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 long long 防止计算时溢出
using ll = long long;

// 模数，一个常用的NTT模数
const int MOD = 998244353;
// NTT的原根
const int G = 3;

// 快速幂函数，计算 (base^exp) % MOD
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模逆元，用于NTT的逆变换
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// NTT（数论变换）核心实现
// a: 要变换的多项式系数
// invert: true表示逆变换，false表示正变换
void ntt(std::vector<ll>& a, bool invert) {
    int n = a.size();

    // 1. 位逆序置换 (Cooley-Tukey的第一步)
    // 使得递归计算时可以直接访问相邻元素
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) {
            std::swap(a[i], a[j]);
        }
    }

    // 2. 蝴蝶操作 (Cooley-Tukey的核心)
    // 从长度为2的子问题开始，倍增合并
    for (int len = 2; len <= n; len <<= 1) {
        ll wlen = power(G, (MOD - 1) / len);
        if (invert) {
            wlen = modInverse(wlen);
        }
        for (int i = 0; i < n; i += len) {
            ll w = 1;
            for (int j = 0; j < len / 2; j++) {
                ll u = a[i + j];
                ll v = (a[i + j + len / 2] * w) % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len / 2] = (u - v + MOD) % MOD;
                w = (w * wlen) % MOD;
            }
        }
    }

    // 3. 如果是逆变换，需要将结果除以n
    if (invert) {
        ll n_inv = modInverse(n);
        for (ll& x : a) {
            x = (x * n_inv) % MOD;
        }
    }
}

// 多项式乘法
std::vector<ll> multiply(std::vector<ll> a, std::vector<ll> b) {
    int deg_a = a.size() - 1;
    int deg_b = b.size() - 1;
    int res_deg = deg_a + deg_b;
    int n = 1;
    while (n < res_deg + 1) n <<= 1;

    a.resize(n);
    b.resize(n);

    ntt(a, false);
    ntt(b, false);

    std::vector<ll> c(n);
    for (int i = 0; i < n; i++) {
        c[i] = (a[i] * b[i]) % MOD;
    }

    ntt(c, true);
    c.resize(res_deg + 1);
    return c;
}

// 多项式快速幂
// base: 基底多项式
// exp: 指数
// max_deg: 结果多项式需要保留的最大次数
std::vector<ll> poly_pow(std::vector<ll> base, int exp, int max_deg) {
    std::vector<ll> res = {1}; // 结果初始化为多项式 1
    while (exp > 0) {
        if (exp % 2 == 1) {
            res = multiply(res, base);
            if (res.size() > max_deg + 1) {
                res.resize(max_deg + 1);
            }
        }
        base = multiply(base, base);
        if (base.size() > max_deg + 1) {
            base.resize(max_deg + 1);
        }
        exp /= 2;
    }
    return res;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    int m = n / 2;
    
    // 预处理阶乘
    std::vector<ll> fact(n + 1);
    fact[0] = 1;
    for (int i = 1; i <= n; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }

    // 基底多项式 P(x) = 1 + 3x + x^2
    std::vector<ll> base_poly = {1, 3, 1};
    
    // 计算 Q(x) = P(x)^m，结果的最高次数是 2m = n
    std::vector<ll> coefficients_B = poly_pow(base_poly, m, n);

    // 计算最终答案
    // ans = sum_{k=0 to n} (-1)^k * B_k * (n-k)!
    ll final_answer = 0;
    for (int k = 0; k <= n; ++k) {
        if (k >= coefficients_B.size()) break; // B_k 为 0，不用算了
        
        ll term = (coefficients_B[k] * fact[n - k]) % MOD;
        if (k % 2 == 1) { // k是奇数，项为负
            final_answer = (final_answer - term + MOD) % MOD;
        } else { // k是偶数，项为正
            final_answer = (final_answer + term) % MOD;
        }
    }

    std::cout << final_answer << std::endl;

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N \log N \log M)$，其中 $N=n$, $M=m$。
    *   多项式快速幂需要进行 $O(\log m)$ 次多项式乘法。
    *   每次多项式乘法的操作数由结果的度数决定，最大度数为 $n$。使用NTT进行一次度数最高为 $n$ 的多项式乘法，需要的时间是 $O(n \log n)$。
    *   预处理阶乘需要 $O(n)$。
    *   最后的求和需要 $O(n)$。
    *   所以总时间复杂度由多项式快速幂主导，为 $O(n \log n \log m)$。

*   **空间复杂度**: $O(N)$，其中 $N=n$。
    *   我们需要存储阶乘，大小为 $O(n)$。
    *   NTT和多项式乘法中，需要开辟大小为 $O(n)$ 的向量来存储多项式系数。

## 知识点总结

这道题是喵一个非常好的例子，把好几个知识点巧妙地融合在了一起！

1.  **期望的线性性**: 解决期望问题的第一把钥匙，能将复杂全局期望分解为简单局部期望的和。
2.  **容斥原理**: 经典的组合计数工具，处理“恰好”、“一个都不”这类约束的利器。
3.  **Rook多项式**: 解决棋盘上放置不攻击的车问题的数学工具。本题最巧妙的一步就是发现，无论随机排列是什么，禁止区域的Rook多项式都是不变的！
4.  **NTT (数论变换)**: 算法竞赛中多项式乘法的标准做法，是FFT在模算术下的变体。
5.  **多项式快速幂**: 将普通快速幂的思想应用到多项式上，用于高效计算多项式的幂。

通过这道题，我们可以学到如何一步步地将一个复杂的期望问题，通过数学推导，转化成一个可以用高效算法解决的计算问题。是不是很有趣呢，喵~