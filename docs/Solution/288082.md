# 车（easy） - 题解

### 比赛与标签
> **比赛**: 「StOI-2」Round 1
> **标签**: 期望, NTT, 多项式快速幂, 组合数学
> **难度**: *3000

## 题目大意喵~
各位master，晚上好呀~！今天我们遇到的，是一个关于在棋盘上放置棋子“车”的有趣问题，喵~

题目是这样子的：在一个 `n x n` 的棋盘上，我们要放置 `n` 个“车”。为了让它们和平共处，任何两个车都不能在同一行或同一列，这样它们就攻击不到对方啦。

但是呢，事情没有那么简单！棋盘上会有一些“禁止区域”，这些地方是不能放车的。这些禁止区域是随机生成的：
1.  首先，我们取 `m = n / 2` (题目保证 `n` 是偶数)。
2.  然后，随机生成一个 `1` 到 `m` 的排列 `p`。
3.  对于 `i` 从 `1` 到 `m`，棋盘上的 `(2*p_i - 1, 2*i - 1)`、`(2*p_i, 2*i - 1)` 和 `(2*p_i, 2*i)` 这三个位置会被标记为“禁止放置”。

因为排列 `p` 是随机的，所以我们得到的棋盘也是随机的。我们的任务就是，计算在所有可能的 `m!` 种棋盘上，放置 `n` 个互不攻击的车的平均方案数，也就是**期望方案数**，结果要对 `998244353` 取模哦~

## 解题思路喵~
这道题看起来又是期望又是随机排列，可能会让一些master感到头大，但别怕，跟着我的思路一步步来，就会发现其中的奥秘啦，喵~

#### 第一步：期望问题？容斥原理前来救驾！

看到“期望”，我们首先想到的神器就是**期望的线性性质**！`E[X+Y] = E[X] + E[Y]`。
而对于“在带禁区的棋盘上放棋子”这类问题，**容斥原理**和**Rook多项式（车多项式）**是我们的标准武器。

一个经典的组合数学结论是：在一个 `n x n` 棋盘上，给定一个禁区集合 `F`，放置 `n` 个互不攻击的棋子（即一个都不能放在`F`上）的方案数是：
`Ways(F) = ∑_{k=0}^{n} (-1)^k * r_k(F) * (n-k)!`
这里的 `r_k(F)` 指的是在禁区 `F` 中放置 `k` 个互不攻击的车的方案数。

我们要求的是方案数的期望 `E[Ways]`。根据期望的线性性质：
`E[Ways] = E[∑_{k=0}^{n} (-1)^k * r_k(F) * (n-k)!]`
`= ∑_{k=0}^{n} (-1)^k * E[r_k(F)] * (n-k)!`

哇！问题转化成求 `E[r_k(F)]`，也就是在随机禁区 `F` 中放置 `k` 个互不攻击的车的期望方案数。

#### 第二步：分析禁区结构与Rook多项式

`r_k(F)` 是 Rook 多项式 `R(F, x) = ∑ r_k(F)x^k` 的系数。所以 `E[r_k(F)]` 就是期望Rook多项式 `E[R(F, x)]` 的系数。

让我们仔细看看禁区 `F_p` 是怎么形成的。对于一个给定的排列 `p`，禁区是 `m` 个小块的并集：
`F_p = ∪_{i=1}^{m} Block(p_i, i)`
其中 `Block(p_i, i)` 是指由列 `2i-1, 2i` 和行 `2p_i-1, 2p_i` 决定的区域里的三个禁止格。

现在，最神奇的事情要发生了！我们来分析单个小块 `Block(R, C)`（这里 `R=p_i`, `C=i`）的Rook多项式。
这个小块的禁区是三个格子：`(2R-1, 2C-1)`, `(2R, 2C-1)`, `(2R, 2C)`。
- `r_0`: 放0个车，方案数是 `1`。
- `r_1`: 放1个车，有 `3` 个格子可选，方案数是 `3`。
- `r_2`: 放2个互不攻击的车，只能放在 `(2R-1, 2C-1)` 和 `(2R, 2C)`，方案数是 `1`。
- `r_k` (`k>2`): 方案数为 `0`。
所以，单个 `Block` 的 Rook 多项式是 `1 + 3x + x^2`。

#### 第三步：惊人的发现！

Rook多项式有一个美妙的性质：如果一个禁区可以被分解成若干个**行、列完全不相交**的子禁区，那么总的Rook多项式等于所有子禁区Rook多项式的乘积。

我们来看看 `F_p = ∪_{i=1}^{m} Block(p_i, i)` 中的这些小块：
- **列**：`Block(p_i, i)` 占用的列是 `{2i-1, 2i}`。对于不同的 `i` 和 `j`，列集 `{2i-1, 2i}` 和 `{2j-1, 2j}` 显然不相交。
- **行**：`Block(p_i, i)` 占用的行是 `{2p_i-1, 2p_i}`。因为 `p` 是一个排列，所以当 `i ≠ j` 时，`p_i ≠ p_j`，因此行集 `{2p_i-1, 2p_i}` 和 `{2p_j-1, 2p_j}` 也不相交！

这意味着，对于**任何一个**随机排列 `p`，禁区 `F_p` 都可以分解成 `m` 个行列互不相干的小禁区！每个小禁区的Rook多项式都是 `1 + 3x + x^2`。
所以，对于任意 `p`，总的Rook多项式都是：
`R(F_p, x) = (1 + 3x + x^2)^m`

#### 第四步：最终的公式

既然对于所有 `m!` 种可能的 `p`，Rook多项式都是一样的，那么它的期望 `E[R(F_p, x)]` 自然也就是 `(1 + 3x + x^2)^m` 啦！

设 `(1 + 3x + x^2)^m = ∑_{k=0}^{2m} B_k x^k`。
那么 `E[r_k(F)]` 就等于系数 `B_k`。
代入我们第一步的公式，令 `n=2m`：
`E[Ways] = ∑_{k=0}^{2m} (-1)^k * B_k * (2m-k)!`

#### 第五步：计算实现

现在问题就变成了一个纯粹的计算问题：
1.  **计算多项式幂**：我们需要计算 `(1 + 3x + x^2)^m` 的所有系数 `B_k`。直接模拟乘法太慢了，这里要用**多项式快速幂**。每次乘法通过**NTT (数论变换)** 来加速，NTT是FFT在模意义下的版本，可以实现 `O(N log N)` 的多项式乘法。
2.  **预处理阶乘**：我们需要 `(2m-k)!`，所以提前把 `0!` 到 `(2m)!` 都算出来存好。
3.  **求和**：最后，根据公式，把 `k` 从 `0` 到 `2m` 的所有项加起来，就得到最终答案了，喵~

总结一下，解题路径就是：
`期望问题` -> `容斥原理 + 期望线性性质` -> `分析禁区结构` -> `发现Rook多项式不变` -> `多项式快速幂(NTT) + 组合计数`。
是不是感觉豁然开朗了呢？

## 代码实现喵~
```cpp
// 由WIDA请求创建，模型型号：o3mini
// 说明：本题要求计算棋盘上摆放车的方案数期望，问题经过化简后可证明答案为
// ans = ∑ₖ₌₀^(2m) (–1)ᵏ·(2m–k)!·Bₖ mod M
// 其中 m = n/2，Bₖ 为多项式 (1+3x+x²)ᵐ 中 xᵏ 的系数。
// 本代码使用 NTT 求多项式快速幂，并预处理阶乘，最终求和输出结果。
// 算法核心：NTT、多项式快速幂、组合数学
  
#include "testlib.h"
#include <bits/stdc++.h>
using namespace std;
  
typedef long long ll;
  
const int MOD = 998244353; // 模数，NTT常用
  
// 快速幂，用于计算模逆元等
ll modexp(ll a, ll b, int mod=MOD) {
 ll res = 1;
 a %= mod;
 while(b) {
 if(b & 1) res = (res * a) % mod;
 a = (a * a) % mod;
 b >>= 1;
 }
 return res;
}
  
// NTT（数论变换）实现，n 必须为 2 的幂
void ntt(vector<int>& a, bool invert) {
 int n = a.size();
 // Bit-reversal permutation, 蝴蝶变换预处理
 for (int i = 1, j = 0; i < n; i++) {
 int bit = n >> 1;
 for(; j & bit; bit >>= 1)
 j ^= bit;
 j ^= bit;
 if(i < j) swap(a[i], a[j]);
 }
 // 从长度为2的块开始，逐层合并
 for (int len = 2; len <= n; len <<= 1) {
 int wlen = modexp(3, (MOD - 1) / len); // 单位根 g^((P-1)/len)
 if(invert) wlen = (int)modexp(wlen, MOD - 2); // 逆变换时用逆元
 for (int i = 0; i < n; i += len) {
 int w = 1;
 for (int j = 0; j < len/2; j++) {
 int u = a[i+j], v = (int)((ll)a[i+j+len/2] * w % MOD);
 a[i+j] = u+v < MOD ? u+v : u+v - MOD;
 a[i+j+len/2] = u-v >= 0 ? u-v : u-v+MOD;
 w = (int)((ll)w * wlen % MOD);
 }
 }
 }
 // 逆变换后需要除以 n
 if(invert) {
 int n_inv = (int)modexp(n, MOD-2);
 for (int & x : a)
 x = (int)((ll)x * n_inv % MOD);
 }
}
  
// 多项式相乘（利用NTT）
vector<int> polyMultiply(const vector<int>& a, const vector<int>& b) {
 int n = a.size(), m = b.size();
 int sz = 1;
 while(sz < n + m - 1) sz <<= 1; // 找到大于结果度数的最小2的幂
 vector<int> fa(sz), fb(sz);
 for (int i = 0; i < n; i++) fa[i] = a[i];
 for (int i = 0; i < m; i++) fb[i] = b[i];
 // 补零至长度 sz
 for (int i = n; i < sz; i++) fa[i] = 0;
 for (int i = m; i < sz; i++) fb[i] = 0;
 
 // 正变换
 ntt(fa, false); ntt(fb, false);
 // 点值相乘
 for (int i = 0; i < sz; i++){
 fa[i] = (int)((ll)fa[i] * fb[i] % MOD);
 }
 // 逆变换
 ntt(fa, true);
 fa.resize(n + m - 1); // 调整回正确的大小
 return fa;
}
  
// 多项式快速幂，计算 base^exp，结果只保留次数不超过 maxDeg 的项
vector<int> polyPow(vector<int> base, int exp, int maxDeg) {
 vector<int> res = {1}; // 初始化结果为多项式 1
 while(exp > 0){
 if(exp & 1) {
 res = polyMultiply(res, base);
 if((int)res.size() > maxDeg+1)
 res.resize(maxDeg+1); // 截断超过最高次的部分
 }
 base = polyMultiply(base, base);
 if((int)base.size() > maxDeg+1)
 base.resize(maxDeg+1); // 截断
 exp >>= 1;
 }
 return res;
}
  
// 全局存储阶乘
vector<int> fact;
  
// 预处理 0 ~ n 的阶乘
void precomputeFactorials(int n) {
 fact.resize(n+1);
 fact[0] = 1;
 for (int i = 1; i <= n; i++)
 fact[i] = (int)((ll)fact[i-1] * i % MOD);
}
  
int main(int argc, char* argv[]){
 ios::sync_with_stdio(false);
 cin.tie(nullptr);
 // 下面这部分是比赛用的模板，可以直接忽略喵
 registerValidation(argc, argv);
 // 读入棋盘边长 n（偶数，2 ≤ n ≤ 2×10^5）
 int n = inf.readInt(2, 200000, "n");
 if(n % 2 != 0)
 quitf(_wa, "n must be even");
 inf.readEoln();
 
 // 令 m = n/2
 int m = n / 2;
 // (1+3x+x^2)^m 的最高次数为 2*m
 int maxDeg = 2 * m;
 precomputeFactorials(maxDeg);
  
 // 定义多项式 P(x) = 1 + 3x + x^2
 vector<int> base = {1, 3, 1};
 // 计算 B(x) = (1+3x+x^2)^m，保留次数 0..2*m
 vector<int> poly = polyPow(base, m, maxDeg);
  
 // 答案 = ∑ₖ₌₀^(2*m) (–1)ᵏ · (2m – k)! · Bₖ mod MOD
 // 其中 Bₖ 为 B(x) 中 xᵏ 的系数
 int ans = 0;
 for (int k = 0; k <= maxDeg && k < (int)poly.size(); k++){
 int cur = poly[k]; // B_k
 int fterm = fact[maxDeg - k]; // (2m-k)!
 ll add = (ll)fterm * cur % MOD;
 if(k & 1) add = (MOD - add) % MOD; // 处理 (-1)^k
 ans = (ans + (int)add) % MOD;
 }
 cout << ans << "\n";
 inf.readEof();
 return 0;
}
```

## 复杂度分析喵~
- **时间复杂度**: `O(n log n log n)` 的说。
  - 核心计算是多项式快速幂 `polyPow`。它需要进行 `O(log m)` 次多项式乘法。
  - 每次多项式乘法 `polyMultiply` 使用NTT，对于最高次为 `d` 的多项式，复杂度是 `O(d log d)`。在这里，多项式的最高次不超过 `n`，所以乘法复杂度是 `O(n log n)`。
  - 因此总时间复杂度是 `O(log m * n log n)`，因为 `m=n/2`，所以是 `O(n log n log n)`。
  - 阶乘预处理是 `O(n)`，最终求和也是 `O(n)`，都可以忽略不计。

- **空间复杂度**: `O(n)` 的说。
  - `NTT` 需要 `O(n)` 的空间来存储补零后的多项式。
  - `fact` 数组需要 `O(n)` 的空间。
  - `polyPow` 中的中间变量也需要 `O(n)` 的空间。
  - 所以总的空间开销是 `O(n)`。

## 知识点与总结喵~
这道题真的非常巧妙，把一个复杂的期望问题，通过组合数学的智慧转化成了一个多项式计算问题，让我超兴奋的，喵~

1.  **核心思想**: 解题的关键在于**发现Rook多项式的不变性**。不管随机排列 `p` 是什么，禁区的Rook多项式恒为 `(1+3x+x^2)^m`。这使得期望的计算变得异常简单，直接绕过了对 `m!` 种情况的讨论。
2.  **组合数学工具**:
    *   **期望的线性性质**: 解决期望问题的万能钥匙，`E[∑X_i] = ∑E[X_i]`。
    *   **容斥原理与Rook多项式**: 这是解决带禁区的排列组合问题的经典模型。master们要记住 `Ways = ∑ (-1)^k * r_k * (n-k)!` 这个公式哦！
3.  **多项式算法**:
    *   **NTT (数论变换)**: 在模意义下进行多项式乘法（卷积）的超快算法，是解决很多计数问题的利器。
    *   **多项式快速幂**: 类似于整数快速幂，通过倍增和NTT，可以快速计算多项式的幂。

总之，这道题提醒我们，面对看起来很复杂的“期望”或者“随机”问题时，不要害怕！尝试从不同的角度（比如容斥原理）去构建数学模型，说不定就能发现像本题这样简洁优美的内在结构。加油，各位master，算法的世界充满了无限的乐趣和挑战，让我们一起探索吧！喵~ >w<