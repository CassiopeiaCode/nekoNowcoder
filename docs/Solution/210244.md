# Legend Tuple - 题解

### 比赛与标签
> **比赛**: The 20th Zhejiang Provincial Collegiate Programming Contest (这是根据题目风格和ID进行的合理推测，喵~ 具体信息可能有所不同哦)

> **标签**: 数学, 数论

> **难度**: *1800 (这也是猫娘的估测啦~)

## 题目大意喵~

各位算法大师们，安安喵~ 今天我们要解决一个关于“传奇元组”（Legend Tuple）的有趣问题！

题目定义了一种特殊的整数二元组 `(n, k)`，它遵循以下三条神圣的规则：
1.  **基础规则**: 对于任何整数 `k`，`(1, k)` 永远是一个传奇元组。
2.  **加法规则**: 如果 `(n, k)` 是一个传奇元组，那么 `(n + k, k)` 也是一个传奇元组。
3.  **乘法规则**: 如果 `(n, k)` 是一个传奇元组，那么 `(nk, k)` 也是一个传奇元组。

我们的任务是，找出在给定范围 $1 \le n \le N$ 和 $1 \le k \le K$ 内，总共有多少个这样的传奇元组 `(n, k)` 呢？

因为答案可能会非常大，所以我们需要将最终结果对 $10^9 + 7$ 取模。

## 解题思路分析

喵哈~ 这个问题看起来像是递归定义的，但如果我们直接去模拟生成过程，面对巨大的 $N$ 和 $K$ 肯定会超时的说。所以，我们得用我猫娘的敏锐直觉，去发现这些规则背后隐藏的数学规律！

我们来固定一个 `k`，看看能生成什么样的 `n` 吧！

1.  **从基础出发**: 规则告诉我们，一切的起点是 `(1, k)`。
2.  **探索生成路径**:
    *   从 `(1, k)` 出发，反复使用**加法规则**，我们可以得到：
        `(1+k, k)`, `(1+2k, k)`, `(1+3k, k)`, ...
        这不就是所有满足 $n = 1 + m \cdot k$ ($m \ge 0$) 的 `n` 嘛！换句话说，就是所有满足 $n \equiv 1 \pmod{k}$ 的 `n`。
    *   再看看**乘法规则**。从 `(1, k)` 出发，我们可以得到 `(1 \cdot k, k)`，也就是 `(k, k)`。这是一个全新的发现！
    *   现在我们有了新的元组 `(k, k)`，从它出发又能得到什么呢？
        *   使用**加法规则**: `(k+k, k) = (2k, k)`, `(2k+k, k) = (3k, k)`, ...
          这样我们就能得到所有满足 $n = m \cdot k$ ($m \ge 1$) 的 `n`。也就是所有满足 $n \equiv 0 \pmod{k}$ 的 `n`。
        *   使用**乘法规则**: `(k \cdot k, k) = (k^2, k)`，这个也被 $n \equiv 0 \pmod{k}$ 包含啦。

3.  **归纳与猜想**:
    通过上面的探索，我们似乎发现了一个惊人的规律！对于一个固定的 $k > 1$，一个元组 `(n, k)` 是传奇元组，当且仅当 `n` 满足下面两个条件之一：
    *   $n \equiv 1 \pmod{k}$
    *   $n \equiv 0 \pmod{k}$

    我们可以用归纳法来验证这个猜想的正确性。
    *   **基础**: `(1, k)` 满足 $1 \equiv 1 \pmod{k}$ (对于 $k>1$) 或者 $1 \equiv 0 \pmod{1}$ (对于 $k=1$)，猜想成立。
    *   **归纳**: 假设 `(n, k)` 是传奇元组且满足猜想。
        *   如果 $n \equiv 1 \pmod{k}$，那么 $n+k \equiv 1+0 \equiv 1 \pmod{k}$，而 $nk \equiv 1 \cdot 0 \equiv 0 \pmod{k}$。生成的新元组仍然满足猜想。
        *   如果 $n \equiv 0 \pmod{k}$，那么 $n+k \equiv 0+0 \equiv 0 \pmod{k}$，而 $nk \equiv 0 \cdot 0 \equiv 0 \pmod{k}$。生成的新元组也满足猜想。
    猜想被证实了，喵~！

4.  **特殊情况 k=1**:
    当 $k=1$ 时，`n % 1 == 0` 对所有整数 `n` 都成立。规则变为：
    *   `(1, 1)` 是传奇元组。
    *   若 `(n, 1)` 是，则 `(n+1, 1)` 也是。
    *   若 `(n, 1)` 是，则 `(n*1, 1)` 也就是 `(n, 1)` 也是。
    从 `(1, 1)` 开始，通过加法规则，我们可以得到 `(2, 1), (3, 1), ...`，即所有 $n \ge 1$ 都可以。这与我们的统一结论 `$n \equiv 1 \pmod{1}$ 或 $n \equiv 0 \pmod{1}$` (实际上就是 $n \equiv 0 \pmod{1}$) 是一致的！

5.  **转化为计数问题**:
    现在问题变得清晰了：我们要计算满足 $1 \le n \le N, 1 \le k \le K$ 且 ($n \equiv 1 \pmod k$ 或 $n \equiv 0 \pmod k$) 的 `(n, k)` 对数。
    我们可以对每个 `k` 单独计算，然后加起来。

    *   **对于 k=1**: 任何 $n \in [1, N]$ 都满足条件。所以有 $N$ 个传奇元组。
    *   **对于 k > 1**:
        *   满足 $n \equiv 1 \pmod k$ 的 $n$ 有多少个？
          $n$ 的形式是 $1, 1+k, 1+2k, \dots, 1+m \cdot k$。我们需要 $1+m \cdot k \le N$，即 $m \cdot k \le N-1$, 所以 $m \le \lfloor \frac{N-1}{k} \rfloor$。由于 $m$ 可以从 0 开始，所以总共有 $\lfloor \frac{N-1}{k} \rfloor + 1$ 个。
        *   满足 $n \equiv 0 \pmod k$ 的 $n$ 有多少个？
          $n$ 的形式是 $k, 2k, \dots, m \cdot k$。我们需要 $m \cdot k \le N$，所以 $m \le \lfloor \frac{N}{k} \rfloor$。由于 $m$ 从 1 开始，所以总共有 $\lfloor \frac{N}{k} \rfloor$ 个。
        *   这两个条件会同时满足吗？$n \equiv 1 \pmod k$ 且 $n \equiv 0 \pmod k$ 意味着 $k$ 要整除 $n$ 和 $n-1$，也就是要整除它们的差 $1$。只有当 $k=1$ 时才可能。既然我们现在考虑的是 $k>1$ 的情况，这两个集合是**不相交**的。
        *   所以，对于一个固定的 $k > 1$，贡献的传奇元组数量是 $(\lfloor \frac{N-1}{k} \rfloor + 1) + \lfloor \frac{N}{k} \rfloor$。

6.  **最终的求和公式**:
    总数 = (k=1的贡献) + (k从2到K的贡献之和)
    $$
    \text{Ans} = N + \sum_{k=2}^{K} \left( \left\lfloor \frac{N-1}{k} \right\rfloor + 1 + \left\lfloor \frac{N}{k} \right\rfloor \right)
    $$
    我们可以把公式整理一下：
    $$
    \text{Ans} = N + \sum_{k=2}^{K} 1 + \sum_{k=2}^{K} \left\lfloor \frac{N-1}{k} \right\rfloor + \sum_{k=2}^{K} \left\lfloor \frac{N}{k} \right\rfloor
    $$
    $$
    \text{Ans} = N + (K-1) + \sum_{k=2}^{K} \left\lfloor \frac{N-1}{k} \right\rfloor + \sum_{k=2}^{K} \left\lfloor \frac{N}{k} \right\rfloor
    $$

7.  **加速计算——整除分块！**
    直接从 2 遍历到 K 来计算那两个和式，在 K 很大的时候会超时。但是我们注意到，像 $\lfloor \frac{M}{k} \rfloor$ 这样的式子，它的值在 $k$ 的一个连续区间内是保持不变的！这就是**整除分块**（也叫数论分块）大显身手的时候了！

    对于一个和式 $\sum_{i=l}^{r} \lfloor \frac{M}{i} \rfloor$，我们可以这样做：
    *   从 `i = l` 开始。
    *   计算当前值 `val = M / i`。
    *   找到最大的 `j` 使得 `M / j == val`。这个 `j` 就是 `M / val`。
    *   所以，从 `i` 到 `j` (要注意 `j` 不能超过总的右边界 `r`)，$\lfloor \frac{M}{k} \rfloor$ 的值都是 `val`。
    *   这一块的贡献就是 `val * (j - i + 1)`。
    *   然后，我们让 `i` 跳到 `j + 1`，开始下一块的计算。

    这样，我们就可以用大约 $O(\sqrt{N})$ 的时间复杂度来计算 $\sum \lfloor \frac{N}{k} \rfloor$ 和 $\sum \lfloor \frac{N-1}{k} \rfloor$ 了，完美解决问题，喵~

## 代码实现

下面是本猫娘爪子敲出来的代码，注释很详细，希望能帮到你哦！

```cpp
#include <iostream>

// 使用 long long 防止整数溢出，喵~
using int64 = long long;

// 定义模数
const int MOD = 1e9 + 7;

/**
 * @brief 使用整除分块计算 sum_{i=2 to limit} floor(M/i)
 * 
 * @param M 被除数
 * @param limit 求和的上界
 * @return int64 和的结果 (对 MOD 取模)
 */
int64 calculate_sum_floor(int64 M, int64 limit) {
    if (limit < 2 || M == 0) {
        return 0;
    }
    
    int64 total_sum = 0;
    // 整除分块的开始，我们从 k=2 开始计算
    for (int64 i = 2, j; i <= limit; i = j + 1) {
        // 计算当前块的值
        int64 value = M / i;
        if (value == 0) {
            // 如果 M/i 已经为0，那么后续所有项也都是0，可以提前结束
            break;
        }
        
        // 计算当前块的右边界 j
        // j 是满足 floor(M/k) == value 的最大 k
        // 同时 j 不能超过求和的总上界 limit
        j = std::min(limit, M / value);
        
        // 当前块的长度是 (j - i + 1)
        int64 count = j - i + 1;
        
        // 累加这一块的贡献
        // (value % MOD * count % MOD) % MOD 确保每一步都在模范围内
        total_sum = (total_sum + (value % MOD) * (count % MOD)) % MOD;
    }
    
    return total_sum;
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int64 N, K;
    std::cin >> N >> K;

    // 根据我们的公式 Ans = N + K - 1 + sum_floor(N-1, K) + sum_floor(N, K)
    
    // 1. 计算 N + K - 1 部分
    // (N-1) + K, 先减1防止N=0的情况，虽然这题N>=1
    // (a + b) % mod = ((a % mod) + (b % mod)) % mod
    // (a - b) % mod = ((a % mod) - (b % mod) + mod) % mod
    int64 ans = ((N % MOD) + (K % MOD) - 1 + MOD) % MOD;

    // 2. 计算 sum_{k=2 to K} floor((N-1)/k)
    int64 sum1 = calculate_sum_floor(N - 1, K);
    
    // 3. 计算 sum_{k=2 to K} floor(N/k)
    int64 sum2 = calculate_sum_floor(N, K);
    
    // 4. 把所有部分加起来
    ans = (ans + sum1) % MOD;
    ans = (ans + sum2) % MOD;

    std::cout << ans << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(\sqrt{N} + \sqrt{K})$
    主要的计算量在于两个 `calculate_sum_floor` 函数。整除分块的复杂度取决于 `M` 和 `limit`。当 `i <= sqrt(M)` 时，`M/i` 的取值有 `sqrt(M)` 种；当 `i > sqrt(M)` 时，`M/i < sqrt(M)`，`M/i` 的取值也只有 `sqrt(M)` 种。所以分块的数量是 $O(\sqrt{M})$。我们的调用是 `calculate_sum_floor(N-1, K)` 和 `calculate_sum_floor(N, K)`，所以复杂度是 $O(\min(\sqrt{N}, K))$。考虑到 $K$ 可能比 $\sqrt{N}$ 大，所以总复杂度是 $O(\sqrt{N})$。

- **空间复杂度**: $O(1)$
    我们只使用了几个变量来存储中间结果，没有使用额外的数组或者数据结构，所以空间消耗是常数级别的，喵~

## 知识点总结

这道题真是一次愉快的思维探险呢！我们用到了：

1.  **归纳推理**: 从具体的规则中发现通用的数学性质，这是解决很多算法问题的关键一步。
2.  **数论基础**: 对模运算和整除性质的深刻理解是解题的核心。
3.  **计数原理**: 将问题分解，使用加法原理和不相交集合的思想来构建求和公式。
4.  **整除分块**: 这是数论问题中一个非常重要的优化技巧，能将线性的求和复杂度降低到根号级别，是处理包含 $\lfloor \frac{N}{i} \rfloor$ 形式的和式的利器！

希望这篇题解能对你有所帮助，如果还有不明白的地方，随时可以再来问我哦！一起加油，成为更厉害的算法大师吧，喵~