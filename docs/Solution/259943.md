# 大户爱开了 N 家驿站 - 题解

### 比赛与标签
> **比赛**: NowCoder (Contest ID likely related to BC139 based on code paths)

> **标签**: 思维, CDQ分治, 树状数组

> **难度**: **** (中等偏上)

## 题目大意喵~

一位名叫大户爱的可爱女孩开了 $N$ 家驿站，每家驿站都有一个二维坐标 $(x_i, h_i)$，分别代表位置和海拔，喵~

-   从驿站 $i$ 到驿站 $j$ 存在一条单向的“驿路”，当且仅当 $x_i > x_j$ 并且 $h_i > h_j$。
-   现在有两家快递巨头，要把所有的驿路瓜分掉。每条驿路 $(i, j)$ 都会被其中一家垄断。
-   我们用 $a_{0,i}, b_{0,i}$ 分别表示从驿站 $i$ 出发的驿路被第一、二家公司垄断的数量。
-   用 $a_{1,i}, b_{1,i}$ 分别表示到达驿站 $i$ 的驿路被第一、二家公司垄断的数量。

大户爱不希望任何一家公司太强势，所以她想通过分配每条驿路的归属，来最小化一个“不平衡度”的总和。这个总不平衡度是：
$$
\sum_{k=1}^{\text{总驿站数}} \left( |a_{0,k} - b_{0,k}| + |a_{1,k} - b_{1,k}| \right)
$$
题目会有 $Q$ 次独立的询问。每次询问都会**临时**增加一家新的驿站 $(x_{N+1}, h_{N+1})$，然后问你，对于这 $N+1$ 家驿站组成的新网络，最小的总不平衡度是多少，喵？

## 解题思路分析

这道题的表达式看起来好复杂呀，喵~ 但别怕，让本猫娘带你一步步解开它的神秘面纱！

#### 关键洞察：简化目标函数

我们要求的最小值是 $\sum (|a_{0,k} - b_{0,k}| + |a_{1,k} - b_{1,k}|)$。
对于任何一个驿站 $k$，从它出发的总驿路数是固定的，我们称之为出度 $d_{out}(k)$。也就是说，$a_{0,k} + b_{0,k} = d_{out}(k)$。
那么 $|a_{0,k} - b_{0,k}| = |a_{0,k} - (d_{out}(k) - a_{0,k})| = |2a_{0,k} - d_{out}(k)|$。
同理，对于入度 $d_{in}(k)$，我们有 $|a_{1,k} - b_{1,k}| = |2a_{1,k} - d_{in}(k)|$。

所以，我们的目标变成了最小化：
$$
\sum_{k=1}^{\text{总驿站数}} \left( |2a_{0,k} - d_{out}(k)| + |2a_{1,k} - d_{in}(k)| \right)
$$
对于一个固定的度数 $d$，要让 $|2a - d|$ 最小，我们应该让 $a$ 尽可能接近 $d/2$。
-   如果 $d$ 是偶数，我们可以取 $a = d/2$，此时 $|2a-d|=0$。
-   如果 $d$ 是奇数，我们只能取 $a = \lfloor d/2 \rfloor$ 或 $a = \lceil d/2 \rceil$，此时 $|2a-d|=1$。

所以，对于单个驿站 $k$ 的某一项（比如出度），它对总和的最小贡献就是 $d_{out}(k) \pmod 2$。

那么，我们是否总能找到一种分配方案，使得**所有**驿站的每一项都达到这个理论最小值呢？答案是肯定的，喵！

这可以类比一个图论问题：想象一个大的二分图，左边有 $N$ 个点代表每个驿站的“发件处”，右边有 $N$ 个点代表“收件处”。每条驿路 $(i, j)$ 对应一条从左边点 $i$ 到右边点 $j$ 的边。我们要给每条边染上两种颜色（代表两家公司），使得每个点的两种颜色的边数尽可能相等。这是一个经典的可以通过欧拉回路思想证明的结论：我们总可以通过巧妙的分配，使得每个点的两种颜色边数之差不超过1。

因此，整个问题的最小总不平衡度就是所有驿站出入度奇偶性的总和！
$$
\text{最小总不平衡度} = \sum_{k=1}^{\text{总驿站数}} \left( d_{out}(k) \pmod 2 + d_{in}(k) \pmod 2 \right)
$$
问题瞬间清晰起来了，对吧？我们只需要数数就行了，喵~

#### 处理独立询问

每次询问都增加一个点，然后计算新的总不平衡度。如果每次都重新计算所有点的度数，那可太慢了。由于询问是**离线**的，我们可以把所有初始点和查询点放在一起处理，这通常是使用CDQ分治或者带数据结构的扫描线的信号。

对于一个查询点 $Q_j = (x_j, h_j)$，新的总不平衡度是：
$$
\text{Ans}_j = \sum_{k=1}^{N+1} (d'_{out}(k) \pmod 2 + d'_{in}(k) \pmod 2)
$$
其中 $d'$ 是加入了 $Q_j$ 之后的新度数。
这个和可以拆成三部分：
1.  新节点 $Q_j$ 自身的贡献：$(d'_{out}(Q_j) \pmod 2 + d'_{in}(Q_j) \pmod 2)$
2.  原有的 $N$ 个节点出度部分的总贡献：$\sum_{i=1}^N d'_{out}(P_i) \pmod 2$
3.  原有的 $N$ 个节点入度部分的总贡献：$\sum_{i=1}^N d'_{in}(P_i) \pmod 2$

我们来分析一下第二部分：
$d'_{out}(P_i) = d_{out}(P_i) + [P_i \text{能到达} Q_j]$，其中 `[...] 是布尔表达式，真为1假为0。
所以 $d'_{out}(P_i) \pmod 2 = (d_{out}(P_i) \pmod 2) \oplus [x_i > x_j \land h_i > h_j]$。
令 $P_{out}(i) = d_{out}(P_i) \pmod 2$，$\delta_i = [x_i > x_j \land h_i > h_j]$。
$\sum_{i=1}^N (P_{out}(i) \oplus \delta_i) = \sum_{i=1}^N (P_{out}(i) + \delta_i - 2 \cdot P_{out}(i) \cdot \delta_i)$
$= (\sum_{i=1}^N P_{out}(i)) + (\sum_{i=1}^N \delta_i) - 2 \sum_{i=1}^N P_{out}(i) \cdot \delta_i$
$= (\sum_{i=1}^N P_{out}(i)) + (\text{能到达} Q_j \text{的} P_i \text{数量}) - 2 \cdot (\sum_{i: P_i \text{能到达} Q_j} P_{out}(i))$

把所有部分都这样展开，就能得到一个可以高效计算的公式。对于每个查询 $Q_j$，我们需要计算以下四种值：
1.  $C_{out}(Q_j)$: $Q_j$ 能到达的初始点数量，即满足 $x_j > x_i, h_j > h_i$ 的 $P_i$ 数量。
2.  $C_{in}(Q_j)$: 能到达 $Q_j$ 的初始点数量，即满足 $x_i > x_j, h_i > h_j$ 的 $P_i$ 数量。
3.  $S_{out}(Q_j)$: 在能到达 $Q_j$ 的初始点中，出度为奇数的点的数量，即 $\sum_{i: x_i > x_j, h_i > h_j} P_{out}(i)$。
4.  $S_{in}(Q_j)$: 在 $Q_j$ 能到达的初始点中，入度为奇数的点的数量，即 $\sum_{i: x_j > x_i, h_j > h_i} P_{in}(i)$。

这些都是典型的二维偏序问题（或者叫二维数点问题），可以用树状数组（BIT）来解决！

#### 算法步骤

1.  **预处理**：
    *   对所有出现过的 $h$ 坐标进行离散化。
    *   对于初始的 $N$ 个点，计算出每个点 $P_i$ 的 $P_{out}(i)$ 和 $P_{in}(i)$。这本身就是两次二维数点，可以用树状数组+排序（按 $x$ 坐标）在 $O(N \log N)$ 时间内完成。
    *   计算初始的总不平衡度 $B = \sum_{i=1}^N (P_{out}(i) + P_{in}(i))$。

2.  **离线处理查询**：
    *   把 $N$ 个初始点和 $Q$ 个查询点放进一个列表里。
    *   **第一轮扫描**：按 $x$ 坐标升序处理所有点。
        *   维护两个树状数组：bit_count` 用来计数，`bit_sum_pin` 用来求和 $P_{in}$。
        *   当遇到一个初始点 $P_i$ 时，将其信息加入树状数组：`bit_count.add(h_i, 1)`，`bit_sum_pin.add(h_i, P_{in}(i))。
        *   当遇到一个查询点 $Q_j$ 时，用树状数组查询它左下方的点：
            *   $C_{out}(Q_j) = \text{bit\_count.query}(h_j - 1)$
            *   $S_{in}(Q_j) = \text{bit\_sum\_pin.query}(h_j - 1)$
            *   根据推导的公式，更新 $Q_j$ 的答案。
    *   **第二轮扫描**：按 $x$ 坐标降序处理所有点。
        *   类似地，维护 bit_count` 和 `bit_sum_pout`。
        *   当遇到初始点，加入信息。
        *   当遇到查询点，查询其右上方的信息，计算出 $C_{in}(Q_j)$ 和 $S_{out}(Q_j)$，并更新答案。

3.  **输出**：最后输出每个查询的最终答案即可，喵~

这样，通过两次扫描和树状数组，我们就能高效地解决所有查询啦！

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，希望能帮助你理解，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;

const int MAX_VAL = 200001; // 坐标和海拔的最大值

// 树状数组 (Fenwick Tree)
template<typename T>
struct FenwickTree {
    vector<T> bit;
    int size;

    FenwickTree(int sz) : size(sz), bit(sz + 1, 0) {}

    void add(int idx, T delta) {
        for (; idx <= size; idx += idx & -idx) {
            bit[idx] += delta;
        }
    }

    T query(int idx) {
        T sum = 0;
        for (; idx > 0; idx -= idx & -idx) {
            sum += bit[idx];
        }
        return sum;
    }
    
    void clear() {
        fill(bit.begin(), bit.end(), 0);
    }
};

// 用来存储驿站和查询的结构体
struct Point {
    int id;
    int x, h;
    bool is_query; // 是不是查询点
};

// 比较函数，用于排序
bool comparePoints(const Point& a, const Point& b) {
    if (a.x != b.x) {
        return a.x < b.x;
    }
    // 查询点需要先于初始点处理，以统计正确的范围
    return a.is_query > b.is_query;
}

int main() {
    // 加速输入输出，喵~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, q;
    cin >> n >> q;

    vector<Point> initial_points(n);
    vector<Point> all_points(n + q);
    
    // 读入初始点
    for (int i = 0; i < n; ++i) {
        initial_points[i].id = i;
        cin >> initial_points[i].x >> initial_points[i].h;
        initial_points[i].is_query = false;
        all_points[i] = initial_points[i];
    }

    // 读入查询点
    vector<long long> answers(q);
    for (int i = 0; i < q; ++i) {
        all_points[n + i].id = i;
        cin >> all_points[n + i].x >> all_points[n + i].h;
        all_points[n + i].is_query = true;
    }

    // --- 步骤1: 预处理 ---
    vector<int> parity_out(n), parity_in(n);
    
    // 计算 P_out (出度奇偶性)
    sort(initial_points.begin(), initial_points.end(), comparePoints);
    FenwickTree<int> ft_parity_out(MAX_VAL);
    for (const auto& p : initial_points) {
        parity_out[p.id] = ft_parity_out.query(p.h - 1) % 2;
        ft_parity_out.add(p.h, 1);
    }

    // 计算 P_in (入度奇偶性)
    sort(initial_points.rbegin(), initial_points.rend(), comparePoints);
    FenwickTree<int> ft_parity_in(MAX_VAL);
    for (const auto& p : initial_points) {
        parity_in[p.id] = (ft_parity_in.query(MAX_VAL) - ft_parity_in.query(p.h)) % 2;
        ft_parity_in.add(p.h, 1);
    }
    
    long long base_imbalance = 0;
    for (int i = 0; i < n; ++i) {
        base_imbalance += parity_out[i] + parity_in[i];
    }
    
    for (int i = 0; i < q; ++i) {
        answers[i] = base_imbalance;
    }

    // --- 步骤2: 离线处理查询 ---

    // 第一轮扫描: x 升序
    sort(all_points.begin(), all_points.end(), comparePoints);
    FenwickTree<long long> ft_count(MAX_VAL);
    FenwickTree<long long> ft_sum_pin(MAX_VAL);

    for (const auto& p : all_points) {
        if (p.is_query) {
            long long c_out = ft_count.query(p.h - 1);
            long long s_in = ft_sum_pin.query(p.h - 1);
            // 加上新点自身出度的贡献，以及对老点入度的影响
            answers[p.id] += (c_out % 2) + (c_out - 2 * s_in);
        } else {
            ft_count.add(p.h, 1);
            ft_sum_pin.add(p.h, parity_in[p.id]);
        }
    }

    // 第二轮扫描: x 降序
    sort(all_points.rbegin(), all_points.rend(), comparePoints);
    ft_count.clear();
    FenwickTree<long long> ft_sum_pout(MAX_VAL);

    for (const auto& p : all_points) {
        if (p.is_query) {
            long long c_in = ft_count.query(MAX_VAL) - ft_count.query(p.h);
            long long s_out = ft_sum_pout.query(MAX_VAL) - ft_sum_pout.query(p.h);
            // 加上新点自身入度的贡献，以及对老点出度的影响
            answers[p.id] += (c_in % 2) + (c_in - 2 * s_out);
        } else {
            ft_count.add(p.h, 1);
            ft_sum_pout.add(p.h, parity_out[p.id]);
        }
    }

    // --- 步骤3: 输出答案 ---
    for (int i = 0; i < q; ++i) {
        cout << answers[i] << "\n";
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O((N+Q) \log(\text{MAX\_VAL}))$
    -   预处理计算初始点的出入度奇偶性需要对 $N$ 个点排序并使用树状数组，复杂度是 $O(N \log N + N \log(\text{MAX\_VAL}))$。
    -   离线处理部分，我们将 $N+Q$ 个点排序，然后进行两次扫描，每次扫描都伴随着树状数组的操作。总复杂度是 $O((N+Q) \log(N+Q) + (N+Q) \log(\text{MAX\_VAL}))$。
    -   由于坐标值范围不大，$\log(\text{MAX\_VAL})$ 和 $\log(N+Q)$ 是同级别的。所以整体时间复杂度是 $O((N+Q) \log(N+Q))$。

-   **空间复杂度**: $O(N+Q+\text{MAX\_VAL})$
    -   我们需要存储所有的初始点和查询点，空间为 $O(N+Q)$。
    -   树状数组的大小取决于坐标的最大值，空间为 $O(\text{MAX\_VAL})$。

## 知识点总结

这道题真是一次有趣的冒险，喵！它教会了我们：

1.  **问题转换与简化**: 最重要的技巧！面对一个形式复杂的优化目标，尝试从其数学性质入手，寻找等价或更简单的形式。本题中，将复杂的绝对值和最小化问题，通过图论思想（虽然没有真的建图）转化为简单的奇偶性求和问题，是解题的关键。
2.  **离线处理**: 当多次查询相互独立，且可以改变处理顺序时，就可以考虑离线算法。将所有操作（这里是加入点）和查询预先读入，然后通过排序等方式，以一个更优的顺序处理它们。
3.  **CDQ分治思想/扫描线**: 离线处理常常和CDQ分治或扫描线算法结合。本题的解法本质上是一个二维平面上的扫描线算法，我们按 $x$ 坐标扫描，用数据结构（树状数组）维护另一维（$h$ 坐标）的信息。
4.  **树状数组 (Fenwick Tree)**: 解决一维前缀和、区间和问题的利器。在扫描线算法中，它被用来高效地处理动态的二维范围查询。

希望这篇题解能帮到你，如果还有问题，随时可以再来问本猫娘哦，喵~！