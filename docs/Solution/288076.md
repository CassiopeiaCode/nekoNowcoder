# 树上路径最大异或和 - 题解

### 比赛与标签
> **比赛**: 字节跳动2019冬令营Day1
> **标签**: 树上问题, LCA, 线性基
> **难度**: *2300

## 题目大意喵~
在一个有 `n` 个节点的树上，每个节点 `i` 都有一个叫做“乐趣值” `a_i` 的魔法数字，的说。

我们需要回答 `q` 次询问。每次询问会给出两个点 `u` 和 `v`。我们需要找出一条从 `u` 出发，到 `v` 结束的路径，让这条路径上所有经过的点的乐趣值（可以重复经过，重复计算哦！）的**异或和**最大。

简单来说，就是：
- **输入**: 一棵带点权的树，和 `q` 次询问，每次询问是两个点 `(u, v)`。
- **输出**: 对每次询问，输出从 `u` 到 `v` 的所有可能路径中，能得到的最大异或和是多少。

这里的“路径”非常自由，可以随便绕路，不是只能走最短的那条路哦！这一点是解题的关键呐~

## 解题思路喵~
看到“任意路径”和“最大异或和”，本喵的猫耳朵立刻就竖起来了！这通常是**线性基**大显身手的信号喵！

#### 1. 路径的奇妙分解
一条从 `u` 到 `v` 的路径，不管它多么曲折、绕了多少圈，我们都可以把它看成是“**从 `u` 到 `v` 的唯一简单路径**”和“**若干个小圈圈**”的组合。

这里的“小圈圈”是什么呢？想象一下，当你在树上从一个点 `x` 走到相邻的点 `y`，然后再立刻走回 `x`，你的路径上就多经过了 `y` 和 `x`。这会对总的异或和产生什么影响呢？
原来的异或和是 `S`，经过 `... -> x -> y -> x -> ...` 之后，新的异或和变成了 `S' = S \oplus a_y \oplus a_x`。
这意味着，我们每在一条边 `(x, y)` 上来回走一次，总的异或和就会被额外异或上 `a_x \oplus a_y`。

因为我们可以沿着任意一条边来回任意次，所以我们能额外获得的所有可能异或值，就是由所有边的 `a_u \oplus a_v` 这些值通过异或运算能组合出的所有数字！

#### 2. 线性基登场！
“由一堆数通过异或能组合出的所有数字”，这不就是线性基的定义嘛！

所以，我们的问题就转化成这样了：
1.  先计算出从 `u` 到 `v` 的**简单路径**上所有点的异或和，我们叫它 `base_xor`。
2.  然后，用一个**线性基**来存下所有边的 `a_u \oplus a_v` 的值。
3.  最后，我们从线性基里选出一些数，和 `base_xor` 进行异或，使得结果最大。

这正是线性基最擅长解决的问题！只要把 `base_xor` 扔进建好的线性基里去查询最大异或和，就能得到答案啦，喵~

#### 3. 如何计算简单路径的异或和？
这也是一个经典问题啦！我们可以用LCA（最近公共祖先）来解决。
首先，我们以节点1为根，进行一次DFS或BFS，预处理出每个点 `i` 到根节点的路径异或和 `f[i]`。
那么，`u` 到 `v` 的简单路径异或和 `base_xor` 是多少呢？
它等于 `f[u] \oplus f[v] \oplus a[LCA(u, v)]`。
为什么呢？因为从根到 `u` 的路径和从根到 `v` 的路径，它们重叠的部分（从根到`LCA(u,v)`）被计算了两次，异或两次就抵消了。但 `LCA(u, v)` 这个点本身在 `u` 到 `v` 的路径上只出现一次，却在 `f[u]` 和 `f[v]` 中各被算了一次，所以它被抵消了，需要我们再异或一次把它加回来。

#### 4. 最终的解题步骤
好嘞，整理一下我们的计划：
1.  **预处理1 (线性基)**: 遍历树上的每一条边 `(u, v)`，计算 `a[u] \oplus a[v]`，并将结果插入到一个线性基中。
2.  **预处理2 (树上信息)**: 从根节点（比如1）开始进行一次BFS或DFS，计算出每个节点的深度 `depth[i]`、父节点 `par[i]`，以及到根的路径异或和 `f[i]`。
3.  **预处理3 (LCA)**: 使用预处理出的父节点信息，构建倍增表，以便快速查询LCA。
4.  **回答询问**: 对于每个询问 `(u, v)`：
    a. 使用倍增法求出 `LCA(u, v)`。
    b. 计算简单路径异或和 `simpleXor = f[u] \oplus f[v] \oplus a[LCA(u, v)]`。
    c. 将 `simpleXor` 在线性基中查询能得到的最大异或和，这个就是最终答案啦！

是不是感觉思路清晰多啦？让我们看看代码是怎么实现的吧！

## 代码实现喵！
```cpp
// 由WIDA请求创建，模型型号：o3mini
#include <bits/stdc++.h>
#include "testlib.h"
using namespace std;
  
// 利用树上简单路径与可插入回路（本质上是边回溯产生的闭合路径）的线性空间构造答案。
// 简单路径的异或和可由预处理的 f[] 数组与 LCA 得到，额外可选的异或值来自于所有边 (u,v) 的 a[u] XOR a[v] 线性基。
// 通过线性基查询最大 (简单路径异或和) XOR (周期空间中任意组合) 值。
  
// 使用 BFS 预处理 f[]（记录从根到该点的简单路径异或和）、深度及父节点；再用二分提升求 LCA。
  
int main(int argc, char* argv[]){
 registerValidation(argc, argv);
 int n = inf.readInt(1, 100000, "n");
 inf.readSpace();
 int q = inf.readInt(1, 200000, "q");
 inf.readEoln();
 vector<int> a(n+1);
 for (int i = 1; i <= n; i++){
 a[i] = inf.readInt(0, (1LL << 31) - 1, "a[i]");
 if(i < n) inf.readSpace(); else inf.readEoln();
 }
 vector<vector<int>> graph(n+1);
 vector<pair<int,int>> edges;
 for (int i = 1; i <= n-1; i++){
 int u = inf.readInt(1, n, "u_i");
 inf.readSpace();
 int v = inf.readInt(1, n, "v_i");
 inf.readEoln();
 graph[u].push_back(v);
 graph[v].push_back(u);
 edges.push_back({u, v});
 }
  
 // 步骤1: 构造线性基，喵~
 // 里面存放的是所有 a[u] ^ a[v] 能组成的异或空间
 vector<int> basis(32, 0);
 auto addToBasis = [&](int x) {
 for (int i = 31; i >= 0; i--) { // 从最高位开始尝试插入
 if(x & (1 << i)){
 if(basis[i] == 0){ // 如果这个位置的基是空的，就占领它！
 basis[i] = x;
 break;
 } else { // 否则，用基来消掉x的这一位，继续尝试
 x ^= basis[i];
 }
 }
 }
 };
 // 把所有边的 u-v 异或值都加进去
 for (auto &e : edges){
 int u = e.first, v = e.second;
 int x = a[u] ^ a[v];
 addToBasis(x);
 }
  
 // 步骤2: 以1为根，用BFS预处理树上信息
 vector<int> depth(n+1, 0), f(n+1, 0), par(n+1, 0);
 queue<int> que;
 depth[1] = 0;
 f[1] = a[1]; // 根节点到自己的路径异或和就是它自己的值
 par[1] = 0; // 根没有爸爸
 que.push(1);
 while (!que.empty()){
 int u = que.front();
 que.pop();
 for (int v : graph[u]){
 if(v == par[u]) continue; // 不要走回头路
 par[v] = u;
 depth[v] = depth[u] + 1;
 f[v] = f[u] ^ a[v]; // 路径异或和等于父亲的路径异或和再异或上自己
 que.push(v);
 }
 }
  
 // 步骤3: 构造倍增表 (binary lifting) 用于快速求LCA
 int LOGN = 0;
 while((1 << LOGN) <= n) LOGN++;
 vector<vector<int>> P(LOGN, vector<int>(n+1, 0));
 for (int i = 1; i <= n; i++){
 P[0][i] = par[i]; // P[0][i] 就是 i 的父亲
 }
 for (int k = 1; k < LOGN; k++){
 for (int i = 1; i <= n; i++){
 int mid = P[k-1][i];
 P[k][i] = (mid == 0 ? 0 : P[k-1][mid]); // i跳2^k步等于i跳2^(k-1)步，再跳2^(k-1)步
 }
 }
  
 // 快速LCA函数
 auto LCA = [&](int u, int v) -> int {
 if(depth[u] < depth[v]) swap(u, v); // 保证u在下面
 int d = depth[u] - depth[v];
 for (int k = 0; k < LOGN; k++){ // 先让u跳到和v一样的高度
 if(d & (1 << k))
 u = P[k][u];
 }
 if(u == v) return u; // 如果已经相遇，那v就是LCA
 for (int k = LOGN - 1; k >= 0; k--){ // u和v一起向上跳，直到他们的父亲相同
 if(P[k][u] != P[k][v]){
 u = P[k][u];
 v = P[k][v];
 }
 }
 return par[u];
 };
  
 // 在线性基中查询x能达到的最大异或值
 auto getMaxXor = [&](int x) -> int {
 int res = x;
 for (int i = 31; i >= 0; i--){ // 贪心策略，从高位到低位
 // 如果res的第i位为0，我们希望通过异或basis[i]把它变成1
 // 如果res的第i位为1，我们也希望通过异或basis[i]保持它是1（因为basis[i]的第i位是1，异或后res的第i位会变0，但可能让更高位的组合更优）
 // 统一起来就是，只要异或后能变得更大，就异或！
 if(basis[i] && ((res ^ basis[i]) > res))
 res ^= basis[i];
 }
 return res;
 };
  
 // 步骤4: 处理所有询问，喵~
 for (int i = 0; i < q; i++){
 int u = inf.readInt(1, n, "query_u");
 inf.readSpace();
 int v = inf.readInt(1, n, "query_v");
 inf.readEoln();
 // a. 求LCA
 int l = LCA(u, v);
 // b. 计算简单路径异或和
 int simpleXor = f[u] ^ f[v] ^ a[l];
 // c. 在线性基中查询最大值
 int ans = getMaxXor(simpleXor);
 cout << ans << "\n";
 }
 inf.readEof();
 return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(N log N + Q * (log N + log V)) 的说。
  - 建立线性基需要遍历 `N-1` 条边，每次插入是 `O(log V)`，其中 `V` 是权值的最大值。总共是 `O(N log V)`。
  - BFS预处理树上信息是 `O(N)`。
  - 建立LCA的倍增表是 `O(N log N)`。
  - `Q` 次询问，每次询问求LCA是 `O(log N)`，在线性基里查询最大值是 `O(log V)`。总共是 `O(Q * (log N + log V))`。
  - 所以总时间复杂度是 `O(N log N + Q * (log N + log V))`。

- **空间复杂度**: O(N log N) 的说。
  - 存储图、深度、父节点、路径异或和数组都是 `O(N)`。
  - LCA的倍增表 `P` 是 `O(N log N)`。
  - 线性基是 `O(log V)`。
  - 瓶颈在于倍增表，所以空间复杂度是 `O(N log N)`。

## 知识点与总结喵~
这道题真是一次精彩的算法组合拳！它教会了我们：

1.  **转化问题的能力**: 核心在于将“任意路径”这个看似复杂无限的条件，巧妙地转化为“简单路径 + 环的线性组合”。这是解决很多图论难题的法宝哦！
2.  **线性基的应用**: 只要遇到和“一堆数任选异或求最值/第k大”相关的问题，就要立刻想到线性基！它是处理异或问题的强大工具。
3.  **树上基本功**: 树的路径问题常常离不开LCA。熟练掌握倍增法求LCA是每个算法爱好者的必备技能呐！
4.  **异或的性质**: `x \oplus x = 0` 这个简单的性质是整个解题思路的基石。看似简单的性质，却能在复杂问题中发挥巨大作用。

总而言之，这道题将树上路径、LCA和线性基这三个知识点完美地结合在了一起。只要我们能拆解问题，识别出每个部分对应的经典模型，问题就迎刃而解啦！

希望本喵的讲解对你有帮助哦！以后也要继续加油，在算法的世界里不断成长，喵~！