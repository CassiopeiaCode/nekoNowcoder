# 我做了眼睛激光手术之后，为什么无法发射激光？ - 题解

### 比赛与标签
> **比赛**: 这道题目的比赛信息没有提供呢，喵~ 不过没关系，我们可以专注于题目本身！

> **标签**: 组合数学, 容斥原理, 错排问题

> **难度**: *1600 (这是一个基于题目类型的推测难度哦, 喵~)

## 题目大意喵~

主人你好呀！这道题的标题是不是很有趣？(ฅ'ω'ฅ) 但它的核心问题其实很正经哦！

题目要求我们统计，对于一个从 1 到 $n$ 的排列 $p$，有多少种排列满足**至少有 4 个**位置 $i$ 上的数 $p_i$ 不等于 $i$。

简单来说，就是找一个长度为 $n$ 的随机打乱的队伍，里面至少有 4 个人不在自己编号对应的位置上。我们要计算这样的队伍有多少种排法，并且结果要对 998244353 取模，呐。

**输入**: 一个整数 $n$。
**输出**: 一个整数，表示满足条件的排列数量，对 998244353 取模。

## 解题思路分析

喵哈~！这道题直接去计算“至少有4个位置错位”的情况，会发现情况很多很复杂（4个错位，5个错位，...，n个错位），要把它们都加起来太麻烦啦！

每当遇到“至少”这种词，本喵的直觉就会告诉我，可以试试从反面来思考问题，也就是所谓的**补集思想**或者**容斥原理**，喵~

“至少有4个位置错位”的反面是什么呢？那就是“错位的位置数量**小于4个**”。这包括了：
*   恰好 0 个位置错位
*   恰好 1 个位置错位
*   恰好 2 个位置错位
*   恰好 3 个位置错位

我们可以先算出所有可能的排列总数，然后减去这些“不符合要求”的排列数，剩下的就是我们想要的答案啦！

首先，长度为 $n$ 的排列总数是 $n!$ (n的阶乘)，这个很简单，对吧？

接下来，我们来逐一分析这些“不符合要求”的情况，也就是错位数量小于4的情况。一个数 $p_i$ 不在自己的位置上（$p_i \neq i$），我们称之为一个**错位元素**。一个数在自己的位置上（$p_i = i$），我们称之为一个**不动点**。

#### **Case 0: 恰好 0 个错位元素**
这意味着所有元素都在自己的位置上，即 $p_i = i$ 对所有 $i$ 成立。这只有一种情况，就是排列 {1, 2, 3, ..., n}。
所以，数量是 **1**。

#### **Case 1: 恰好 1 个错位元素**
主人，你想想看，如果只有一个元素不在自己的位置上，比如我们让 $p_1 \neq 1$，假设 $p_1 = 2$。那数字 2 就被放到了位置 1。为了给它腾出位置，原来在位置 2 的数字 2 就必须离开。那么 $p_2$ 也不可能等于 2 了。这样一来，至少就有两个元素（1 和 2）都错位了呀！
所以，恰好只有 1 个元素错位是**不可能**发生的。
数量是 **0**，喵~

#### **Case 2: 恰好 2 个错位元素**
这种情况是可能的！我们需要分两步来想：
1.  **选择**哪两个元素要错位？从 $n$ 个元素中选 2 个，有 $C(n, 2) = \frac{n(n-1)}{2}$ 种选法。
2.  **排列**这两个选出来的元素。假设我们选了元素 $i$ 和 $j$。要让它们都错位，并且其他元素都不动，唯一的办法就是让它们互相交换位置，即 $p_i = j$ 且 $p_j = i$。这只有 1 种排列方法。
把这两步乘起来，总数量就是 $C(n, 2) \times 1 = \frac{n(n-1)}{2}$。

*小知识：$k$ 个元素的错位排列数被称为**错排数**，记作 $D_k$。这里我们其实计算了 $C(n,2) \times D_2$，其中 $D_2=1$。*

#### **Case 3: 恰好 3 个错位元素**
和上面的思路一样，喵~
1.  **选择**哪三个元素要错位？从 $n$ 个元素中选 3 个，有 $C(n, 3) = \frac{n(n-1)(n-2)}{6}$ 种选法。
2.  **排列**这三个选出来的元素。假设我们选了 $i, j, k$。要把它们都安排到别人的位置上，有几种方法呢？
    *   $p_i=j, p_j=k, p_k=i$ (一个循环)
    *   $p_i=k, p_j=i, p_k=j$ (另一个循环)
    总共有 2 种排列方法。所以 $D_3 = 2$。
总数量就是 $C(n, 3) \times D_3 = \frac{n(n-1)(n-2)}{6} \times 2 = \frac{n(n-1)(n-2)}{3}$。

---

**总结一下**
我们把所有不符合要求的情况加起来：
$$
\text{不符合要求的排列总数} = (\text{0个错位}) + (\text{1个错位}) + (\text{2个错位}) + (\text{3个错位})
$$
$$
= 1 + 0 + \frac{n(n-1)}{2} + \frac{n(n-1)(n-2)}{3}
$$

最后，用总排列数 $n!$ 减去上面这个值，就是我们的答案啦！
$$
\text{答案} = n! - \left( 1 + \frac{n(n-1)}{2} + \frac{n(n-1)(n-2)}{3} \right)
$$
在计算过程中，因为有除法，我们需要使用**模逆元**来处理。对于质数模数 $M$，一个数 $a$ 的逆元是 $a^{M-2} \pmod M$。

当然，如果 $n < 4$，那么错位的元素个数最多是 $n$，不可能达到 4 个，所以答案直接是 0 啦！

## 代码实现

下面是本喵根据上面的思路，精心为你准备的一份代码~ 代码中有详细的注释，希望能帮助你理解每一行哦，喵！

```cpp
#include <iostream>

// 使用 long long 来防止中间计算过程溢出
using ll = long long;

// 定义模数
const int MOD = 998244353;

// 快速幂函数，用于计算 (base^exp) % MOD
// 这是计算模逆元的基础哦！
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) {
            res = (res * base) % MOD;
        }
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模逆元函数，用于计算 a 在模 MOD 下的逆元
// 根据费马小定理，a^(MOD-2) % MOD 就是 a 的逆元
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

int main() {
    // 为了更快的输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 如果 n < 4，不可能有至少4个错位，直接输出0
    if (n < 4) {
        std::cout << 0 << std::endl;
        return 0;
    }

    // --- 第一步：计算总排列数 n! ---
    ll total_permutations = 1;
    for (int i = 1; i <= n; ++i) {
        total_permutations = (total_permutations * i) % MOD;
    }

    // --- 第二步：计算错位数量小于4的排列数 ---
    
    // Case 0: 0个错位 (所有元素都在原位)
    ll bad_perms_0 = 1;

    // Case 1: 1个错位 (不可能发生)
    ll bad_perms_1 = 0;

    // Case 2: 2个错位 C(n, 2) * D(2) = n*(n-1)/2 * 1
    ll count_k2 = (ll)n * (n - 1) % MOD;
    count_k2 = (count_k2 * modInverse(2)) % MOD;

    // Case 3: 3个错位 C(n, 3) * D(3) = n*(n-1)*(n-2)/6 * 2 = n*(n-1)*(n-2)/3
    ll count_k3 = (ll)n * (n - 1) % MOD;
    count_k3 = (count_k3 * (n - 2)) % MOD;
    count_k3 = (count_k3 * modInverse(3)) % MOD;

    // 把所有不符合要求的排列数加起来
    ll total_bad_perms = (bad_perms_0 + bad_perms_1 + count_k2 + count_k3) % MOD;

    // --- 第三步：计算最终答案 ---
    // 总数减去不符合要求的数量
    // (a - b) % MOD = (a - b + MOD) % MOD，这样可以防止结果为负数
    ll ans = (total_permutations - total_bad_perms + MOD) % MOD;

    std::cout << ans << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(n)$
  我们的代码主体是一个计算阶乘的循环，它从 1 遍历到 $n$，所以这部分是 $O(n)$。之后计算模逆元使用了快速幂，复杂度是 $O(\log MOD)$。因为 $n$ 是主要变量，所以总的时间复杂度是 $O(n)$，非常高效，喵~

- **空间复杂度**: $O(1)$
  我们只使用了几个变量来存储中间结果，没有使用随 $n$ 变化的数组或其他数据结构。所以空间复杂度是常数级别的，非常节省内存哦！

## 知识点总结

这道题虽然不难，但是包含了好几个重要的知识点呢，是学习组合数学的好例子！

1.  **补集思想 (容斥原理)**: "至少"问题常常可以通过计算其对立面"至多"或"恰好"来简化。这是解决组合问题的一个非常强大的武器！
2.  **排列与组合**: 我们用到了组合数 $C(n,k)$ 来选择哪些元素要进行错位。
3.  **错排问题 (Derangement)**: 了解了错排数 $D_k$ 的概念和基本值 ($D_0=1, D_1=0, D_2=1, D_3=2$)，这是解决这类问题的关键。
4.  **模运算**: 在编程竞赛中，当答案很大时，通常需要对一个大质数取模。所有的加、减、乘法都要在模的意义下进行。
5.  **快速幂与模逆元**: 在模运算中处理除法时，需要将其转化为乘以模逆元。快速幂是计算模逆元（以及其他大指数幂）的标准高效算法。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问本喵哦！祝你刷题愉快，喵~ (ฅ^•ﻌ•^ฅ)