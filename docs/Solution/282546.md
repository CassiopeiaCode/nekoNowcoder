# 本题与 easy version 的区别在于本题每个点的随机区间是给定的，并且有多组针对颜色区间的询问，相对的数据范围也有区别。 - 题解

### 比赛与标签
> **比赛**: Nowcoder Contest

> **标签**: 数据结构, 线段树, 数学, 期望

> **难度**: *3000

## 题目大意喵~

主人你好呀，喵~ 来看这道有趣的题目吧！

是这样的，我们有一个初始为空的序列，还有一个颜色池，里面的颜色编号从 $1$ 到 $m$。接下来会有 $q$ 次操作，操作分为两种：

1.  **添加操作**: 在序列的末尾添加一个新的元素。这个新元素的颜色会从给定的区间 $[lt, rt]$ 中等概率随机选择一个。序列的长度因此会加一。
2.  **查询操作**: 给定一个颜色区间 $[lt, rt]$。现在，我们只关心这个区间里的颜色。我们需要从当前序列的所有可能非空子区间（比如序列长度为 $n$，就有 $n(n+1)/2$ 个子区间）中，等概率随机选择一个。然后，计算这个子区间中，包含了多少种**不同**的、且颜色在 $[lt, rt]$ 内的颜色。我们要输出这个数量的**期望值**。

哦对了，这道题是**强制在线**的，也就是说，每次操作给出的 $[lt', rt']$ 需要和上一次查询的答案 `lstans` 进行 `xor 和取模运算，才能得到真正的 $[lt, rt]$ 呢。具体的解密方式题目里有说哦，喵~

## 解题思路分析

这道题看起来好复杂呀，又是随机颜色，又是随机子区间，还要算期望，喵呜~ 不过别怕，只要我们一步步拆解，就能找到线索的！

### 期望的线性性质是我们的好朋友！

期望题目的一个通用大杀器就是**期望的线性性质**，即“和的期望等于期望的和”。

我们要求的期望是“一个随机子区间中不同有效颜色的数量”。
根据线性性质，这可以转化为“对每一种有效颜色 $k$，它在一个随机子区间中出现的概率”的总和。

设当前序列长度为 $N$，查询的有效颜色区间为 $C = [lt, rt]$。
要求的期望 $E$ 可以写成：
$$
E = \sum_{k \in C} P(k \text{ 出现在一个随机子区间中})
$$

一个子区间是随机选的，总共有 $N(N+1)/2$ 个。所以，一个颜色 $k$ 出现在随机子区间中的概率，就是它在所有子区间中出现的次数的期望值，再除以总子区间数。
$$
P(k \text{ 出现在一个随机子区间中}) = \frac{E[\text{包含颜色 } k \text{ 的子区间数量}]}{N(N+1)/2}
$$
而 $E[\text{包含颜色 } k \text{ 的子区间数量}]$，根据期望的线性性质，又等于 $\sum_{1 \le i \le j \le N} P(k \text{ 出现在子区间 } [i,j] \text{ 中})$。

所以，最终的答案就是：
$$
E = \frac{2}{N(N+1)} \sum_{k \in C} \sum_{1 \le i \le j \le N} P(k \text{ 出现在子区间 } [i,j] \text{ 中})
$$
这个公式看起来还是好吓人呀！但我们已经把问题转化成了求一个和。我们的目标就是高效地算出 $\sum_{k \in C} \left( \sum_{1 \le i \le j \le N} P(k \text{ 出现在 } [i,j] \text{ 中}) \right)$。

### 一个神奇的转化

我们来聚焦于单个颜色 $k$ 的贡献，也就是 $\sum_{1 \le i \le j \le N} P(k \text{ 出现在 } [i,j] \text{ 中})$。
直接计算 $P(k \text{ 出现在 } [i,j] \text{ 中})$ 比较麻烦，因为它涉及到 $j-i+1$ 个元素。

这时候，就需要猫娘的直觉了！我们换个角度看这个和式。
固定右端点 $j$，我们来求和 $\sum_{i=1}^j P(k \text{ 出现在 } [i,j] \text{ 中})$。
一个颜色 $k$ 出现在 $[i,j]$ 中，等价于它在**前缀** $[1,j]$ 中的**最后一次出现**的位置大于等于 $i$。
设 $L_j(k)$ 是颜色 $k$ 在前缀 $[1,j]$ 中最后一次出现的位置（如果没出现，可以认为是 $0$）。$L_j(k)$ 是一个随机变量。
那么 $P(k \text{ 出现在 } [i,j] \text{ 中}) = P(L_j(k) \ge i)$。

于是，内层的和变成了：
$$
\sum_{i=1}^j P(k \text{ 出现在 } [i,j] \text{ 中}) = \sum_{i=1}^j P(L_j(k) \ge i)
$$
对于一个取非负整数的随机变量 $X$，我们有 $E[X] = \sum_{i=1}^{\infty} P(X \ge i)$。这里 $L_j(k)$ 就是这样的变量，所以：
$$
\sum_{i=1}^j P(L_j(k) \ge i) = E[L_j(k)]
$$
哇！这么一变，式子清爽多啦！
所以，颜色 $k$ 的总贡献就是 $\sum_{j=1}^N E[L_j(k)]$。

### 动态维护期望值

现在，问题变成了：当序列不断增长时，如何动态维护每个颜色的 $E[L_j(k)]$ 的前缀和？

设 $p_{j,k}$ 为第 $j$ 个元素颜色为 $k$ 的概率。
考虑 $L_j(k)$ 的期望 $E[L_j(k)]$。
当我们要确定 $L_j(k)$ 时：
-   有 $p_{j,k}$ 的概率，第 $j$ 个元素的颜色就是 $k$。此时 $L_j(k) = j$。
-   有 $1-p_{j,k}$ 的概率，第 $j$ 个元素的颜色不是 $k$。此时 $L_j(k)$ 和 $L_{j-1}(k)$ 是一样的。

根据全期望公式，我们可以得到一个递推关系：
$$
E[L_j(k)] = j \cdot p_{j,k} + E[L_{j-1}(k)] \cdot (1 - p_{j,k})
$$

我们定义两个状态量，来跟踪每个颜色 $k$ 的演化：
1.  $X_n(k) = E[L_n(k)]$：处理完 $n$ 个元素后，颜色 $k$ 在 $[1,n]$ 中最后出现位置的期望。
2.  $Y_n(k) = \sum_{j=1}^n E[L_j(k)] = \sum_{j=1}^n X_j(k)$：我们最终要求的就是这个值的区间和。

当第 $n$ 个元素（颜色范围 $[L,R]$，概率 $p_n = \frac{1}{R-L+1}$）加入时，状态如何更新呢？
-   $X_n(k) = n \cdot p_{n,k} + X_{n-1}(k) \cdot (1-p_{n,k})$
-   $Y_n(k) = Y_{n-1}(k) + X_n(k)$

这个更新是一个线性的变换！
对于 $k \in [L,R]$，$p_{n,k} = p_n$。
$$
\begin{cases}
X_n(k) = X_{n-1}(k) \cdot (1-p_n) + n \cdot p_n \\
Y_n(k) = Y_{n-1}(k) + X_n(k) = Y_{n-1}(k) + X_{n-1}(k) \cdot (1-p_n) + n \cdot p_n
\end{cases}
$$
对于 $k \notin [L,R]$，$p_{n,k} = 0$。
$$
\begin{cases}
X_n(k) = X_{n-1}(k) \\
Y_n(k) = Y_{n-1}(k) + X_n(k) = Y_{n-1}(k) + X_{n-1}(k)
\end{cases}
$$

### 线段树来帮忙！

我们发现，每次添加元素，都是对一个**颜色区间**内的所有 $k$ 应用一种线性变换，对区间外的所有 $k$ 应用另一种线性变换。
而查询操作，则是询问一个**颜色区间**内 $Y_n(k)$ 的总和。

这不就是为**线段树**量身定做的问题嘛！喵~

我们可以建立一棵关于颜色 $1, \dots, m$ 的线段树。
-   **树上节点**: 每个节点维护它所代表的颜色区间内，$\sum X_k$ 和 $\sum Y_k$ 的值。
-   **懒标记**: 每个节点需要一个懒标记，来表示待应用的线性变换。一个变换可以表示为 $(X, Y) \to (aX+b, Y+cX+e)$，所以懒标记需要存 $(a,b,c,e)$ 四个系数。
-   **更新操作**: 添加一个元素，就对应着对线段树进行一到两次（如果颜色范围不是整个 $[1,m]$）的区间更新。
-   **查询操作**: 直接在线段树上进行区间查询，求出 $\sum Y_k$，然后乘上前面的系数 $\frac{2}{N(N+1)}$ 就好啦。

这样，每次操作的复杂度就是线段树的区间操作复杂度 $O(\log m)$，总复杂度就是 $O((n+q)\log m)$，完全可以接受！

好啦，思路清晰了，可以开始写代码了，喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的代码哦，希望能帮助到你理解！

``cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

// 使用 long long 防止溢出
using ll = long long;

const int MOD = 998244353;
const int MAX_M = 500005;

// 快速幂，用于求逆元
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模块逆元
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// 预计算逆元，可以稍微快一点
vector<ll> inv(MAX_M + 1);
void precompute_inverses() {
    inv[1] = 1;
    for (int i = 2; i <= MAX_M; ++i) {
        inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;
    }
}

// 线段树节点
struct Node {
    ll sum_x; // 区间内 E[L_n(k)] 的和
    ll sum_y; // 区间内 sum(E[L_j(k)]) 的和
};

// 懒标记
struct LazyTag {
    ll mul_x, add_x; // X_new = X_old * mul_x + add_x
    ll mul_y_from_x, add_y; // Y_new = Y_old + X_old * mul_y_from_x + add_y
    
    // 检查是否是单位变换 (即没有懒标记)
    bool is_identity() const {
        return mul_x == 1 && add_x == 0 && mul_y_from_x == 0 && add_y == 0;
    }
};

vector<Node> tree;
vector<LazyTag> lazy;

// 合并子节点信息
void pull_up(int p) {
    tree[p].sum_x = (tree[2 * p].sum_x + tree[2 * p + 1].sum_x) % MOD;
    tree[p].sum_y = (tree[2 * p].sum_y + tree[2 * p + 1].sum_y) % MOD;
}

// 将懒标记应用到当前节点
void apply_tag(int p, int len, const LazyTag& tag) {
    // 更新 sum_y
    // Y_new = Y_old + X_old * mul_y_from_x + add_y * len
    tree[p].sum_y = (tree[p].sum_y + tree[p].sum_x * tag.mul_y_from_x + tag.add_y * len) % MOD;
    if (tree[p].sum_y < 0) tree[p].sum_y += MOD;

    // 更新 sum_x
    // X_new = X_old * mul_x + add_x * len
    tree[p].sum_x = (tree[p].sum_x * tag.mul_x + tag.add_x * len) % MOD;
    if (tree[p].sum_x < 0) tree[p].sum_x += MOD;
}

// 合并懒标记
void compose_tags(LazyTag& old_tag, const LazyTag& new_tag) {
    // old: X -> a1*X + b1, Y -> Y + c1*X + e1
    // new: X -> a2*X + b2, Y -> Y + c2*X + e2
    // composed: X -> a2*(a1*X+b1) + b2 = (a1*a2)*X + (a2*b1+b2)
    //           Y -> (Y+c1*X+e1) + c2*(a1*X+b1) + e2 = Y + (c1+a1*c2)*X + (e1+b1*c2+e2)
    
    ll a1 = old_tag.mul_x, b1 = old_tag.add_x;
    ll c1 = old_tag.mul_y_from_x, e1 = old_tag.add_y;
    
    ll a2 = new_tag.mul_x, b2 = new_tag.add_x;
    ll c2 = new_tag.mul_y_from_x, e2 = new_tag.add_y;

    old_tag.mul_x = (a1 * a2) % MOD;
    old_tag.add_x = (b1 * a2 + b2) % MOD;
    old_tag.mul_y_from_x = (c1 + a1 * c2) % MOD;
    old_tag.add_y = (e1 + b1 * c2 + e2) % MOD;
}

// 下推懒标记
void push_down(int p, int l, int r) {
    if (lazy[p].is_identity()) return;

    int mid = l + (r - l) / 2;
    int left_child = 2 * p, right_child = 2 * p + 1;
    
    apply_tag(left_child, mid - l + 1, lazy[p]);
    compose_tags(lazy[left_child], lazy[p]);

    apply_tag(right_child, r - mid, lazy[p]);
    compose_tags(lazy[right_child], lazy[p]);

    lazy[p] = {1, 0, 0, 0}; // 重置父节点懒标记
}

void build(int p, int l, int r) {
    tree[p] = {0, 0};
    lazy[p] = {1, 0, 0, 0};
    if (l == r) return;
    int mid = l + (r - l) / 2;
    build(2 * p, l, mid);
    build(2 * p + 1, mid + 1, r);
}

void update(int p, int l, int r, int ql, int qr, const LazyTag& tag) {
    if (ql > qr) return;
    if (ql <= l && r <= qr) {
        apply_tag(p, r - l + 1, tag);
        compose_tags(lazy[p], tag);
        return;
    }

    push_down(p, l, r);
    int mid = l + (r - l) / 2;
    if (ql <= mid) {
        update(2 * p, l, mid, ql, qr, tag);
    }
    if (qr > mid) {
        update(2 * p + 1, mid + 1, r, ql, qr, tag);
    }
    pull_up(p);
}

ll query(int p, int l, int r, int ql, int qr) {
    if (ql > qr) return 0;
    if (ql <= l && r <= qr) {
        return tree[p].sum_y;
    }

    push_down(p, l, r);
    int mid = l + (r - l) / 2;
    ll res = 0;
    if (ql <= mid) {
        res = (res + query(2 * p, l, mid, ql, qr)) % MOD;
    }
    if (qr > mid) {
        res = (res + query(2 * p + 1, mid + 1, r, ql, qr)) % MOD;
    }
    return res;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    precompute_inverses();

    int n_init, m, q;
    cin >> n_init >> m >> q;

    tree.resize(4 * m + 4);
    lazy.resize(4 * m + 4);
    build(1, 1, m);

    int current_n = 0;
    ll last_ans = 0;

    auto add_element = [&](int l, int r) {
        current_n++;
        ll p = inv[r - l + 1];
        ll one_minus_p = (1 - p + MOD) % MOD;
        
        // 更新 [l, r] 之外的区间
        // X_new = X_old, Y_new = Y_old + X_old
        LazyTag tag_outside = {1, 0, 1, 0};
        update(1, 1, m, 1, l - 1, tag_outside);
        update(1, 1, m, r + 1, m, tag_outside);

        // 更新 [l, r] 区间
        // X_new = X_old * (1-p) + n*p
        // Y_new = Y_old + X_new = Y_old + X_old * (1-p) + n*p
        LazyTag tag_inside = {one_minus_p, (ll)current_n * p % MOD, one_minus_p, (ll)current_n * p % MOD};
        update(1, 1, m, l, r, tag_inside);
    };
    
    for (int i = 0; i < n_init; ++i) {
        int l, r;
        cin >> l >> r;
        add_element(l, r);
    }

    for (int i = 0; i < q; ++i) {
        int type;
        ll lt_prime, rt_prime;
        cin >> type >> lt_prime >> rt_prime;

        ll lt = (lt_prime ^ last_ans) % m + 1;
        ll rt = (rt_prime ^ last_ans) % m + 1;
        if (lt > rt) swap(lt, rt);

        if (type == 1) {
            add_element(lt, rt);
        } else {
            ll total_contribution = query(1, 1, m, lt, rt);
            if (current_n == 0) {
                last_ans = 0;
            } else {
                ll total_subarrays_inv = modInverse((ll)current_n * (current_n + 1) / 2 % MOD);
                last_ans = (total_contribution * total_subarrays_inv) % MOD;
            }
            cout << last_ans << "\n";
        }
    }

    return 0;
}

```

## 复杂度分析

-   **时间复杂度**: $O((N_{init}+Q) \log M)$。
    我们有 $N_{init}$ 个初始元素和 $Q$ 个操作。每次操作（添加或查询）都对应着常数次线段树的区间操作。线段树建立在颜色范围 $1 \dots M$ 上，所以每次操作的时间复杂度是 $O(\log M)$。

-   **空间复杂度**: $O(M)$。
    主要的额外空间开销是线段树和懒标记数组，它们的规模都和颜色范围 $M$ 成正比。

## 知识点总结

这道题是期望、动态规划和数据结构的一个美妙结合，喵~

1.  **期望的线性性质**: 这是解决复杂期望问题的关键钥匙。它让我们能够把一个宏观的、复杂的期望问题，分解成许多个微观的、简单的子问题（比如单个颜色的贡献）来分别计算，最后再加起来。

2.  **期望DP与递推**: 我们通过分析“最后一次出现的位置”的期望，建立起了 $E[L_j(k)]$ 的递推关系。这种从 $j-1$ 到 $j$ 推导期望变化的思路是DP思想的体现。

3.  **线段树维护复杂变换**: 当我们需要对一个区间进行统一的、可合并的线性变换，并查询区间和时，带懒标记的线段树就是不二之选。这道题的懒标记稍微复杂一些，需要维护一个四元组来表示线性变换，但原理是相通的。

4.  **强制在线**: 一个常见的技巧，防止离线算法。处理方法比较固定，就是按题目要求解密输入就好啦。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，喵~