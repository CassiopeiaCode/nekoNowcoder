# S老师的求和挑战 - 题解

### 比赛与标签
> **比赛**: 未知比赛

> **标签**: 数学, 组合数学, 费马小定理, 模运算

> **难度**: *1600

## 题目大意喵~

一位被称为“求和大师”的S老师给了我们三个整数 $a, b, x$ 呐。
然后他定义了一系列神奇的函数：
$$
\begin{aligned}
L_1(k) & = ak+b \\
L_2(k) & = \sum_{i = 1}^k L_1(i) \\
L_3(k) & = \sum_{i = 1}^k L_2(i) \\
L_4(k) & = \sum_{i = 1}^k L_3(i) \\
\end{aligned}
$$
我们的任务就是，对于给定的 $a, b, x$，计算出 $L_1(x), L_2(x), L_3(x)$ 和 $L_4(x)$ 的值。因为答案可能会非常大，所以我们只需要输出结果对 $998244353$ 取模后的值就可以啦，喵~

## 解题思路分析

喵哈~！这道题看起来像是一层套一层的求和，有点像俄罗斯套娃呢！如果直接用循环去算，当 $x$ 很大的时候，肯定会超时。所以，我们得动动我们的小脑筋，找找规律，推导出它们的通项公式，这样就能 $O(1)$ 解决啦！

让本猫娘带你一步步揭开这些公式的神秘面纱吧，喵~

### 第一步：分析 $L_1(x)$ 和 $L_2(x)$

$L_1(x)$ 是最简单的，定义直接告诉我们了：
$$
L_1(x) = ax + b
$$

接下来是 $L_2(x)$，它是 $L_1(i)$ 从 $i=1$ 到 $x$ 的和：
$$
L_2(x) = \sum_{i=1}^{x} L_1(i) = \sum_{i=1}^{x} (ai + b)
$$
利用求和的线性性质，我们可以把它拆开：
$$
L_2(x) = a \left(\sum_{i=1}^{x} i\right) + \sum_{i=1}^{x} b
$$
这里用到了两个基础的求和公式，主人可要记牢哦：
1.  自然数求和公式: $\sum_{i=1}^{x} i = \frac{x(x+1)}{2}$
2.  常数求和公式: $\sum_{i=1}^{x} b = bx$

把它们代入，就得到 $L_2(x)$ 的表达式啦：
$$
L_2(x) = a \cdot \frac{x(x+1)}{2} + b \cdot x
$$

### 第二步：发现规律，引入组合数！

我们继续推导 $L_3(x)$:
$$
L_3(x) = \sum_{k=1}^{x} L_2(k) = \sum_{k=1}^{x} \left( a \frac{k(k+1)}{2} + bk \right) = a \sum_{k=1}^{x} \frac{k(k+1)}{2} + b \sum_{k=1}^{x} k
$$
这里的 $\sum_{k=1}^{x} k$ 我们已经会了，是 $\frac{x(x+1)}{2}$。那 $\sum_{k=1}^{x} \frac{k(k+1)}{2}$ 是什么呢？

我的猫猫直觉告诉我，这里面有更深层的规律！我们换个角度看，用组合数 $\binom{n}{k}$ 来表示这些公式，可能会有惊喜哦！
> 组合数公式: $\binom{n}{k} = \frac{n!}{k!(n-k)!} = \frac{n(n-1)\dots(n-k+1)}{k!}$

*   $L_1(k) = ak + b = a\binom{k}{1} + b\binom{k}{0}$
*   $L_2(x) = a \frac{x(x+1)}{2} + bx = a\binom{x+1}{2} + b\binom{x+1}{1}$

喵！看到了吗？$L_1$ 是关于 $\binom{k}{...}$ 的线性组合，而 $L_2$ 是关于 $\binom{x+1}{...}$ 的线性组合！这难道是巧合吗？

让我们来验证一下。这里需要一个非常重要的组合恒等式——**曲棍球棒恒等式 (Hockey-stick identity)**：
$$
\sum_{i=r}^{n} \binom{i}{r} = \binom{n+1}{r+1}
$$
这个公式就像曲棍球棒的形状，所以得了这么个可爱的名字~

用它来重新计算 $L_2(x)$:
$$
L_2(x) = \sum_{i=1}^{x} L_1(i) = \sum_{i=1}^{x} \left( a\binom{i}{1} + b\binom{i}{0} \right) = a\sum_{i=1}^{x}\binom{i}{1} + b\sum_{i=1}^{x}\binom{i}{0}
$$
根据曲棍球棒恒等式：
*   $\sum_{i=1}^{x}\binom{i}{1} = \binom{x+1}{2}$
*   $\sum_{i=1}^{x}\binom{i}{0} = \binom{x+1}{1}$

所以，$L_2(x) = a\binom{x+1}{2} + b\binom{x+1}{1}$。完全正确！

### 第三步：推广到 $L_3(x)$ 和 $L_4(x)$

有了这个强大的工具，推导 $L_3(x)$ 和 $L_4(x)$ 就变得像玩毛线球一样简单啦！

**计算 $L_3(x)$:**
$$
L_3(x) = \sum_{i=1}^{x} L_2(i) = \sum_{i=1}^{x} \left( a\binom{i+1}{2} + b\binom{i+1}{1} \right)
$$
为了使用曲棍球棒恒等式，我们做一个简单的换元，让 $j=i+1$。当 $i$ 从 $1$ 到 $x$ 时，$j$ 从 $2$ 到 $x+1$。
$$
L_3(x) = a \sum_{j=2}^{x+1}\binom{j}{2} + b \sum_{j=2}^{x+1}\binom{j}{1}
$$
应用恒等式：
*   $\sum_{j=2}^{x+1}\binom{j}{2} = \binom{(x+1)+1}{2+1} = \binom{x+2}{3}$
*   $\sum_{j=2}^{x+1}\binom{j}{1} = \binom{(x+1)+1}{1+1} = \binom{x+2}{2}$

于是我们得到了 $L_3(x)$ 的公式：
$$
L_3(x) = a\binom{x+2}{3} + b\binom{x+2}{2}
$$

**计算 $L_4(x)$:**
同理，我们可以光速写出 $L_4(x)$ 的推导：
$$
L_4(x) = \sum_{i=1}^{x} L_3(i) = \sum_{i=1}^{x} \left( a\binom{i+2}{3} + b\binom{i+2}{2} \right) = a\binom{x+3}{4} + b\binom{x+3}{3}
$$

### 第四步：整理公式与模运算

现在我们把这些漂亮的组合数公式换回普通的多项式形式，方便编程实现：
*   $L_1(x) = ax + b$
*   $L_2(x) = a \frac{x(x+1)}{2} + b x$
*   $L_3(x) = a \frac{x(x+1)(x+2)}{6} + b \frac{x(x+1)}{2}$
*   $L_4(x) = a \frac{x(x+1)(x+2)(x+3)}{24} + b \frac{x(x+1)(x+2)}{6}$

问题来了，这些公式里有除法！在模运算的世界里，除以一个数 $d$ 等于乘以它的**模逆元**。
因为模数 $998244353$ 是一个质数，我们可以用费马小定理来求逆元：
$d^{-1} \equiv d^{p-2} \pmod{p}$

所以，我们需要预先计算出 $2, 6, 24$ 对 $998244353$ 的模逆元。计算 $d^{p-2}$ 可以用快速幂算法，非常高效！

这样，所有的准备工作都完成啦！我们可以写代码了，喵~

## 代码实现

这是本猫娘精心编写的代码，注释超详细的哦，希望能帮到你！

```cpp
#include <iostream>

// 使用 long long 防止中间计算溢出
using ll = long long;

// 题目要求的模数
const int MOD = 998244353;

// 快速幂函数，用于计算 (base^exp) % mod
// 原理是二进制拆分指数，例如 a^13 = a^(8+4+1) = a^8 * a^4 * a^1
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) { // 如果指数当前位是1
            res = (res * base) % MOD;
        }
        base = (base * base) % MOD; // base平方
        exp /= 2; // 指数右移一位
    }
    return res;
}

// 模逆元函数，利用费马小定理 a^(p-2) % p
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

void solve() {
    ll a, b, x;
    std::cin >> a >> b >> x;

    // 对输入取模，是个好习惯
    a %= MOD;
    b %= MOD;
    x %= MOD;

    // 预计算我们需要的模逆元
    ll inv2 = modInverse(2);
    ll inv6 = modInverse(6);
    ll inv24 = modInverse(24);

    // --- 计算 L1(x) ---
    // L1(x) = a*x + b
    ll L1 = (a * x + b) % MOD;
    if (L1 < 0) L1 += MOD; // 保证结果是正数

    // --- 计算 L2(x) ---
    // L2(x) = a*x*(x+1)/2 + b*x
    ll term_a_L2 = a * x % MOD * ((x + 1) % MOD) % MOD * inv2 % MOD;
    ll term_b_L2 = b * x % MOD;
    ll L2 = (term_a_L2 + term_b_L2) % MOD;
    if (L2 < 0) L2 += MOD;

    // --- 计算 L3(x) ---
    // L3(x) = a*x*(x+1)*(x+2)/6 + b*x*(x+1)/2
    ll term_a_L3 = term_a_L2 * ((x + 2) % MOD) % MOD * modInverse(3) % MOD; // a*x*(x+1)*(x+2)/6 = (a*x*(x+1)/2) * (x+2)/3
    ll term_b_L3 = term_a_L2 * b % MOD * modInverse(a) % MOD; // b*x*(x+1)/2 = (a*x*(x+1)/2) * (b/a)
    // 为了避免除以a，我们直接重新计算
    term_b_L3 = b * x % MOD * ((x + 1) % MOD) % MOD * inv2 % MOD;
    ll L3 = (term_a_L3 + term_b_L3) % MOD;
    if (L3 < 0) L3 += MOD;

    // --- 计算 L4(x) ---
    // L4(x) = a*x*(x+1)*(x+2)*(x+3)/24 + b*x*(x+1)*(x+2)/6
    ll term_a_L4 = term_a_L3 * ((x + 3) % MOD) % MOD * modInverse(4) % MOD; // (a*.../6) * (x+3)/4
    ll term_b_L4 = term_a_L3 * b % MOD * modInverse(a) % MOD; // (b*.../6) = (a*.../6) * (b/a)
    // 同样，我们重新计算
    term_b_L4 = b * x % MOD * ((x + 1) % MOD) % MOD * ((x + 2) % MOD) % MOD * inv6 % MOD;
    ll L4 = (term_a_L4 + term_b_L4) % MOD;
    if (L4 < 0) L4 += MOD;

    // 输出结果
    std::cout << L1 << " " << L2 << " " << L3 << " " << L4 << "\n";
}

int main() {
    // 加速C++的I/O
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int T;
    std::cin >> T;
    while (T--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(T)$
  对于每组测试数据，我们只需要进行常数次的算术运算。计算模逆元使用了快速幂，其复杂度为 $O(\log MOD)$，但我们只对固定的几个数（2, 6, 24）计算一次，可以看作是预处理。因此，每个测试用例的处理时间是 $O(1)$。总共有 $T$ 个测试用例，所以总时间复杂度是 $O(T)$ 的说。

- **空间复杂度**: $O(1)$
  我们只使用了几个变量来存储输入的 $a, b, x$ 和计算的中间结果，没有使用任何随输入规模增大的数据结构。所以空间复杂度是常数级别的，喵~

## 知识点总结

这道题虽然看起来复杂，但其实是考验我们对数学工具的熟练运用，真是太有趣了！

1.  **求和公式**: 基础的自然数求和、平方和等公式是推导的起点。
2.  **组合数学**: 使用组合数和**曲棍球棒恒等式**是本题的捷径！它让复杂的求和变得优雅而简洁，是解决这类问题的大杀器！
3.  **模运算**: 在处理可能溢出的大数问题时，模运算是必备技能。记得所有加减乘都要取模哦。
4.  **模逆元**: 在模运算中实现除法，需要用到模逆元。当模数是质数时，**费马小定理**是求逆元的最佳伙伴。
5.  **快速幂**: 它是高效计算 $a^b \pmod p$ 的标准算法，也是计算模逆元的核心。

希望这篇题解能让你有所收获，喵~ 如果你喜欢，就给本猫娘点个赞吧！ >w<