# [给定一棵由 n 个节点构成的以 1 为根节点的有根二叉树... - 题解](https://www.dotcpp.com/oj/problem296391.html)

### 比赛与标签
> **比赛**: [该题目未与特定比赛关联]

> **标签**: 树形dp, 线段树合并

> **难度**: *2500

## 题目大意喵~

主人你好呀~！这道题是这样的喵：

我们拿到了一棵有 $n$ 个节点的有根二叉树，树根是节点 1 哦。每个节点上都有一个权值 $\text{val}_i$。我们的任务是，找出这棵树上有多少个“连通块”，满足一个特殊的条件，然后把数量告诉我就好啦，记得要对 $998244353$ 取模哦！

那么，什么是“连通块”呢？就是一个点的集合，集合里任意两个点之间的简单路径上的所有点，也都在这个集合里。简单来说，就是从树上掰下来的一小块，它自己也是一棵小树，喵~

那特殊的条件又是什么呢？对于一个连通块，我们把它里面的所有节点，按照在**原树**中的**后序遍历**顺序排成一队。我们要求，按照这个顺序，对应节点的权值序列必须是**非严格递增**的。比如说，连通块里的点按后序遍历顺序是 $b_1, b_2, \dots, b_k$，那么它们的权值就要满足 $\text{val}_{b_1} \le \text{val}_{b_2} \le \dots \le \text{val}_{b_k}$。

## 解题思路分析

这道题要在树上计数，而且是关于连通块的，一看就很有树形DP的味道呢，喵~ 我们的目标是统计所有满足条件的连通块数量。一个很自然的想法是，把所有连通块按它们的“根”分类。这里的“根”不是指原树的根，而是指一个连通块中深度最浅的那个节点。

所以，我们可以把总答案分解为：
$$
\text{总答案} = \sum_{u=1}^{n} (\text{以节点 } u \text{ 为根的、满足条件的连通块数量})
$$

现在问题就转化成了，对于每个节点 $u$，如何计算以它为根的合法连通块数量。我们用一个函数 $f(u)$ 来表示这个数量。

一个以 $u$ 为根的连通块，必然包含节点 $u$ 本身。它还可以包含一些从 $u$ 的左孩子 $\text{lc}$ 和右孩子 $\text{rc}$ 延伸下去的连通部分。具体来说，一个以 $u$ 为根的连通块 $C$ 可以由以下部分组成：
1.  节点 $u$ 本身。
2.  一个以 $\text{lc}$ 为根的连通块 $C_L$。
3.  一个以 $\text{rc}$ 为根的连通块 $C_R$。

所以 $C = \{u\} \cup C_L \cup C_R$（其中 $C_L$ 和 $C_R$ 可以是空的）。

接下来，我们来分析那个“权值非严格递增”的条件。原树的后序遍历顺序是“左子树 -> 右子树 -> 根”。所以，对于我们这个连通块 $C$，其中节点的后序遍历顺序就是：先是 $C_L$ 中的所有节点（按它们在原树中的后序遍历顺序），然后是 $C_R$ 中的所有节点（同理），最后是节点 $u$。

要让整个权值序列非严格递增，就需要满足以下所有条件：
1.  $C_L$ 本身是合法的（即 $C_L$ 内部节点的权值按后序遍历是非严格递增的）。
2.  $C_R$ 本身是合法的。
3.  如果 $C_L$ 和 $C_R$ 都不为空，那么 $C_L$ 中最后一个节点的权值要小于等于 $C_R$ 中第一个节点的权值。
4.  如果 $C_R$ 不为空，那么 $C_R$ 中最后一个节点的权值要小于等于 $u$ 的权值。
5.  如果 $C_L$ 不为空且 $C_R$ 为空，那么 $C_L$ 中最后一个节点的权值要小于等于 $u$ 的权值。

这里的“第一个/最后一个节点”都是指在后序遍历顺序中的。
-   对于 $C_L$ 来说，它的后序遍历最后一个节点就是它的根 $\text{lc}$。
-   对于 $C_R$ 来说，它的后序遍历最后一个节点就是它的根 $\text{rc}$。
-   对于 $C_R$ 来说，它的后序遍历第一个节点是 $C_R$ 中最“左”的那个叶子节点。我们把它记作 $\text{first}(C_R)$。

这样一来，条件就清晰多啦：
1.  $C_L$ 是一个以 $\text{lc}$ 为根的合法连通块。
2.  $C_R$ 是一个以 $\text{rc}$ 为根的合法连通块。
3.  $\text{val}(\text{lc}) \le \text{val}(\text{first}(C_R))$。
4.  $\text{val}(\text{rc}) \le \text{val}(u)$。
5.  （$C_R$ 为空时）$\text{val}(\text{lc}) \le \text{val}(u)$。

这个 $\text{val}(\text{first}(C_R))$ 看起来好麻烦呀，它取决于 $C_R$ 的具体形态。但是，本猫娘发现了一个关键的小秘密！因为 $C_R$ 本身是合法的，所以它的权值序列是 `val(first(C_R)) $\le \dots \le$ val(rc)`。这意味着 `val(first(C_R)) <= val(rc)` 总是成立的！

所以，如果 `val(lc) <= val(rc)`，那么 `val(lc) <= val(rc)` 是 `val(lc) <= val(first(C_R))` 的一个更强的约束。不对，反了喵！`val(first(C_R)) <= val(rc)`，所以只要 `val(lc) <= val(first(C_R))` 成立，我们并不能推断出 `val(lc)` 和 `val(rc)` 的关系。
但是！我们要求的 `val(lc) <= val(first(C_R))`，而 `val(first(C_R)) 是 $C_R$ 中所有节点权值的最小值。所以这个条件依然依赖于 $C_R$ 的具体选择。

看来我们需要一个更强大的 DP 状态。我们不能只记录一个计数值，而是需要记录更详细的信息。对于每个节点 $u$，我们想知道以它为根的合法连通块们，它们的“起始权值”（即 $\text{val}(\text{first}(C))$）都是多少。

所以，我们的 DP 状态 dp[u]` 可以是一个映射（map）：`v_first -> count`。它表示以 $u$ 为根的合法连通块中，起始权值为 `v_first` 的有多少个。

由于权值可能很大，直接用 map 会很慢。但是权值的种类数最多只有 $N$ 种，所以我们可以先对所有权值进行**离散化**。然后，这个 `dp[u]` 就可以用一个数据结构来高效地维护了。它需要支持：
-   点修改（增加某个 `v_first` 的 `count`）。
-   区间查询（查询某个 `v_first` 范围内的总 `count`）。
-   整体合并和修改（比如把 `dp[lc]` 的所有信息合并到 `dp[u]` 里）。

这不就是**线段树合并**的经典应用场景嘛！喵~

我们用 `root[u]` 代表维护 `dp[u]` 的线段树的根节点。线段树的下标就是离散化后的权值。

下面是 `dfs(u)` 的详细流程，我们在后序遍历（左、右、根）的过程中完成计算：
1.  递归处理左子树 `lc` 和右子树 `rc`，得到它们各自的线段树 `root[lc]` 和 `root[rc]`。
2.  为节点 `u` 创建一棵新的线段树 `root[u]`，只包含一个信息：以 `{u}` 这个最简单的连通块，它的起始和终止权值都是 `val(u)`。所以我们 `update(root[u], discrete(val(u)), 1)`。
3.  考虑组合。一个以 $u$ 为根的合法连通块，可以由以下四种方式构成：
    -   **只有 `u`**：已经在第2步处理了。
    -   **`u` 和来自左子树的 `C_L`**：需要 `val(lc) <= val(u)`。如果满足，`dp[lc]` 中的每个连通块都可以和 `u` 组合。新连通块的 `v_first` 和 `C_L` 的一样。
    -   **`u` 和来自右子树的 `C_R`**：需要 `val(rc) <= val(u)`。如果满足，`dp[rc]` 中的每个连通块都可以和 `u` 组合。新连通块的 `v_first` 和 `C_R` 的一样。
    -   **`u`、`C_L` 和 `C_R`**：需要 `val(rc) <= val(u)` 并且 `val(lc) <= val(first(C_R))`。

我们可以把这些组合操作用线段树合并来实现：
1.  `dfs(u)` 返回 `root[u]`。
2.  `root[lc] = dfs(lc)`, `root[rc] = dfs(rc)`。
3.  创建 `root[u]`，并插入 `{u}` 的信息。
4.  **处理右子树**:
    -   计算 `C_L` 和 `C_R` 组合时，对 `C_R` 的要求总数。我们把这个值记为 `ways_from_R`。
        `ways_from_R = query(root[rc], range=[discrete(val(lc)), discrete(val(rc))])`。
        为什么查询的上界是 `discrete(val(rc))` 呢？因为我们发现了 `val(first(C_R)) <= val(rc)` 总是成立！所以我们只需要在 `[discrete(val(lc)), discrete(val(rc))]` 这个范围内找 `v_first` 就行啦。
    -   如果 `val(rc) <= val(u)`，将 `root[rc]` 合并到 `root[u]` 中。这对应了所有 `{u} U C_R` 的情况。
5.  **处理左子树**:
    -   如果 `val(lc) <= val(u)`，我们将 `root[lc]` 合并到 `root[u]`。但这次合并有点特别，`root[lc]` 中的每一个计数，都代表一种 `C_L` 的选择。对于每一种 `C_L`，它可以选择：
        a. 单独和 `u` 组合（1种方式）。
        b. 和 `u` 以及一个合法的 `C_R` 组合 (`ways_from_R` 种方式)。
        所以 `root[lc]` 中的每个计数都要乘以 `(1 + ways_from_R)`。这可以通过给线段树打上一个乘法懒标记来实现。
6.  `root[u]` 构建完毕后，树中所有值的和就是以 `u` 为根的合法连通块总数。我们把它累加到最终答案 `ans` 中。

这样，通过一次 DFS，我们就能计算出所有节点的贡献，从而得到最终答案，喵~

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 使用 long long 防止溢出，喵~
using ll = long long;

const int MOD = 998244353;
const int MAXN = 500005;

// 树的结构
int n;
int node_val[MAXN];
int children[MAXN][2]; // children[i][0] 是左孩子，children[i][1] 是右孩子

// 离散化相关
vector<int> distinct_vals;
int discrete_map[MAXN];
int m; // 离散化后不同值的数量

// 线段树节点
struct SegTreeNode {
    int ls = 0, rs = 0;
    ll sum = 0;
    ll mul_tag = 1;
};

vector<SegTreeNode> seg_tree;
int seg_tree_node_count = 0;

// 创建一个新的线段树节点
int new_node() {
    seg_tree.emplace_back();
    return ++seg_tree_node_count;
}

// 下放懒标记
void push_down(int p) {
    if (seg_tree[p].mul_tag == 1) return;
    ll& tag = seg_tree[p].mul_tag;

    if (seg_tree[p].ls) {
        int l_child = seg_tree[p].ls;
        seg_tree[l_child].sum = (seg_tree[l_child].sum * tag) % MOD;
        seg_tree[l_child].mul_tag = (seg_tree[l_child].mul_tag * tag) % MOD;
    }
    if (seg_tree[p].rs) {
        int r_child = seg_tree[p].rs;
        seg_tree[r_child].sum = (seg_tree[r_child].sum * tag) % MOD;
        seg_tree[r_child].mul_tag = (seg_tree[r_child].mul_tag * tag) % MOD;
    }
    tag = 1;
}

// 单点更新
void update(int& p, int l, int r, int pos, int val) {
    if (!p) p = new_node();
    if (l == r) {
        seg_tree[p].sum = (seg_tree[p].sum + val) % MOD;
        return;
    }
    push_down(p);
    int mid = l + (r - l) / 2;
    if (pos <= mid) {
        update(seg_tree[p].ls, l, mid, pos, val);
    } else {
        update(seg_tree[p].rs, mid + 1, r, pos, val);
    }
    seg_tree[p].sum = (seg_tree[seg_tree[p].ls].sum + seg_tree[seg_tree[p].rs].sum) % MOD;
}

// 区间查询
ll query(int p, int l, int r, int ql, int qr) {
    if (!p || ql > qr) return 0;
    if (ql <= l && r <= qr) {
        return seg_tree[p].sum;
    }
    push_down(p);
    int mid = l + (r - l) / 2;
    ll res = 0;
    if (ql <= mid) {
        res = (res + query(seg_tree[p].ls, l, mid, ql, qr)) % MOD;
    }
    if (qr > mid) {
        res = (res + query(seg_tree[p].rs, mid + 1, r, ql, qr)) % MOD;
    }
    return res;
}

// 合并两棵线段树，q 合并到 p，并给 q 的所有值乘上一个因子
int merge(int p, int q, int l, int r, ll factor) {
    if (!p) {
        if (!q) return 0;
        seg_tree[q].sum = (seg_tree[q].sum * factor) % MOD;
        seg_tree[q].mul_tag = (seg_tree[q].mul_tag * factor) % MOD;
        return q;
    }
    if (!q) return p;

    if (l == r) {
        seg_tree[p].sum = (seg_tree[p].sum + seg_tree[q].sum * factor) % MOD;
        return p;
    }
    
    push_down(p);
    push_down(q);
    int mid = l + (r - l) / 2;
    seg_tree[p].ls = merge(seg_tree[p].ls, seg_tree[q].ls, l, mid, factor);
    seg_tree[p].rs = merge(seg_tree[p].rs, seg_tree[q].rs, mid + 1, r, factor);
    seg_tree[p].sum = (seg_tree[seg_tree[p].ls].sum + seg_tree[seg_tree[p].rs].sum) % MOD;
    return p;
}

ll total_ans = 0;

// 树形DP的核心，喵~
int dfs(int u) {
    if (u == 0) return 0;

    int lc = children[u][0];
    int rc = children[u][1];

    int root_l = dfs(lc);
    int root_r = dfs(rc);

    int root_u = 0;
    update(root_u, 1, m, discrete_map[u], 1);

    ll ways_from_R = 0;
    if (rc != 0 && node_val[rc] <= node_val[u]) {
        if (lc != 0 && node_val[lc] <= node_val[rc]) {
            ways_from_R = query(root_r, 1, m, discrete_map[lc], discrete_map[rc]);
        }
        root_u = merge(root_u, root_r, 1, m, 1);
    }
    
    if (lc != 0 && node_val[lc] <= node_val[u]) {
        root_u = merge(root_u, root_l, 1, m, (ways_from_R + 1) % MOD);
    }

    total_ans = (total_ans + seg_tree[root_u].sum) % MOD;
    return root_u;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> node_val[i];
        distinct_vals.push_back(node_val[i]);
    }
    for (int i = 1; i <= n; ++i) {
        cin >> children[i][0] >> children[i][1];
    }

    // 离散化
    sort(distinct_vals.begin(), distinct_vals.end());
    distinct_vals.erase(unique(distinct_vals.begin(), distinct_vals.end()), distinct_vals.end());
    m = distinct_vals.size();
    for (int i = 1; i <= n; ++i) {
        discrete_map[i] = lower_bound(distinct_vals.begin(), distinct_vals.end(), node_val[i]) - distinct_vals.begin() + 1;
    }
    
    // 预留空间，防止 vector 重新分配内存导致指针失效
    seg_tree.resize(MAXN * 25);
    
    dfs(1);

    cout << total_ans << endl;

    return 0;
}
``

## 复杂度分析

- **时间复杂度**: $O(N \log N)$，喵~
  - 首先，对权值进行排序和离散化，需要 $O(N \log N)$ 的时间。
  - 接着是 dfs` 过程。我们对整棵树进行一次深度优先搜索。在每个节点 `u，我们会进行线段树的合并、查询和更新操作。
  - 线段树合并的复杂度与两棵树重合部分的节点数成正比。由于每个节点只会被创建一次，并在合并后成为新树的一部分，所以所有合并操作的总复杂度是 $O(N \log N)$，其中 $\log N$ 是线段树的深度（离散化后最多有 $N$ 个值）。
  - 查询和更新操作也是 $O(\log N)$ 的。
  - 所以总的时间复杂度是 $O(N \log N)$。

- **空间复杂度**: $O(N \log N)$，喵~
  - 存储树的结构和节点权值需要 $O(N)$ 的空间。
  - 线段树是动态开点的。每次 update 最多创建 $\log N$ 个新节点。在整个 dfs 过程中，我们最多创建 $O(N \log N)$ 个线段树节点。所以线段树占用的空间是 $O(N \log N)$。
  - 因此，总的空间复杂度是 $O(N \log N)$。

## 知识点总结

这道题是一道非常好的练习题，融合了多种算法思想，喵~
1.  **树形DP**: 这是解决树上计数问题的基本框架。我们将问题分解为子问题，通过递归（DFS）的方式自底向上地解决。
2.  **线段树合并**: 当树形DP的状态是一个与权值相关的复杂集合（比如本题的 v_first -> count` 的映射）时，线段树合并就成了一个强大的工具。它能高效地合并子树的信息，同时支持查询。
3.  **离散化**: 当题目中的权值范围很大，但实际用到的权值种类不多时，离散化是降低空间和时间复杂度的常用技巧。
4.  **懒标记 (Lazy Propagation)**: 在线段树合并时，有时需要对一整棵子树进行统一的修改（比如本题的乘法操作），使用懒标记可以高效地完成这个任务。
5.  **问题分析与转化**: 解题的关键在于正确分析题目条件，将复杂的“非严格递增”序列条件，转化为对子问题解的几个具体约束（比如 `val(lc) <= val(first(C_R))`），并发现其中的隐藏性质（`val(first(C_R)) <= val(rc)`），从而简化问题。

希望这篇题解能帮助到你哦，主人！如果还有不明白的地方，随时可以再来问我，喵~ >w<