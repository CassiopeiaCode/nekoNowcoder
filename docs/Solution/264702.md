# 有一棵共有 n 个结点的有根树... - 题解

### 比赛与标签
> **比赛**: The 2nd Universal Cup. Stage 1: Shenyang

> **标签**: 博弈论, 树形DP, 深度优先搜索

> **难度**: 暂无评分

## 题目大意喵~

各位Master，我们来玩一个有趣的游戏吧，喵~

游戏在一个有 $n$ 个节点的有根树上进行，其中1号节点是树根。除了树根，其他的节点 $i$（从 $2$ 到 $n$）上都有 $c_i$ 个金币。

游戏开始时，棋子放在根节点。Alice 和 Bob 轮流操作，Alice 先手。每次操作，玩家需要将棋子从当前节点 $x$ 移动到它的任意一个**子孙**节点 $y$ 上。移动后，该玩家就能获得节点 $y$ 上的所有金币。

当棋子移动到一个叶子节点时，就不能再移动了，游戏就结束啦。

Alice 的目标是让自己最终获得的金币总数 $a$ 减去 Bob 的金币总数 $b$（也就是 $a-b$）尽可能大。而 Bob 的目标正好相反，他想让 $a-b$ 尽可能小。他们两个都非常聪明，每一步都会选择对自己最有利的策略。

我们的任务就是，预测在双方都采取最优策略的情况下，游戏结束时 $a-b$ 的值会是多少呢？

**输入格式**
- 第一行是一个整数 $T$，表示有 $T$ 组测试数据。
- 每组数据：
    - 第一行是一个整数 $n$。
    - 第二行是 $n-1$ 个整数，分别表示节点 $2, 3, \ldots, n$ 上的金币数量。
    - 第三行是 $n-1$ 个整数，分别表示节点 $2, 3, \ldots, n$ 的父节点。

**输出格式**
- 对每组数据，输出一个整数，表示最终的 $a-b$ 值。

## 解题思路分析

这道题是一个典型的博弈论问题，发生在一棵树上，喵~ Alice 和 Bob 都采取最优策略，这提示我们可以用**极小化极大算法 (Minimax)** 的思想来解决。结合树形的结构，这道题就变成了一个经典的**树形动态规划 (Tree DP)** 问题啦！

#### 1. 定义DP状态

首先，我们需要定义一个状态来表示游戏在某个节点的 "价值"。这个 "价值" 就是我们最终要求的 $a-b$ 的差值。

让我们来定义 `dp[u]`：**表示棋子当前在节点 `u`，轮到当前玩家行动时，该玩家能够为自己带来的，相对于对手的最终分数优势**。换句话说，如果轮到 Alice 在节点 `u` 行动，`dp[u]` 就是游戏结束时 Alice 能比 Bob 多得的分数；如果轮到 Bob，`dp[u]` 就是 Bob 能比 Alice 多得的分数。

#### 2. 寻找状态转移方程

现在，我们来思考一下，当棋子在节点 `u`，轮到当前玩家（比如 Alice）行动时，她会怎么做呢？

Alice 的目标是最大化 $a-b$。她可以把棋子移动到 `u` 的任意一个子孙节点 `v`。
- 当她选择移动到 `v` 时，她会立刻获得 `v` 节点上的 $c_v$ 个金币。
- 之后，棋子到达了 `v`，轮到对手 Bob 行动。根据我们的 `dp` 定义，Bob 在 `v` 节点行动，能为他自己带来 `dp[v]` 的分数优势。
- 那么，对于 Alice 来说，Bob 获得的 `dp[v]` 优势，就相当于她自己损失了 `dp[v]`。
- 所以，Alice 选择移动到 `v` 这一步，给她带来的总分数优势就是 $c_v - dp[v]$。

Alice 是个聪明的玩家，她会遍历所有可能的子孙节点 `v`，并选择那个能使 $c_v - dp[v]$ 最大的 `v`。所以，我们可以得到状态转移方程：

$$
dp[u] = \max_{v \in \text{descendants}(u)} \{ c_v - dp[v] \}
$$

#### 3. 优化状态转移

这个状态转移方程需要遍历一个节点的所有子孙，效率太低了，喵~ 如果一个节点的子孙很多，计算会非常慢。我们得想办法优化它！

一个节点 `u` 的所有子孙，可以按照它的**孩子**节点来划分。`u` 的子孙集 = `u` 的所有孩子节点，加上这些孩子节点的所有子孙。

所以，当 Alice 在 `u` 节点时，她的选择可以分为两类：
1.  移动到 `u` 的一个**孩子**节点 `w`。
2.  移动到 `u` 的一个**孙子或更深**的节点（也就是 `w` 的某个子孙 `v`）。

让我们分析一下 Alice 从 `u` 出发，把棋子移到孩子 `w` 的子树里，能获得的最大收益。
-   **选择1：直接移动到 `w`**。收益是 $c_w - dp[w]$。
-   **选择2：移动到 `w` 的某个子孙 `v`**。这个选择带来的收益是 $c_v - dp[v]$。Alice 会选择 `w` 的子孙 `v` 中，能使这个值最大的那个。这恰好就是 `dp[w]` 的定义！因为 $dp[w] = \max_{v \in \text{descendants}(w)} \{c_v - dp[v]\}$。

所以，如果 Alice 决定进入 `w` 的子树，她能获得的最大收益就是 $\max(c_w - dp[w], dp[w])$。

既然 Alice 会选择对她最有利的孩子子树，那么 `dp[u]` 就是在所有孩子 `w` 中，能提供的最大收益的那个。于是，我们得到了优化后的状态转移方程：

$$
dp[u] = \max_{w \in \text{children}(u)} \{ \max(c_w - dp[w], dp[w]) \}
$$

#### 4. Base Case 和计算顺序

-   **Base Case**: 如果 `u` 是一个叶子节点，那么玩家在 `u` 无法进行任何操作。所以，从 `u` 出发能获得的额外分数优势是 0。即 $dp[\text{leaf}] = 0$。
-   **计算顺序**: 我们可以看到，`dp[u]` 的计算依赖于它的所有孩子节点的 `dp` 值。这提示我们应该从树的底部（叶子）向上计算到树根。**深度优先搜索 (DFS)** 的后序遍历天然满足这个计算顺序！

我们从根节点开始DFS，先递归处理完所有子节点，在回溯时，利用子节点已经计算好的 `dp` 值来计算当前节点的 `dp` 值。

最终，我们要求的答案就是 `dp[root]`，也就是 Alice 在游戏开始时（棋子在根节点）能获得的最大分数优势。

因为题目中节点 1 是根，且没有金币，我们可以将节点 1 到 $n$ 映射到 0 到 $n-1$ 的数组下标，根节点为 0，它的金币为 0。

## 代码实现

下面是本猫娘根据上面的思路，用 C++ 重新编写的、带有详细注释的代码哦，希望能帮助到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 使用 long long 来防止分数溢出，喵~
using ll = long long;

// 全局变量，方便在DFS中访问
int n;
std::vector<ll> coins;          // 存储每个节点的金币
std::vector<std::vector<int>> adj; // 邻接表存树
std::vector<ll> dp;             // dp[u] 表示在节点u行动的玩家能获得的最大分数优势

// 深度优先搜索，用于计算DP值
void dfs(int u) {
    // 如果当前节点是叶子节点，它的孩子列表为空，循环不会执行
    // dp[u] 初始为0，这正好是叶子节点的base case，喵~

    // 遍历所有孩子节点 v
    for (int v : adj[u]) {
        // 先递归计算子节点的dp值
        dfs(v);

        // 根据状态转移方程更新父节点 u 的 dp 值
        // 从 u 出发，可以移动到孩子 v，收益是 coins[v] - dp[v]
        // 也可以移动到 v 的子孙，最大收益是 dp[v]
        // 所以从 v 这棵子树能获得的最大收益是 max(coins[v] - dp[v], dp[v])
        // 我们要在所有孩子中取一个最大的收益
        dp[u] = std::max(dp[u], std::max(coins[v] - dp[v], dp[v]));
    }
}

void solve() {
    // 读入节点数
    std::cin >> n;

    // 初始化/清空数据结构
    // 节点编号为 0 到 n-1
    coins.assign(n, 0);
    adj.assign(n, std::vector<int>());
    dp.assign(n, 0);

    // 读入金币，题目给的是节点2到n的金币，对应我们的下标1到n-1
    for (int i = 1; i < n; ++i) {
        std::cin >> coins[i];
    }

    // 读入父节点，构建邻接表
    // 题目给的是节点2到n的父节点，对应我们的下标1到n-1
    for (int i = 1; i < n; ++i) {
        int parent;
        std::cin >> parent;
        // 题目是1-based，我们转成0-based
        adj[parent - 1].push_back(i);
    }

    // 从根节点0开始DFS
    dfs(0);

    // 最终答案就是 dp[0]
    std::cout << dp[0] << std::endl;
}

int main() {
    // 加速输入输出
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N)$。我们的 `dfs` 函数会访问每个节点和每条边恰好一次。构建邻接表也是 $O(N)$ 的。对于每组测试数据，总的时间复杂度是线性的，非常高效哦！
-   **空间复杂度**: $O(N)$。我们使用了邻接表 `adj`、金币数组 `coins` 和 `dp` 数组，它们的大小都和节点数 $N$ 成正比。DFS的递归栈深度在最坏情况下（一条链）也是 $O(N)$。

## 知识点总结

这道题真是一次愉快的思维探险呢，喵~ 它融合了几个核心的算法知识点：

1.  **博弈论 (Game Theory)**: 识别出这是一个双方最优决策的对抗性游戏是解题的第一步。这通常导向 Minimax 思想。
2.  **树形动态规划 (Tree DP)**: 将 Minimax 思想应用在树形结构上，形成了树形 DP。DP 的状态定义和转移方程是解决问题的核心。
3.  **深度优先搜索 (DFS)**: DFS 是实现树形 DP 的常用工具。它的后序遍历特性（先处理子树，再处理根）完美契合了 DP 状态的依赖关系。
4.  **状态转移优化**: 从一个朴素的（遍历所有子孙）但正确的状态转移方程，通过分析游戏选择的结构，优化成一个高效的（只依赖孩子节点）方程，是本题的关键技巧。

希望这篇题解能帮助你更好地理解这道题！继续加油，你也是算法大师，喵~