# 魔法商店的小鱼干 - 题解

### 比赛与标签
> **比赛**: 蓝桥杯星球的算法挑战赛
> **标签**: 贪心, 二分, 前缀和
> **难度**: *1800

## 喵~ 题目讲了什么呀？
各位小主人，下午好喵~！今天我们来逛一家神奇的魔法商店，这里有好多好多美味的小鱼干！(ฅ'ω'ฅ)

是这样的说：
1.  店里有 `n` 种小鱼干礼包，第 `i` 种礼包有 `a_i` 条小鱼干，卖 `2^(i-1)` 个猫猫币。
2.  一个很重要的信息是，更贵的礼包里的小鱼干数量不会更少，也就是 `a_i <= a_j` 如果 `i < j` 的说。
3.  每天，每种礼包我们最多只能买一个哦。
4.  接下来的 `q` 天，我们家的小猫咪每天需要吃掉 `b_i` 条小鱼干。
5.  我们的任务是，为每一天计算一下，为了凑够至少 `b_i` 条小鱼干，最少需要花多少猫猫币呢？

简单来说，就是每天我们都要做一个选择题：从 `n` 种礼包里选一些出来，让小鱼干总数不少于当天的需求 `b_i`，同时总花费要最小。最后的结果要对 `998244353` 取模哦！

## 解题思路大揭秘！
这道题看起来有点像背包问题，但是它的价格设计得非常特殊，这可是解题的关键所在喵！

#### 关键性质：价格的秘密
第 `i` 个礼包的价格是 `2^(i-1)`。我们来观察一下这些价格：`1, 2, 4, 8, 16, ...`。
有没有发现一个神奇的规律？
`1 < 2`
`1 + 2 = 3 < 4`
`1 + 2 + 4 = 7 < 8`
...
总结一下就是：**前 `k` 个礼包的总价格，永远比第 `k+1` 个礼包的价格要便宜！** (`(2^k - 1) < 2^k`)

这个性质告诉我们一个非常重要的贪心策略：**为了省钱，我们应该尽可能地避免购买价格高的礼包**。比如，如果我们能用第1到第5个礼包的组合满足需求，就绝对不要去碰第6个礼包，因为第6个礼包自己就比前5个加起来还要贵！

#### 贪心策略：先全款拿下，再“退货”省钱
基于上面的发现，我们可以想出一个“最大胆”的购买方案，然后再想办法优化它，喵~

1.  **初步购买**：我们先找到一个最小的 `k`，使得只购买第 `1` 到第 `k` 个礼包，小鱼干的总数就刚好足够（或者超出）当天的需求 `b_i`。也就是说，`a_1 + a_2 + ... + a_k >= b_i`，但是 `a_1 + a_2 + ... + a_{k-1} < b_i`。
    这个 `k` 怎么找最快呢？当然是用 **二分查找** 啦！我们可以预处理出 `a` 数组的前缀和 `sum`，然后在 `sum` 数组上二分，就能在 `O(log n)` 的时间里快速找到这个 `k`。

2.  **计算初始花费和“富余”**：现在我们买下了 `1` 到 `k` 号所有礼包。总花费是 `2^0 + 2^1 + ... + 2^(k-1) = 2^k - 1`。我们得到的小鱼干总数是 `sum[k]`。
    这时候，我们手里的小鱼干可能比需要的多了一些，多出来的部分就是 `surplus = sum[k] - b_i`。

3.  **贪心“退货”**：为了让花费最小，我们可以看看能不能“退掉”一些已经购买的礼包，只要退掉之后剩下的小鱼干还够吃就行。
    应该先退哪个呢？当然是退最贵的那个啦！这样省的钱最多！
    我们手里有 `{1, 2, ..., k}` 号礼包。最贵的是 `k` 号，但我们不能退，因为退了它，前 `k-1` 个肯定不够。所以我们从 `k-1` 号礼包开始考虑。
    -   当前我们有 `surplus` 这么多的富余小鱼干。我们想退掉一个礼包 `j`，这个礼包有 `a_j` 条小鱼干。只要 `a_j <= surplus`，就说明退掉它之后，我们的小鱼干总数 `sum[k] - a_j` 仍然大于等于 `b_i`，这是完全可以的！
    -   所以，我们的策略是：在还持有的礼包中，找到最贵的那个（也就是编号最大的那个）`j`，满足 `a_j <= surplus`。然后我们就“退掉”它：总花费减去 `2^(j-1)`，富余的小鱼干也减去 `a_j`。
    -   然后我们重复这个过程，直到没有任何一个持有的礼包可以被退掉为止。

怎么快速找到这个“最贵的、可以退掉的”礼包 `j` 呢？还是用 **二分查找**！我们在 `a[1...k-1]` 数组上二分，查找满足 `a_j <= surplus` 的最大 `j`。

#### 算法总结
对于每一天的需求 `b_i`：
1.  预处理 `a` 的前缀和 `sum` 数组和 `2` 的幂次 `pow` 数组。
2.  **二分查找** `sum` 数组，找到最小的 `k` 使得 `sum[k] >= b_i`。
3.  计算初始总花费 `cost = 2^k - 1` 和富余的小鱼干 `left = sum[k] - b_i`。
4.  进入一个循环，只要 `left > 0`：
    a. 在当前持有的最贵礼包编号 `j`（初始为 `k`）范围内，**二分查找** 最大的礼包编号 `l < j`，使得 `a[l] <= left`。
    b. 如果找到了这样的 `l`，就退货！`cost -= pow[l]`，`left -= a[l]`。然后下一次我们只在 `l` 之前的礼包里找，更新查找上界。
    c. 如果找不到，就结束循环。
5.  最终的 `cost` 就是答案啦！

## AC代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <list>
#include <set>
//#include <cmath>
#include <cassert>
 
using namespace std;
 
typedef long long ll;
 
const int N = 100005, M = 1505, mo = 998244353;
// a: 存储每种礼包的小鱼干数量
// pow: 预计算2的幂次，pow[i] = 2^(i-1)
// sum: a数组的前缀和
ll a[N], pow[N], sum[N];
 
int main() {
    int n, m; // n是礼包种类数，m是天数(查询次数)
    long long max_val = 1e18;
    max_val *= 4; // 设置一个很大的上限，防止前缀和溢出
    
    scanf("%d%d", &n, &m);
    
    // 读入数据并计算前缀和
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        sum[i] = (sum[i - 1] + a[i]);
        // 如果前缀和已经非常大，就用一个标记值代替，避免long long溢出
        if (sum[i] > max_val) {
            sum[i] = max_val + 1; 
        }
    }

    // 预计算2的幂次，作为价格
    pow[1] = 1;
    for (int i = 2; i <= n + 1; i++) pow[i] = pow[i - 1] * 2 % mo;

    // 处理m次查询
    for (int i = 1; i <= m; i++) {
        ll b; // 当天需要的小鱼干数量
        ll ans = 0;
        scanf("%lld", &b);

        // 第一次二分：找到最小的k，使得 sum[k] >= b
        int l = 1, r = n + 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (sum[mid] < b) l = mid + 1;
            else r = mid;
        }
        
        int j = l; // j就是我们找到的k
        if (j > n) { // 如果所有礼包都买下还不够，那就不可能了（题目保证有解）
            // 这里可以加一些特殊处理，但根据题意这种情况可能不会出现
        }

        // 计算初始花费：购买1到j号所有礼包，总价是 2^j - 1
        // (pow[j+1] - 1 + mo) % mo 是一种更稳妥的写法
        // 这里用 (pow[j] * 2 - 1) % mo 也可以
        ans = (pow[j + 1] - 1 + mo) % mo;

        // 计算富余的小鱼干数量
        ll left = sum[j] - b;

        // 第二步：贪心“退货”
        int current_max_idx = j; // 当前持有的最贵礼包编号
        while (left > 0) {
            // 第二次二分：在[1, current_max_idx)中找能退的最大礼包
            // 找的是满足 a[mid] <= left 的最大 mid
            // 这里实现的是找 a[mid] > left 的最小 mid，然后 mid-1 就是目标
            int search_l = 1, search_r = current_max_idx;
            while (search_l < search_r) {
                int mid = search_l + (search_r - search_l) / 2;
                if (a[mid] <= left) search_l = mid + 1;
                else search_r = mid;
            }
            search_l--; // l-1是满足 a[l-1] <= left 的最大下标
            
            if (search_l == 0) break; // 如果找不到可以退的礼包，就结束

            // 退掉 l 号礼包
            ans = (ans - pow[search_l] + mo) % mo; // 花费减少
            left -= a[search_l]; // 富余的小鱼干减少
            current_max_idx = search_l; // 下次只在更便宜的礼包里找
        }
        printf("%lld\n", (ans % mo + mo) % mo);
    }
}
```

## 复杂度分析喵
- **时间复杂度**: O(n + q * log^2(n)) 的说
  - 预处理前缀和 `sum` 和价格 `pow` 数组需要 `O(n)` 的时间。
  - 对于 `q` 次查询中的每一次：
    - 第一次二分查找 `k` 需要 `O(log n)`。
    - "退货"循环中，每次我们都用二分查找 `O(log j)` 来找到可以退的礼包 `l`，然后将下一次的查找上界 `j` 更新为 `l`。这个过程使得查找范围快速缩小。可以证明，这一系列二分查找的总时间复杂度是 `O(log^2 n)` 级别的。
  - 所以总的时间复杂度就是 `O(n + q * log^2 n)`，对于 `n, q <= 10^5` 来说是完全可以接受的！

- **空间复杂度**: O(n) 的说
  - 我们需要 `a`, `sum`, `pow` 三个数组来存储数据，所以空间复杂度是 `O(n)`。

## 知识点与总结
这道题真是一次有趣的购物体验呢，喵~ 它教会了我们：

1.  **洞察性质**: 解题的第一步往往是观察题目给出的特殊条件。本题中“价格是2的幂”这一性质是解开谜题的黄金钥匙！
2.  **贪心思想**: 基于关键性质，我们设计出了“先买后退”的贪心策略。贪心就是每一步都做出当前看起来最优的选择，最终得到全局最优解。
3.  **二分查找**: 无论是确定初始购买范围，还是在“退货”时寻找最佳目标，二分查找都像魔法一样帮我们把 `O(n)` 的线性扫描优化到了 `O(log n)`，大大提高了效率。
4.  **前缀和**: 这是处理区间和问题的经典技巧，能让我们 `O(1)` 地查询任意区间的和（虽然本题只用了从头开始的和），是二分查找的好搭档。
5.  **模块化思维**: 将一个复杂问题分解成“初步解决”和“优化”两个阶段，思路会清晰很多。

希望这篇题解能帮助到各位小主人！编程就像寻宝，只要耐心分析，总能找到藏在题目里的闪亮宝藏！加油喵~！(>ω<)ﾉ