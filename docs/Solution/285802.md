# 魔法商店 - 题解

### 比赛与标签
> **比赛**: 蓝桥杯 (具体场次信息未提供，喵~)

> **标签**: 贪心, 二分

> **难度**: *1800

## 题目大意喵~

各位小主人，欢迎来到我的题解小屋，喵~ 今天我们要解决的是一个关于买小鱼干的可爱问题！

想象一下，有一家魔法商店，里面有 $n$ 种不同的小鱼干礼包。第 $i$ 种礼包里有 $a_i$ 条小鱼干，售价是 $2^{i-1}$ 个猫猫币。这些礼包有个特点哦：越贵的礼包（也就是 $i$ 越大的），里面的小鱼干数量 $a_i$ 不会比便宜的更少，这是老板的慷慨保证呐！

小蓝每天都要为他的小猫准备午餐。在接下来的 $q$ 天里，第 $i$ 天小猫需要吃掉 $b_i$ 条小鱼干。小蓝每天都会去魔法商店采购，但是每种礼包每天只能买一次。

我们的任务就是，帮小蓝计算一下，为了满足小猫每天的需求（鱼干数量大于等于 $b_i$），他最少需要花费多少猫猫币呢？因为花费可能会很大，所以结果需要对 998244353 取模哦。

简单来说，就是对每次查询的 $b_i$，从 $n$ 种礼包中挑选一个子集，使得鱼干总数不小于 $b_i$，同时花费的总价最小。

## 解题思路分析

这道题的核心是在满足鱼干数量的同时，让花费的成本最小。一看到成本是 $2^0, 2^1, 2^2, \dots$，本猫娘的DNA就动了，喵！这不就是二进制的权重嘛！

购买礼包的组合，其总花费可以看作一个二进制数。例如，购买第1、3号礼包，花费是 $2^{1-1} + 2^{3-1} = 2^0 + 2^2 = 1+4=5$，这在二进制里就是 `101`。第 $i$ 位是1，就代表购买了第 $i+1$ 号礼包。想要成本最小，其实就是想让这个二进制数尽可能小。

怎么让一个二进制数最小呢？当然是尽量让高位为0啦！也就是说，我们要尽可能地不买那些昂贵的、编号大的礼包。

这启发了我们一个贪心的思路。但是从哪个方向贪心呢？是从贵到便宜，还是从便宜到贵？

### 初始的大胆想法：全家桶再打折！

一个比较直观的想法是，我们先用最便宜的礼包来凑数，直到满足需求为止。

1.  **初步购买**：我们按顺序从小到大（从1号到$n$号）购买礼包，直到手头的鱼干总数第一次超过当天的需求 $B$。假设我们买到第 $k_0$ 号礼包时，鱼干总数 $\sum_{i=1}^{k_0} a_i$ 终于大于等于 $B$ 了。
    这个最小的 $k_0$ 可以通过对 $a_i$ 的前缀和数组进行二分查找来快速找到，喵~

2.  **“反悔”优化**：现在我们买下了 $1, \dots, k_0$ 号所有礼包。鱼干总数是 $S_{k_0}$，花费是 $\sum_{i=1}^{k_0} 2^{i-1} = 2^{k_0} - 1$。但我们可能买多了！多出来的鱼干数量是 $E = S_{k_0} - B$。
    我们能不能“退掉”几个已买的礼包，来省点钱呢？当然可以！只要退掉之后，剩下的鱼干还够吃就行。也就是说，我们退掉的礼包所含的鱼干总数不能超过 $E$。

3.  **贪心退货**：为了让省下的钱最多，我们应该优先退掉最贵的礼包。因为礼包 $j$ 的价格是 $2^{j-1}$，所以退掉编号大的礼包，省的钱（成本降幅）也越大。
    所以，我们从已购的礼包中，从最贵的（$k_0$ 号）开始，一个个往下看：
    对于礼包 $j$（从 $k_0$ 到 1），如果它包含的鱼干数 $a_j$ 不超过我们当前多余的鱼干数 $E$，那我们就可以退掉它！
    退掉后，我们的花费就减少了 $2^{j-1}$，多余的鱼干数也减少了 $a_j$。然后我们继续看下一个更便宜的礼包，直到检查完所有已购礼包。

这个“先买后退”的策略，每一步都追求局部最优（找最小的 $k_0$，退最贵的包），最终就能得到全局最优解，是不是很神奇，喵~

### 算法实现步骤

结合上面的思路，我们可以整理出清晰的算法流程：

1.  **预处理**：
    *   计算数组 `a` 的前缀和 `fishPrefixSum`，`fishPrefixSum[i]` 表示前 $i$ 个礼包的总鱼干数。
    *   计算 $2$ 的幂次 `powerOf2`，`powerOf2[i]` 存 $2^{i-1} \pmod{998244353}$。

2.  **处理每次查询**：对于每天需要的鱼干数 `B`：
    *   **步骤一：找到初始购买方案**
        使用二分查找，在前缀和数组 `fishPrefixSum` 中找到最小的索引 `k0`，使得 `fishPrefixSum[k0] >= B`。
        此时，我们的初始花费为 `(powerOf2[k0+1] - 1)`，即 $2^{k_0}-1$。
        拥有的鱼干总数为 `fishPrefixSum[k0]`，多出的鱼干为 `excessFish = fishPrefixSum[k0] - B`。

    *   **步骤二：贪心退货**
        设置一个循环，只要 `excessFish > 0` 就继续。在循环中：
        a. 我们需要在当前可以退货的礼包范围 `[1, current_max_idx]` 中，找到最贵的（即索引最大）且可以退掉的礼包。一个礼包 `j` 可以被退掉的条件是 `a[j] <= excessFish`。
        b. 这个查找也可以用二分！在 `a[1...current_max_idx]` 中二分查找满足 `a[j] <= excessFish` 的最大索引 `j`。
        c. 如果找到了这样的礼包 `j`，就执行退货：从总花费中减去 `powerOf2[j]`，并从 `excessFish` 中减去 `a[j]`。然后把下一次的查找范围缩小到 `[1, j-1]`。
        d. 如果找不到可以退的礼包了，就结束退货流程。

3.  **输出结果**：输出最终计算出的最小花费。记得处理好取模和负数情况哦！

举个例子：`a = [3, 5, 10, 20]`, `B = 15`。
*   前缀和 `S = [3, 8, 18, 38]`。
*   二分找到最小的 `k0` 使得 `S[k0] >= 15`，是 `k0=3`。
*   初始方案：买1,2,3号礼包。鱼干 `18` 条，花费 `1+2+4=7`。
*   多余鱼干 `E = 18 - 15 = 3`。
*   开始退货，范围 `[1,3]`，`E=3`：
    *   看3号礼包 (`a[3]=10`)：`10 > 3`，退不了。
    *   看2号礼包 (`a[2]=5`)：`5 > 3`，退不了。
    *   看1号礼包 (`a[1]=3`)：`3 <= 3`，可以退！
    *   退掉1号！花费 `-= 1` 变为 `6`。`E -= 3` 变为 `0`。
*   `E` 变成0，退货结束。最终花费6。完美，喵！

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，变量名清晰，注释详尽，希望能帮助你理解，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

// 使用 long long 防止数值溢出
using int64 = long long;

const int MOD = 998244353;

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, q;
    cin >> n >> q;

    vector<int64> fish_counts(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        cin >> fish_counts[i];
    }

    // 1. 预处理
    // 计算鱼干数量的前缀和，方便快速查询
    vector<int64> fish_prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        fish_prefix_sum[i] = fish_prefix_sum[i - 1] + fish_counts[i];
        // 防止溢出，设置一个足够大的上限
        if (fish_prefix_sum[i] > 4e18) {
            fish_prefix_sum[i] = 4e18;
        }
    }

    // 计算2的幂，即每个礼包的价格
    vector<int64> power_of_2(n + 2, 0);
    power_of_2[0] = 1; // 2^0 = 1
    for (int i = 1; i <= n + 1; ++i) {
        power_of_2[i] = (power_of_2[i - 1] * 2) % MOD;
    }

    // 2. 处理每次查询
    for (int i = 0; i < q; ++i) {
        int64 daily_requirement;
        cin >> daily_requirement;

        // 步骤一：找到满足需求的最小礼包组合 (1...k0)
        // lower_bound 在 [first, last) 范围内查找不小于 value 的第一个元素
        // 我们在 fish_prefix_sum 的 [1, n+1) 范围内查找 daily_requirement
        auto it = lower_bound(fish_prefix_sum.begin() + 1, fish_prefix_sum.end(), daily_requirement);
        int k0 = distance(fish_prefix_sum.begin(), it);

        // 初始成本是 2^k0 - 1
        int64 min_cost = (power_of_2[k0] - 1 + MOD) % MOD;
        
        // 计算多余的鱼干
        int64 excess_fish = fish_prefix_sum[k0] - daily_requirement;

        // 步骤二：贪心退货
        int current_max_idx = k0;
        while (excess_fish > 0 && current_max_idx > 0) {
            // 在 a[1...current_max_idx] 中找到能退的、最贵的礼包
            // upper_bound 查找第一个大于 excess_fish 的元素
            // 它前面的一个元素就是不大于 excess_fish 的最后一个元素
            int low = 1, high = current_max_idx, idx_to_remove = 0;
            while(low <= high) {
                int mid = low + (high - low) / 2;
                if (fish_counts[mid] <= excess_fish) {
                    idx_to_remove = mid; // 这是一个可能的候选
                    low = mid + 1;       // 尝试找更大的
                } else {
                    high = mid - 1;      // 太大了，往前找
                }
            }
            
            if (idx_to_remove == 0) {
                // 没有能退的礼包了
                break;
            }

            // 执行退货
            min_cost = (min_cost - power_of_2[idx_to_remove - 1] + MOD) % MOD;
            excess_fish -= fish_counts[idx_to_remove];
            
            // 下次退货时，不能再考虑这个礼包和比它更贵的礼包
            current_max_idx = idx_to_remove - 1;
        }

        cout << min_cost << "\n";
    }

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N + Q \cdot K \cdot \log N)$
    *   预处理前缀和与2的幂次需要 $O(N)$ 的时间。
    *   对于 $Q$ 次查询，每次查询：
        *   第一次二分查找 $k_0$ 需要 $O(\log N)$。
        *   之后的退货循环，设它迭代了 $K$ 次。在每次迭代中，我们又进行了一次二分查找来找到可以退货的礼包，这需要 $O(\log N)$。
    *   虽然在最坏的情况下，$K$ 理论上可以很大，但在大多数情况下，由于 $a_i$ 的增长和我们总是移除最大的那部分，这个循环的次数是相当有限的，足以通过本题，喵~

*   **空间复杂度**: $O(N)$
    *   我们主要需要三个数组：`fish_counts`、`fish_prefix_sum` 和 `power_of_2`，它们的大小都与 $N$ 成正比。

## 知识点总结

这道题是贪心思想和二分查找的完美结合，非常考验对问题本质的洞察力，呐！

1.  **贪心思想**:
    *   **核心洞察**：成本 $2^{i-1}$ 的结构是解题的关键。最小化成本等价于最小化一个二进制数，应优先不选高位的项（即昂贵的礼包）。
    *   **策略**：采用了“先全买，再优化”的策略。先用最经济实惠的方式（买连续最便宜的）满足基本要求，然后再贪心地“退货”来最大化地降低成本。

2.  **二分查找**:
    *   二分查找是加速这个过程的利器！
    *   第一次用在**前缀和数组**上，快速定位到满足条件的初始购买方案的上界 $k_0$。
    *   第二次用在**原数组 `a`** 上，在退货阶段快速找到能退掉的最昂贵的礼包。

3.  **前缀和**:
    *   一个经典技巧，能将“查询区间和”的操作从 $O(N)$ 优化到 $O(1)$，是使用二分查找的基础。

4.  **模运算**:
    *   处理大数问题时的基本操作。注意减法时要 `(a - b + MOD) % MOD` 防止出现负数。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，成为算法大师，喵~！