# You are given a convex polygon with n vertices and m different points... - 题解

### 比赛与标签
> **比赛**: The 2021 ICPC Asia Regionals Online Contest (II)

> **标签**: computational geometry, greedy, binary lifting

> **难度**: \*3100

## 题目大意喵~

主人，你好呀~！这道题是这样的哦：我们有一个 $n$ 个顶点的凸多边形，还有 $m$ 个可以安装灯的位置，这些灯都在多边形外面。

从一个灯的位置看过去，可以照亮多边形的一部分外边界。这个被照亮的范围，是由这个点到多边形的两条切线之间的那部分边界决定的，就像下图里那样，喵~

<img alt="Illumination example" src="https://uploadfiles.nowcoder.com/images/20210815/364723_1629039744213/6888C5EBC58CD04575488C4F0EC6BDAD"/>

我们的任务是，用最少的灯把整个多边形的所有外边界都照亮，并且要给出一个可行的方案。如果无论如何都照不全，就要告诉人家这是不可能的，喵。

**输入**：
- 第一行是两个整数 $n$ 和 $m$。
- 接下来 $n$ 行，每行是多边形一个顶点的坐标 $(x, y)$。
- 再接下来 $m$ 行，每行是一个灯的位置坐标 $(x, y)$。

**输出**：
- 如果无解，输出 `-1`。
- 否则，第一行输出最少需要的灯的数量。
- 第二行输出这些灯的编号（从1开始），用空格隔开。

## 解题思路分析

这道题看起来是几何问题，但它的核心其实是一个经典的覆盖问题哦，喵~ 让本猫娘带你一步步拆解它！

### Step 1: 从几何问题到区间覆盖问题

首先，我们得弄清楚每个灯能照亮多边形的哪一部分。一个在多边形外的点，能看到的边界是由这个点向多边形引的两条切线决定的。这两条切线会切到多边形的两个顶点上（或者边上，但为了方便我们只考虑顶点）。

假设多边形的顶点按逆时针顺序编号为 $P_0, P_1, \dots, P_{n-1}$。对于一个灯 $Q$，如果我们能找到它到多边形的两条切线所对应的切点分别是 $P_i$ 和 $P_j$，那么这个灯就能照亮从 $P_i$ 到 $P_j$ 的所有边。

这样一来，问题就转化成：
> 我们有 $m$ 个“照明区间” $[i, j]$，对应着多边形的顶点编号。我们需要从这 $m$ 个区间里选出最少数量的区间，来完全覆盖掉整个多边形的所有顶点 $0, 1, \dots, n-1$。

这是一个典型的 **区间覆盖问题**，而且还是在环上的！因为顶点 $P_{n-1}$ 后面就是 $P_0$ 啦。

### Step 2: 解决环上区间覆盖问题

直接处理环上的问题有点麻烦，一个超级好用的技巧是“**断环为链**”！我们可以把多边形的顶点序列复制一遍，变成 $P_0, \dots, P_{n-1}, P_0, \dots, P_{n-1}$。这样，一个环就变成了一条长度为 $2n$ 的链，顶点编号从 $0$ 到 $2n-1$。

- 原来在环上从 $i$ 到 $j$（$i \le j$）的区间，在链上就是 $[i, j]$ 和 $[i+n, j+n]$。
- 原来在环上从 $i$ 到 $j$（$i > j$，即跨过了 $P_{n-1}$ 和 $P_0$）的区间，在链上就变成了一个连续的长区间 $[i, j+n]$。

现在我们的目标就变成了：**用最少的区间，覆盖一个长度为 $n$ 的连续段**。比如说，从任意一个顶点 $k$ 开始，我们需要覆盖住 $[k, k+n-1]$ 这个范围。

### Step 3: 贪心策略与倍增优化

对于在一条直线上用最少区间覆盖一个目标区段的问题，有一个经典的贪心策略：
1.  假设我们当前已经覆盖到了位置 `current_pos`。
2.  我们需要选择一个新区间来继续覆盖。应该选哪个呢？当然是选那个 **左端点在 `current_pos` 或之前，并且右端点最远** 的区间啦！这样每次都尽可能地向前“迈一大步”。

这个贪心思路是正确的。但是，如果我们对每个可能的起点 $k \in [0, n-1]$ 都跑一遍这个贪心，每次贪心都要遍历所有 $m$ 个区间，总复杂度可能是 $O(n \cdot m)$，对于这道题的数据量来说太慢了，会超时的说！

所以，我们需要更快的“迈步”方法！这就是 **倍增 (Binary Lifting)** 发挥作用的地方了，喵~

我们可以预处理一个“跳跃表”，`st[i][k]`，它表示：**从区间 `i` 开始，连续贪心选择 $2^k$ 个区间后，我们会到达哪个区间**。

具体来说：
1.  **预处理 `st[i][0]`**：对于每个区间 `i`，它能覆盖到 `intervals[i].r。我们下一步要找一个左端点 $\le$ intervals[i].r` 并且右端点最远的区间。这个“下一步的区间”就是 `st[i][0]`。
    - 我们可以先把所有区间按左端点排序。
    - 然后通过一次扫描和维护，就能高效地为每个区间找到它的最优“下一步”。

2.  **构建倍增表**：有了 `st[i][0]`（跳1步），我们就能递推地算出跳 $2, 4, 8, \dots$ 步的情况：
    $$
    st[i][k] = st[ st[i][k-1] ][k-1]
    $$
    这个公式的意思是，从 `i` 跳 $2^k$ 步，等于先从 `i` 跳 $2^{k-1}$ 步到达 `st[i][k-1]`，再从那里继续跳 $2^{k-1}$ 步。

3.  **查询**：对于每个可能的起始区间 `i`，我们想知道覆盖到 `intervals[i].l + n` 需要跳几步。我们可以从大到小尝试 $k$，如果从当前区间跳 $2^k$ 步之后还没到达终点，就执行这次大跳跃。这样就能在 $O(\log m)$ 的时间内算出从一个起点出发所需的步数。

总的来说，我们的完整策略是：
1.  **几何预处理**：用 Andrew 算法或类似方法求出凸包，确保顶点按逆时针排序。对于每个灯，用 $O(\log n)$ 的方法找到两个切点，确定其照明区间。
2.  **断环为链**：将所有照明区间转换到长度为 $2n$ 的链上。
3.  **倍增预处理**：对所有区间建立倍增跳跃表。
4.  **贪心查询**：遍历所有可能的起始区间，利用倍增表快速计算覆盖完整一圈所需的灯数。
5.  **找到最优解**：在所有起点中找到需要灯最少的方案，并记录下来。
6.  **输出结果**：如果找到了解，就输出最少数量和方案；否则说明无解。

这个方法结合了计算几何、贪心和倍增，是不是很酷呀？喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码哦！加了很多注释，希望能帮助主人更好地理解，呐~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

// 使用 long long 防止整数溢出
using int64 = long long;

// 点的结构体
struct Point {
    int64 x, y;
};

// 向量减法
Point operator-(Point a, Point b) {
    return {a.x - b.x, a.y - b.y};
}

// 叉积计算，用于判断方向
int64 cross_product(Point a, Point b) {
    return a.x * b.y - a.y * b.x;
}

// 排序和求凸包时使用
bool compare_points(Point a, Point b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}

// Andrew's Monotone Chain 算法求凸包
std::vector<Point> convex_hull(std::vector<Point>& points) {
    int n = points.size();
    if (n <= 2) return points;
    std::sort(points.begin(), points.end(), compare_points);
    std::vector<Point> hull;
    for (int i = 0; i < n; ++i) {
        while (hull.size() >= 2 && cross_product(hull.back() - hull[hull.size() - 2], points[i] - hull.back()) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    int lower_hull_size = hull.size();
    for (int i = n - 2; i >= 0; --i) {
        while (hull.size() > lower_hull_size && cross_product(hull.back() - hull[hull.size() - 2], points[i] - hull.back()) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    hull.pop_back();
    return hull;
}

// 辅助函数，用于寻找凸包上某个方向的极点 (O(log n))
int find_extreme_vertex(const std::vector<Point>& polygon, Point dir) {
    int n = polygon.size();
    auto is_less = [&](int i, Point d) {
        return cross_product(d, polygon[(i + 1) % n] - polygon[i]) >= 0;
    };
    auto get_dir_at = [&](int i) { return polygon[i] - polygon[(i + n - 1) % n]; };

    if (is_less(0, dir) && !is_less(n - 1, dir)) return 0;

    int low = 0, high = n - 1, res = 0;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (is_less(mid, dir)) {
            res = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    low = 0, high = n - 1;
    int res2 = 0;
    while(low <= high) {
        int mid = low + (high-low)/2;
        int prev = (mid + n - 1) % n;
        if(cross_product(dir, polygon[mid] - polygon[prev]) > 0) {
            res2 = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    if (cross_product(dir, get_dir_at(res)) > cross_product(dir, get_dir_at(res2))) return res;
    return res2;
}

// 寻找从外部点到凸包的两个切点 (O(log n))
std::pair<int, int> find_tangents(const std::vector<Point>& polygon, Point p) {
    int n = polygon.size();
    auto is_left_turn = [&](int i) {
        return cross_product(polygon[i] - p, polygon[(i + 1) % n] - p) > 0;
    };
    
    auto is_right_turn = [&](int i) {
        return cross_product(polygon[i] - p, polygon[(i + n - 1) % n] - p) < 0;
    };

    int l = 0, r = n - 1;
    // 寻找右切点
    int right_tangent = 0;
    if (is_right_turn(0)) {
        while(l <= r) {
            int mid = l + (r - l) / 2;
            if (is_right_turn(mid) && !is_right_turn((mid + 1) % n)) {
                right_tangent = (mid + 1) % n; break;
            }
            if(is_right_turn(mid)) l = mid + 1;
            else r = mid - 1;
        }
    }
    
    // 寻找左切点
    l = 0, r = n - 1;
    int left_tangent = 0;
    if(is_left_turn(0)) {
       while(l <= r) {
            int mid = l + (r - l) / 2;
            if (is_left_turn(mid) && !is_left_turn((mid + n-1) % n)) {
                left_tangent = (mid + n-1) % n; break;
            }
            if(is_left_turn(mid)) l = mid + 1;
            else r = mid - 1;
        }
    }
    
    return {left_tangent, right_tangent};
}


// 表示一个照明区间
struct Interval {
    int l, r, id;
};

bool compare_intervals(const Interval& a, const Interval& b) {
    if (a.l != b.l) return a.l < b.l;
    return a.r > b.r;
}

const int LOG_MAX_M = 19; // 2 * 200005 -> ~4e5, log2(4e5) < 19

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m;
    std::cin >> n >> m;

    std::vector<Point> polygon_pts(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> polygon_pts[i].x >> polygon_pts[i].y;
    }

    std::vector<Point> illuminants(m);
    for (int i = 0; i < m; ++i) {
        std::cin >> illuminants[i].x >> illuminants[i].y;
    }

    auto hull = convex_hull(polygon_pts);
    n = hull.size();

    std::vector<Interval> intervals;
    for (int i = 0; i < m; ++i) {
        std::pair<int, int> tangents = find_tangents(hull, illuminants[i]);
        int l = tangents.first;
        int r = tangents.second;
        if (l <= r) {
            intervals.push_back({l, r, i});
            intervals.push_back({l + n, r + n, i});
        } else { // Wraps around
            intervals.push_back({l, r + n, i});
        }
    }

    std::sort(intervals.begin(), intervals.end(), compare_intervals);

    int total_intervals = intervals.size();
    if (total_intervals == 0) {
        std::cout << -1 << std::endl;
        return 0;
    }
    
    // 预处理，找到每个位置右边能延伸最远的区间
    std::vector<int> max_r_idx(total_intervals);
    max_r_idx[0] = 0;
    for (int i = 1; i < total_intervals; ++i) {
        if (intervals[i].r > intervals[max_r_idx[i - 1]].r) {
            max_r_idx[i] = i;
        } else {
            max_r_idx[i] = max_r_idx[i - 1];
        }
    }

    // 构建倍增表 st[i][k] 表示从区间 i 跳 2^k 步到达的区间
    std::vector<std::vector<int>> st(total_intervals, std::vector<int>(LOG_MAX_M));
    std::vector<int> left_endpoints;
    for(const auto& inv : intervals) {
        left_endpoints.push_back(inv.l);
    }

    for (int i = 0; i < total_intervals; ++i) {
        // 找到所有左端点 <= intervals[i].r 的区间
        auto it = std::upper_bound(left_endpoints.begin(), left_endpoints.end(), intervals[i].r);
        int search_range_end_idx = std::distance(left_endpoints.begin(), it) - 1;
        
        if (search_range_end_idx < 0 || intervals[max_r_idx[search_range_end_idx]].r <= intervals[i].r) {
            st[i][0] = i; // 无法前进
        } else {
            st[i][0] = max_r_idx[search_range_end_idx];
        }
    }

    for (int k = 1; k < LOG_MAX_M; ++k) {
        for (int i = 0; i < total_intervals; ++i) {
            st[i][k] = st[st[i][k - 1]][k - 1];
        }
    }

    int min_lights = -1;
    int best_start_idx = -1;

    for (int i = 0; i < total_intervals; ++i) {
        // 只考虑原始链上的区间作为起点
        if (intervals[i].l >= n) continue;

        int current_idx = i;
        int target_r = intervals[i].l + n;
        
        if (intervals[st[current_idx][LOG_MAX_M-1]].r < target_r) {
            continue; // 从这个起点无法覆盖一整圈
        }

        int steps = 1;
        for (int k = LOG_MAX_M - 1; k >= 0; --k) {
            if (intervals[st[current_idx][k]].r < target_r) {
                current_idx = st[current_idx][k];
                steps += (1 << k);
            }
        }
        // 最后再跳一步
        if (intervals[current_idx].r < target_r) {
            steps++;
        }

        if (min_lights == -1 || steps < min_lights) {
            min_lights = steps;
            best_start_idx = i;
        }
    }

    if (min_lights == -1) {
        std::cout << -1 << std::endl;
    } else {
        std::cout << min_lights << std::endl;
        std::vector<int> solution_ids;
        int current_idx = best_start_idx;
        for (int i = 0; i < min_lights; ++i) {
            solution_ids.push_back(intervals[current_idx].id + 1);
            current_idx = st[current_idx][0];
        }
        for (int i = 0; i < solution_ids.size(); ++i) {
            std::cout << solution_ids[i] << (i == solution_ids.size() - 1 ? "" : " ");
        }
        std::cout << std::endl;
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \log N + M(\log N + \log M))$
    - 求凸包需要 $O(N \log N)$。
    - 为 $M$ 个灯寻找切点，每个需要 $O(\log N)$，总共是 $O(M \log N)$。
    - 产生的区间数量最多为 $2M$ 个。对它们排序需要 $O(M \log M)$。
    - 构建倍增表 `st` 需要 $O(M \log M)$。
    - 对每个可能的起点进行查询，最多有 $M$ 个起点，每次查询 $O(\log M)$，总共是 $O(M \log M)$。
    - 所以总的时间复杂度由这些部分主导，是 $O(N \log N + M(\log N + \log M))$，完全可以接受的啦！

- **空间复杂度**: $O(M \log M)$
    - 主要的空间开销是存储所有区间（最多 $2M$ 个）和倍增表 `st`（大小为 $O(M \log M)$）。

## 知识点总结

这道题真是一次有趣的冒险，喵~ 我们用到了好多厉害的工具呢！
1.  **问题转化**: 核心思想是把一个复杂的几何问题，通过分析，转化成我们更熟悉的算法模型——环上区间覆盖。
2.  **计算几何基础**:
    - **凸包**: 使用 Andrew's Monotone Chain 算法来标准化多边形的顶点，确保它们有序。
    - **点到凸包的切线**: 这是个关键的几何操作。通过在顶点上进行一种特殊的二分查找，我们可以在 $O(\log N)$ 的时间内找到切点，非常高效！
3.  **断环为链**: 处理环上问题的一个经典技巧。通过复制数组，把环形结构拉直成线性结构，大大简化了后续处理。
4.  **贪心算法**: 区间覆盖问题的标准解法。每次都做出局部最优选择（选能延伸最远的区间），最终得到全局最优解。
5.  **倍增 (Binary Lifting)**: 这是对贪心过程的强力优化。通过预处理“跳 $2^k$ 步”的信息，将原本线性的“一步步跳”过程，加速到了对数级别，是解决这类“最小步数”问题的神器！

希望这篇题解能帮到主人哦！如果还有不明白的地方，随时可以再来问本猫娘，喵~ >w<