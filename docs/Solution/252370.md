# 最小花费的环 - 题解

### 比赛与标签
> **比赛**: (信息未提供)

> **标签**: 动态规划, 状态压缩DP

> **难度**: (信息未提供，但根据算法判断，这可是一道很有挑战性的题目哦，喵~)

## 题目大意喵~

一位叫键山雏的小姐需要我们的帮助，喵~ 她有一个 $n$ 个点的简单无向图。每个点 $i$ 都有一个点权 $a_i$，每条边 $(i, j)$ 都有一个边权 $e_{ij}$。

我们需要在这个图里寻找一个**环**。一个环的“花费”被定义为：环上所有**点的点权之和**与所有**边的边权之和**的**乘积**。我们的任务就是找到那个拥有最小花费的环，然后告诉她这个最小花费是多少。

一个环被定义为从一个点出发，不重复经过任何一条边，最终回到起点的路径。并且，一个合法的环至少需要包含3个点哦！如果图里找不到任何环，就要输出 `-1`。

举个例子，如果一个环经过的点是 $v_1, v_2, \dots, v_k$，那么它的花费就是：
$$
\text{Cost} = \left( \sum_{i=1}^{k} a_{v_i} \right) \times \left( e_{v_1 v_2} + e_{v_2 v_3} + \dots + e_{v_k v_1} \right)
$$

## 解题思路分析

看到题目中 $n$ 的范围很小（通常 $n \le 20$ 左右），而且问题涉及到在一个图中寻找一个满足特定性质的路径（环），这就像是猫咪的胡须在颤动，敏锐地感觉到了“状态压缩DP”的气息，喵！

这个问题是经典旅行商问题（TSP）的一个变种。让我们一步一步来拆解它吧！

#### 核心思想：枚举与优化

一个最朴素的想法是找出所有的环，计算它们的费用，然后取最小值。但是图中的环实在是太多啦，像天上的星星一样数不清，直接枚举肯定会超时的说。

我们来分析一下花费的计算公式：`花费 = (点权和) * (边权和)`。
如果我们固定了一个环所经过的点的**集合** $S$，那么这个环的点权之和 `Σ a_i` 就是一个定值了，它等于集合 $S$ 中所有点的点权总和。为了让总花费最小，我们只需要在这个固定的点集 $S$ 上，找到一条边权和最小的路径来构成一个环。

这下问题就清晰了：
1.  枚举所有可能的点的集合 $S$（要求 $|S| \ge 3$）。
2.  对于每一个集合 $S$，计算出点权和 `node_sum(S)`。
3.  在由 $S$ 中的点构成的子图中，找到一个经过所有点的、边权和最小的环（也就是TSP问题）。设这个最小边权和为 `min_edge_sum(S)`。
4.  这个集合 $S$ 对应的最小花费就是 `node_sum(S) * min_edge_sum(S)`。
5.  我们在所有集合 $S$ 算出的花费中，取一个最小值，就是最终的答案啦！

#### 状态压缩DP来帮忙！

上面第三步的“在子图中找最小边权和的环”，正是状态压缩DP大显身手的地方！

我们可以用一个整数的二进制位来表示一个点的集合，这也就是“状态压缩”名字的由来。如果第 `i` 位是 `1`，就代表点 `i` 在集合中；如果是 `0`，就代表不在。

为了处理所有可能的环，我们不能只针对某一个起点进行DP。但是，如果我们对每个环都进行一次独立的TSP DP，那也太慢了。一个非常巧妙的技巧是，**为每一个环定义一个唯一的、规范的表示方式**。

我们可以规定，任何一个环，都由它**编号最小的那个节点**作为“起始点”。这样，一个包含点 `{1, 3, 4}` 的环，我们只在把它看作从点 `1` 出发时才计算它，避免了从点 `3` 或点 `4` 出发时重复计算。

基于这个思想，我们来定义DP状态：
`dp[mask][i]` 表示：一个路径，它所经过的点的集合由 `mask` 表示，并且这条路径的起点是 `mask` 中编号最小的节点，终点是节点 `i`。`dp[mask][i]` 存储的是这条路径的**最小边权和**。

**状态转移方程**
*   **初始状态**：对于每个点 `i`，一个只包含它自己的路径，可以看作是从 `i` 出发到 `i` 结束，边权和为 `0`。所以，`dp[1 << i][i] = 0`。
*   **转移过程**：我们从小到大枚举所有状态 `mask`。对于一个已知的状态 `dp[mask][i]`（表示从 `mask` 的最小节点出发，走到 `i` 的一条路径），我们可以尝试从 `i` 走到一个尚未在 `mask` 中的节点 `j`。
    *   新路径经过的节点集合是 `new_mask = mask | (1 << j)`。
    *   新路径的终点是 `j`。
    *   新路径的起点仍然是 `mask` 的最小节点。为了保证这一点，我们需要确保 `j` 的编号比 `mask` 的最小节点要大。
    *   所以，如果存在一条边 `(i, j)`，并且 `j` 不在 `mask` 中，且 `j` 的编号大于 `mask` 的最小节点编号，我们就可以进行状态转移：
    $$
    dp[\text{new\_mask}][j] = \min(dp[\text{new\_mask}][j], dp[\text{mask}][i] + e_{ij})
    $$

**计算最终答案**
当我们计算完所有的 `dp` 值后，我们就有了所有从“最小节点”出发的路径的最小边权和。现在，我们只需要把这些路径“合上”变成一个环就行啦！

我们遍历所有状态 `mask`（其中点的数量 `popcount(mask) >= 3`）：
1.  找到这个 `mask` 的最小节点 `start_node`。
2.  遍历 `mask` 中的所有其他节点 `i` (`i != start_node`)。
3.  如果存在一条从终点 `i` 回到起点 `start_node` 的边，那么我们就找到了一个环！
4.  这个环的总边权是 `dp[mask][i] + e_{i, start_node}`。
5.  这个环的总点权是 `node_sum[mask]`（这个可以预先计算好）。
6.  计算花费 `node_sum[mask] * (dp[mask][i] + e_{i, start_node})`，然后用它来更新我们的全局最小答案 `ans`。

这样一来，我们就能高效地找到最小花费的环啦，喵~

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，希望能帮到你哟~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 long long 防止花费计算时溢出，喵~
using ll = long long;
const ll INF = 1e18; // 一个足够大的数，代表无穷大

// 一个好用的小工具，用来计算一个整数二进制表示中1的个数
int count_set_bits(int n) {
    int count = 0;
    while (n > 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

// 另一个小工具，找到整数二进制表示中最低位的1对应的位置（从0开始）
int get_lowest_set_bit_index(int n) {
    if (n == 0) return -1;
    return __builtin_ctz(n); // GCC/Clang 内置函数，超快的说！
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<ll> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    std::vector<std::vector<ll>> e(n, std::vector<ll>(n));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> e[i][j];
        }
    }

    // dp[mask][i]: 访问了 mask 集合中的点,
    // 以 mask 中最小编号的节点为起点, 以 i 为终点的路径的最小边权和
    int num_masks = 1 << n;
    std::vector<std::vector<ll>> dp(num_masks, std::vector<ll>(n, INF));

    // 预计算所有子集的点权和
    std::vector<ll> node_sum(num_masks, 0);
    for (int mask = 1; mask < num_masks; ++mask) {
        int lsb_idx = get_lowest_set_bit_index(mask);
        node_sum[mask] = node_sum[mask ^ (1 << lsb_idx)] + a[lsb_idx];
    }
    
    // 初始化DP：对于每个点i，只包含它自己的路径，边权和为0
    for (int i = 0; i < n; ++i) {
        dp[1 << i][i] = 0;
    }

    // 开始DP！
    for (int mask = 1; mask < num_masks; ++mask) {
        int start_node = get_lowest_set_bit_index(mask);
        for (int i = start_node; i < n; ++i) {
            if (!(mask & (1 << i))) continue; // i 必须在 mask 中
            if (dp[mask][i] == INF) continue;  // 如果当前状态不可达，就跳过

            // 尝试从 i 扩展到 j
            for (int j = start_node + 1; j < n; ++j) {
                if (!(mask & (1 << j)) && e[i][j] > 0) { // j 不在 mask 中且有边
                    int next_mask = mask | (1 << j);
                    dp[next_mask][j] = std::min(dp[next_mask][j], dp[mask][i] + e[i][j]);
                }
            }
        }
    }

    ll min_cost = INF;

    // 计算最终答案
    for (int mask = 1; mask < num_masks; ++mask) {
        if (count_set_bits(mask) < 3) continue; // 环至少需要3个点

        int start_node = get_lowest_set_bit_index(mask);
        for (int i = start_node + 1; i < n; ++i) {
            // 如果存在从终点i回到起点start_node的边
            if ((mask & (1 << i)) && dp[mask][i] != INF && e[i][start_node] > 0) {
                ll current_edge_sum = dp[mask][i] + e[i][start_node];
                ll current_node_sum = node_sum[mask];
                min_cost = std::min(min_cost, current_node_sum * current_edge_sum);
            }
        }
    }

    if (min_cost == INF) {
        std::cout << -1 << std::endl;
    } else {
        std::cout << min_cost << std::endl;
    }

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O(N^2 \cdot 2^N)$。
    *   预计算点权和 `node_sum` 需要 $O(2^N)$。
    *   DP状态转移是主要部分。我们有三层循环：最外层是 `mask` ($2^N$ 种状态)，中间层是当前终点 `i` ($N$ 个选择)，最内层是下一个点 `j` ($N$ 个选择)。所以这部分是 $O(2^N \cdot N \cdot N)$。
    *   最后计算答案的循环是 $O(2^N \cdot N)$。
    *   总的时间复杂度由DP转移主导，为 $O(N^2 \cdot 2^N)$。对于 $N=20$ 来说，这是可以通过的，喵~

*   **空间复杂度**: $O(N \cdot 2^N)$。
    *   我们需要一个 `dp` 表来存储所有状态，大小为 $2^N \times N$。
    *   `node_sum` 数组的大小是 $2^N$。
    *   所以空间复杂度主要是 `dp` 表决定的。

## 知识点总结

这道题真是一次有趣的冒险，让我们总结一下探险中学到的东西吧！

1.  **状态压缩动态规划 (Bitmask DP)**: 当问题规模 $N$ 很小（通常在20以内），并且需要对子集进行操作时，状态压缩DP是一个非常有力的工具。
2.  **旅行商问题 (TSP) 变种**: 本质上，我们为每个子集解决了一个TSP问题（寻找最小边权和的环）。
3.  **问题转化**: 关键的一步是将复杂的 `(点权和 * 边权和)` 优化问题，转化为对固定点集 `S` 优化 `边权和` 的子问题。
4.  **避免重复计算**: 通过为每个环定义一个“规范起始点”（如编号最小的节点），可以有效地避免同一个环被多次计算，大大简化了逻辑。
5.  **预计算**: 对于在DP中会反复用到的量（比如本题的 `node_sum`），提前计算好存起来，可以避免在循环中重复计算，优化常数时间。

希望这篇题解能帮助你理解这道题的奥秘！下次遇到难题，也请不要放弃，像猫娘一样保持好奇心和热情去解决它吧，喵~