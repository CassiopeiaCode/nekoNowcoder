# 我死去，她重生 - 题解

### 比赛与标签
> **比赛**: [信息缺失]

> **标签**: [信息缺失]

> **难度**: [信息缺失]

## 题目大意喵~

主人你好呀，这道题是关于跳跃的游戏哦，喵~

我们有 $n$ 个点，每个点 $i$ (从 1 到 $n$) 都有一个权值 $a_i$。我们可以从一个点 $i$ 跳到另一个点 $j$，但必须满足三个条件，缺一不可呐：

1.  **权值更小**: 目标点的权值必须比当前点的权值小，也就是 $a_j < a_i$。
2.  **下标更小**: 目标点的下标也必须比当前点的下标小，也就是 $j < i$。
3.  **模 k 不同余**: 两个点的下标模 $k$ 的余数不能相同，也就是 $i \not\equiv j \pmod k$。

我们的任务是，对于每一个点 $i$，找出从它出发，最多能连续跳跃多少次。也就是说，要找到一条从 $i$ 开始的最长跳跃路径 $i \to j_1 \to j_2 \to \dots$, 然后输出这个路径的长度（也就是跳跃的次数），喵~

## 解题思路分析

这道题的核心是寻找一个满足特定条件的最长路径，很自然地就会想到动态规划（DP）呢，喵~

#### 步骤一：定义 DP 状态

我们定义 `dp[i]` 为从点 `i` 出发能够进行的最大跳跃次数。
一条跳跃路径是这样的： $i \to j_1 \to j_2 \to \dots \to j_m$。
从定义可以看出，从点 $i$ 出发跳一步到点 $j_1$，之后的最长路径就取决于从 $j_1$ 出发能跳多少次了。所以 `dp[i]` 和其他点的 `dp` 值有关，关系如下：

$$
dp[i] = 1 + \max( \{ -1 \} \cup \{ dp[j] \mid \text{可以从 i 跳到 j} \} )
$$

这里的 $\max$ 集合里加入-1是为了处理边界情况：如果点 $i$ 无法跳到任何点，那么 max 的结果是 -1，`dp[i]` 就等于 $1 + (-1) = 0$，表示0次跳跃，这很合理对吧，喵~

把跳跃条件代入，`dp[i]` 的计算公式就变成：

$$
dp[i] = 1 + \max( \{ -1 \} \cup \{ dp[j] \mid j < i, a_j < a_i, i \not\equiv j \pmod k \} )
$$

#### 步骤二：朴素的 DP 实现

因为计算 `dp[i]` 需要用到所有 `j < i` 的 `dp[j]` 值，所以我们可以从 `i = 1` 到 `n` 的顺序来计算 `dp` 数组。

一个简单的想法是：
```cpp
// 伪代码
for i from 1 to n:
  max_prev_dp = -1
  for j from 1 to i-1:
    if a[j] < a[i] and i % k != j % k:
      max_prev_dp = max(max_prev_dp, dp[j])
  dp[i] = 1 + max_prev_dp
```
这个方法需要两层循环，时间复杂度是 $O(N^2)$。题目给的 $N$ 最大有 $10^6$，平方一下可不得了，肯定会超时的！我们必须想办法优化内层的循环，喵~

#### 步骤三：高级优化 - LIS 变种 + 分组思想

内层循环的目标是，在满足条件的 `j` 中找到最大的 `dp[j]`。这是一个带有二维限制（下标 `j` 和权值 `a_j`）和模数限制的查询。

这种“在某个范围内的前缀/后缀中找最优值”的问题，让我们想起了著名的“最长递增子序列（LIS）”的 $O(N \log N)$ 解法。我们可以借鉴它的思想！

在 LIS 的优化解法中，我们通常会维护一个数组（比如叫 `tails`），`tails[len]` 存储长度为 `len` 的递增子序列的最小末尾元素。这样 `tails` 数组是单调的，我们可以用二分查找来加速。

我们也可以为我们的问题设计类似的结构。我们按 `i` 从 1 到 `n` 的顺序处理：

1.  **`dp[i]` 的含义**: 从 `i` 出发的最长跳跃次数。
2.  **辅助数据结构**: 我们需要一些结构来帮我们快速找到 `max(dp[j])`。
    *   `min_start_val_for_len[p]`: 存储 "能跳 `p` 次的所有路径的起点的最小权值"。也就是说，`min_start_val_for_len[p] = min({a_j | dp[j] = p})`。这个数组一定是单调递增的，因为能跳更多次通常意味着起点权值更大。
    *   `all_start_vals_for_len[p]`: 一个集合，存储所有 "能跳 `p` 次的路径的起点权值"，即 `{a_j | dp[j] = p}`。

**核心逻辑**

当我们计算 `dp[i]` 时：

1.  **寻找候选长度**: 首先，我们忽略模 `k` 的限制。要从 `i` 跳到 `j`，需要 $a_j < a_i$。为了让 `dp[i]` 尽可能大，我们需要找到一个 `j`，它的 `dp[j]` 最大，同时满足 $a_j < a_i$。
    利用 `min_start_val_for_len` 数组的单调性，我们可以通过二分查找（比如 `upper_bound`）快速找到一个候选的最大跳跃次数 `s`。这个 `s` 满足：存在一个 `j`，`dp[j] = s-1` 并且 `a_j < a_i`。所以 `dp[i]` 的理想值是 `s`。

2.  **校验模 `k` 限制**: 上一步找到的 `s` 只是一个理想值。我们必须检查，在所有能跳 `s-1` 次的起点 j 中（即 $a_j \in \text{all\_start\_vals\_for\_len}[s-1]$），是否存在一个 j 同时满足 $a_j < a_i$ 和 $j \not\equiv i \pmod k$。
    *   如果存在，太棒了！`dp[i]` 就确定为 `s`。
    *   如果不存在，说明所有满足 `dp[j] = s-1` 和 `a_j < a_i` 的 `j` 都不幸地和 `i` 模 `k` 同余了。我们不能选它们。所以，我们只能退而求其次，尝试看看能不能构成一个 `s-1` 次的跳跃，也就是去检查是否存在 `j` 满足 `dp[j] = s-2` 和其他条件。
    *   这个过程就像一个 `while` 循环，从理想的 `s` 开始，不断递减，直到找到一个满足所有条件的长度。

3.  **更新**: 找到了正确的 `dp[i]` 值（比如是 `s_final`）之后，我们就需要用点 `i` 的信息去更新我们的辅助数据结构：
    *   把 `a_i` 加入到 `all_start_vals_for_len[s_final]` 集合中。
    *   更新 `min_start_val_for_len[s_final]` 的值为 `min(min_start_val_for_len[s_final], a_i)`。

**关于权值 $a_i$**：因为 $a_i$ 的值很大，但我们只关心它们之间的大小关系，所以可以先对它们进行**离散化**，把它们映射到 `1` 到 `n` 的范围内，方便作为数组下标使用，喵~

这个思路虽然有点复杂，但是通过二分查找和巧妙的数据结构，成功地把复杂度降低到了一个可以通过的水平！`check` 函数的内部虽然有个循环，但在大多数情况下，它不会遍历集合中的太多元素，整体的均摊复杂度是很好的。

## 代码实现

这是本猫娘根据上面的思路，重新为您写的一份代码，加了很多注释哦，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

// 使用 long long 防止数值溢出
using ll = long long;

// 检查是否存在一个合法的跳板 j
// p: 想要达成的跳跃次数
// current_val_rank: 当前点 i 的权值 (离散化后)
// current_idx: 当前点 i 的下标
// all_start_vals_for_len: 存储每个跳跃次数对应的起点权值集合
// rank_to_idx: 离散化后的权值到原始下标的映射
bool check_valid_predecessor(int p, int current_val_rank, int current_idx, int k,
                             const std::vector<std::set<int>>& all_start_vals_for_len,
                             const std::vector<int>& rank_to_idx) {
    // 想要跳 p 次，需要找到一个能跳 p-1 次的前驱 j
    if (p == 0) return true; // 0次跳跃总是可以的
    if (p - 1 >= all_start_vals_for_len.size()) return false; // 不存在能跳 p-1 次的路径

    const auto& predecessors = all_start_vals_for_len[p - 1];
    // 从小于 current_val_rank 的最大权值开始反向查找
    auto it = predecessors.lower_bound(current_val_rank);

    // 使用反向迭代器遍历所有权值小于 current_val_rank 的前驱
    for (auto rit = std::reverse_iterator(it); rit != predecessors.rend(); ++rit) {
        int pred_val_rank = *rit;
        int pred_idx = rank_to_idx[pred_val_rank];
        // 找到了一个满足模 k 不同余的前驱，check 成功！
        if (pred_idx % k != current_idx % k) {
            return true;
        }
    }
    // 遍历完所有可能的前驱，都没找到合适的
    return false;
}

int main() {
    // 加速输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, k;
    std::cin >> n >> k;

    std::vector<ll> a(n + 1);
    std::vector<ll> unique_sorted_a(n);
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
        unique_sorted_a[i - 1] = a[i];
    }

    // --- 离散化 ---
    std::sort(unique_sorted_a.begin(), unique_sorted_a.end());
    unique_sorted_a.erase(std::unique(unique_sorted_a.begin(), unique_sorted_a.end()), unique_sorted_a.end());

    std::vector<int> a_rank(n + 1);
    std::vector<int> rank_to_idx(n + 1);
    for (int i = 1; i <= n; ++i) {
        // lower_bound 返回第一个不小于 a[i] 的元素的迭代器
        // 减去 begin() 得到从0开始的下标，我们+1让它变成从1开始的排名
        a_rank[i] = std::lower_bound(unique_sorted_a.begin(), unique_sorted_a.end(), a[i]) - unique_sorted_a.begin() + 1;
        rank_to_idx[a_rank[i]] = i;
    }

    // --- DP 核心过程 ---
    std::vector<int> ans(n + 1, 0);
    // min_start_val_for_len[p]: 能跳 p 次的路径的最小起点权值
    std::vector<int> min_start_val_for_len;
    // all_start_vals_for_len[p]: 能跳 p 次的路径的所有起点权值集合
    std::vector<std::set<int>> all_start_vals_for_len;

    // 从 i=1 开始处理
    for (int i = 1; i <= n; ++i) {
        // upper_bound 找到第一个 > a_rank[i] 的元素位置
        // 这个位置的索引 s 就是 dp[i] 的候选值
        auto it = std::upper_bound(min_start_val_for_len.begin(), min_start_val_for_len.end(), a_rank[i]);
        int s = it - min_start_val_for_len.begin();

        // 从最佳候选 s 开始，向下检查是否满足模 k 限制
        while (s > 0 && !check_valid_predecessor(s, a_rank[i], i, k, all_start_vals_for_len, rank_to_idx)) {
            s--;
        }
        ans[i] = s;

        // 更新我们的辅助数据结构
        if (s >= min_start_val_for_len.size()) {
            // 发现了新的最长路径长度
            min_start_val_for_len.push_back(a_rank[i]);
            all_start_vals_for_len.push_back({a_rank[i]});
        } else {
            // 更新现有长度的最小起始权值
            if (a_rank[i] < min_start_val_for_len[s]) {
                min_start_val_for_len[s] = a_rank[i];
            }
            all_start_vals_for_len[s].insert(a_rank[i]);
        }
    }

    // 输出结果
    for (int i = 1; i <= n; ++i) {
        std::cout << ans[i] << (i == n ? "" : " ");
    }
    std::cout << std::endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \log N)$
    - **离散化**: 对权值数组排序需要 $O(N \log N)$。
    - **主循环**: 循环 $N$ 次。
        - **二分查找**: `upper_bound` 在 `min_start_val_for_len`上操作，其长度最多为 $N$，所以是 $O(\log N)$。
        - **`check` 函数**: 内部对 std::set 的 lower_bound 是 $O(\log N)$。之后的反向遍历，虽然最坏情况下可能很慢，但由于 min_start_val_for_len 的性质，a_rank[i] 不会比 `min_start_val_for_len[s-1]` 大太多，所以均摊下来每次检查的元素数量不多。
        - **更新**: 对 `std::set` 的插入是 $O(\log N)$。
    - 综合来看，每个元素的处理主要是对数级别的，所以总时间复杂度是 $O(N \log N)$，喵~

- **空间复杂度**: $O(N)$
    - `a`, `a_rank`, `ans` 等数组都需要 $O(N)$ 的空间。
    - `all_start_vals_for_len` 中所有 `set` 的元素总数加起来就是 $N$，所以也是 $O(N)$ 的空间。

## 知识点总结

这道题真是一次有趣的挑战呢！它融合了好几个知识点：

1.  **动态规划 (DP)**: 解决问题的基本框架，通过子问题的解来构建最终的答案。
2.  **最长递增/递减子序列 (LIS/LDS) 的优化思想**: 借鉴了 LIS $O(N \log N)$ 解法中维护单调数组并使用二分查找的核心技巧。
3.  **离散化**: 处理权值范围巨大但数量有限的情况的常用方法。
4.  **数据结构 `std::set`**: 用于高效地存储和查询（特别是 `lower_bound`）一组不重复的元素。

希望这篇题解能帮助你理解这道题的精髓！继续加油哦，你超棒的，喵~！