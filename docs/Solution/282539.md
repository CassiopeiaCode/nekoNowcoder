# 我死去，她重生 - 题解

### 比赛与标签
> **比赛**: 暂无
> **标签**: 动态规划, 最长上升子序列, 二分查找, 数据结构
> **难度**: *2500

## 题目大意喵~
喵~ 主人，这道题是说，我们有 n 个点，每个点都有一个权值 `a_i` 呐。我们可以从一个点 `i` 跳到另一个点 `j`，但必须满足三个神奇的条件哦：

1.  `j < i` (只能往回跳，也就是跳到下标更小的点)
2.  `a_j < a_i` (只能跳到权值更小的点)
3.  `i % k != j % k` (下标 `i` 和 `j` 对 `k` 取模的余数不能相同)

我们的任务就是，对于每一个点 `i` (从 1 到 n)，找出从它出发，最多能连续跳跃多少次呢？

比如说，从 `i` 出发跳到 `j1`，再从 `j1` 跳到 `j2`，这就是一个长度为 2 的跳跃序列，跳了 2 次。我们要对每个 `i` 都求出这个最大次数。

## 解题思路详解喵~

这道题本质上是在一个有向无环图 (DAG) 中寻找最长路径的问题，只不过我们需要对每个点都计算一次。如果我们把每个点 `i` 看作图中的一个节点，从 `i` 到 `j` 的跳跃看作一条有向边，那么题目中的三个条件就是建边的规则。

一个直接的想法是动态规划。我们定义 `dp[i]` 为**以点 `i` 结尾的跳跃路径最多包含多少次跳跃**。

为了计算 `dp[i]`，我们需要找到一个满足所有跳跃条件的点 `j`，然后从 `j` 跳到 `i`。这样，`dp[i]` 就是所有可能的 `dp[j]` 中的最大值加一。状态转移方程就是：

`dp[i] = 1 + max{ dp[j] }`
其中 `j` 必须满足：`j < i`, `a_j < a_i`, `i % k != j % k`。
如果找不到这样的 `j`，那么 `dp[i] = 0`。

我们从 `i = 1` 到 `n` 依次计算 `dp[i]`。但是，每次计算 `dp[i]` 都需要遍历所有 `j < i` 的点，总的时间复杂度是 `O(n^2)`，对于 `n` 高达 `10^6` 的数据范围来说，肯定是会超时的说！必须要想办法优化才行！

### 聪明的优化方法！
这个问题和经典的“最长上升子序列 (LIS)”问题非常像！LIS 问题的 `O(n log n)` 解法给了我们很大的启发。在 LIS 中，我们维护一个数组 `f`，其中 `f[s]` 表示长度为 `s+1` 的上升子序列的最小结尾元素。

我们可以借鉴这个思想！在这里，我们是“最长下降路径”，所以我们也可以定义 `f[s]` 为**跳跃 `s` 次的路径的最小结尾权值**。

当我们计算 `dp[i]` 时，我们想找到一个最长的路径来“接”在 `i` 前面。假设这个最长路径跳了 `s-1` 次，那么我们就可以构成一个跳了 `s` 次的新路径。
要满足 `a_j < a_i`，我们只需要在所有跳了 `s-1` 次的路径中，找到一个结尾权值 `a_j` 小于 `a_i` 的。为了让未来的选择更多，我们肯定希望这个 `a_j` 越小越好，也就是 `f[s-1] < a_i`。

我们可以通过在 `f` 数组上进行二分查找（比如用 `upper_bound`）来快速找到满足 `f[s-1] < a_i` 的最大 `s-1`。这样，我们就找到了一个长度为 `s` 的候选答案。

### 棘手的模数限制
但是！我们还有一个额外的限制 `i % k != j % k` 呢！

只记录最小结尾权值 `f[s-1]` 是不够的。因为那个结尾权值最小的路径，它的终点 `j` 可能恰好满足 `j % k == i % k`，这样就不能跳了！

怎么办呢？我们可能需要选择一个结尾权值不是最小，但下标满足模数限制的路径。

所以，我们需要记录更多的信息。这正是代码中 `g` 数组的用武之地！
`g[s]` 是一个 `set`，它存储了所有**跳跃 `s` 次的路径的结尾权值**。

现在，我们的策略升级了喵~：
1.  **离散化**：`a_i` 的值太大了，但我们只关心它们的大小关系。所以先把 `a_i` 离散化，映射到 `1` 到 `n` 的范围。同时，用一个数组 `c` 记录下每个离散化后的值对应的原始下标 `i`，`c[a_i_new] = i`。
2.  **DP过程**：
    - 遍历 `i` 从 1 到 `n`。
    - 对于当前的 `a_i`，我们先用二分查找在 `f` 数组中找到一个初步的答案 `s`。这个 `s` 代表我们**可能**可以实现 `s` 次跳跃。
    - **关键检查**：现在，我们用 `check` 函数来验证这个 `s` 是否真的可行。`check` 函数会在 `g[s-1]` (所有跳了 `s-1` 次的路径的结尾权值集合) 中，寻找所有小于 `a_i` 的权值。对于每一个这样的权值 `val`，我们通过 `c[val]` 找到它对应的原始下标 `j`，然后检查 `j % k != i % k`。只要找到一个满足条件的，说明长度为 `s` 的跳跃是可行的！
    - **长度回溯**：如果 `check` 失败了，说明所有能构成 `s` 次跳跃的路径都和 `i` 的下标模 `k` 冲突了。我们只好退而求其次，试试看能不能构成 `s-1` 次跳跃，于是 `s--`，然后再次 `check`。这个过程会一直持续，直到找到一个可行的 `s` 或者 `s` 减到 0。
    - **更新状态**：找到了最终的 `s` 后，`dp[i]` 就等于 `s`。然后我们用 `a_i` 来更新 `f[s]` 和 `g[s]`，为后面的计算做准备。具体来说，`f[s] = min(f[s], a_i)`，并且把 `a_i` 加入 `g[s]` 集合。

这样，我们就为每个 `i` 都找到了最长的跳跃次数，完美解决了问题！

## 代码实现喵！
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#pragma G++ optimize("Ofast")
#pragma G++ optimize("unroll-loops")
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
#include<functional>
#include<queue>
#include<unordered_map>
#include<map>
#include<set>
#include<stack>
#include<cmath>
#include<bitset>
#include<random>
#include<iomanip>
#include<numeric>
 
using namespace std;
using ll=long long;
using ld=long double;
using P=pair<ll,ll>;
const int INF=1e9;
const ll inf=1e18;
 
void solve()
{
    int n,k; cin>>n>>k;
    vector<ll>a(n+1),b(n+1),c(n+1);
 
    // 读入数据
    for(int i=1;i<=n;i++)
    {
        cin>>a[i],b[i]=a[i];
    }
 
    // --- 离散化处理 ---
    // 排序并去重，得到所有不同的权值
    sort(b.begin()+1,b.end());
    b.erase(unique(b.begin(),b.end()),b.end());
    // a[i] 存储的是离散化后的值（排名）
    // c[rank] = original_index，方便通过排名反查原始下标
    for(int i=1;i<=n;i++)
    {
        a[i]=lower_bound(b.begin(),b.end(),a[i])-b.begin();
        c[a[i]]=i;
    }
 
    // f[s] 存储跳跃s次的路径的最小结尾权值
    vector<ll>f(1,a[1]);
    // ans[i] 存储以i结尾的路径的最大跳跃次数
    vector<int>ans(n+1);
    // g[s] 存储所有跳跃s次的路径的结尾权值集合
    vector<set<ll>>g(1,set<ll>{a[1]});
 
    // 检查函数：检查是否可以从某个跳了p-1次的路径跳到当前点i
    // p: 新路径的跳跃次数
    // x: 当前点的权值 a[i]
    // y: 当前点的下标 i
    auto check=[&](int p,int x,int y)->bool{
        // 在g[p-1]（所有跳了p-1次的路径的终点权值集合）中，找到第一个大于等于x的迭代器
        auto it=g[p-1].lower_bound(x);
        // 从 it 向前反向遍历，这样遍历到的都是权值小于x的终点
        for(auto rit=reverse_iterator(it);rit!=g[p-1].rend();rit++)
        {
            // *rit 是上一个点的权值，c[*rit]是它的原始下标
            // 如果存在一个前驱点j，使得j%k != i%k，则检查通过
            if(c[*rit]%k!=y%k)return true;
        }
        // 如果所有权值小于x的前驱点j都满足j%k == i%k，则检查失败
        return false;
    };
 
    // 从第二个点开始计算
    for(int i=2;i<=n;i++)
    {
        // 在f数组上二分，找到第一个f[s] > a[i]的位置s
        // 这意味着a[i]可以接在所有跳跃次数小于s的路径后面
        // 所以我们最优的候选跳跃次数是s
        int s=upper_bound(f.begin(),f.end(),a[i])-f.begin();
        
        // 关键步骤：检查并回溯
        // 如果对于跳跃s次，所有可能的前驱都与i的下标模k冲突，
        // 就尝试s-1次，直到找到可行的s或者s=0
        while(s&&!check(s,a[i],i))s--;

        // 更新状态
        if(s>=f.size()) // 如果s是一个新的最大长度
        {
            f.push_back(a[i]);
            g.push_back(set<ll>{a[i]});
        }
        else // 否则，更新现有长度s的信息
        {
            // a[i] 是一个跳跃s次的路径的结尾，且a[i]可能比f[s]更小
            f[s]=min(f[s],a[i]);
            // 将a[i]加入g[s]集合
            g[s].insert(a[i]);
        }
        // 记录答案
        ans[i]=s;
    }
 
    for(int i=1;i<=n;i++)
    {
        cout<<ans[i]<<" ";
    }
}   
 
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t=1; 
    while(t--)solve();
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(N log N + C) 的说。
  - 外层循环是 `O(N)`。
  - 循环内部，`upper_bound` 对 `f` 数组（长度最多为N）进行二分查找，是 `O(log N)`。
  - `check` 函数是复杂度的关键。它对 `set` 进行 `lower_bound`（`O(log N)`）和反向遍历。虽然单次遍历最坏情况下可能很长，但由于 `check` 失败时 `s` 会减小，且每个元素只会被插入到 `g` 中一次，在整个算法的生命周期中，`check` 函数的总开销 `C` 被摊还了，实际表现远好于最坏情况，足以通过本题。
- **空间复杂度**: O(N) 的说。
  - `a`, `b`, `c`, `ans` 数组都是 `O(N)`。
  - `f` 数组最多有 `N` 个元素。
  - `g` 是一个 `vector` of `set`，虽然看起来很大，但每个 `a_i` 只会被插入到 `g` 的其中一个 `set` 里一次。所以所有 `set` 的元素总数是 `O(N)`。

## 知识点与总结喵！
这道题是一道非常精彩的动态规划优化题，融合了多种算法思想，值得我们好好回味呐！

1.  **DP on Sequences**: 题目的核心是寻找满足特定条件的最长路径，这是序列动态规划的典型应用。
2.  **LIS 思想的延伸**: 它完美展示了如何将经典的 `O(n log n)` LIS 优化思想（即“耐心排序”思想）应用到更复杂的问题上。
3.  **用数据结构处理额外约束**: 当标准的优化（只存最优值）因为额外约束而失效时，一个常见的思路就是用更强大的数据结构（比如本题的 `set`）来记录更多信息，从而在决策时有更多的选择。
4.  **离散化**: 处理值域大但只关心相对大小关系的题目的必备技巧！

喵~ 这道题告诉我们，经典的算法思想非常灵活，只要稍微改造一下，就能解决更复杂的问题喵！遇到LCS/LIS的变种题，可以先想想标准解法，然后分析新加的条件会如何影响状态的记录和转移，再决定要增加哪些信息来辅助决策，就像我们这样用 `set` 来记录所有可能性一样！继续加油哦，主人！