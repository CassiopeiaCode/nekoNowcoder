# 我们都是独立完成作业的好孩子 - 题解

### 比赛与标签
> **比赛**: 暂无信息喵~

> **标签**: 暂无信息喵~

> **难度**: 暂无信息喵~

## 题目大意喵~

有两个好朋友A和B，他们有两门作业：数学和语文，需要全部完成。

-   同学A独立完成数学和语文分别需要 $a_1$ 和 $b_1$ 分钟。
-   同学B独立完成数学和语文分别需要 $a_2$ 和 $b_2$ 分钟。

他们可以互相帮助！如果一个人已经完成了一项作业，另一个人再做同一项作业时，就可以借鉴，时间减半哦（比如A借鉴B的数学，只需要 $\frac{a_1}{2}$ 分钟）。

但是有一个重要的规则：一旦开始**独立**写某项作业，就必须写完，不能中途跑去借鉴别人的。两个人可以同时写作业。

我们的任务是，找出一种最棒的合作方案，让两个人都完成所有作业所花费的总时间最短，喵~

**输入格式**
第一行一个整数 $T$，表示有 $T$ 组测试数据。
接下来 $T$ 行，每行四个整数 $a_1, b_1, a_2, b_2$。

**输出格式**
对于每组数据，输出一个整数，表示最短的总时间。

## 解题思路分析

这道题看起来像一个调度问题，需要我们合理安排A和B同学的写作业顺序，喵~ 因为只有两个人、两种作业，状态空间并不大，这给了我们一个提示：或许可以把所有可能的合作“策略”都想一遍，然后找出那个用时最短的！

最终的总时间，取决于最后完成作业的那位同学的完成时间。也就是说，我们要最小化 $\max(A\text{的完成时间}, B\text{的完成时间})$。

让我们来分析一下都有哪些可行的策略吧，就像小猫咪分析怎么才能最快拿到小鱼干一样，嘿嘿~

我们将所有可能的情况分为几大类来讨论，这样思路会更清晰哦！

#### 策略一：完全独立，互不干扰

这是最简单的情况，A和B各写各的，谁也不等谁。
-   A同学完成两门作业需要的时间是 $T_A = a_1 + b_1$。
-   B同学完成两门作业需要的时间是 $T_B = a_2 + b_2$。
因为他们是同时开始的，所以总时间就是他们中较慢的那一个人的时间。
$$
\text{Time}_1 = \max(a_1 + b_1, a_2 + b_2)
$$

#### 策略二：交叉合作，一人主攻一科

一个很自然的想法是，A和B发挥各自的优势，一人先独立完成一门，然后互相借鉴。

-   **情况2a：A主攻数学，B主攻语文**
    1.  **开拓阶段**：A开始独立写数学（耗时 $a_1$），同时B开始独立写语文（耗时 $b_2$）。这个阶段在 $\max(a_1, b_2)$ 分钟后结束，此时，数学和语文作业的“初稿”都完成了。
    2.  **借鉴阶段**：在此之后，A可以借鉴B完成的语文作业，B可以借鉴A完成的数学作业。
        -   A借鉴语文需要 $b_1/2$ 分钟，A的总完成时间是 $\max(a_1, b_2) + b_1/2$。
        -   B借鉴数学需要 $a_2/2$ 分钟，B的总完成时间是 $\max(a_1, b_2) + a_2/2$。
    3.  总时间就是这两个完成时间中更晚的那个。
        $$
        \text{Time}_{2a} = \max(\max(a_1, b_2) + b_1/2, \max(a_1, b_2) + a_2/2) = \max(a_1, b_2) + \max(b_1/2, a_2/2)
        $$

-   **情况2b：A主攻语文，B主攻数学** (和上面对称)
    $$
    \text{Time}_{2b} = \max(b_1, a_2) + \max(a_1/2, b_2/2)
    $$

#### 策略三：一拖一，流水线式合作

这种策略是，一个人（比如A）当“学霸”，独立完成全部两门作业，另一个人（B）当“小跟班”，全程借鉴。但B不需要等A全部做完才开始哦，可以流水线作业！

-   **情况3a：A先做数学再做语文，B全程借鉴**
    1.  A花 $a_1$ 分钟完成数学。
    2.  在时刻 $a_1$，A开始做语文（耗时 $b_1$），同时B可以开始借鉴数学了（耗时 $a_2/2$）。
    3.  A完成语文的时刻是 $a_1 + b_1$。
    4.  B完成借鉴数学的时刻是 $a_1 + a_2/2$。
    5.  B要借鉴语文，必须等A在 $a_1+b_1$ 时刻完成。同时B自己也要在 $a_1+a_2/2$ 时刻才有空。所以B开始借鉴语文的时刻是 $\max(a_1+b_1, a_1+a_2/2)$。
    6.  B完成语文还需要 $b_2/2$ 的时间。所以B的最终完成时间是 $\max(a_1+b_1, a_1+a_2/2) + b_2/2$。
    7.  A的完成时间是 $a_1+b_1$。总时间是两人中更晚的那个。
        $$
        \text{Time}_{3a} = \max(a_1+b_1, \max(a_1+b_1, a_1+a_2/2) + b_2/2)
        $$
        这可以化简为：
        $$
        \text{Time}_{3a} = \max(a_1+b_1, a_1+a_2/2) + b_2/2 = a_1 + \max(b_1, a_2/2) + b_2/2
        $$

通过对称分析，我们可以得到另外三种“一拖一”策略的时间：
-   **情况3b：A先做语文再做数学，B全程借鉴**
    $$
    \text{Time}_{3b} = b_1 + \max(a_1, b_2/2) + a_2/2
    $$
-   **情况3c：B先做数学再做语文，A全程借鉴**
    $$
    \text{Time}_{3c} = a_2 + \max(b_2, a_1/2) + b_1/2
    $$
-   **情况3d：B先做语文再做数学，A全程借鉴**
    $$
    \text{Time}_{3d} = b_2 + \max(a_2, b_1/2) + a_1/2
    $$

#### 策略四：混合策略

这是最复杂的一种情况，喵~ 比如，A独立完成两门，B也独立完成一门，但借鉴另一门。

-   **情况4a：A独立完成数学和语文，B独立完成语文、借鉴数学**
    1.  **并行阶段**：A开始做数学（耗时 $a_1$），同时B开始做语文（耗时 $b_2$）。
    2.  A在 $a_1$ 时刻完成数学后，立刻开始做语文（耗时 $b_1$），A的总完成时间是 $T_A = a_1 + b_1$。
    3.  B在 $b_2$ 时刻完成语文后，需要借鉴A的数学。但A的数学在 $a_1$ 时刻才完成。所以B开始借鉴数学的时刻是 $\max(a_1, b_2)$。
    4.  B借鉴数学需要 $a_2/2$ 时间，所以B的总完成时间是 $T_B = \max(a_1, b_2) + a_2/2$。
    5.  总时间就是 $\max(T_A, T_B)$。
        $$
        \text{Time}_{4a} = \max(a_1+b_1, \max(a_1, b_2) + a_2/2)
        $$

同样，通过对称性，我们可以得到另外三种混合策略的时间：
-   **情况4b：A独立(M+C)，B独立(M)、借鉴(C)**
    $$
    \text{Time}_{4b} = \max(a_1+b_1, \max(b_1, a_2) + b_2/2)
    $$
-   **情况4c：B独立(M+C)，A独立(M)、借鉴(C)**
    $$
    \text{Time}_{4c} = \max(a_2+b_2, \max(a_2, b_1) + a_1/2)
    $$
-   **情况4d：B独立(M+C)，A独立(C)、借鉴(M)**
    $$
    \text{Time}_{4d} = \max(a_2+b_2, \max(b_2, a_1) + b_1/2)
    $$

#### 总结

我们已经分析了所有可能的、合理的合作方式！现在，我们只需要把上面计算出的所有策略的总时间（$Time_1, Time_{2a}, Time_{2b}, \dots$）全部算出来，然后取其中最小的那个，就是我们的最终答案啦！这就像猫咪面前放了一堆小鱼干，当然是挑最大最香的那个... 啊不对，是挑时间最短的那个方案，喵哈哈~

## 代码实现

下面就是把我们刚才的分析转换成代码啦！因为输入的时间可能很大，所以要用 `long long` 来存储时间，防止溢出哦。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

// 使用 long long 防止时间总和溢出
using ll = long long;

// 一个辅助函数，让代码更清晰喵~
void solve() {
    ll a1, b1, a2, b2;
    std::cin >> a1 >> b1 >> a2 >> b2;

    // 初始化最小时间为一个非常大的值，或者用第一个策略的结果
    ll min_time;

    // 策略一：完全独立
    min_time = std::max(a1 + b1, a2 + b2);

    // 策略二：交叉合作
    // 2a: A主攻数学, B主攻语文
    min_time = std::min(min_time, std::max(a1, b2) + std::max(a2 / 2, b1 / 2));
    // 2b: A主攻语文, B主攻数学
    min_time = std::min(min_time, std::max(b1, a2) + std::max(a1 / 2, b2 / 2));

    // 策略三：一拖一，流水线式合作
    // 3a: A(数->语), B借鉴
    min_time = std::min(min_time, a1 + std::max(b1, a2 / 2) + b2 / 2);
    // 3b: A(语->数), B借鉴
    min_time = std::min(min_time, b1 + std::max(a1, b2 / 2) + a2 / 2);
    // 3c: B(数->语), A借鉴
    min_time = std::min(min_time, a2 + std::max(b2, a1 / 2) + b1 / 2);
    // 3d: B(语->数), A借鉴
    min_time = std::min(min_time, b2 + std::max(a2, b1 / 2) + a1 / 2);

    // 策略四：混合策略
    // 4a: A(独立全科), B(独立语文, 借鉴数学)
    min_time = std::min(min_time, std::max(a1 + b1, std::max(a1, b2) + a2 / 2));
    // 4b: A(独立全科), B(独立数学, 借鉴语文)
    min_time = std::min(min_time, std::max(a1 + b1, std::max(b1, a2) + b2 / 2));
    // 4c: B(独立全科), A(独立数学, 借鉴语文)
    min_time = std::min(min_time, std::max(a2 + b2, std::max(a2, b1) + a1 / 2));
    // 4d: B(独立全科), A(独立语文, 借鉴数学)
    min_time = std::min(min_time, std::max(a2 + b2, std::max(b2, a1) + b1 / 2));
    
    // 还可以考虑一种最简单的“串行”合作方式，虽然通常不是最优的，但为了完整性也可以加上
    // A做完所有，B再开始借鉴所有
    min_time = std::min(min_time, a1 + b1 + (a2 + b2) / 2);
    // B做完所有，A再开始借鉴所有
    min_time = std::min(min_time, a2 + b2 + (a1 + b1) / 2);

    std::cout << min_time << std::endl;
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: 对于每一组测试数据，我们都只进行了一系列固定的算术运算和比较。计算量是恒定的，不随输入数据的大小而改变。所以，对单组数据来说，时间复杂度是 $O(1)$。如果有 $T$ 组数据，总时间复杂度就是 $O(T)$，非常高效的说！
-   **空间复杂度**: 我们只用了几个 `long long` 变量来存储输入和中间结果，没有使用任何大小随输入变化的数组或容器。所以空间复杂度是 $O(1)$，占用的内存非常小，喵~

## 知识点总结

这道题虽然看起来有点绕，但核心思想并不复杂，主要考察的是我们的分析和建模能力。
1.  **枚举与分类讨论**: 面对一个状态不多、可能性有限的问题，一个非常强大的武器就是分类讨论。把所有可能的情况不重不漏地列出来，是解决问题的关键。
2.  **调度模型**: 问题的本质是一个迷你的双人双任务调度模型。正确地计算每种调度策略下的总时间是核心难点。这需要我们仔细地追踪每个人的时间线，并用 `max` 函数来处理并行和等待。
3.  **细心与耐心**: 在推导公式时，很容易搞混 $a_1, b_1, a_2, b_2$，或者在 `max` 和 `+` 的组合上出错。就像猫咪梳理毛发一样，需要细心和耐心才能把逻辑理顺，得出正确的公式。
4.  **化繁为简**: 把一个复杂场景分解成几个简单的、可分析的策略，再将这些策略组合起来，是解决复杂问题的常用技巧。

希望这篇题解能帮助你理解这道题的乐趣所在！一起加油，做出更多的题目吧，喵~！