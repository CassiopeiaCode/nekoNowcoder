# k 进制异或和 - 题解

### 比赛与标签
> **比赛**: 牛客练习赛118
> **标签**: 模拟, 数学
> **难度**: *1177

## 喵喵，这是什么任务呀？
主人，你好呀~！这道题的任务其实非常可爱哦！(ฅ'ω'ฅ)

我们有两个正整数 `A` 和 `B`，还有一个进制 `k`。题目定义了一种叫做“k进制异或和”的奇妙运算，其实它就是 **k 进制下的不进位加法** 呐。

我们的目标就是计算出 `A` 和 `B` 的这个“k进制异或和”，然后把结果以我们熟悉的十进制形式输出就可以啦！

举个栗子：如果 `k=10`，`A=18`，`B=23`。
- 个位上是 `8` 和 `3`，相加是 `11`。不进位加法就是 `11 % 10 = 1`。
- 十位上是 `1` 和 `2`，相加是 `3`。不进位加法就是 `3 % 10 = 3`。
- 所以结果的十位是 `3`，个位是 `1`，合起来就是 `31` 啦！

## 解密 k 进制异或喵！
这道题的核心就是理解“k进制不进位加法”是怎么回事。普通的加法，比如十进制里 `8+3=11`，我们会向高位进一个 `1`。但是这里，我们是“不进位”的，也就是说，每一位的计算都是独立的，不会影响到其他位，喵~

对于任意一个进制 `k`，`A` 和 `B` 的不进位加法可以这样分解：
1.  把 `A` 和 `B` 都想象成 `k` 进制数。
2.  然后，我们把这两个 `k` 进制数像小学的竖式加法一样对齐。
3.  从最低位（最右边）开始，一位一位地计算。
4.  对于每一位，我们把 `A` 和 `B` 在这一位上的数字加起来，然后对 `k` 取个模。这个结果就是我们最终答案在这一位上的数字。
5.  把所有位计算出的新数字组合起来，就得到了一个 `k` 进制的结果。
6.  最后，把这个 `k` 进制的结果转换回十进制，就是我们的答案啦！

那么，我们怎么在程序里实现这个过程呢？其实我们不需要真的把 `A` 和 `B` 完整地转换成 `k` 进制的数组或字符串。我们可以用一个循环来模拟这个过程，非常巧妙的说！

我们可以用 `A % k` 来得到 `A` 在 `k` 进制下的最低位数字，用 `A //= k` (整除) 来“砍掉”`A` 的最低位。对 `B` 也做同样的操作。这样，我们就可以在一个 `while` 循环里，从低到高，逐位处理 `A` 和 `B` 的所有数位了！

具体的步骤就是：
1.  初始化一个结果 `res = 0`，还有一个位权 `factor = 1`（代表个位，也就是 `k^0`）。
2.  当 `A` 或者 `B` 还不为0的时候，就一直循环：
    - 取出 `A` 的 `k` 进制最低位 `a = A % k`。
    - 取出 `B` 的 `k` 进制最低位 `b = B % k`。
    - 计算这一位上的新数字 `digit = (a + b) % k`。
    - 把这个新数字的实际值 (`digit * factor`) 加到我们的总结果 `res` 上。
    - 更新 `A` 和 `B`，进入下一位：`A //= k`, `B //= k`。
    - 更新位权，为下一位做准备：`factor *= k`。
3.  循环结束时，`res` 里存的就是最终的十进制答案啦！

是不是很简单呢？就像把两条鱼的鱼骨一节一节拼起来一样，喵~

## 看我一爪子写出代码喵！
```cpp
// 呀っほー！这里是 Python 的 AC 代码~ Python 的整数可以变得无限大，所以处理 10^18 这种大数字非常方便呢！
// 如果用 C++ 或者 Java 的话，要记得用 long long 或者 long 类型哦，不然会溢出的说。

// 首先，读入 k, A, B 三个数字
k, A, B = list(map(int,input().split()))

// res 用来存放我们最终的十进制结果喵~
res = 0
// factor 是当前位的权重，一开始是个位（k^0=1），然后是k位（k^1），k^2位……的说。
factor = 1

// 只要 A 或者 B 还没被我们“分解”完，就继续循环呐。
// 当 A 和 B 都变成 0 时，说明所有位都处理完了。
while A > 0 or B > 0:
    // a 是 A 在 k 进制下的当前最低位数字
    a = A % k
    // b 是 B 在 k 进制下的当前最低位数字
    b = B % k

    // 核心操作！把这两个位的数字加起来，再对 k 取模，这就是不进位加法啦！
    digit = (a + b) % k

    // 把计算出的当前位的结果 digit 乘上它的权重 factor，加到总结果里去。
    res += digit * factor

    // 更新权重，准备处理下一位（更高位）。
    factor *= k
    
    // “砍掉”A 和 B 的最低位，这样在下一次循环里，A % k 取到的就是原本的次低位了。
    A //= k
    B //= k

// 所有位都处理完毕，打印结果就好啦！
print(res)
```

## 复杂度分析
- **时间复杂度**: O(log_k(max(A, B))) 的说。
  循环的次数取决于 `A` 和 `B` 中较大那个数在 `k` 进制下的位数。一个数 `N` 在 `k` 进制下的位数大约是 `log_k(N)`。因为 `A` 和 `B` 最大是 `10^18`，`k` 最小是 `2`，所以 `log` 级别的复杂度是非常非常快的，完全不用担心超时，喵~

- **空间复杂度**: O(1) 的说。
  我们只用了几个变量（`res`, `factor`, `a`, `b` 等）来辅助计算，没有使用额外的、随输入大小变化的存储空间。所以空间复杂度是常数级别的。

## 小猫娘的知识宝库！
这道题虽然背景故事有点点伤感，但是解法本身却非常直白可爱呢！(｡･ω･｡)ﾉ♡

- **核心思想**: **进制转换**与**模拟**。这道题的本质就是模拟一个自定义的算术运算。不要被“异或”这个词吓到，题目里已经解释清楚了，它就是“不进位加法”。

- **关键技巧**: **“逐位处理”**。当遇到和特定进制的位操作相关的题目时，循环、取模（`%`）和整除（`//`）是我们的好朋友！它们可以让我们方便地从低位到高位，一位一位地处理数字，而不需要真的把整个数转换成一个数组。

- **数据范围**: 看到 `10^18` 就要立刻警觉起来！在C++/Java里，这意味著必须使用 `long long` / `long`。Python 的大整数特性在这里就显得特别省心啦。

- **举一反三**: 这种按位处理的思想非常通用。如果题目把规则改成 `(a * b) % k`，或者 `(a - b + k) % k`，甚至是更奇怪的规则，我们都可以用完全相同的框架来解决问题，只需要修改 `digit = (a + b) % k` 这一行代码就好啦。

希望这篇题解能帮到你，要继续加油哦，喵~！