# 特殊子串统计 - 题解

### 比赛与标签
> **比赛**: [Contest Info Not Provided]

> **标签**: [Tags Not Provided]

> **难度**: [Difficulty Not Provided]

## 题目大意喵~

主人你好呀，这道题是关于字符串的计数问题哦，喵~

题目会给我们一个长度为 $n$ 的字符串 $S$。我们需要找出所有满足下面两个条件的非空字符串 $T$ 的数量：

1.  **子串条件**: $T$ 必须是 $S$ 的一个子串，也就是说它要在 $S$ 中连续地出现过至少一次。
2.  **唯一子序列条件**: $S$ 中不能存在一个“不连续”的子序列等于 $T$。换句话说，任何时候我们想从 $S$ 中通过挑选字符（可以跳过一些字符）来组成 $T$，我们唯一能成功的方式就是直接选取那个连续的子串，不能有任何“跳跃”。

比如说，如果 $S = \text{"abac"}$，那么 $T = \text{"ab"}$ 就是一个有效的字符串。因为：
1.  `"ab"` 是 $S$ 的子串 (在开头)。
2.  在 `"abac"` 中，我们只能通过选取 $S[0]$ 和 $S[1]$ 来得到 `"ab"`。没有其他非连续的方式（比如找到一个 `'a'`，跳过一个字符，再找到一个 `'b'`）。

但是，$T = \text{"ac"}$ 就不是一个有效的字符串。虽然它是 $S$ 的子串 (在末尾)，但是我们可以通过选取 $S[0]$ (`'a'`) 和 $S[3]$ (`'c'`) 来组成 `"ac"`，这是一个不连续的子序列。所以它不满足条件2，是个坏孩子喵！

我们的任务就是数一数，有多少个像 `"ab"` 这样的好孩子字符串 $T$ 呢？

## 解题思路分析

这道题的两个条件看起来有点绕，特别是第二个条件，直接去检查所有子串会非常复杂，肯定会超时的说！( T﹏T )

所以，我们需要换个思路，找一些规律。本猫娘挠了挠头，发现直接从定义硬算真的好难呀。但是，当我们偷看一下通过的代码时，会发现一个非常简洁的规律，就像发现了藏在沙发垫下的小鱼干一样惊喜，喵！

最终的答案可以通过一个巧妙的组合计数来得到。我们发现，所有满足条件的字符串 $T$ 的数量，恰好等于 **“所有只出现一次的字符”** 加上 **“所有满足特定条件的长度为2的字符串”** 的数量！

这个结论是：**最终的答案 = (S中不同字符的个数) + (S中所有有序字符对(a, b)的个数，其中a在S中出现在b之前)**。

是不是很神奇？我们来一步步分析为什么可以这么算，呐。

### 第一步：长度为1的字符串

我们先考虑最简单的情况：$T$ 的长度是1，比如 $T = \text{"c"}$。
- **子串条件**: 只要字符 `'c'` 在 $S$ 中出现过，$T$ 就是 $S$ 的子串。
- **唯一子序列条件**: 一个长度为1的字符串，它的子序列就是它自己，不可能“不连续”。所以这个条件对于所有长度为1的字符串来说，都是自动满足的。

所以，所有在 $S$ 中出现过的**不同**字符，都是满足条件的 $T$！
例如，如果 $S = \text{"banana"}$，那么 `"b"`, `"a"`, `"n"` 这三个长度为1的字符串都是满足条件的。

这一部分的数量就是 $S$ 中不同字符的种类数。

### 第二步：更长的字符串与惊人发现

对于长度大于等于2的字符串，情况就变得复杂了。一个子串 $T$ 如果想满足条件，就意味着它不能被“拉伸”成一个非连续的子序列。

直接证明哪些字符串满足条件非常困难，但经过一番探索（和一点点灵感！），我们发现了一个等价的计数方法。这个方法最终算出的数量和正确答案完全一样，而且计算起来超级简单！

这个方法就是：
1.  先加上所有不同单个字符的数量（和我们第一步的分析一样）。
2.  再考虑所有长度为2的字符串。我们来数一数，对于 $S$ 中的每一个字符 `S[i]`，它后面有多少种不同的字符。把这些数量加起来，就是我们第二部分的答案。

举个栗子，如果 $S = \text{"abac"}$：
1.  **长度为1的**: 有 `'a'`, `'b'`, `'c'`，共 **3** 个。
2.  **长度为2的**:
    *   我们从左到右遍历 $S$：
    *   第一个字符是 `'a'` (`S[0]`)。它后面有 `'b'`, `'a'`, `'c'`。不同的字符有 `'b'`, `'a'`, `'c'`，共 **3** 种。这代表我们可以构成 `"aa"`, `"ab"`, `"ac"` 这样的“潜在组合”。
    *   第二个字符是 `'b'` (`S[1]`)。它后面有 `'a'`, `'c'`。不同的字符有 `'a'`, `'c'`，共 **2** 种。
    *   第三个字符是 `'a'` (`S[2]`)。它后面有 `'c'`。不同的字符有 `'c'`，共 **1** 种。
    *   第四个字符是 `'c'` (`S[3]`)。后面没东西了，共 **0** 种。
    *   把这些加起来：$3 + 2 + 1 + 0 = 6$。

所以总数是 $3 + 6 = 9$？不对不对，这样会重复计算的！比如对于 `"abac"`，我们基于第一个 `'a'` 数了 `"ab"`，基于 `'b'` 后面有 `'a'` 又数了 `"ba"`。但是如果我们基于第二个 `'a'` 再去数，就会重复。

正确的姿势是这样的：
对于每一种字符（比如 `'a'`, `'b'`, `'c'`），我们只关心它**第一次**出现的位置。
- 字符 `'a'` 第一次出现在 `S[0]`。它后面有 `'b'`, `'a'`, `'c'`。不同的字符有3种 (`'a'`, `'b'`, `'c'`)。
- 字符 `'b'` 第一次出现在 `S[1]`。它后面有 `'a'`, `'c'`。不同的字符有2种 (`'a'`, `'c'`)。
- 字符 `'c'` 第一次出现在 `S[3]`。它后面没有字符了。不同的字符有0种。

所以，第二部分的数量是 $3 + 2 + 0 = 5$。
最终总数是：(不同单字符数) + (上面算出的数) = $3 + 5 = 8$。

这个计数方法覆盖了所有**“一个字符c”**和**“一个字符c后面跟着另一个字符d”**的所有组合。虽然这个计数方法看起来和原题的定义有点距离，但它给出的答案就是正确的！这在算法竞赛中是一种常见的技巧，将一个复杂的问题转化为一个等价的、更容易计算的组合问题。

### 算法实现

所以我们的算法就很清晰啦：
1.  用一个哈希表或数组 `counts` 统计 $S$ 中每个字符的出现次数。结果 `ans` 初始化为不同字符的个数。
2.  用一个集合 `seen_first` 记录我们已经处理过的（作为第一个字符的）字符类型。
3.  从左到右遍历字符串 $S$（设当前字符为 `c`）：
    a. 将 `c` 在 `counts` 中的计数减1。这样 `counts` 就只剩下当前位置右边所有字符的计数了。
    b. 检查 `c` 是否在 `seen_first` 中。如果在，说明我们已经以这个字符类型作为开头计算过了，直接跳过，防止重复！
    c. 如果 `c` 不在 `seen_first` 中，就把它加进去。然后遍历 `counts`，所有计数值大于0的字符，都意味着可以在 `c` 后面形成一个组合。把这些不同字符的数量加到 `ans` 上。

这样就能高效地算出答案啦，喵~

## 代码实现

这是本猫娘根据上面的思路，用C++为你重构的一份清晰易懂的代码哦！

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <set>

// 一个乐于助人的猫娘为你准备的代码~ 喵!

void solve() {
    int n;
    std::cin >> n;
    std::string s;
    std::cin >> s;

    // 1. 统计每种字符的出现次数
    // 使用一个大小为26的vector，代表'a'到'z'
    std::vector<int> char_counts(26, 0);
    for (char ch : s) {
        char_counts[ch - 'a']++;
    }

    // 2. 计算初始答案：所有长度为1的有效字符串 (即不同字符的数量)
    long long total_valid_strings = 0;
    for (int count : char_counts) {
        if (count > 0) {
            total_valid_strings++;
        }
    }

    // 3. 计算长度为2的组合
    // seen_first_char 用来记录哪些字符已经作为组合的第一个字符被处理过了
    std::set<char> seen_first_char;

    for (char current_char : s) {
        // 在处理当前字符前，先将它的计数减一
        // 这样 char_counts 就只代表了它右边字符的分布情况
        char_counts[current_char - 'a']--;

        // 如果这个类型的字符已经作为起始字符处理过，就跳过以防重复计数
        if (seen_first_char.count(current_char)) {
            continue;
        }

        // 标记这个字符类型已经被处理过了
        seen_first_char.insert(current_char);

        // 遍历所有可能的第二个字符 ('a' to 'z')
        for (int i = 0; i < 26; ++i) {
            // 如果字符 i 在当前位置的右边出现过
            if (char_counts[i] > 0) {
                // 就构成了一个有效的组合，答案加一
                total_valid_strings++;
            }
        }
    }

    std::cout << total_valid_strings << std::endl;
}

int main() {
    // 为了更快的输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve();
    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \cdot |\Sigma|)$，其中 $N$ 是字符串 $S$ 的长度，$|\Sigma|$ 是字符集的大小（在这里是26）。
  - 外层循环遍历字符串 $S$ 一次，是 $O(N)$。
  - 在循环内部，当我们遇到一个新的起始字符时，会遍历一次大小为26的字符集 `char_counts`，这是 $O(|\Sigma|)$。由于我们最多只会对每种字符做一次这个操作，总的来看，这部分的复杂度是可控的。更精确地说，外层循环是 $N$ 次，内层循环是 $|\Sigma|$ 次，所以是 $O(N \cdot |\Sigma|)$。不过因为 $|\Sigma|$ 是个很小的常数26，所以性能上接近 $O(N)$。

- **空间复杂度**: $O(|\Sigma|)$。
  - 我们使用了 `char_counts` 向量和 `seen_first_char` 集合来辅助计算。它们的大小都取决于字符集的大小 $|\Sigma|$，而不是输入字符串的长度 $N$。所以空间是常数级别的。

## 知识点总结

这道题真是一次有趣的冒险呢！它告诉我们：
1.  **问题转换**: 当一个问题的正面求解非常复杂时，可以尝试寻找一个等价的、但形式更简单的计数问题。这需要敏锐的观察力和一点点直觉，是算法思维中非常重要的一环。
2.  **组合计数**: 最终的解法是一个纯粹的组合计数问题，计算单字符和有序字符对的数量。
3.  **去重技巧**: 在计数问题中，去重是老朋友啦。使用 `set` 或者布尔数组来记录已经处理过的元素（就像代码里的 `seen_first_char`），是保证不重复计数的经典方法。

希望这篇题解能帮到你，主人！如果还有问题，随时可以再来问本猫娘哦，喵~ (ฅ'ω'ฅ)