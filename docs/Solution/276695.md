# [No Subsequence] - 题解

### 比赛与标签
> **比赛**: [AtCoder Beginner Contest 317](https://atcoder.jp/contests/abc317)
> **标签**: 计数, 字符串
> **难度**: *855

## 题目大意喵
主人，这道题是这样子的：

给我们一个长度为 `n` 的字符串 `S`。我们需要找出所有满足下面两个条件的非空字符串 `T` 的数量：

1.  `T` 必须是 `S` 的一个**子串**（也就是在 `S` 中连续出现）。
2.  `S` 中**不存在**等于 `T` 的**不连续子序列**。

举个例子，如果 `S = "abac"`:
- `T = "ba"` 是一个子串。我们能在 `S` 中找到不连续的 "b...a" 吗？唯一的 'b' 在 `S[1]`，后面的 'a' 在 `S[2]`，是紧挨着的，所以找不到不连续的。因此 `T="ba"` 是一个符合条件的字符串。
- `T = "ac"` 是一个子串。我们能在 `S` 中找到不连续的 "a...c" 吗？可以！`S[0]` 是 'a'，`S[3]` 是 'c'，它们不连续。所以 `S` 中存在不连续的子序列 "ac"。因此 `T="ac"` **不**符合条件。

我们的任务就是数一数，到底有多少个像 "ba" 这样符合条件的 `T` 呢？

## 解题思路喵~
这道题的条件看起来有点复杂，特别是第二个条件，要检查一个子串是否能被表示为不连续的子序列，感觉会非常麻烦。如果我们去枚举 `S` 的所有子串，然后再对每个子串去检查条件，那肯定会慢得像猫步一样，绝对会超时的说！

所以，我们需要换个思路，从贡献的角度来思考。我们不去找 `T`，而是去想，`S` 中的每个字符能构成多少个符合条件的 `T` 呢？

一个非常重要的观察点是：**一个符合条件的字符串 `T`，它的第一个字符在 `S` 中的位置，会极大地影响 `T` 是否有效**。

为什么呢？假设 `T = "ab"`，并且 `S = "xayb"`。`T` 不是 `S` 的子串，不符合条件。
再假设 `S = "axaby"`。`T="ab"` 是 `S` 的子串（在 `S[2..3]`）。但是，我们也可以用 `S[1]` 的 'a' 和 `S[3]` 的 'b' 组成一个不连续的子序列 "ab"。所以 `T="ab"` 就不符合条件了。

这个例子给了我们启发：如果一个子串 `T` 的首字符在 `S` 中不是第一次出现，那么它很可能就会变得“不符合条件”。比如 `S = "abac"`, 子串 `T = "ac"` (从`S[2]`开始)。因为在它前面 `S[0]` 已经有一个 'a' 了，所以我们可以用 `S[0]` 的 'a' 和 `S[3]` 的 'c' 组成一个不连续的 "ac"，于是 `T` 就被“污染”了。

这引导我们得出一个超——关键的简化思路！我们只考虑由每个字符**第一次出现**的位置所能“生成”的字符串。

1.  **长度为 1 的字符串 `T`**:
    `T` 就是一个单字符 `c`。只要 `c` 在 `S` 中出现过，它就是子串。而单字符的子序列不存在“不连续”的概念。所以，`S` 中所有**不同**的字符，本身都是一个符合条件的 `T`。
    例如 `S = "abac"`，"a", "b", "c" 都是符合条件的。

2.  **长度大于 1 的字符串 `T`**:
    基于上面的观察，我们来大胆猜测一个计数方法：我们只在每个字符 `c` **第一次**出现的位置 `p`，来统计以它为首的贡献。
    - 假设字符 `c1` 在 `S` 中第一次出现的位置是 `p`。
    - 那么，以 `c1` 为首，我们可以和它后面的**任意一个**出现过的字符 `c2` 组合成一个字符串 `c1c2`。
    - 比如 `S = "abac"`:
        - 字符 'a' 第一次出现在 `S[0]`。它后面出现了 'b', 'a', 'c' 这三种不同的字符。所以我们可以构成 "aa", "ab", "ac" 这些“候选”组合。
        - 字符 'b' 第一次出现在 `S[1]`。它后面出现了 'a', 'c' 这两种不同的字符。所以我们可以构成 "ba", "bc" 这些“候选”组合。
        - 字符 'c' 第一次出现在 `S[3]`。它后面没有字符了。
    - 这样，我们总共的答案就是：
      (所有不同单字符的数量) + (所有通过上述方法生成的不同二元组 `(c1, c2)` 的数量)

这个计数方法看起来是不是很像在数**长度为1和长度为2的不同子序列**的数量？没错！最终的解法就是这么简洁！虽然从原题意直接推导到这个结论有点跳跃，但它确实是正确的。我们可以认为，任何更长的字符串，或者不满足这个构造方法的字符串，都会因为能够形成不连续子序列而被排除掉。

所以，我们的算法就是：
1.  初始化答案 `res` 为 `S` 中不同字符的数量。
2.  遍历字符串 `S`，同时维护一个 `set` 记录我们已经作为“首字符”处理过的字符。
3.  对于当前字符 `s[i]`:
    - 如果 `s[i]` 已经作为首字符处理过了，就跳过。
    - 否则，将 `s[i]` 加入 `set`，然后统计在 `S` 的后缀 `S[i+1:]` 中出现了多少种不同的字符，把这个数量加到 `res` 上。
4.  最终的 `res` 就是答案啦！

## 代码实现喵
下面就是把上面的思路变成代码的样子啦，代码很简洁，但是蕴含着巧妙的计数思想哦，喵~

```cpp
// 喵~ 这是Python的代码实现哦，因为Python处理字符串和计数实在是太方便啦！
from collections import Counter

# 读取输入喵
n = int(input())
s = input()

# cs 是一个计数器，用来统计S中每个字符的出现次数
# 这样我们就能快速知道后缀中还有哪些字符了
cs = Counter(s)

# res 初始化为S中不同字符的数量
# 这就是所有长度为1的合格字符串T的数量啦
res = len(cs)

# ks 用来记录我们已经当作“首字符”处理过的字符
# 确保每种字符只作为首字符贡献一次答案，防止重复计数
ks = set()

# 开始遍历字符串S的每一个字符
for i in s:
    # 假设当前字符在位置p，我们把它从总计数中减掉1
    # 这样cs就相当于记录了S[p+1:]后缀中各字符的数量
    cs[i] -= 1
    
    # 如果这个字符i已经作为首字符处理过了，就直接跳到下一个
    if i in ks:
        continue
    
    # 这是第一次遇到字符i作为首字符，把它加到ks里
    ks.add(i)
    
    # 现在，我们来数一数后缀里有多少种不同的字符
    # j 代表一种字符
    for j in cs:
        # 如果字符j在后缀中的数量大于0，说明它在后面出现过
        if cs[j] > 0:
            # 那么(i, j)就构成了一个我们想要计数的组合，答案+1
            res += 1

# 输出最终结果
print(res)

```

## 复杂度分析的说
- **时间复杂度**: O(N * |Σ|) 的说。外层循环遍历字符串 `S`，长度为 `N`。内层循环遍历 `cs` 的键，也就是字符集 `Σ`。因为英文字母的字符集大小是常数（26），所以可以认为是 O(N) 的。
- **空间复杂度**: O(|Σ|) 的说。我们用了 `cs` (Counter) 和 `ks` (set) 来存储字符信息，它们的空间大小都取决于字符集的大小，也是一个常数。

## 知识点与总结喵~
这道题真是一只披着狼皮的猫咪！表面上条件复杂，让人想用动态规划或者复杂的搜索，但实际上是一个巧妙的**计数问题**。

核心思想是**转化贡献**和**避免重复**：
1.  **转化问题**: 将复杂的“子串且非不连续子序列”的判断，巧妙地转化为了一个更简单的组合计数问题。虽然这个转化的证明过程比较绕，但在比赛中，通过观察和样例推断出这个简洁的计数模型是解题的关键！
2.  **贡献法**: 我们没有枚举最终的字符串 `T`，而是考虑 `S` 中的每个位置/每种字符能为最终答案贡献多少。
3.  **Set去重**: 使用 `set` (代码中的 `ks`) 来记录已经处理过的首字符，这是避免重复计数的经典技巧。

希望这篇题解能帮到你哦！如果遇到了困难，不要灰心，像猫娘一样，优雅地跳过去，继续前进吧！加油，喵~！