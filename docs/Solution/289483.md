# 至多一次删除构造好字符串 - 题解

### 比赛与标签
> **比赛**: 无

> **标签**: 无

> **难度**: 无

## 题目大意喵~

主人你好呀~ 这道题是关于字符串的小魔法哦！(ฅ'ω'ฅ)

我们拿到一个只包含小写字母的字符串 `s`，它的长度是 $n$。我们可以施展一个魔法，这个魔法最多只能用一次（也就是说，可以用0次或者1次）。

魔法的效果是：从字符串里选一个字符，然后把它删掉。剩下的字符会紧紧地挨在一起，形成一个新的、短一点的字符串。

我们的任务是判断，通过这**最多一次**的删除魔法，能不能让最终的字符串变成一个“好字符串”呢？

一个“好字符串”的定义是：里面没有任何两个相邻的字符是相同的。比如说，`"abacaba"` 就是一个好字符串，但 `"hello"` 就不是，因为它有两个相邻的 `l`，喵~

如果可以做到，我们就开心地输出 `YES`；如果不行呢，就只好输出 `NO` 啦。

## 解题思路分析

这道题听起来好像要我们尝试删除每一个字符，然后检查结果，但那样太慢啦，猫咪的爪爪会累坏的！我们一定有更聪明的办法，对吧？呐，我们来一起分析一下问题的本质是什么，喵~

一个字符串“不好”，就是因为它存在至少一对相邻且相同的字符，比如 `s[i] == s[i+1]`。我们就把这种 `s[i] == s[i+1]` 的情况叫做一个“瑕疵点”吧。

我们的目标是，通过最多一次删除，让整个字符串里一个“瑕疵点”都没有。

我们可以分情况来讨论字符串里“瑕疵点”的数量，喵~

#### 情况一：字符串里一个“瑕疵点”都没有

如果原始字符串 `s` 本身就是一个“好字符串”，那它当然满足要求啦！我们不需要施展任何魔法（0次操作），直接就是 `YES`。这种情况是最简单的，就像一只乖乖睡觉的猫咪，什么都不用做就很完美了，的说。

#### 情况二：字符串里只有一个“瑕疵点”

如果字符串里只有一个地方出现了 `s[i] == s[i+1]` 的情况，比如 `"abccde"`。这个瑕疵点就是 `cc`。
我们有一次删除的机会！我们可以选择删除第一个 `c`，字符串变成 `"abcde"`，哇，完美！或者删除第二个 `c`，字符串也变成 `"abcde"`，同样完美！

所以，如果只有一个瑕疵点，我们总能通过删除其中一个重复的字符来修复它。删除之后，原来 `s[i-1]` 和 `s[i+1]` 会成为邻居。它们会不会也相同，制造出新的瑕疵呢？

假设删除 `s[i]` 后，`s[i-1]` 和 `s[i+1]` 相同了。因为我们知道 `s[i] == s[i+1]`，所以这意味着 `s[i-1] == s[i]`。但如果 `s[i-1] == s[i]`，那么在原始字符串中，位置 `i-1` 本身就是一个瑕疵点。这就与我们“只有一个瑕疵点”的前提矛盾了！所以这种情况不会发生。

因此，当只有一个瑕疵点时，我们总能用一次删除把它修复，答案是 `YES`！

#### 情况三：字符串里有两个或更多的“瑕疵点”

这下情况就变得棘手了呢，喵~

1.  **瑕疵点互相分离**：比如字符串是 `"abbcdd"`。这里有两个瑕疵点，`bb` 和 `dd`。它们离得远远的。如果我们用唯一的删除机会修复了 `bb`（比如删除一个 `b`），字符串变成 `"abcd"`，但 `dd` 还在那里捣乱。反之亦然。我们只有一次魔法，不能同时修复两个地方的问题呀！所以，这种情况肯定是 `NO`。

2.  **瑕疵点挨在一起**：比如字符串是 `"aaab"`。这里的瑕疵点有两个，分别是第一个 `a` 和第二个 `a`，以及第二个 `a` 和第三个 `a`。它们是连在一起的。
    -   如果我们删除第一个 `a`，剩下 `"aab"`，还是有瑕疵。
    -   如果我们删除第二个 `a`，剩下 `"aab"`，还是有瑕疵。
    -   如果我们删除第三个 `a`，剩下 `"aab"`，还是有瑕疵。
    看起来，只要出现三个或以上连续相同的字符，比如 `aaa`，无论我们删掉哪一个，都会剩下 `aa`，问题依然存在。所以，这种情况也是 `NO`。

#### 总结一下思路

分析到这里，结论就非常清晰啦！我们根本不需要真正去模拟删除。我们只需要数一数原始字符串 `s` 中有多少个“瑕疵点”（也就是有多少个位置 `i` 满足 `s[i] == s[i+1]`）。

-   如果瑕疵点的数量是 **0**，说明字符串本来就是好的 -> `YES`。
-   如果瑕疵点的数量是 **1**，说明我们可以通过一次删除修复它 -> `YES`。
-   如果瑕疵点的数量 **大于1**，说明我们无法用一次删除解决所有问题 -> `NO`。

所以，最终的算法就是：遍历一遍字符串，统计瑕疵点的数量。如果数量超过1，就直接判定 `NO`。如果遍历完数量仍然不多于1，就是 `YES`。是不是超级简单呢，喵！(＾▽＾)

## 代码实现

这是本猫娘根据上面的思路，为你精心准备的 C++ 代码哦！注释写得很详细，希望能帮到你，喵~

```cpp
#include <iostream>
#include <string>
#include <vector>

// 一个好习惯是把逻辑放在函数里，让 main 函数保持整洁，喵~
void solve() {
    int n;
    std::cin >> n;
    std::string s;
    std::cin >> s;

    // 用来记录瑕疵点的数量
    int flaw_count = 0;

    // 遍历字符串，检查每一对相邻的字符
    // 只需要遍历到 n-2 索引，因为我们要比较 s[i] 和 s[i+1]
    for (int i = 0; i < n - 1; ++i) {
        // 如果发现一对相邻且相同的字符，就是一个瑕疵点
        if (s[i] == s[i+1]) {
            flaw_count++;
        }

        // 这是一个小优化哦！
        // 如果瑕疵点数量已经超过1个，那么答案肯定是 NO
        // 就没有必要再继续往下数了，可以直接结束判断
        if (flaw_count > 1) {
            break; 
        }
    }

    // 根据瑕疵点的数量得出最终结论
    if (flaw_count <= 1) {
        std::cout << "YES" << std::endl;
    } else {
        std::cout << "NO" << std::endl;
    }
}

int main() {
    // 为了让输入输出更快一点，这是竞赛中的常用技巧，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    
    // 调用我们的解题函数
    solve();
    
    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(n)$
    我们只需要从头到尾遍历一次字符串来统计瑕疵点的数量。循环最多执行 $n-1$ 次。所以，时间复杂度和字符串的长度 $n$ 是线性关系，记作 $O(n)$。

-   **空间复杂度**: $O(1)$ (辅助空间)
    我们只用了一个额外的整型变量 `flaw_count` 来计数。这个变量占用的空间是固定的，和输入字符串的长度 $n$ 无关。所以辅助空间复杂度是 $O(1)$。如果算上存储输入字符串 `s` 的空间，总空间复杂度是 $O(n)$。

## 知识点总结

这道题虽然简单，但也是对思维方式的一次小小锻炼呢！

1.  **问题转化**: 把一个看起来复杂的操作问题（尝试所有删除），转化为一个简单的计数问题。这是算法解题中非常重要的思想！
2.  **分类讨论**: 通过对“瑕疵点”数量的分类讨论（0个、1个、大于1个），让复杂的逻辑变得清晰可控。
3.  **贪心思想**: 我们发现只要瑕疵点多于一个，就一定无解。这其中蕴含了一点贪心的味道：我们不需要考虑复杂的删除策略，只需要关注最坏的情况。
4.  **代码优化**: 在循环中，一旦确定了最终结果（比如瑕疵点超过1个），就可以提前使用 `break` 退出，避免不必要的计算。这是编程实践中的好习惯哦，喵~

希望这篇题解能让你有所收获！继续加油，你超棒的！(>ω<)ﾉ