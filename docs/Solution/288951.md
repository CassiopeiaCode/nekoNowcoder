# 本题为问题的简单版本，两题的区别在于，本题您只需要回答一次询问即可，且本题没有修改操作。 - 题解

### 比赛与标签
> **比赛**: XCPC Weekly Contest #33
> **标签**: 数学, 贡献法, 分治, 费马小定理
> **难度**: *2800

## 题目大意喵~
主人，这道题是这样子的呐：

首先，我们有一个由 `1`到 `n` 这 `n` 个整数组成的**排列** `a`。

然后，题目定义了两个概念：
1.  `mex(i, j)`：对于子数组 `a[i...j]`，`mex` 是指这个子数组中**没有出现过的最小正整数**。比如说，如果子数组是 `{2, 3, 5}`，那么 `1` 没出现，`1` 就是最小的，所以 `mex` 就是 `1`。如果子数组是 `{1, 3, 4}`，那么 `2` 是最小的没出现的正整数，`mex` 就是 `2`。
2.  `t(i, j)`：这个值等于子数组的长度乘以它的 `mex` 值，也就是 `t(i, j) = (j - i + 1) * mex(i, j)`。

我们的最终任务，就是计算下面这个超级复杂的求和式：
$$ F(a_1,\dots,a_n)=\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n} 2^{t(i,j)} \times t(i,j) $$

简单来说，就是要遍历所有可能的连续子数组 `a[i...j]`，对每一个子数组算出它的 `t(i, j)` 值，然后计算 `2^(t(i, j)) * t(i, j)`，最后把所有这些结果加起来。

因为答案会非常非常大，所以要对 `998244353` 取模哦！

## 解题思路喵~
直接遍历所有 `n(n+1)/2` 个子数组，再对每个子数组计算 `mex`，时间复杂度至少是 `O(n^2)` 的，肯定会超时喵！所以我们需要更聪明的办法。

这种求和问题，一个非常强大的思路就是 **贡献法**！我们不一个一个地数子数组，而是换个角度，去考虑每一种可能的 `mex` 值，它会对总答案产生多少贡献。

一个子数组 `a[i...j]` 的 `mex` 值是 `k`，需要满足两个条件：
1.  子数组 `a[i...j]` **必须包含** `1, 2, ..., k-1` 所有的数。
2.  子数组 `a[i...j]` **不能包含** `k` 这个数。

我们可以从小到大枚举 `mex` 的值 `k`（从 `1` 到 `n+1`），然后计算所有 `mex(i, j) = k` 的子数组的贡献之和。

为了方便，我们先预处理一个 `id` 数组，`id[x]` 表示数字 `x` 在排列 `a` 中的位置。

**1. 当 `mex = 1` 时：**
子数组的 `mex` 是 `1`，说明它不包含数字 `1`。数字 `1` 的位置是 `id[1]`。那么，所有满足条件的子数组，要么完全在 `id[1]` 的左边（即 `j < id[1]`），要么完全在 `id[1]` 的右边（即 `i > id[1]`）。
*   对于 `id[1]` 左边的部分（区间 `[1, id[1]-1]`），我们可以计算出所有子数组的贡献。
*   对于 `id[1]` 右边的部分（区间 `[id[1]+1, n]`），我们也可以计算出所有子数组的贡献。
这部分的计算相对独立和简单，可以单独处理。

**2. 当 `mex = k > 1` 时：**
这是解题的核心部分！我们采用一种增量的方式来思考。
我们维护一个区间 `[L, R]`，表示包含 `1, 2, ..., k-1` 所有数字的**最小连续区间**。
*   初始时，`k=2`，这个区间只包含数字 `1`，所以 `L = R = id[1]`。
*   然后我们迭代 `k` 从 `2` 到 `n`。在每一步，我们考虑数字 `k` 的位置 `S = id[k]`。

有三种情况：
*   **情况一：`S` 已经在 `[L, R]` 内部了 (`L < S < R`)**。
    这意味着任何包含 `1..k-1` 的最小区间 `[L, R]`，都已经把 `k` 包含进来了。所以，任何包含 `1..k-1` 的子数组，也必然包含 `k`。因此，**不存在** `mex` 值为 `k` 的子数组。我们直接跳过，考虑 `k+1` 即可。

*   **情况二：`S` 在 `[L, R]` 的左边 (`S < L`)**。
    此时，要满足 `mex(i,j) = k`，子数组 `[i, j]` 必须包含 `[L, R]`，但不能包含 `S`。这意味着子数组的左端点 `i` 必须在 `S` 的右边，即 `S < i <= L`；右端点 `j` 必须在 `R` 的右边，即 `R <= j <= n`。
    我们需要对所有这样的 `(i, j)` 对，求 `2^t * t` 的和，其中 `t = (j-i+1) * k`。

*   **情况三：`S` 在 `[L, R]` 的右边 (`S > R`)**。
    同理，此时 `1 <= i <= L` 且 `R <= j < S`。

对于情况二和三，我们都需要计算一个二维矩形区域内所有 `(i, j)` 的 `F(i, j)` 之和。这是一个非常复杂的双重求和。幸运的是，这个求和式具有一定的规律，可以通过一些精妙的数学推导（涉及到等比数列求和及其“导数”的形式）来快速计算，而不需要真的去循环 `i` 和 `j`。代码中那些看起来像天书一样的公式，就是这个数学推导的结果喵~

计算完 `k` 的贡献后，我们将 `S` 并入 `[L, R]`，更新 `L = min(L, S)`，`R = max(R, S)`，然后继续处理 `k+1`。

**3. 当 `mex = n+1` 时：**
只有一个子数组的 `mex` 会是 `n+1`，那就是包含所有 `1..n` 数字的整个数组 `a[1..n]`。它的长度是 `n`，所以 `t = n * (n+1)`。它的贡献是 `2^(n*(n+1)) * n*(n+1)`。这个在循环结束后单独加上就好啦。

**总结一下思路：**
1.  预处理 `id` 数组。
2.  单独计算 `mex = 1` 的所有子数组的贡献。
3.  循环 `mex` 从 `2` 到 `n`，维护最小覆盖区间 `[L, R]`，根据 `id[mex]` 的位置，用数学公式计算当前 `mex` 的贡献，并更新 `[L, R]`。
4.  最后加上 `mex = n+1`（整个数组）的贡献。
5.  注意求幂时，根据**费马小定理**，`a^b % p` 等价于 `a^(b % (p-1)) % p`，可以防止指数过大。

这样，我们把 `O(n^2)` 的问题转化为了一个 `O(n log n)` 的问题，就可以通过啦！

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include<bits/stdc++.h>
using namespace std;
 
#define int ll // 为了方便，将 int 定义为 long long
#define ll long long
#define ull unsigned long long
#define i128 __int128
 
ll read()
{
    ll x = 0; bool f = false; char c = getchar();
    while(c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while(c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c & 15), c = getchar();
    return f ? -x : x;
}
 
const ll mod = 998244353;
const int N = 2e5 + 5;
int n, a[N], id[N]; // a是原数组，id[x]记录数字x的位置
 
// 快速幂函数，用于计算 a^b % mod
// 注意指数 b 是对 mod-1 取模，这是费马小定理的应用
ll qpow(ll a, ll b, ll mod)
{
    ll ans = 1;
    while(b)
    {
        if(b & 1) ans = ans * a % mod;
        b >>= 1;
        a = a * a % mod;
    }
    return ans;
}
 
// 这是一个没用上的函数，可以忽略喵~
ll C2(ll n){ return n * (n - 1) / 2 % mod; }
 
void solve()
{   
    n = read();
    for(int i = 1; i <= n; ++i) a[i] = read(), id[a[i]] = i; // 读入并记录位置
    
    ll ans = 0;

    // --- Part 1: 计算 mex = 1 的贡献 ---
    // 子数组在数字1的左边
    for(int len = 1; len <= id[1] - 1; ++len)
    {
        ll cnt = id[1] - len; // 长度为len的子数组有cnt个
        ll t_val = len * 1; // t(i,j) = len * mex = len * 1
        ll sum = qpow(2, t_val, mod) * t_val % mod;
        sum = sum * cnt % mod;
        ans = (ans + sum) % mod;
    }
    // 子数组在数字1的右边
    for(int len = 1; len <= n - id[1]; ++len)
    {
        ll cnt = n - id[1] - len + 1; // 长度为len的子数组有cnt个
        ll t_val = len * 1; // t(i,j) = len * mex = len * 1
        ll sum = qpow(2, t_val, mod) * t_val % mod;
        sum = sum * cnt % mod;
        ans = (ans + sum) % mod;
    }

    // --- Part 2: 计算 mex = 2 到 n 的贡献 ---
    // L, R 是包含 1..mex-1 的最小区间
    for(ll L = id[1], R = id[1], mex = 2; mex <= n; )
    {
        // 如果 mex 的位置已经在 [L,R] 内，则不存在 mex(i,j)=mex 的情况
        if(id[mex] >= L && id[mex] <= R)
        {
            ++mex;
            continue;
        }
         
        int S = id[mex]; // S 是数字 mex 的位置
        if(S < L) // mex 在当前区间的左边
        {
            // 对于所有 S < i <= L, R <= j <= n 的子数组 [i,j]，它们的 mex 是 mex
            // 下面这部分是计算这些子数组贡献总和的数学魔法，直接使用即可喵
            for(ll i = R - L + 1; i <= R - S; ++i)
            {
                ll sum1 = qpow(2, mex * (n - R + 1) % (mod - 1), mod);
                sum1 = sum1 * (i + n - R + 1) % mod;
                sum1 = (sum1 - i + mod) % mod;
                ll sum2 = qpow(2, mex * (n - R + 2) % (mod - 1), mod);
                sum2 = (sum2 - qpow(2, mex, mod) + mod) % mod;
                sum2 = sum2 * qpow(qpow(2, mex, mod) - 1, mod - 2, mod) % mod;
                sum1 = (sum1 - sum2 + mod) % mod;
                sum1 = sum1 * qpow(qpow(2, mex, mod) - 1, mod - 2, mod) % mod;
                sum1 = sum1 * qpow(2, mex * i % (mod - 1), mod) % mod * mex % mod;
                ans = (ans + sum1) % mod;
            }
            L = S; // 更新左边界
        }else // mex 在当前区间的右边
        {
            // 对于所有 1 <= i <= L, R <= j < S 的子数组 [i,j]，它们的 mex 是 mex
            // 同样是计算贡献的数学魔法
            for(int i = R - L + 1; i <= S - L; ++i)
            {
                ll sum1 = qpow(2, mex * L % (mod - 1), mod);
                sum1 = sum1 * (i + L) % mod;
                sum1 = (sum1 - i + mod) % mod;
                ll sum2 = qpow(2, mex * (L + 1) % (mod - 1), mod);
                sum2 = (sum2 - qpow(2, mex, mod) + mod) % mod;
                sum2 = sum2 * qpow(qpow(2, mex, mod) - 1, mod - 2, mod) % mod;
                sum1 = (sum1 - sum2 + mod) % mod;
                sum1 = sum1 * qpow(qpow(2, mex, mod) - 1, mod - 2, mod) % mod;
                sum1 = sum1 * qpow(2, mex * i % (mod - 1), mod) % mod * mex % mod;
                ans = (ans + sum1) % mod;
            }
            R = S; // 更新右边界
        }
    }
    
    // --- Part 3: 计算 mex = n+1 的贡献 ---
    // 只有整个数组 a[1..n] 的 mex 是 n+1
    ll t_val_full = 1ll * n * (n + 1);
    ll final_term = qpow(2, t_val_full % (mod - 1), mod) * (t_val_full % mod) % mod;
    ans = (ans + final_term) % mod; // 加上这最后的贡献
    
    printf("%lld\n", ans);
}
 
signed main()
{
    int T = 1;
    while(T--) solve();
    return 0;
}
```

## 复杂度分析喵~
- **时间复杂度**: O(n log n) 的说。
  我们预处理 `id` 数组是 `O(n)`。计算 `mex=1` 的贡献是 `O(n * log(mod))`，因为循环 `n` 次，每次有快速幂。核心的 `for` 循环虽然看起来有多层，但 `L` 只会减小，`R` 只会增大，它们总的变化范围是 `O(n)`。内部的 `for` 循环 `for(ll i = ...)` 的总迭代次数加起来也是 `O(n)` 的。每次迭代内部有快速幂，所以这部分总复杂度是 `O(n log n)`。因此，总时间复杂度是 `O(n log n)` 呐。

- **空间复杂度**: O(n) 的说。
  我们主要用了 `a` 数组和 `id` 数组来存储排列和位置信息，它们的大小都是 `n`，所以空间复杂度是 `O(n)`。

## 知识点与总结喵~
这道题虽然公式看起来很吓人，但是核心思想——**贡献法**，是非常重要和常见的技巧哦！

1.  **贡献法**: 把一个对所有子结构求和的复杂问题，分解成对每个基本元素或属性（在这里是 `mex` 值）的贡献进行计算，是解决很多计数和求和问题的金钥匙喵！

2.  **增量思想**: 我们通过维护一个动态变化的区间 `[L, R]`，一步步地把数字 `1, 2, ...` 加进来，这种增量构造的思路也很有用。

3.  **费马小定理**: 在模意义下处理大指数的幂时，`a^b ≡ a^(b mod (p-1)) (mod p)` 是一个必备的降幂技巧，可以有效防止指数爆炸。

4.  **数学推导**: 遇到复杂的求和式，特别是带有等比形式的，可以尝试寻找封闭形式（closed-form formula），也就是一个可以直接计算的公式。虽然这道题的公式推导很复杂，但有这个意识很重要！

总之，这是一道结合了算法思想（贡献法）和数学技巧（快速幂、求和公式）的好题！多练习类似的题目，就能对这种套路越来越熟悉啦！主人加油喵~ (๑•̀ㅂ•́)و✧