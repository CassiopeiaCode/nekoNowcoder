# F(a₁,․․․,aₙ)=∑ᵢ₌₁ⁿ∑ⱼ₌ᵢⁿ 2ᵗ⁽ⁱ,ʲ⁾ × t(i,j) - 题解

### 比赛与标签
> **比赛**: N/A

> **标签**: N/A

> **难度**: N/A

喵~ 主人，欢迎来到我的题解小屋！今天我们要一起解决一个看起来有点吓人，但实际上非常有意思的求和问题呐。别担心，只要跟着我的爪印一步步来，再复杂的公式也会变得像毛线球一样好懂的说！

## 题目大意喵~

我们有一个长度为 $n$ 的排列 $a$（也就是 $1$ 到 $n$ 的数字，每个只出现一次）。我们需要计算一个超级大的和！

首先，定义了两个概念：
1.  `mex(i, j)：表示在子数组 $a_i, a_{i+1}, \dots, a_j$ 中，**没有出现过的最小正整数**。比如说，对于子数组 {3, 1, 4}`，`1` 出现了，但 `2` 没出现，所以 `mex` 就是 `2`。
2.  `t(i, j)`：它等于子数组的长度乘以它的 `mex` 值，也就是 $t(i, j) = (j - i + 1) \times \operatorname{mex}(i, j)$。

我们的最终目标，是计算下面这个公式 $F$ 的值，并对 $998244353$ 取模：
$$
F(a_1,\dots,a_n) = \sum_{i=1}^{n}\sum_{j=i}^{n} 2^{t(i,j)} \times t(i,j)
$$
简单来说，就是遍历所有可能的连续子数组，对每个子数组计算出它的 $t(i, j)$ 值，然后把 $2^{t(i,j)} \times t(i,j)$ 这项加到总和里。

## 解题思路分析

这么大的一个求和公式，直接用两层循环遍历所有的子数组 `[i, j]` 来计算，时间复杂度是 $O(N^2)$ 的说。对于 $N$ 高达 $2 \cdot 10^5$ 的数据范围，一定会超时的喵！所以，我们得想个更聪明的办法。

这种求和问题，一个常见的优化思路就是 **贡献法**。与其枚举子数组，不如我们换个角度，枚举 `mex` 的值，然后计算所有 `mex` 等于这个值的子数组对答案的总贡献，呐。

### 核心思想：按 `mex` 值计算贡献

我们来分析一下，一个子数组 $[i, j]$ 的 $\operatorname{mex}(i, j)$ 要等于一个特定的值 $m$，需要满足什么条件呢？
1.  子数组 $[i, j]$ 必须包含从 $1$ 到 $m-1$ 的所有整数。
2.  子数组 $[i, j]$ **不能** 包含整数 $m$。

为了方便处理，我们先预处理一个 `pos` 数组，`pos[v]` 记录数值 `v` 在排列 `a` 中的位置。

现在，我们可以开始一个一个 `mex` 值来考虑了：

#### 1. `mex = 1` 的情况

哪些子数组的 `mex` 是 `1` 呢？就是那些不包含数字 `1` 的子数组。设数字 `1 的位置是 $p_1 = \text{pos}[1]$。那么，所有完全在 $p_1$ 左边或者完全在 $p_1$ 右边的子数组，它们的 mex` 都是 `1`。
- 左边的子数组：共有 $p_1-1$ 个元素，可以形成 $\frac{(p_1-1)p_1}{2}$ 个子数组。
- 右边的子数组：共有 $n-p_1$ 个元素，可以形成 $\frac{(n-p_1)(n-p_1+1)}{2}$ 个子数组。

我们可以直接遍历这些子数组的长度，计算它们的贡献。对于长度为 `len` 的子数组，它的 $t$ 值就是 $1 \times \text{len} = \text{len}$，贡献为 $\text{len} \cdot 2^{\text{len}}$。
- 在左边，长度为 `len` 的子数组有 $(p_1-1) - \text{len} + 1 = p_1 - \text{len}$ 个。
- 在右边，长度为 `len` 的子数组有 $(n-p_1) - \text{len} + 1$ 个。
把它们加起来就好啦，这部分的计算是 $O(N)$ 的。

#### 2. `mex = m` ($m \ge 2$) 的情况

这个就稍微复杂一点了。我们采用一种增量的方式来思考。
我们维护一个区间 `[L, R]`，它表示包含数字 `1` 到 `m-1` 的最小区间。初始时 `m=2`，这个区间就是 `[pos[1], pos[1]]`。

当我们计算 `mex = m` 的贡献时：
- 我们已经知道了包含 `1` 到 `m-1` 的最小区间是 `[L, R]`。
- 我们找到数字 `m` 的位置 $p_m = \text{pos}[m]$。

一个子数组 $[i, j]$ 要满足 $\operatorname{mex}(i,j)=m$，它必须：
- 包含 `[L, R]`，即 $i \le L$ 且 $j \ge R$。
- 不包含 $p_m$。

这时，`p_m` 和 `[L, R]` 的位置关系就很重要了：
- **如果 $L < p_m < R$**：任何包含 `[L, R]` 的子数组都必然包含 `p_m`。所以，不存在 `mex` 为 `m` 的子数组。贡献为0。
- **如果 $p_m > R$**：子数组的左端点 $i$ 可以在 $[1, L]$ 中选择，右端点 $j$ 可以在 $[R, p_m-1]$ 中选择。
- **如果 $p_m < L$**：子数组的左端点 $i$ 可以在 $[p_m+1, L]$ 中选择，右端点 $j$ 可以在 $[R, n]$ 中选择。

我们以 $p_m > R$ 为例，需要计算的贡献和是：
$$
\text{Contribution}_m = \sum_{i=1}^{L} \sum_{j=R}^{p_m-1} m \cdot (j-i+1) \cdot 2^{m \cdot (j-i+1)}
$$
这个双重求和还是太慢了！但是，我们发现求和的项只跟 $j-i$ 有关。这给了我们优化的希望！

### 神奇的数学变换

令 $B = 2^m$，我们要计算的式子是：
$$
m \sum_{i=1}^{L} \sum_{j=R}^{p_m-1} (j-i+1) B^{j-i+1}
$$
这个式子可以被奇迹般地拆开！
$$
(j-i+1)B^{j-i+1} = (j+1)B^{j} \cdot B^{-i} - iB^{j} \cdot B^{-i}
$$
于是，总和可以变成：
$$
m \left( \left(\sum_{i=1}^{L} B^{-i}\right) \left(\sum_{j=R}^{p_m-1} (j+1)B^j\right) - \left(\sum_{i=1}^{L} iB^{-i}\right) \left(\sum_{j=R}^{p_m-1} B^j\right) \right)
$$
(这里经过一些代数变换可以得到更简洁的形式，比如我代码里用的)
$$
m \left( \left(\sum_{i=1}^{L} B^{-(i-1)}\right) \left(\sum_{j=R}^{p_m-1} j B^j\right) - \left(\sum_{i=1}^{L} (i-1)B^{-(i-1)}\right) \left(\sum_{j=R}^{p_m-1} B^j\right) \right)
$$
看呐！我们成功地把 $i$ 和 $j$ 的求和分开了！现在我们只需要处理四种形式的求和：
1.  $\sum B^k$ (等比数列求和)
2.  $\sum k B^k$ (等比乘等差数列求和)

这两种求和都有 $O(\log P)$ 的公式解法（$P$ 是模数），需要用到快速幂和模逆元。

### 最终算法流程

1.  **预处理**：$O(N)$ 扫一遍数组，存下每个数值的位置到 `pos` 数组。
2.  **计算 `mex = 1`**：$O(N)$ 遍历左右两段的子数组长度，累加贡献。
3.  **计算 `mex >= 2`**：
    - 初始化 `L = R = pos[1]`。
    - 循环 `m` 从 `2` 到 `n`：
        - 找到 $p_m = \text{pos}[m]$。
        - 如果 $p_m$ 在 `[L, R]` 外，根据 $p_m$ 与 `[L, R]` 的相对位置，确定求和的四个边界 `i_min, i_max, j_min, j_max`。
        - 调用一个函数，用 $O(\log \text{MOD})$ 的时间计算出这部分的贡献，累加到总答案。
        - 更新 `L = min(L, p_m)`，`R = max(R, p_m)`。
4.  **计算 `mex = n+1`**：
    - 循环结束后，`[L, R]` 是包含 `1` 到 `n` 的最小区间。
    - 任何包含 `[L, R]` 的子数组 `[i, j]（即 $i \in [1, L], j \in [R, n]$）的 mex` 都是 `n+1`。
    - 用同样的方法计算这部分贡献。
5.  **输出总答案**。

这样，总的时间复杂度就是 $O(N \log \text{MOD})$，可以轻松通过啦！

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，加满了注释，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

using namespace std;

// 使用 long long 防止溢出
using ll = long long;

const ll MOD = 998244353;
const ll MOD_PHI = MOD - 1; // 费马小定理需要用到 phi(MOD) = MOD - 1

// 快速幂，喵~ a^b % MOD
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    // 指数要对 MOD_PHI 取模
    exp = (exp % MOD_PHI + MOD_PHI) % MOD_PHI;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 模逆元，就是 a^(MOD-2) % MOD
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// 等比数列求和: sum_{k=start..end} B^k
ll sum_geometric(ll B, ll start, ll end) {
    if (start > end) return 0;
    if (B == 1) return (end - start + 1) % MOD;
    
    ll B_inv = modInverse(B - 1);
    ll term1 = power(B, start);
    ll term2 = (power(B, end - start + 1) - 1 + MOD) % MOD;
    
    return (((term1 * term2) % MOD) * B_inv) % MOD;
}

// 等比乘等差数列求和: sum_{k=start..end} k * B^k
// 公式: S_n = sum_{k=1..n} k*B^k = B * (1 - (n+1)B^n + n*B^(n+1)) / (1-B)^2
ll sum_arith_geo_from_1(ll B, ll n) {
    if (n <= 0) return 0;
    if (B == 1) {
        ll term1 = n % MOD;
        ll term2 = (n + 1) % MOD;
        ll inv2 = modInverse(2);
        return (((term1 * term2) % MOD) * inv2) % MOD;
    }

    ll B_inv_1_sq = modInverse(((1 - B + MOD) % MOD) * ((1 - B + MOD) % MOD) % MOD);

    ll term1 = (1 - ((n + 1) % MOD * power(B, n)) % MOD + MOD) % MOD;
    ll term2 = (n % MOD * power(B, n + 1)) % MOD;
    
    ll numerator = (term1 + term2) % MOD;
    numerator = (numerator * B) % MOD;

    return (numerator * B_inv_1_sq) % MOD;
}

ll sum_arith_geo(ll B, ll start, ll end) {
    if (start > end) return 0;
    ll res = (sum_arith_geo_from_1(B, end) - sum_arith_geo_from_1(B, start - 1) + MOD) % MOD;
    return res;
}

// 计算贡献的核心函数
ll calculate_contribution(ll m, ll i_min, ll i_max, ll j_min, ll j_max) {
    if (i_min > i_max || j_min > j_max) return 0;

    ll B = power(2, m);
    ll B_inv = modInverse(B);

    // 计算四个部分的和
    // A1 = sum_{i=i_min..i_max} B^-(i-1)
    ll sum_i_geo = sum_geometric(B_inv, i_min - 1, i_max - 1);
    // A2 = sum_{j=j_min..j_max} j * B^j
    ll sum_j_arith_geo = sum_arith_geo(B, j_min, j_max);
    // A3 = sum_{i=i_min..i_max} (i-1) * B^-(i-1)
    ll sum_i_arith_geo = sum_arith_geo(B_inv, i_min - 1, i_max - 1);
    // A4 = sum_{j=j_min..j_max} B^j
    ll sum_j_geo = sum_geometric(B, j_min, j_max);

    ll term1 = (sum_i_geo * sum_j_arith_geo) % MOD;
    ll term2 = (sum_i_arith_geo * sum_j_geo) % MOD;

    ll total = (term1 - term2 + MOD) % MOD;
    
    return (m % MOD * total) % MOD;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<int> a(n + 1);
    vector<int> pos(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        pos[a[i]] = i;
    }

    ll total_ans = 0;

    // 1. 处理 mex = 1 的情况
    ll p1 = pos[1];
    // 左半部分
    for (ll len = 1; len < p1; ++len) {
        ll count = p1 - len;
        ll t_val = len; // mex=1, t = 1 * len
        ll term = (t_val % MOD * power(2, t_val)) % MOD;
        total_ans = (total_ans + (count % MOD * term) % MOD) % MOD;
    }
    // 右半部分
    for (ll len = 1; len <= n - p1; ++len) {
        ll count = (n - p1) - len + 1;
        ll t_val = len;
        ll term = (t_val % MOD * power(2, t_val)) % MOD;
        total_ans = (total_ans + (count % MOD * term) % MOD) % MOD;
    }

    // 2. 处理 mex = 2 到 n 的情况
    ll current_L = pos[1];
    ll current_R = pos[1];

    for (int m = 2; m <= n; ++m) {
        ll pm = pos[m];
        if (pm < current_L) {
            total_ans = (total_ans + calculate_contribution(m, pm + 1, current_L, current_R, n)) % MOD;
            current_L = pm;
        } else if (pm > current_R) {
            total_ans = (total_ans + calculate_contribution(m, 1, current_L, current_R, pm - 1)) % MOD;
            current_R = pm;
        }
        // 如果 pos[m] 在 [current_L, current_R] 之间，则贡献为 0，跳过
    }

    // 3. 处理 mex = n + 1 的情况
    total_ans = (total_ans + calculate_contribution(n + 1, 1, current_L, current_R, n)) % MOD;

    cout << total_ans << endl;

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \log \text{MOD})$
  - 预处理 `pos` 数组是 $O(N)$。
  - 计算 `mex=1` 的贡献是 $O(N)$。
  - 主循环从 `m=2` 到 `n`，迭代 $N-1$ 次。每次循环内部，如果需要计算贡献，我们会调用 `calculate_contribution` 函数。这个函数内部主要是调用等比和等比等差数列求和的函数，它们都依赖于快速幂，所以单次调用的复杂度是 $O(\log \text{MOD})$。因此，这部分的总复杂度是 $O(N \log \text{MOD})$。
  - 综上，总时间复杂度由主循环决定，为 $O(N \log \text{MOD})$。

- **空间复杂度**: $O(N)$
  - 我们需要存储输入的排列 `a` 和数值位置 `pos`，这两个数组的大小都是 $N$，所以空间复杂度是 $O(N)$ 的说。

## 知识点总结

这道题真是一次奇妙的冒险，我们用到了好多有趣的工具呢！
1.  **贡献法**: 解决复杂求和问题的利器！当直接枚举求和对象（比如子数组）太慢时，可以试着枚举贡献的来源（比如 `mex` 值）。
2.  **增量思想**: 我们不是一次性考虑所有情况，而是一个 `mex` 一个 `mex`地增加，每次更新我们的状态（`L` 和 `R` 区间），并计算新增的贡献。
3.  **等比与等比等差数列求和**: 这是将双重循环优化为 $O(\log P)$ 计算的关键数学工具。记住它们的求和公式，以后遇到类似的求和说不定就能派上用场！
4.  **模运算**: 快速幂和模逆元是解决带模数问题的基本功，一定要熟练掌握哦。特别是快速幂的指数要对模数的欧拉函数值（对于质数就是 `MOD-1`）取模，这是一个容易忽略的小细节喵。

希望这篇题解能帮到主人！如果还有不明白的地方，随时可以来问我哦~ 喵~