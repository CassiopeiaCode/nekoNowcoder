# love relationship - 题解

### 比赛与标签
> **比赛**: The 2021 ICPC Asia Jinan Regional Contest, Gym 103470
> **标签**: 数论, 组合数学, 整数划分, 动态规划
> **难度**: 困难

## 题目大意喵~

各位主人，下午好喵~！今天我们来解决一个关于爱与数学的有趣问题，喵~！

这道题是这样描述的：有 $n$ 个人，他们之间形成了一种叫做“爱情关系”的东西。这种关系其实就是一个 $n$ 个人的排列组合，记作 $\mathcal{R}$。比如说，如果 $\mathcal{R} = [3, 1, 2]$，就表示第1个人喜欢第3个人，第2个人喜欢第1个人，第3个人喜欢第2个人。

在这种关系里，可能会形成一些小圈子，比如 A 爱 B，B 爱 C，C 又爱 A，这就形成了一个3人圈，我们叫它 **3-love polygon**。类似的，还有2人圈、1人圈（自己爱自己）等等。一个 $n$ 人的“爱情关系”可以被分解成若干个这样的小圈子（在数学上就是置换的轮换分解）。

一个“爱情关系”的**类型**，是由它包含的各种大小圈子的数量决定的。比如，一个类型可以被描述为 $(a_1, a_2, \dots, a_n)$，其中 $a_k$ 表示有 $a_k$ 个 $k$ 人圈。当然，所有圈子的人数加起来必须等于总人数 $n$，也就是 $\sum_{k=1}^{n} k \cdot a_k = n$。

对于每一种类型 $(a_1, a_2, \dots, a_n)$，都对应着一定数量的具体“爱情关系”，我们把这个数量记为 $f(a_1, a_2, \dots, a_n)$。

现在，有一个挑剔的人 Avery，他有一个讨厌的数字 $P$。如果某个关系类型对应的数量 $f(\dots)$ 刚好是 $P$ 的倍数，他就会觉得这种类型是“恶心”的。

我们的任务就是，帮助 Apollo 找出，对于给定的 $n$ 和 $P$（$P$ 是一个质数），有多少种**不同类型**的“爱情关系”是**不恶心**的。也就是说，我们要计算满足 $\sum k \cdot a_k = n$ 并且 $f(a_1, \dots, a_n) \not\equiv 0 \pmod{P}$ 的类型 $(a_1, \dots, a_n)$ 的总数，喵~

**输入**:
- 多组测试数据。
- 每组数据包含两个数：人数 $n$ ($1 \le n \le 10^{18}$) 和 Avery 讨厌的质数 $P$ ($2 \le P \le 10^5$)。

**输出**:
- 对于每组数据，输出一个整数，代表不“恶心”的关系类型的数量，结果对 $10^9 + 7$ 取模。

## 解题思路分析

这道题的数学推导有点复杂呢，喵~ 它把我们带到了组合数学和群论的奇妙世界里！让本猫娘一步步带你解开它的神秘面纱吧！

#### 问题的转化

首先，我们得知道那个神秘的函数 $f(a_1, a_2, \dots, a_n)$ 到底是什么。这是一个经典的组合计数问题：计算一个 $n$ 元置换群中，具有给定循环结构（$a_k$ 个长度为 $k$ 的循环）的元素个数。它的计算公式是：

$$
f(a_1, \dots, a_n) = \frac{n!}{\prod_{k=1}^{n} (k^{a_k} \cdot a_k!)}
$$

我们的目标是找出所有满足 $\sum k \cdot a_k = n$ 的整数序列 $(a_1, \dots, a_n)$ 中，使得 $f(\dots) \not\equiv 0 \pmod{P}$ 的序列个数。

因为 $n$ 可以达到 $10^{18}$，直接枚举所有 $n$ 的整数划分，然后逐个计算 $f(\dots)$ 是否能被 $P$ 整除，是绝对行不通的，喵~ 我们需要一个更强大的数学武器！

#### 神奇的数学定理

这个问题的本质是在问：在对称群 $S_n$ 中，有多少个共轭类的大小不能被质数 $P$ 整除。这是一个相当高深的数学问题，它的完整证明需要用到群论和母函数等知识，对于我们解题来说，直接运用其结论就足够啦，喵~

这个神奇的结论是这样的：

> 令 $A_P(n)$ 为我们要求的 "不恶心" 的关系类型数量。
> 将 $n$ 写成 $P$ 进制形式：
> $$ n = n_0 + n_1 P + n_2 P^2 + \dots + n_m P^m $$
> 其中 $0 \le n_i < P$。
>
> 那么，$A_P(n)$ 可以通过以下公式计算：
> $$ A_P(n) = p(n_0) \times (n_1 + 1) \times (n_2 + 1) \times \dots \times (n_m + 1) $$
> 这里的 $p(k)$ 是指整数 $k$ 的**整数划分**数量（即将 $k$ 写成一个或多个正整数之和的方案数）。

这个公式真是太优雅了，不是吗？它把一个关于巨大数 $n$ 的复杂问题，分解成了对 $n$ 的 $P$ 进制下的每一位的简单计算！

#### 如何计算 $p(k)$？

现在问题就转化成了如何计算 $p(n_0)$ 和 $n$ 的 $P$ 进制表示。

1.  **$n$ 的 $P$ 进制表示**: 这个很简单，我们只需要不断地对 $n$ 进行取模 `n % P` 和整除 `n / P 操作就可以依次得到 $n_0, n_1, n_2, \dots$。

2.  **整数划分数 $p(k)$**: 我们需要计算 $p(n_0)$。因为 $n_0 = n \pmod P$，所以 $n_0 < P$，而题目中 $P \le 10^5$。这意味着我们只需要预处理出 $10^5$ 以内的所有整数划分数 $p(k)$ 即可。

    计算 $p(k)$ 的一个高效方法是使用动态规划，并借助**欧拉五边形数定理 (Euler's Pentagonal Number Theorem)**。该定理给出了一个计算 $p(k)$ 的递推式：
    $$
    p(k) = \sum_{j=1}^{\infty} (-1)^{j-1} \left( p(k - g_j) + p(k - g_{-j}) \right)
    $$
    其中，$g_j = \frac{j(3j-1)}{2}$ 是广义五边形数（$j=1, 2, 3, \dots$）。
    具体展开就是：
    $$
    p(k) = p(k-1) + p(k-2) - p(k-5) - p(k-7) + p(k-12) + \dots
    $$
    这个递推式的项数大约是 $O(\sqrt{k})$ 级别，所以我们可以在 $O(K\sqrt{K})$ 的时间内预处理出所有 $p(1)$到 $p(K)$ 的值。

#### 算法步骤总结

好啦，现在我们可以整理出完整的解题步骤了，喵~

1.  **预处理**:
    - 创建一个数组 partitions` (或 `dp`)，大小为 $100001$。
    - `partitions[0]` 初始化为 1 (0的整数划分为1种，即空集)。
    - 使用五边形数定理，通过动态规划计算出从 $k=1$ 到 $100000$ 的所有 `partitions[k] 的值，记得每步计算都要对 $10^9+7$ 取模。

2.  **处理查询**:
    - 对于每个给定的 $n$ 和 $P$：
    - 首先，计算 $n$ 的 $P$ 进制最低位 $n_0 = n \pmod P$。
    - 答案的初始值就是 partitions[n_0]。
    - 然后，令 $n = n / P$。
    - 进入一个循环，只要 $n > 0$ 就继续：
        - 取出当前 $n$ 的 $P$ 进制最低位 $n_i = n \pmod P$。
        - 将答案乘以 $(n_i + 1)$，并对 $10^9+7$ 取模。
        - 更新 $n = n / P$。
    - 循环结束后，得到的最终答案就是我们想要的数量啦！

这样，我们就巧妙地解决了这个看似棘手的问题，喵~！

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的一份代码哦~ 注释很详细，希望能帮到你！

``cpp
#include <iostream>
#include <vector>
#include <numeric>

// 使用 long long 来处理大数 n
using ll = long long;

// MOD 是题目要求的模数
const int MOD = 1e9 + 7;
// P 的最大值，决定了我们预处理的范围
const int MAX_P = 100005;

// 用于存储预计算的整数划分数 p(k)
std::vector<int> partitions(MAX_P);

// 预处理整数划分数的函数
void precompute_partitions() {
    // 0 的整数划分有1种（空集），这是递推的基础
    partitions[0] = 1;

    for (int n = 1; n < MAX_P; ++n) {
        // 根据欧拉五边形数定理进行递推
        // p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + ...
        for (int j = 1; ; ++j) {
            // 计算广义五边形数 g_j 和 g_{-j}
            ll pentagonal_pos = (ll)j * (3 * j - 1) / 2;
            ll pentagonal_neg = (ll)j * (3 * j + 1) / 2;

            // 标志位，控制加减号，每两项变一次
            bool positive_sign = (j % 2 != 0);

            if (pentagonal_pos <= n) {
                if (positive_sign) {
                    partitions[n] = (partitions[n] + partitions[n - pentagonal_pos]) % MOD;
                } else {
                    // C++ 的 % 可能是负数，所以加 MOD 保证正数
                    partitions[n] = (partitions[n] - partitions[n - pentagonal_pos] + MOD) % MOD;
                }
            }

            if (pentagonal_neg <= n) {
                if (positive_sign) {
                    partitions[n] = (partitions[n] + partitions[n - pentagonal_neg]) % MOD;
                } else {
                    partitions[n] = (partitions[n] - partitions[n - pentagonal_neg] + MOD) % MOD;
                }
            }

            // 如果最小的五边形数都超过了 n，就可以结束内层循环了
            if (pentagonal_pos > n) {
                break;
            }
        }
    }
}

void solve() {
    ll n;
    int p;
    std::cin >> n >> p;

    // 根据定理 A_P(n) = p(n_0) * (n_1+1) * (n_2+1) * ...
    
    // 计算 n 的 P 进制最低位 n_0
    ll n0 = n % p;
    // 答案的初始值为 p(n_0)
    ll ans = partitions[n0];

    // 接下来处理 n 的更高位
    n /= p;
    while (n > 0) {
        // 取出当前 n 的 P 进制最低位 n_i
        ll ni = n % p;
        // 乘以 (n_i + 1)
        ans = (ans * (ni + 1)) % MOD;
        // 继续处理更高位
        n /= p;
    }
    
    std::cout << ans << "\n";
}

int main() {
    // 加速输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // 在所有计算开始前，先进行预处理
    precompute_partitions();

    int t;
    std::cin >> t;
    for (int i = 1; i <= t; ++i) {
        std::cout << "Case #" << i << ": ";
        solve();
    }

    return 0;
}
``

## 复杂度分析

-   **时间复杂度**: $O(K\sqrt{K} + T \cdot \log_P n)$
    -   预处理部分 (precompute_partitions) 需要计算到 $K = 100000$。对于每个数 $k$，内层循环运行约 $\sqrt{k}$ 次。所以总的预处理时间复杂度是 $O(K\sqrt{K})$。
    -   对于每个查询，我们需要对 $n$ 进行 $P$ 进制分解。循环次数为 $O(\log_P n)$。所以 $T$ 组查询的总时间是 $O(T \cdot \log_P n)$。
    -   总时间复杂度由这两部分组成。

-   **空间复杂度**: $O(K)$
    -   我们主要使用了一个数组 partitions` 来存储预处理的整数划分数，其大小为 $K = 100005$。所以空间复杂度是 $O(K)$。

## 知识点总结

这道题真是一次有趣的探险，我们学到了不少东西呢，喵~

1.  **问题建模**: 将看似复杂的人际关系问题，抽象成图论中的**置换与轮换分解**，这是解决组合问题的第一步。
2.  **整数划分 (Integer Partition)**: 核心概念之一。一个正整数 $n$ 的整数划分是指将 $n$ 表示成若干个正整数之和的方案。我们用 $p(n)$ 表示其方案数。
3.  **欧拉五边形数定理**: 这是计算 $p(n)$ 的强大武器！它提供了一个高效的递推关系，让我们能快速地预处理出所需的 $p(n)$ 值。
4.  **数论与群论定理的应用**: 本题最关键的部分是那个神奇的公式 $A_P(n) = p(n_0) \prod (n_i+1)$。虽然我们不必现场证明它，但了解和应用这个结论是解题的核心。这告诉我们，在算法竞赛中，积累一些高深的数学结论有时能带来意想不到的捷径！
5.  **大数处理技巧**: 当遇到像 $n=10^{18}$ 这样的巨大数时，通常的思路是考察它在某个模数（本题是 $P$）下的性质，或者利用其进制表示来分解问题。

希望这篇题解能让你有所收获，喵~！下次再一起探索更多有趣的算法世界吧！