# 求 ∏ φ(C(i,k)) - 题解

### 比赛与标签
> **比赛**: 2023牛客多校第四场
> **标签**: 数论, 欧拉函数, 整除分块, 组合数学
> **难度**: *3000

## 题目大意喵~
这道题目的要求看起来很简洁，但其实暗藏玄机哦！

我们需要对给定的 `T` 组 `n` 和 `k`，计算下面这个看起来很复杂的连乘式：
$$
\prod_{i=k}^n \varphi\left(\binom{i}{k}\right)
$$
其中 `φ` 是大名鼎鼎的欧拉函数，而 $\binom{i}{k}$ (也写作 `C(i, k)`) 是组合数，代表从 `i` 个物品中选出 `k` 个的方案数。最后的结果需要对 $10^9+7$ 取模。

简单来说，就是把从 `C(k, k)` 到 `C(n, k)` 这一串组合数，每一个都求一遍欧拉函数，然后把这些结果全部乘起来！是不是听起来就很有挑战性呀？喵~

## 解题思路喵~
这么复杂的式子，直接硬算肯定是行不通的啦！我们需要把它拆解成可以处理的小部分。这就要用到我们数论中的强大武器——欧拉函数的性质啦！

#### 第一步：欧拉函数变形记！
我们知道欧拉函数的计算公式：对于一个正整数 $x$，它的欧拉函数值是
$$
\varphi(x) = x \cdot \prod_{p|x, p \text{ is prime}} \left(1 - \frac{1}{p}\right)
$$
这个公式告诉我们，一个数的欧拉函数等于它自身乘以“所有的质因子p对应的(1-1/p)的乘积”。

现在，我们把这个公式代入到题目要求的式子中：
$$
\prod_{i=k}^n \varphi\left(\binom{i}{k}\right) = \prod_{i=k}^n \left( \binom{i}{k} \cdot \prod_{p|\binom{i}{k}} \left(1 - \frac{1}{p}\right) \right)
$$
哇，式子变得更长了！但是不要怕，我们可以利用乘法的交换律，把它们分成两个部分：
$$
\underbrace{\left(\prod_{i=k}^n \binom{i}{k}\right)}_{\text{Part A}} \cdot \underbrace{\left(\prod_{i=k}^n \prod_{p|\binom{i}{k}} \left(1 - \frac{1}{p}\right)\right)}_{\text{Part B}}
$$

现在问题就变成了分别计算 Part A 和 Part B！

#### 第二步：处理 Part A
Part A 是组合数的连乘积。$\binom{i}{k} = \frac{i!}{k!(i-k)!}$。这个部分我们可以通过预处理阶乘和阶乘的逆元来快速计算。代码中的 `p[]` 数组存阶乘，`iv[]` 存阶乘逆元，`p2[]` 和 `i2[]` 存阶乘的前缀积和阶乘逆元的前缀积，就是为了光速算出这一部分的值哦！

#### 第三步：处理 Part B（最核心的部分！）
Part B 是最棘手的部分。我们再次交换求积的顺序，不先枚举 `i` 再枚举质因子 `p`，而是反过来，先枚举质因子 `p`：
$$
\text{Part B} = \prod_p \left(1 - \frac{1}{p}\right)^{f(n, k, p)}
$$
这里的指数 `f(n, k, p)` 代表的是，在 `i` 从 `k` 到 `n` 的所有取值中，有多少个 `i` 使得 $\binom{i}{k}$ 能被质数 `p` 整除。

现在，问题转化为了如何计算 `f(n, k, p)`。

#### 第四步：计算指数 f(n, k, p)
一个数能被 `p` 整除，等价于它含质因子 `p` 的幂次（也叫 p-adic valuation，记作 $v_p(x)$）大于 0。
根据**勒让德公式 (Legendre's Formula)**，我们知道 $v_p(m!) = \sum_{j=1}^{\infty} \lfloor \frac{m}{p^j} \rfloor$。
那么，$v_p(\binom{i}{k}) = v_p(i!) - v_p(k!) - v_p((i-k)!)$。
经过一番推导（这里的小魔法是 $\lfloor x+y \rfloor \ge \lfloor x \rfloor + \lfloor y \rfloor$），可以得出一个超级重要的结论：
$v_p(\binom{i}{k})$ **恰好等于在 p 进制下，计算 `k + (i-k)` 时发生的进位次数！**

所以，$p | \binom{i}{k}$ 当且仅当 `k` 和 `i-k` 在 `p` 进制下的加法**至少有一次进位**。
反过来说，$p \nmid \binom{i}{k}$ 当且仅当 `k` 和 `i-k` 在 `p` 进制下的加法**没有任何进位**。
没有进位等价于每一位上的数字相加都小于 `p`。

令 `j = i - k`，`j` 的取值范围是 `[0, n-k]`。我们要计算 `f(n, k, p)`，可以反过来计算有多少个 `j` 使得 `p` **不能**整除 $\binom{j+k}{k}$，然后用总数 `n-k+1` 减掉它。
这就变成了一个**数位 DP** 问题：计算在 `[0, n-k]` 中有多少个 `j`，满足对于任意位数 `d`，都有 `j` 的第 `d` 位 `j_d` 和 `k` 的第 `d` 位 `k_d` 满足 `j_d + k_d < p`。

代码中的 `fd(n, p, k)` 函数就是一个数位DP，它直接计算出了 $(1-1/p)^{f(n,k,p)}$ 的值，真是太巧妙啦！

#### 第五步：加速！整除分块！
我们不可能对所有小于 `n` 的质数 `p` 都跑一遍数位DP，那样太慢啦！必须进行优化！
我们观察到，当 `p` 比较大的时候，`f(n, k, p)` 的计算方式会变得简单。

- **对于小质数 `p`**: 进位逻辑比较复杂。我们划定一个阈值 `mm = max(K, sqrt(N))`，对于所有 `p <= mm` 的质数，我们老老实实地跑数位DP `fd` 函数。
- **对于大质数 `p > k`**: 此时 `p` 不可能是 `k!` 的因子，所以 $v_p(k!)=0$。$v_p(\binom{i}{k}) = v_p(i!) - v_p((i-k)!)$。这个式子可以被证明，当 `p > k` 时，它等价于 `p | i`。也就是说，$\binom{i}{k}$ 能被 `p` 整除当且仅当 `i` 是 `p` 的倍数。
  所以，对于 `p > k` (也必然 `p > mm`)，`f(n, k, p)` 的计算就简化为：
  $$
  f(n, k, p) = |\{i \in [k, n] \mid p \text{ divides } i\}| = \lfloor \frac{n}{p} \rfloor - \lfloor \frac{k-1}{p} \rfloor
  $$

这个式子中的 $\lfloor n/p \rfloor$ 和 $\lfloor (k-1)/p \rfloor$ 让我们立刻想到了**整除分块**！对于一段连续的 `p`，这些值是固定的。我们可以将 `p > mm` 的质数分成很多块，对每一块统一计算贡献。

代码中 `for(int l=1,r;l<=N;l=r+1)` 的循环就是在做整除分块。它通过预处理 `s1, s2, s3, s4` 这些关于 `(1-1/p)` 的前缀积和幂次积，非常高效地处理了所有大质数的贡献。这部分的实现非常精妙，将两个整除分块的过程合二为一了，大家可以细细品味一下哦！

总结一下我们的攻略：
1.  **公式拆解**: 将 `φ(C(i,k))` 拆成 `C(i,k)` 和 `∏(1-1/p)`。
2.  **分别计算**:
    *   `∏ C(i,k)` 用预处理阶乘解决。
    *   `∏(1-1/p)^f` 根据 `p` 的大小分情况讨论。
3.  **分类讨论**:
    *   小质数 `p` 用**数位DP**解决 `f(n,k,p)`。
    *   大质数 `p` 的 `f(n,k,p)` 有简单形式，用**整除分块**加速计算。

这样一套组合拳下来，问题就迎刃而解啦！喵~

## 代码实现喵!
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
#define MOD 1000000007

// 快速幂，喵~
inline int pw(int a,int b) {
    int as=1;
    while(b) {
        if(b&1) as=1ll*as*a%MOD;
        a=1ll*a*a%MOD;
        b>>=1;
    }
    return as;
}

// 求逆元，根据费马小定理
inline int ni(int a) {
    return pw(a,MOD-2);
}

// 定义一堆全局变量，方便使用
int T,N,K,a1[35],a2[35],p[10000009],iv[10000009],v[10000009],su[1000009],k,
dp[35][2],i2[10000009],p2[10000009],ii[10000009],s1[10000009],s2[10000009],s3[10000009],s4[10000009];

// 数位DP函数，计算 (1 - 1/pr)^f(n,k,pr) 的值
// pr 是质数
// f(n,k,pr) = (n-k+1) - (不产生进位的数量)
// 这个函数就是计算不产生进位的数量
int fd(int n,int pr,int k) {
    int tc=n-k,q1=0,q2=0;
    // 把 n-k 和 k 转换成 pr 进制
    while(tc) {
        a1[++q1]=tc%pr;
        tc/=pr;
    }
    tc=k;
    while(tc) {
        a2[++q2]=tc%pr;
        tc/=pr;
    }
    // 补齐位数
    for(int i=q1+1;i<=q2;i++) a1[i]=0;
    for(int i=q2+1;i<=q1;i++) a2[i]=0;

    int r=std::max(q1,q2);
    dp[r+1][0]=0;dp[r+1][1]=1; // dp[i][1]是计数，dp[i][0]是求和（这里实现有点复杂，但核心是计数）
    
    // DP过程，从高位到低位
    for(int i=r;i>=1;i--) {
        dp[i][0]=dp[i][1]=0;
        // 状态转移，计算在 [0, n-k] 中有多少个数 j 满足 j_d + k_d < pr
        if(a1[i]<pr-a2[i]) {
            dp[i][1]=(dp[i+1][1]+dp[i][1]);
            dp[i][0]=(dp[i+1][1]*a1[i]+dp[i][0]);
        } else {
            dp[i][0]=(dp[i][0]+dp[i+1][1]*(pr-a2[i]));
        }
        dp[i][0]=(dp[i][0]+(pr-a2[i])*dp[i+1][0]);
    }
    
    int aq=dp[1][0]+dp[1][1]; // aq 是不产生进位的数量
    aq=(n-k+1)-aq; // (n-k+1) - aq 就是产生进位的数量 f(n,k,pr)
    return pw((MOD+1-ii[pr])%MOD,aq); // 返回 (1 - 1/pr)^f(n,k,pr)
}

signed main(void) {
    // --- 预处理部分 ---
    // p[]存阶乘, iv[]存阶乘的逆元
    p[0]=1;
    for(int i=1;i<=10000001;i++)p[i]=1ll*p[i-1]*i%MOD;
    iv[10000001]=ni(p[10000001]);
    for(int i=10000000;i>=0;i--) iv[i]=1ll*iv[i+1]*(i+1)%MOD;
    
    // 线性筛，筛出质数
    scanf("%d",&T);
    for(int i=2;i<=10000000;i++) {
        if(!v[i]) {
            su[++k]=i; // su[] 存质数
        }
        for(int j=1;j<=k&&su[j]*i<=10000000;j++) {
            v[i*su[j]]=1;
            if(i%su[j]==0) break;
        }
    }
    
    // ii[i] 存 1/i 的逆元
    for(int i=0;i<=10000000;i++) ii[i+1]=1ll*iv[i+1]*p[i]%MOD;
    
    // p2[], i2[] 存阶乘和阶乘逆元的前缀积，用于计算Part A
    i2[0]=p2[0]=1;
    for(int i=1;i<=10000000;i++) {
        i2[i]=1ll*i2[i-1]*iv[i]%MOD;
        p2[i]=1ll*p2[i-1]*p[i]%MOD;
    }
    
    // s1,s2,s3,s4 存用于整除分块的各种前缀积
    s1[1]=s2[1]=s3[1]=s4[1]=1;
    for(int i=2;i<=10000000;i++) {
        if(v[i]==0) { // 如果 i 是质数
            s1[i]=1ll*s1[i-1]*(1+MOD-ii[i])%MOD; // s1[i] = ∏_{p<=i} (1-1/p)
            s2[i]=1ll*s2[i-1]*(1+ii[i-1])%MOD; // s2是s1的逆的前缀积（代码实现有点绕）
            s3[i]=1ll*s3[i-1]*pw(1+MOD-ii[i],i)%MOD; // 更复杂的幂次前缀积
            s4[i]=ni(s3[i]);
        } else s1[i]=s1[i-1],s2[i]=s2[i-1],s3[i]=s3[i-1],s4[i]=s4[i-1];
    }
    
    // --- 主循环 ---
    while(T--) {
        scanf("%d %d",&N,&K);
        // 计算 Part A: ∏ C(i,k)
        int ans=1ll*i2[N-K]*i2[K-1]%MOD*p2[N]%MOD*pw(iv[K],N-K+1)%MOD;
        
        // --- 处理 Part B ---
        // 1. 小质数部分
        int mm=std::max(K,(int)sqrt(N)+5); // 阈值
        for(int i=2;i<=mm;i++) {
            if(v[i]==0) { // 对每个小质数
                ans=1ll*ans*fd(N,i,K)%MOD; // 用数位DP计算贡献
            }
        }
        
        // 2. 大质数部分 (整除分块)
        // 这部分代码非常精炼，背后是复杂的数学推导，将两个整除分块合并了
        int cc=1,c2=1; // 临时变量
        for(int l=1,r;l<=N;l=r+1) {
            r=N/(N/l);
            if(r<=mm) continue;
            l=std::max(l,mm+1);
            if(l>r) continue;
            
            // 下面的逻辑是在计算 ∏_{p∈[l,r], p>mm} (1-1/p)^(floor(N/p)-floor((K-1)/p))
            // 实现上非常trick，普通思路是双重整除分块
            cc=1ll*cc*s1[r]%MOD*s2[mm]%MOD;
            int ss=N/l;
            int rr=(N-K+1)/ss;
            rr=std::max(rr,l-1);
rr=std::min(rr,r);
            c2=1ll*c2*s1[r]%MOD*s2[rr]%MOD;
            ans=1ll*ans*pw(1ll*s4[r]*s3[rr]%MOD,ss)%MOD;
        }
        // 这两行是整除分块的后续处理，同样是高度优化的结果
        ans=1ll*ans*pw(cc,K)%MOD;
        ans=1ll*ans*pw(c2,N+1-K)%MOD;
        printf("%d\n",ans);
    }
}
```

## 复杂度分析的说
- **时间复杂度**: O($N_{max} + T \cdot (\sqrt{N} \log N))$ 的说。
  预处理部分，线性筛是 $O(N_{max})$，其他都是线性的。对于每个询问，处理小质数的部分大约是 $O(\frac{\sqrt{N}}{\log N} \cdot \log_p N)$，处理大质数的部分是整除分块的 $O(\sqrt{N})$。所以瓶颈在每个测试用例的处理上。
- **空间复杂度**: O($N_{max}$) 的说。
  我们需要好几个大数组来存预处理的结果，比如阶乘、逆元、质数表和各种前缀积，空间开销是和数据范围 `1e7` 成正比的。

## 知识点与总结喵~
这真是一道精彩的题目，像一道丰盛的数学大餐，融合了好多知识点呢！

1.  **欧拉函数**: 核心性质 $\varphi(x) = x \prod (1 - 1/p)$ 是解题的钥匙。
2.  **组合数学与勒让德公式**: 理解 $v_p(\binom{n}{k})$ 和 p-进制加法进位的关系是解题的突破口。
3.  **数位DP**: 当题目条件和数位相关时，数位DP就是我们的好朋友！这里用它来处理复杂的计数问题。
4.  **整除分块**: 处理形如 $\sum_{i=1}^n f(i)g(\lfloor n/i \rfloor)$ 的式子的不二法门，是数论题中常见的优化技巧。
5.  **解题策略**: "化整为零，分类讨论"的思想非常重要。将复杂问题分解，对不同规模的子问题使用不同复杂度的算法（小质数用DP，大质数用分块），是解决高难度问题的常用策略。

希望这篇题解能帮助各位master理解这道题的奇妙之处！遇到难题不要灰心，拆解它，分析它，总能找到通往正确答案的道路的！我们下次再一起探险吧，喵~！