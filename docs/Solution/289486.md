# Mex 操作 - 题解

### 比赛与标签
> **比赛**: [比赛信息未在侧边栏提供]

> **标签**: 贪心, 构造, 数学

> **难度**: [难度评分未在侧边栏提供]

## 题目大意喵~

主人你好呀~ 这道题是这样的喵：

给你一个由 $n$ 个非负整数组成的数组 $a$。我们可以对它进行一种神奇的“Mex 操作”：

1.  首先，找到当前数组中没有出现的最小非负整数，也就是数组的 $\operatorname{mex}$ 值，我们叫它 $m$ 好了，喵~
2.  然后，把数组里每一个数 $a_i$ 都更新成 $\max\{0, a_i - m\}$。

题目想问的是，我们最少需要进行多少轮这样的操作，才能让数组里所有的数都变得一模一样呢？如果不管怎么操作都做不到，就要告诉小牛 `-1` 哦。当然，如果一开始数组里的数就都一样了，那就不需要操作，答案就是 0 啦！

举个栗子：
-   对于数组 `{1, 2, 3}`，没有出现 0，所以 $\operatorname{mex} = 0$。每个数减去 0 不变，数组还是 {1, 2, 3}。
-   对于数组 {0, 2, 5}，没有出现 1，所以 $\operatorname{mex} = 1$。操作后数组变成 {max(0, 0-1), max(0, 2-1), max(0, 5-1)}，也就是 {0, 1, 4} 啦，喵~

## 解题思路分析

这道题看起来操作过程有点复杂，每次都要算 $\operatorname{mex}$，然后更新整个数组，感觉直接模拟会很慢，而且也不知道要模拟多少次呢。所以，我们需要静下心来，像猫咪一样敏锐地洞察问题的本质，喵~

### 最终状态是什么？

我们的目标是让数组中所有数都相等。假设最后所有数都变成了 $c$。
因为操作是 $a_i := \max\{0, a_i - m\}$，数组里的数只会减少或者不变，永远不会增加。所以，最终变成的那个数 $c$ 肯定不会超过数组里最小的那个数。

再想一下，如果所有数都变成了 $c > 0$，那么数组就是 `{c, c, ..., c}`。它的 $\operatorname{mex}$ 就是 0。再进行操作，$a_i := \max\{0, c - 0\} = c$，数组就不会再变了。
如果所有数都变成了 0，数组是 `{0, 0, ..., 0}`。它的 $\operatorname{mex}$ 是 1。再进行操作，$a_i := \max\{0, 0 - 1\} = 0$，数组也稳定不变。

关键在于，操作 `a_i - m` 对所有元素是公平的（只要它们都大于0），它保持了元素之间的差值（比如 `(a_i - m) - (a_j - m) = a_i - a_j`）。要想让原本不相等的两个数 $a_i$ 和 $a_j$ 变得相等，只有一种可能：它们都变成 0！

所以，我们的最终目标一定是把数组中所有的数都变成 0！

### 什么时候无解呢？

既然目标是把所有数变成 0，我们就需要不断地从数组元素中减去一个正数。这个正数就是每一步的 $\operatorname{mex}$ 值。
如果某一步的 $\operatorname{mex} = 0$，那么操作就变成了 $a_i := \max\{0, a_i - 0\} = a_i$，数组就卡住不动了！

什么时候 $\operatorname{mex}$ 会是 0 呢？根据定义，当 `0` 这个数没有在数组里出现时，$\operatorname{mex}$ 就是 0。
所以，如果一开始给定的数组里就没有 0，并且数组里的数还不全相等，那我们就永远无法改变数组，也就不可能让所有数都变成 0。这种情况就是无解的，应该输出 -1。

因此，我们得到了一个重要的**必要条件**：**数组中必须要有 0**。

### 怎么计算最少操作次数？

好啦，现在我们知道了目标是全变为 0，并且数组里肯定有 0。接下来就是计算最少操作次数了。
直接模拟每一步还是太麻烦，我们来找找规律。

为了方便观察，我们先把数组从小到大排个序，得到 $a'_1, a'_2, \dots, a'_n$。
根据上面的推论，必须有 $a'_1 = 0$。

我们来手动模拟一个例子看看，比如数组是 `{0, 3, 5}`。
1.  **当前数组**: `{0, 3, 5}`。$\operatorname{mex} = 1$。
    -   操作 1 次，数组变为 `{0, 2, 4}`。
2.  **当前数组**: `{0, 2, 4}`。$\operatorname{mex} = 1$。
    -   操作 1 次，数组变为 `{0, 1, 3}`。
3.  **当前数组**: `{0, 1, 3}`。现在 `0` 和 `1` 都有了，$\operatorname{mex} = 2$。
    -   操作 1 次，数组变为 `{0, 0, 1}`。
4.  **当前数组**: `{0, 0, 1}` (唯一值为 `{0, 1}$)。$\operatorname{mex} = 2$。
    -   操作 1 次，数组变为 `{0, 0, 0}`。

总共花了 4 步，喵~

我们来分析一下这个过程：
-   一开始，最小的非零数是 3。为了在数组中“凑”出 1，我们用了 2 次 $\operatorname{mex}=1$ 的操作，把 3 变成了 1。这花了 `3 - 1 = 2` 步。
-   现在数组（的唯一值）变成了 `{0, 1, 3}`。为了在数组中“凑”出 2，我们用了 1 次 $\operatorname{mex}=2$ 的操作，把 3 变成了 1。
-   ...这个过程还是很绕。

我们换个角度！把操作次数看成是“填补”排序后数组中数字“空隙”的成本。
对于排好序的数组 $a'_1, a'_2, \dots, a'_n$：
-   我们有 $a'_1=0$。
-   考虑相邻的两个数 $a'_{i-1}$ 和 $a'_i$。如果它们之间有空隙，即 $a'_i > a'_{i-1} + 1$，那么从 $a'_{i-1}+1$ 到 $a'_i-1$ 这些整数都不在数组里。
-   可以发现，操作的本质就是利用当前最小的缺失数字（$\operatorname{mex}$）来削减所有数，从而逐步“填上”这些空隙。
-   比如从 $a'_{i-1}$ 到 $a'_i$，中间缺失了 $a'_i - a'_{i-1} - 1$ 个数。我们可以认为，要把这个空隙“填满”，大致需要这么多次操作。

经过一番神奇的推导（和观察），可以发现一个非常漂亮的规律！总操作次数等于：
$$
\text{总操作数} = 1 + \sum_{i=2}^{n} \max(0, a'_i - a'_{i-1} - 1)
$$

这是为什么呢？
-   $\sum \max(0, a'_i - a'_{i-1} - 1)$ 计算了所有相邻元素之间的“总空隙数”。比如 `{0, 3, 5}`，空隙来自 `(0, 3)` 和 `(3, 5)`。`0` 和 `3` 之间差了 `3-0-1=2` 个数（1和2）。`3` 和 `5` 之间差了 `5-3-1=1` 个数（4）。总空隙是 $2+1=3$。
-   这个总空隙数，可以理解为把所有元素“拉拢”到一起，形成一个连续序列 `0, 1, 2, ...` 所需要的操作次数。
-   那最后的 `+1` 是什么呢？当所有数被“拉拢”成 `{0, 1, 2, ..., k}` 的形式后，还需要最后一次操作，用一个大的 $\operatorname{mex}$ 值（比如 $k+1$）把它们全部变成 0。

让我们用这个公式再算一下 `{0, 3, 5}`：
-   排序后是 `{0, 3, 5}`。
-   $i=2$: $a'_2=3, a'_1=0$。$\max(0, 3 - 0 - 1) = 2$。
-   $i=3$: $a'_3=5, a'_2=3$。$\max(0, 5 - 3 - 1) = 1$。
-   总操作数 = $1 + 2 + 1 = 4$。和我们手动模拟的结果一模一样，喵！

如果数组里有重复的数，比如 `{0, 0, 3, 5, 5}`，公式也适用。
-   $i=2$: $a'_2=0, a'_1=0$。$\max(0, 0-0-1) = 0$。
-   $i=3$: $a'_3=3, a'_2=0$。$\max(0, 3-0-1) = 2$。
-   $i=4$: $a'_4=5, a'_3=3$。$\max(0, 5-3-1) = 1$。
-   $i=5$: $a'_5=5, a'_4=5$。$\max(0, 5-5-1) = 0$。
-   总操作数 = $1 + 0 + 2 + 1 + 0 = 4$。

总结一下我们的解题步骤：
1.  读入数组。
2.  检查数组中的数是否已经全部相同。如果是，恭喜你，0 次操作就够啦！
3.  将数组排序。
4.  检查排序后的第一个数 $a'_1$ 是否为 0。如果不是，说明无法引动 `mex > 0` 的操作，无解，输出 -1。
5.  使用公式 $1 + \sum_{i=2}^{n} \max(0, a'_i - a'_{i-1} - 1)$ 计算结果并输出。

这个方法只需要一次排序和一次遍历，非常高效，喵~

## 代码实现

这是本猫娘根据上面的思路，精心为你准备的代码哦~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 计算数组的 mex 值，这里其实用不到，但有助于理解题目
int calculate_mex(const std::vector<long long>& arr) {
    std::vector<bool> seen(arr.size() + 2, false);
    for (long long val : arr) {
        if (val >= 0 && val < seen.size()) {
            seen[val] = true;
        }
    }
    int mex = 0;
    while (mex < seen.size() && seen[mex]) {
        mex++;
    }
    return mex;
}

int main() {
    // 为了更快的输入输出，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<long long> a(n);
    bool all_same = true;
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        // 在读入时就检查是否所有元素都相同
        if (i > 0 && a[i] != a[i-1]) {
            all_same = false;
        }
    }

    // Case 1: 初始数组所有元素已经相同
    if (all_same) {
        std::cout << 0 << std::endl;
        return 0;
    }

    // 对数组进行排序，方便我们分析
    std::sort(a.begin(), a.end());

    // Case 2: 排序后最小的数不是 0，无法进行有效操作，无解
    if (a[0] != 0) {
        std::cout << -1 << std::endl;
        return 0;
    }

    // Case 3: 计算最少操作次数
    // 根据我们的公式：1 + sum(gaps)
    long long operations_count = 1;
    for (int i = 1; i < n; ++i) {
        // 计算相邻元素之间的“空隙”大小
        if (a[i] > a[i-1] + 1) {
            operations_count += a[i] - a[i-1] - 1;
        }
    }

    std::cout << operations_count << std::endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N \log N)$。
    瓶颈在于对数组进行排序，`std::sort` 的时间复杂度是 $O(N \log N)$。之后计算操作次数的循环是 $O(N)$。所以总的时间复杂度由排序决定，是 $O(N \log N)$ 的说。

-   **空间复杂度**: $O(N)$。
    我们用了一个 `std::vector` 来存储输入的 $N$ 个数，所以空间复杂度是 $O(N)$。如果算上输入数组本身的空间，就是这样。如果不算，那么排序可能是原地的，空间复杂度会更低，但通常我们把输入存储也算进去，喵~

## 知识点总结

这道题真有趣，融合了观察、性质分析和一点点贪心的思想~
1.  **问题简化**: 解决复杂问题的关键一步，是看穿它华丽的外表，找到它最核心的目标。在这里，就是意识到最终状态必然是全 0。
2.  **寻找必要条件**: 通过分析操作的性质，我们找到了“数组中必须有0”这个强大的剪枝条件，直接处理了无解的情况。
3.  **排序大法好**: 对于这类处理数组数值分布的问题，排序往往是打开思路的第一把钥匙。它能让元素间的关系（比如“空隙”）变得清晰可见。
4.  **化繁为简的数学模型**: 最神奇的地方就是那个公式啦！它把一个动态的、多步骤的过程，变成了一个静态的、可以通过初始状态直接计算出来的和式。这体现了从过程到结构化公式的思维转变。

希望本猫娘的讲解对你有帮助哦！如果还有不明白的地方，随时可以再来问我，喵~ >w<