# MEX 操作 - 题解

### 比赛与标签
> **比赛**: 牛客小白月赛
> **标签**: 贪心, 数学, 思维
> **难度**: *1500

## 题目大意喵~
主人你好呀~ 这道题是这样的：我们有一个装着 `n` 个非负整数的数组 `a`。我们可以对它进行一种神奇的“MEX 操作”：

1.  先找出数组里当前所有数字中，**没有出现的最小非负整数**，我们叫它 `mex`。
2.  然后，把数组里的每一个数 `a_i` 都变成 `max(0, a_i - mex)`。

我们的目标是，通过最少次数的 “MEX 操作”，让数组里所有的数都变得一模一样！如果能做到，就告诉小牛需要多少次操作；如果不管怎么操作都做不到，就告诉他 `-1`，让他伤心去吧，喵~

举个栗子：`mex({1, 2, 5}) = 0`，`mex({0, 1, 4}) = 2`。

## 解题思路 Nyan~
这道题看起来像是一个复杂的模拟过程，但其实暗藏着非常巧妙的规律哦！让本喵带你一步步揭开它的神秘面纱吧！

### 第一步：分析特殊情况
首先，我们来思考一下什么情况下任务会失败，或者已经完成了呢？

1.  **已经完成的情况**：如果一开始数组里所有的数就已经相同了，那我们一次操作都不用做，答案就是 `0` 啦！
2.  **不可能完成的情况**：操作是 `a_i := max(0, a_i - mex)`，这意味着数组里的数只会减少或者不变，绝对不会增加。如果我们的目标是让所有数都变成 `k`，那么这个 `k` 必须小于等于数组里最小的数。
    再想一下，如果数组里所有的数都是正数（即没有 `0`），那么 `mex` 是多少呢？当然是 `0` 啦！这时候操作 `a_i := max(0, a_i - 0)` 就等于 `a_i`，数组根本不会变！如果此时数组里的数还不全相同，那它们就永远也变不成相同的了。
    所以，我们得出一个关键结论：**如果初始数组中没有 `0`，并且元素不全相同，则永远无法完成任务**。输出 `-1`。

### 第二步：确定最终目标
既然必须要有 `0` 存在，而数又不能增加，那么所有数最终唯一可能变成的相同值就是 `0`！我们的目标就是把数组里所有的数都变成 `0`。

### 第三步：发现规律，简化问题
既然要处理数组中的数值关系，一个非常自然的想法就是——**排序**！我们把数组 `a` 从小到大排序，得到 `a'_1, a'_2, ..., a'_n`。

根据第一步的结论，我们必须有 `a'_1 = 0`。现在问题变成了，需要多少次操作才能把 `a'_2, ..., a'_n` 都变成 `0` 呢？

让我们来模拟一下，看看操作是如何影响数组的。
假设数组是 `{0, 2, 5}`。
-   **第 1 步**: 排序后是 `{0, 2, 5}`。`mex` 是 `1`。操作后数组变为 `{max(0,0-1), max(0,2-1), max(0,5-1)}` -> `{0, 1, 4}`。
-   **第 2 步**: 数组是 `{0, 1, 4}`。`mex` 是 `2`。操作后数组变为 `{max(0,0-2), max(0,1-2), max(0,4-2)}` -> `{0, 0, 2}`。
-   **第 3 步**: 数组是 `{0, 0, 2}`。`mex` 是 `1`。操作后数组变为 `{0, 0, 1}`。
-   **第 4 步**: 数组是 `{0, 0, 1}`。`mex` 是 `2`。操作后数组变为 `{0, 0, 0}`。成功！总共用了 4 步。

这个过程还是有点复杂。我们换个角度！能不能找到一个“势能函数”，每次操作都会让它的值固定地减少 1 呢？这样我们只要求出初始的“势能”，就是答案了！

让我们观察排序后的数组 `a'`。`{0, 2, 5}`。
相邻数字的“间隙”里，藏了多少没出现的数？
-   `0` 和 `2` 之间，缺了 `1` (1个)。
-   `2` 和 `5` 之间，缺了 `3, 4` (2个)。

总共缺失的数字个数是 `1 + 2 = 3`。而我们计算出的步数是 `4`。这之间有什么关系呢？`4 = 3 + 1`！

我们再试试 `{0, 1, 3}`。
-   `0` 和 `1` 之间，不缺数。
-   `1` 和 `3` 之间，缺了 `2` (1个)。
-   总缺失数是 `1`。我们猜答案是 `1 + 1 = 2`。
-   手动模拟：`{0, 1, 3}` -> `mex=2` -> `{0, 0, 1}` -> `mex=2` -> `{0, 0, 0}`。果然是 2 步！

**最终的解法浮出水面啦！**

1.  如果数组已全部相同，答案是 `0`。
2.  对数组排序。
3.  如果最小的数不是 `0`，答案是 `-1`。
4.  否则，答案是 `1` 加上所有相邻元素 `a'_{i-1}` 和 `a'_i` 之间“空隙”的大小之和。空隙大小就是 `a'_i - a'_{i-1} - 1`（如果 `a'_i <= a'_{i-1} + 1`，则空隙为0）。

为什么是 `+1` 呢？因为即使数组是完美的 `{0, 1, 2, ..., n-1}`，它没有任何空隙，也仍然需要一次 `mex=n` 的操作才能全部归零。这个 `1` 就是这最后一次“收尾”操作的计数。

所以，总操作次数 = (填满所有空隙需要的操作数) + (最后收尾的操作数) = `sum(gaps) + 1`。

## 代码实现喵~
下面就是把我们的思路变成代码啦，本喵加了详细的注释哦！

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
// 题目中用不到的变量可以无视它们哦，可能是模板里带的喵~
ll n,a[100005],ans=1,tt=1,dp[100005],sum[100005],zhi[100005];

int main(){
    // 读入数组大小 n
    cin>>n;
    // 读入数组元素
    for(int i=1;i<=n;i++){
        cin>>a[i];
        // 顺便检查一下是不是所有元素都相同
        if(i>1 && a[i]!=a[i-1]) {
            tt=0; // 只要有一对不相等，就标记为0
        }
    }

    // 如果所有元素一开始就相同，那么不需要操作，直接输出0
    if(tt){
        cout<<0;
        return 0;
    }

    // 对数组进行排序，方便我们观察数字的分布和间隙
    sort(a+1,a+1+n);

    // 如果排序后最小的元素不是0，说明无法通过操作引入0，也就无法完成任务
    if(a[1]!=0){
        cout<<-1;
        return 0;
    }

    // ans 初始化为1，这是为最后一次“收尾”操作预留的
    // 遍历排序后的数组，计算所有“间隙”的大小并累加到ans
    for(int i=2;i<=n;i++){
        // a[i] - a[i-1] - 1 就是它们之间的空隙大小
        // 如果 a[i] <= a[i-1] + 1，说明没有空隙，max(0, ...) 会取0
        ans += max(0LL, a[i]-a[i-1]-1);
    }

    // 输出最终计算出的最少操作次数
    cout<<ans;
    return 0;
}
```

## 复杂度分析的说
-   **时间复杂度**: O(N log N) 的说。
    整个算法的瓶颈在于排序 `sort(a+1, a+1+n)`，它的时间复杂度是 O(N log N)。后续的遍历和计算都是 O(N) 的，所以总的时间复杂度由排序决定。
-   **空间复杂度**: O(N) 的说。
    我们主要用了一个数组 `a` 来存储输入的 `n` 个数，所以空间复杂度是 O(N)。

## 知识点与总结
这道题的思路是不是很奇妙呀？喵~ 它告诉我们，有时候一个看似需要复杂模拟的问题，可以通过发现其内在规律，找到一个“势能函数”或者“代价函数”来大大简化！

-   **核心思想**: 问题转化。将一个动态的、多步骤的模拟问题，转化为一个静态的、基于初始状态的计数问题。
-   **关键洞察**:
    1.  **必要条件**: 必须存在 `0`，否则 `mex` 恒为 `0`，数组无法改变。
    2.  **最终状态**: 唯一可能达成的相同状态是所有元素都为 `0`。
    3.  **代价计算**: 操作次数与排序后数组的“空隙”总数有直接关系。每个操作可以看作是“填补”了一个最小的空隙。
-   **算法步骤**: 贪心 + 数学思维。通过排序来理清元素关系，然后根据数学规律直接计算结果。

希望本喵的讲解对你有帮助哦！继续加油，探索更多算法的奥秘吧，喵~ (ฅ'ω'ฅ)