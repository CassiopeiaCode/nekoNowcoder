# 周期函数 - 题解

### 比赛与标签
> **比赛**: 牛客练习赛119

> **标签**: 字符串哈希, 数学, 分类讨论

> **难度**: *2333

## 题目大意喵~

主人你好呀~ 这道题是说，我们在一个二维平面上有一些点 `(x_i, y_i)`，喵。这些点的 `x` 坐标是严格递增的。把相邻的点用直线连起来，就形成了一个分段线性函数 `f(x)`，就像一座座小山丘一样，喵~

然后呢，题目会给我们很多个询问，每个询问是一个区间 `[l, r]`。我们需要在这个区间上为函数 `f(x)` 找一个“最小周期” `t`。

一个正整数 `t` 能成为周期，需要满足三个很严格的条件哦：
1.  `t` 必须比区间长度 `r-l` 要小，也就是 `0 < t < r - l`。
2.  `r-l` 必须是 `t` 的整数倍。也就是说，整个区间 `[l, r]` 可以被恰好分割成 `k` 个长度为 `t` 的小段。
3.  函数值要满足周期性，也就是对于任何在 `[l, r-t]` 区间里的 `x`，都要有 `f(x) = f(x+t)`。这保证了函数图像在每个小段里都长得一模一样！

我们的任务就是找到满足这些条件的、最小的那个正整数 `t`。如果找不到这样的 `t`，就说明这个区间上没有周期性，要回答 `-1` 哟。

## 解题思路分析

喵哈~ 这道题看起来是在问函数的性质，但其实核心是比较两段函数“形状”是否相同。这让我想到了香喷喷的小鱼干... 啊不，是字符串匹配！喵~

#### 问题的转化：从函数到“形状串”

函数 `f(x)` 在 `[l, r]` 上以 `t` 为周期，意味着函数在 `[l, l+t]`、`[l+t, l+2t]`、...、`[r-t, r]`这些小段内的“形状”是完全一样的。

要比较两段函数的形状是否完全相同，我们只需要比较 `[l, r-t]` 和 `[l+t, r]` 这两段的形状是否一致。如果它们一致，并且 `r-l` 是 `t` 的倍数，那么整个 `[l, r]` 的周期性就得到了保证。

这个“形状”要怎么描述呢？函数 `f(x)` 是分段线性的，它的形状完全由每一段线段的走向决定。而每一段线段（从 `(x_i, y_i)` 到 `(x_{i+1}, y_{i+1})`）的走向又可以由它在 x 和 y 方向上的变化量 `(dx, dy)`，也就是 `(x_{i+1}-x_i, y_{i+1}-y_i)`，来唯一确定。

所以，我们可以把整个函数 `f(x)` 看作一个由 `n-1` 个 `(dx, dy)` 对组成的“形状串”。

#### 字符串哈希来帮忙！

比较两段“形状串”是否相等，最经典的工具就是**字符串哈希**啦，喵！我们可以给每一个完整的线段 `(dx_i, dy_i)` 一个独特的整数值作为它的哈希值。比如，我们可以把 `(dx_i, dy_i)` 映射成一个大整数。为了避免冲突，我们可以用两个不同的哈希函数（也就是双哈希），这样就稳妥多啦。

$$
\text{val}_i = (\text{dx}_i \cdot C_1 + \text{dy}_i \cdot C_2 + C_3) \pmod{M}
$$

有了每个基本线段的哈希值，我们就可以用多项式哈希计算出任意连续一段完整线段的哈希值了。

#### 处理不完整的“边界”线段

最棘手的地方来啦！询问的区间 `[l, r]` 的端点不一定会恰好落在我们给定的 `x_i` 上。它们可能把某条线段从中间“切开”，形成不完整的“边界”线段。

一个区间 `[a, b]` 的形状，可以分解成三个部分：
1.  **起始部分**：从 `a` 开始的一小段，到第一个 `x_i` 结束。
2.  **中间部分**：若干个完整的 `(dx, dy)` 线段。
3.  **结束部分**：从最后一个 `x_j` 开始，到 `b` 结束的一小段。

所以，一个区间的哈希值，也应该由这三部分的哈希值组合而成。
- **中间部分**的哈希值很好算，我们已经预处理了 `(dx, dy)` 序列的哈希值，O(1) 就能查到。
- **边界部分**呢？一段不完整的线段，它的形状由它的**长度**和它**所属的完整线段的类型(dx, dy)** 共同决定。所以我们可以把 `(length, dx, dy)` 这三元组映射成一个哈希值。

这样，我们就可以构建一个 `get_range_hash(a, b)` 函数，它能计算出任意区间 `[a, b]` 的形状哈希值。

#### 寻找最小周期 `t`

根据题意，周期 `t` 必须是区间长度 `d = r-l` 的一个因子。所以，我们只需要检查 `d` 的所有因子就可以啦！

我们的完整算法就是：
1.  **预处理**：
    *   计算出所有 `n-1` 个完整线段的 `(dx_i, dy_i)`。
    *   为每个 `(dx_i, dy_i)` 计算一个（或者两个，为了保险）哈希值 `V_i`。
    *   计算 `V_i` 序列的前缀哈希，方便快速查询任意连续子串的哈希。

2.  **处理询问 `[l, r]`**：
    *   计算区间长度 `d = r-l`。
    *   找出 `d` 的所有因子（除了 `d` 本身），并从小到大排序。
    *   遍历这些因子 `t`：
        a. **检查端点**：`f(l)` 是否等于 `f(l+t)`？这需要我们实现一个 `get_y(pos)` 函数，通过线性插值计算任意位置的函数值。为了避免浮点数精度问题，我们可以用分数形式 `A/B == C/D` -> `A*D == B*C` 来比较。
        b. **检查形状**：`get_range_hash(l, r-t)` 是否等于 `get_range_hash(l+t, r)`？
        *   如果两个条件都满足，那么 `t` 就是一个合法的周期。因为我们是从小到大遍历的，所以第一个找到的 `t` 就是最小周期！马上输出它，然后处理下一个询问。
    *   如果所有因子都试过了还是不行，那就说明不存在周期，输出 `-1`。

这个方法虽然要找 `r-l` 的因子，可能会花一些时间（最坏 $O(\sqrt{r-l})$），但它是最直接的解法，而且可以通过题目哦！

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码~ 加满了注释，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

using namespace std;

// 使用 __int128 来防止哈希计算中溢出
using int128 = __int128;

const int MAXN = 10005;

// 双哈希，双倍的安心喵~
const long long BASE1 = 31, MOD1 = 1e9 + 7;
const long long BASE2 = 37, MOD2 = 1e9 + 9;

int n;
long long q;
long long x[MAXN], y[MAXN];

// 预处理dx, dy以及它们的哈希值
long long dx[MAXN], dy[MAXN];
pair<long long, long long> segment_hashes[MAXN];

// 预处理哈希幂和前缀哈希
pair<long long, long long> p_pow[MAXN];
pair<long long, long long> prefix_hashes[MAXN];

// 找到pos所在的线段编号 (x_i <= pos < x_{i+1})
// C++ 的 lower_bound 找的是第一个不小于 value 的元素
// 所以 x_i <= pos, 我们要找第一个 > pos 的 x, 它的下标减1就是线段编号
int find_segment_idx(long long pos) {
    // upper_bound 找到第一个 > pos 的元素的迭代器
    int i = upper_bound(x + 1, x + n + 1, pos) - x;
    return i - 1;
}

// 计算在pos处的y值，以分数形式返回，避免精度问题
// 返回 pair {分子, 分母}
pair<long long, long long> get_y(long long pos) {
    if (pos == x[n]) {
        return {y[n], 1};
    }
    int idx = find_segment_idx(pos);
    if (x[idx] == pos) {
        return {y[idx], 1};
    }
    // y = y_i + (y_{i+1}-y_i) * (pos - x_i) / (x_{i+1}-x_i)
    //   = (y_i * dx_i + dy_i * (pos - x_i)) / dx_i
    long long numerator = y[idx] * dx[idx] + dy[idx] * (pos - x[idx]);
    long long denominator = dx[idx];
    long long common = std::gcd(abs(numerator), abs(denominator));
    return {numerator / common, denominator / common};
}

// 获取一段完整线段区间的哈希值
pair<long long, long long> get_full_segment_hash(int l_idx, int r_idx) {
    if (l_idx > r_idx) return {0, 0};
    long long h1 = (prefix_hashes[r_idx].first - (prefix_hashes[l_idx - 1].first * p_pow[r_idx - l_idx + 1].first) % MOD1 + MOD1) % MOD1;
    long long h2 = (prefix_hashes[r_idx].second - (prefix_hashes[l_idx - 1].second * p_pow[r_idx - l_idx + 1].second) % MOD2 + MOD2) % MOD2;
    return {h1, h2};
}

// 核心函数：计算任意区间 [l, r] 的形状哈希值
pair<long long, long long> get_range_hash(long long l, long long r) {
    if (l >= r) return {0, 0};

    int l_idx = find_segment_idx(l);
    int r_idx = find_segment_idx(r);

    if (l_idx == r_idx) { // 区间在同一条线段内
        long long len = r - l;
        // 哈希值与长度、线段类型相关
        long long h1 = (len % MOD1 * 13331 + segment_hashes[l_idx].first) % MOD1;
        long long h2 = (len % MOD2 * 13331 + segment_hashes[l_idx].second) % MOD2;
        return {h1, h2};
    }

    // 1. 起始不完整线段的哈希
    long long start_len = x[l_idx + 1] - l;
    long long start_h1 = (start_len % MOD1 * 13331 + segment_hashes[l_idx].first) % MOD1;
    long long start_h2 = (start_len % MOD2 * 13331 + segment_hashes[l_idx].second) % MOD2;

    pair<long long, long long> total_hash = {start_h1, start_h2};

    // 2. 中间完整线段的哈希
    if (l_idx + 1 <= r_idx - 1) {
        pair<long long, long long> mid_hash = get_full_segment_hash(l_idx + 1, r_idx - 1);
        int mid_len = r_idx - 1 - (l_idx + 1) + 1;
        total_hash.first = (total_hash.first * p_pow[mid_len].first + mid_hash.first) % MOD1;
        total_hash.second = (total_hash.second * p_pow[mid_len].second + mid_hash.second) % MOD2;
    }
    
    // 3. 结尾不完整线段的哈希
    long long end_len = r - x[r_idx];
    long long end_h1 = (end_len % MOD1 * 13331 + segment_hashes[r_idx].first) % MOD1;
    long long end_h2 = (end_len % MOD2 * 13331 + segment_hashes[r_idx].second) % MOD2;

    total_hash.first = (total_hash.first * p_pow[1].first + end_h1) % MOD1;
    total_hash.second = (total_hash.second * p_pow[1].second + end_h2) % MOD2;
    
    return total_hash;
}


void solve() {
    long long l, r;
    cin >> l >> r;

    long long len = r - l;
    if (len <= 1) {
        cout << -1 << "\n";
        return;
    }

    vector<long long> divisors;
    for (long long i = 1; i * i <= len; ++i) {
        if (len % i == 0) {
            if (i < len) divisors.push_back(i);
            if (i * i != len && len / i < len) {
                divisors.push_back(len / i);
            }
        }
    }
    sort(divisors.begin(), divisors.end());

    for (long long t : divisors) {
        if (t == 0) continue;

        // 1. 检查端点值
        pair<long long, long long> y1 = get_y(l);
        pair<long long, long long> y2 = get_y(l + t);
        if (y1.first * y2.second != y2.first * y1.second) {
            continue;
        }

        // 2. 检查形状哈希
        pair<long long, long long> h1 = get_range_hash(l, r - t);
        pair<long long, long long> h2 = get_range_hash(l + t, r);

        if (h1 == h2) {
            cout << t << "\n";
            return;
        }
    }

    cout << -1 << "\n";
}

int main() {
    // 喵，让输入输出快一点~
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> x[i];
    for (int i = 1; i <= n; ++i) cin >> y[i];

    // --- 预处理 ---
    p_pow[0] = {1, 1};
    for (int i = 1; i <= n; ++i) {
        p_pow[i].first = (p_pow[i - 1].first * BASE1) % MOD1;
        p_pow[i].second = (p_pow[i - 1].second * BASE2) % MOD2;
    }

    for (int i = 1; i < n; ++i) {
        dx[i] = x[i + 1] - x[i];
        dy[i] = y[i + 1] - y[i];
        // 将 (dx, dy) 映射到一个哈希值
        segment_hashes[i].first = ((dx[i] % MOD1 * 1000000007) % MOD1 + (dy[i] % MOD1 + MOD1) % MOD1) % MOD1;
        segment_hashes[i].second = ((dx[i] % MOD2 * 1000000007) % MOD2 + (dy[i] % MOD2 + MOD2) % MOD2) % MOD2;

        prefix_hashes[i].first = (prefix_hashes[i - 1].first * BASE1 + segment_hashes[i].first) % MOD1;
        prefix_hashes[i].second = (prefix_hashes[i - 1].second * BASE2 + segment_hashes[i].second) % MOD2;
    }

    while (q--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N + Q \cdot \sqrt{R_{max}} \cdot \log N)$
    - 预处理部分是 $O(N)$，用来计算所有线段的哈希值和前缀哈希。
    - 对于每次询问，我们需要找到区间长度 `d = r-l` 的所有因子。用试除法找因子的时间复杂度是 $O(\sqrt{d})$。
    - 对每一个因子 `t`，我们需要做一次 `get_y` 和 `get_range_hash` 的检查。`get_y` 和 `get_range_hash` 内部都使用了 `upper_bound` 在 `x` 数组上二分查找，所以是 $O(\log N)$。
    - 所以总的查询时间是 $O(Q \cdot (\text{d}(r-l)) \cdot \log N)$，其中 `d(r-l)` 是 `r-l` 的因子数量。在最坏情况下，因子数量可能比较多，但试除法的时间是 $O(\sqrt{r-l})$。$R_{max}$ 是 `r-l` 的最大可能值。

- **空间复杂度**: $O(N)$
    - 我们需要存储 `x`, `y` 坐标，以及预处理的 `dx`, `dy`, 哈希幂次和前缀哈希数组。这些都是 $O(N)$ 的空间。

## 知识点总结

这道题真有趣，像是在解一个谜题！它融合了好几个知识点呢：

1.  **问题抽象与转化**: 把一个几何/函数问题，通过分析其内在结构，转化成了一个我们更熟悉的序列比较问题（字符串匹配）。这是算法竞赛中非常重要的一步喵！
2.  **字符串哈希**: 这是解决这类序列（或广义的“串”）比较问题的利器。特别是当问题中包含“区间查询”和“相等判断”时，哈希往往能大力出奇迹。
3.  **处理边界情况**: 算法的鲁棒性体现在细节上。这道题的 `l` 和 `r` 不一定在 `x_i` 上，我们就必须小心地处理这些“不完整”的线段，并为它们设计合理的哈希方式，这是解题的关键。
4.  **数论基础**: 周期 `t` 必须是 `r-l` 的因子，这个性质大大缩小了 `t` 的搜索范围，让我们能从无限的可能性中找到有限的候选者。
5.  **避免精度误差**: 在计算 `get_y` 时，涉及到除法，可能会产生浮点数。为了进行精确比较，我们使用了分数的通分比较 (`a/b == c/d` -> `a*d == b*c`)，这是处理计算几何和一些数学问题时避免精度陷阱的好习惯。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！喵~ >w<