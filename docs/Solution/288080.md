# 周期函数 - 题解喵~

### 比赛与标签
> **比赛**: 小白月赛95
> **标签**: 字符串, 哈希, 二分, 数论
> **难度**: *2500

## Nya~ 题目讲了什么呀？
主人，你好喵~ 这道题其实是想让我们当一回小侦探，在一段给定的函数图像里，找出它隐藏的重复秘密哦！

简单来说，题目会给我们 `n` 个点 `(x_i, y_i)`，它们的 `x` 坐标是严格递增的。把这些点按顺序用直线连起来，就形成了一条弯弯曲曲的折线函数 `f(x)`，它的定义域是从第一个点的 `x_1` 到最后一个点的 `x_n` 呐。

然后会有 `q` 次询问，每次都给出一个区间 `[l, r]`。我们的任务就是，找出函数 `f(x)` 在这个区间上的 **最小正整数周期** `t`。

一个合格的周期 `t` 需要满足三个条件，缺一不可的说：
1.  **真正的周期性**: 对于区间 `[l, r-t]` 里的任何一个 `x`，都要满足 `f(x) = f(x+t)`。也就是说，函数在 `[l, r-t]` 这一段的形状，和把它向右平移 `t` 个单位后的形状 `[l+t, r]` 是完全一样的！
2.  **整除关系**: 区间的总长度 `r-l` 必须是周期 `t` 的整数倍。这保证了整个区间 `[l, r]` 是由若干个完整的周期性小块拼接而成的。
3.  **有效性**: 周期 `t` 必须是正整数，而且要比区间长度 `r-l` 小。

如果能找到满足这些条件的 `t`，我们就输出最小的那个。如果一个都找不到，就说明这段函数没有我们定义的这种周期，那就只好输出 `-1` 啦，喵~

## 寻找周期的魔法喵！
一看到“周期”、“重复”这样的字眼，本猫娘的DNA就动了！这不就是字符串匹配问题里的经典套路嘛？喵~ 我们可以把几何问题巧妙地转换成我们更熟悉的字符串问题来解决！

#### 核心思想：函数图像 -> 字符串
函数图像怎么变成字符串呢？你看，这个函数是由一段段的直线组成的。每一段直线（从 `(x_i, y_i)` 到 `(x_{i+1}, y_{i+1})`）的“形状”都可以被它在水平方向和垂直方向的变化量，也就是 `dx = x_{i+1} - x_i` 和 `dy = y_{i+1} - y_i`，唯一确定下来。

我们可以把每一段这样的 `(dx, dy)` 看作一个“字符”。这样一来，整个函数图像就变成了一个由 `n-1` 个“字符”组成的“字符串”啦！

#### 周期的性质与验证
题目给了一个超——级重要的提示：`r-l` 必须是周期 `t` 的倍数。这意味着什么呢？我们不需要傻乎乎地从 1 开始检查所有可能的 `t`，只需要检查 `r-l` 的所有因子（约数）就可以啦！这一下子就让我们的搜索范围大大减小了呢。

对于 `r-l` 的一个因子 `t`，我们要怎么验证它是不是一个合格的周期呢？
根据周期的定义，我们需要检查函数在 `[l, r-t]` 上的形状是否和 `[l+t, r]` 上完全一样。

这在我们的“字符串”模型里，就等价于检查代表 `[l, r-t]` 的那段子串，是否和代表 `[l+t, r]` 的子串完全相同。

#### 字符串哈希，闪亮登场！
要快速判断两个子串是否相等，字符串哈希就是不二之选！我们可以预先处理出整个“函数字符串”的[前缀哈希值](https://oi-wiki.org/string/hash/)。这样，我们就能在 O(1) 的时间内计算出任何一个连续子串的哈希值。

于是，验证周期的过程就变成了：计算 `hash(f on [l, r-t])` 和 `hash(f on [l+t, r])`，然后比较它俩是否相等。

#### 小小的挑战：处理边界
最棘手的问题来啦！查询的区间 `[l, r]` 的端点，不一定正好是咱们预先定义好的那些 `x_i` 点，它们可能落在某段直线的中间。这就导致了在区间的开头和结尾，我们可能需要处理“半截”的线段。

我们的哈希函数 `get_h(a, b)` 必须足够聪明，能够正确处理这种情况。它需要能计算出由“开头的一小段”、“中间的若干完整段”和“结尾的一小段”共同组成的函数图像的哈希值。代码里的 `get_h` 就是在做这个复杂的工作，它会为这些零碎的部分单独计算哈希值，然后巧妙地将它们与中间完整部分的哈希值拼接起来。

#### 算法流程总结
所以，我们的完整攻略就是这样哒：

1.  **预处理阶段 (O(N))**:
    *   把函数图像看作 `n-1` 个线段组成的序列。
    *   为每个线段 `(dx_i, dy_i)` 设计一个独特的哈希值 `v_i`。
    *   计算这个哈希值序列的前缀哈希 `ha` 数组和 `base` 的幂 `pw` 数组。

2.  **查询阶段 (对每个查询)**:
    *   计算区间长度 `L = r - l`。
    *   用 `O(sqrt(L))` 的时间找出 `L` 的所有因子（不包括 `L` 本身），并从小到大排序。
    *   遍历这些因子 `t`：
        *   作为快速剪枝，可以先检查端点值是否匹配，比如 `f(l)` 是否约等于 `f(l+t)`。代码中的 `y[pl] == gety(l + k)` 就是在做类似的检查。
        *   调用我们强大的 `get_h` 函数，计算 `hash(f on [l, r-t])` 和 `hash(f on [l+t, r])`。
        *   如果哈希值相等，说明我们找到了一个周期！因为我们是从小到大遍历的，所以第一个找到的就是最小周期。立刻输出 `t`，然后处理下一个查询。
    *   如果遍历完所有因子都找不到合适的 `t`，就说明没有周期，输出 `-1`。

这样，一个复杂的几何周期问题，就被我们用字符串哈希的魔法漂亮地解决啦！

## 代码实现 (看我施展魔法代码~✨)
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

// 使用一个大质数作为 base，和一个超大质数作为模数，防止哈希碰撞
const ll base = 1145141, mod = (1ll << 61) - 1;
const ll N = 1e4 + 10;

ll x[N], y[N];
ll inv[N]; // 存 dx 的模逆元，用于计算斜率
ll n, q;
ll ha[N], pw[N]; // ha 是前缀哈希数组，pw 是 base 的幂

// 快速幂，用于计算模逆元
ll qmi(ll a, ll b)
{
    ll res = 1;
    while (b )
    {
        if (b & 1) res = (__int128) res * a % mod;
        a = (__int128) a * a % mod;
        b >>= 1;
    }
    
    return res;
}

// 找出 x 的所有小于 x 的因子
vector<ll> getd(ll x)
{
    vector<ll> d;
    for (ll i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            d.push_back(i);
            if (i * i != x) d.push_back(x / i);
        }
    sort(d.begin(), d.end());
    d.pop_back(); // 周期 t 必须小于 r-l，所以去掉 r-l 本身
    
    return d;
}

// O(1) 计算一段连续【完整线段】的哈希值
ll get_hash(ll l, ll r)
{
    if (l > r) return 0;
    return (ha[r] - (__int128) ha[l - 1] * pw[r - l + 1] % mod + mod) % mod;
}

// 二分查找，找到第一个 x 坐标 >= v 的点的索引
ll find(ll v)
{
    return lower_bound(x + 1, x + n + 1, v) - x;
}

// 计算函数在任意整数点 pos 上的值 f(pos)
// 如果 pos 不是已知的 x_i，就需要线性插值
ll gety(ll pos)
{
    ll p = find(pos);
    if (x[p] == pos) return y[p]; // 正好是已知点
    // 否则，在 (p-1) 和 (p) 两个点之间进行线性插值
    ll dy = y[p] - y[p - 1];
    ll dx = x[p] - x[p - 1];
    ll len = pos - x[p - 1];
    // 如果 f(pos) 不是整数，返回一个特殊值表示无效
    if (dy * len % dx) return 101; 
    return dy * len / dx + y[p - 1];
}

// 计算函数在任意区间 [l, r] 上的哈希值，这是本题的核心和难点
// 它能处理端点不在已知点 x_i 上的情况
ll get_h(ll l, ll r)
{
    ll pl = find(l), pr = find(r);
    // 情况1: 区间端点都是已知点，直接用预处理的哈希
    if (x[pl] == l && x[pr] == r) return get_hash(pl, pr - 1);
    
    // 情况2: 区间左端点是已知点，但右端点在某个线段中间
    if (x[pl] == l)
    {
        // 先计算所有完整线段的哈希
        ll s = get_hash(pl, pr - 2);
        // 再计算右边那段“半截”线段的哈希值
        ll len = r - x[pr - 1];
        ll dy = (__int128) (y[pr] - y[pr - 1] + mod) * len % mod * inv[pr - 1] % mod;
        ll dx = len;
        ll v = (dx * 500 + dy + 205) % mod;
        // 把“半截”的哈希值拼接到后面
        s = ((__int128) s * base + v) % mod;
        return s;
    }
    // 情况3: 区间左端点在某个线段中间 (也可能右端点也在中间)
    // 这个实现假设，如果左端点是半截的，那么右端点要么是已知点，要么超出了左端点所在的完整线段区间
    // 它计算从 x[pl] 到 x[pr] 的哈希，然后把左边“半截”的哈希值拼接到前面
    ll s = get_hash(pl, pr - 1);
    ll len = x[pl] - l;
    ll dy = (__int128) (y[pl] - y[pl - 1] + mod) * len % mod * inv[pl - 1] % mod;
    ll dx = len;
    ll v = (dx * 500 + dy + 205) % mod;
    s = (s + (__int128) v * pw[pr - pl]) % mod;
    return s;
}

int main()
{
    cin >> n >> q;
    
    for (ll i = 1; i <= n; i ++ ) cin >> x[i];
    for (ll i = 1; i <= n; i ++ ) cin >> y[i];
    
    // --- 预处理 ---
    pw[0] = 1;
    for (ll i = 1; i <= n; i ++ ) pw[i] = (__int128) pw[i - 1] * base % mod;
    for (ll i = 1; i < n; i ++ )
    {
        ll dx = x[i + 1] -x[i];
        ll dy = y[i + 1] - y[i];
        inv[i] = qmi(dx, mod - 2); // 预计算 dx 的逆元
        // 将 (dx, dy) 映射成一个唯一的哈希值 v
        ll v = dx * 500 + dy + 205;
        // 计算前缀哈希
        ha[i] = ((__int128) ha[i - 1] * base + v) % mod;
    }
    
    // lambda 表达式，方便在循环内调用
    auto find = [&](ll v) -> ll
    {
        return lower_bound(x + 1, x + n, v) - x;
    };
    
    // --- 处理查询 ---
    while (q -- )
    {
        ll l, r;
        cin >> l >> r;
        if (r - l <= 1) // 周期必须是正整数，且小于区间长度
        {
            cout << -1 << '\n';
            continue;
        }
        
        vector<ll> d = getd(r - l); // 获取所有可能的周期
        ll ans = -1;
        ll pl = find(l);
        for (auto k : d) // 从小到大检查每个可能的周期 k
            // 核心判断：1. 端点值要对得上 2. 内部形状(哈希值)要一样
            if (gety(l) == gety(l + k) && get_h(l, r - k) == get_h(l + k, r))
            {
                ans = k;
                break; // 找到最小的就跑
            }
        cout << ans << '\n';
    }
    
    return 0;
}
```

## 复杂度分析 (时间魔法的消耗~)
- **时间复杂度**: O(N + Q * (sqrt(L) * log N)) 的说。
  - 预处理阶段计算前缀哈希是 O(N) 的。
  - 对于 Q 次查询，每次查询我们需要：
    - 找出 `L = r-l` 的所有因子，这需要 `O(sqrt(L))`。
    - 对于每个因子（潜在的周期 `t`），我们需要调用 `find` (`lower_bound`，O(log N)) 和哈希函数。哈希函数内部也主要是 `find` 操作耗时。
  - 所以总的时间复杂度就是预处理加上所有查询的耗时总和。

- **空间复杂度**: O(N) 的说。
  - 我们需要 O(N) 的空间来存储 `x`, `y` 坐标，以及预处理的 `ha` (前缀哈希) 和 `pw` (base的幂) 数组。

## 知识点与总结 (猫猫的提炼时间！)
这道题真的非常有趣，它教会了我们如何用算法的思维去连接不同的领域！

1.  **核心思想：抽象与建模**
    最关键的一步，就是将一个看似复杂的几何函数周期问题，抽象建模成了一个我们非常熟悉的字符串（序列）匹配问题。这种化繁为简、转换问题的能力是成为算法高手的必备技能哦！

2.  **字符串哈希**
    字符串哈希是解决这类匹配问题的神器！它能用一个数字来“指纹”一个子串，使得比较两个子串是否相等的时间复杂度从 O(长度) 降到了 O(1)。本题中使用的 `__int128` 配合大质数模数的双重保险，是防止哈希冲突的专业做法，值得学习。

3.  **数论知识**
    “周期 `t` 必须是区间长度 `r-l` 的因子”这一性质是解题的突破口，它将无限的可能周期缩减到了有限且数量不多的几个候选者，极大地优化了算法效率。

4.  **注意细节**
    处理好边界情况是写对代码的关键。本题中，查询区间的端点可能不是给定的整数点，如何为这些“半截”的线段设计并计算哈希值，是实现中的最大难点。

总之，主人要记住哦，很多看起来棘手的难题，只要我们能找到正确的角度去观察，把它转换成我们熟悉的模型，问题往往就迎刃而解了！要多多培养这种发现问题本质的洞察力喵~ ❤️