# Little09 - 题解

### 比赛与标签
> **比赛**: The 2nd Universal Cup. Stage 2: SPb

> **标签**: DP, 排序

> **难度**: *2200

## 题目大意喵~

主人你好呀，喵~ 这道题是说，我们被传送到了一个二维的魔法平面上，上面有 $N$ 个闪闪发光的据点，每个据点都有自己的坐标 $(x_i, y_i)$。同时，我们手上还有一张神秘的指令卷轴 `s`，长度为 $M$，上面写满了 'L', 'R', 'U', 'D' 这些移动指令，呐。

我们的任务是，看看能不能从这 $N$ 个据点里，找出一条由 $M+1$ 个**不同**的据点组成的路径 $p_1, p_2, \dots, p_{m+1}$。

这条路径必须严格遵守指令卷轴 `s` 的说！比如说，如果第 $i$ 个指令 $s_i$ 是 'U' (向上)，那么据点 $p_{i+1}$ 就必须在据点 $p_i$ 的正上方（也就是 $x$ 坐标相同，但 $y$ 坐标更大）。

具体的移动规则是这样的：
- **'L' (左)**: $x_{p_{i+1}} < x_{p_i}$ 并且 $y_{p_{i+1}} = y_{p_i}$。
- **'R' (右)**: $x_{p_{i+1}} > x_{p_i}$ 并且 $y_{p_{i+1}} = y_{p_i}$。
- **'U' (上)**: $y_{p_{i+1}} > y_{p_i}$ 并且 $x_{p_{i+1}} = x_{p_i}$。
- **'D' (下)**: $y_{p_{i+1}} < y_{p_i}$ 并且 $x_{p_{i+1}} = x_{p_i}$。

如果能找到这样一条神奇的路径，就开心地告诉人家 "YES"，如果找不到的话，就只好遗憾地回答 "NO" 啦，喵~

## 解题思路分析

这道题看起来是在问是否存在一条满足特定条件的路径，很自然地，本猫娘的胡须就指向了**动态规划 (Dynamic Programming)** 的方向，喵！

我们可以一步一步地来构建这条路径。让我们来定义一个状态：`dp[k][i]` 表示我们是否能找到一条满足前 $k-1$ 个指令，并且最终停在第 $i$ 个据点上的路径。

- **状态定义**: `dp[k][i]` = `true` 如果据点 `i` 可以作为路径的第 `k` 个点，否则为 `false`。
- **初始状态**: 路径的第一个点可以是任意据点，所以 `dp[1][i] = true` 对所有 $i \in [1, N]$ 都成立。
- **状态转移**: 对于第 $k$ 步（使用指令 $s_{k-1}$），要计算 `dp[k][j]`，我们需要检查是否存在一个上一步可达的据点 `i` (`dp[k-1][i] == true`)，并且从据点 `i` 到据点 `j` 的移动符合指令 $s_{k-1}$。

写成公式就是：
$$
dp[k][j] = \bigvee_{i=1}^{N} (dp[k-1][i] \land \text{can_move}(i, j, s_{k-1}))
$$
其中 `can_move(i, j, s_{k-1})` 判断从点 `i` 到点 `j` 是否是指令 $s_{k-1}$ 对应的合法移动。

但是，我们很快就会发现一个问题！$N$ 最大有 $10^5$，$M$ 最大有 $2000$。上面这个朴素的 DP 想法，每一步转移都需要 $O(N^2)$ 的时间（枚举 `i` 和 `j`），总时间复杂度高达 $O(M \cdot N^2)$。这太慢啦，我的猫爪都要算麻了！必须想个更聪明的办法，喵~

### 聪明的优化方法！

关键的突破口在于移动的规则！'L', 'R', 'U', 'D' 都是**轴对齐**的移动。这意味着，每次移动，要么 `x` 坐标不变，要么 `y` 坐标不变。这是非常重要的性质！

我们可以利用这个性质来优化状态转移的过程。我们不再需要对每个点 `j` 都遍历所有可能的上一步点 `i`。

我们以指令 **'U' (上)** 为例来想一想：
从据点 $A(x_A, y_A)$ 移动到据点 $B(x_B, y_B)$，需要满足 $x_A = x_B$ 且 $y_A < y_B$。

这意味着，所有 'U' 方向的移动都发生在同一条垂直线上。于是，我们可以把所有据点按 `x` 坐标进行分组。对于同一组（`x` 坐标相同）的点，我们再按 `y` 坐标从小到大排个序。

现在，我们按顺序处理这一组点 $P_1, P_2, \dots, P_k$（它们的 `y` 坐标递增）。
当我们要判断点 $P_j$ 在当前这步 (`U` 移动) 是否可达时，我们只需要知道在它**下方**（即 $P_1, \dots, P_{j-1}$）的这些点中，有没有**任何一个**是上一步可达的。

我们可以用一个简单的布尔变量 `can_reach_from_below` 来记录这个信息！
当我们从下往上扫描这一组点时：
1.  对于当前点 $P_j$，它是否可达，就取决于 `can_reach_from_below` 的值。
2.  处理完 $P_j$ 后，我们用 $P_j$ 在**上一步**是否可达来更新 `can_reach_from_below`。如果上一步能到 $P_j$，那么对于 $P_j$ 上方的点来说，就存在一个可达的下方的点了！

这样一来，对于每一个 `x` 相同的分组，我们只需要一次线性扫描就可以完成所有点的状态更新！

### 推广到所有方向

这个聪明的想法可以推广到所有四个方向：
- **'U' (上)**: 将点按 $(x, y)$ 升序排序。对于每个 `x` 相同的组，**从前往后**（`y` 从小到大）扫描。
- **'D' (下)**: 将点按 $(x, y)$ 升序排序。对于每个 `x` 相同的组，**从后往前**（`y` 从大到小）扫描。
- **'R' (右)**: 将点按 $(y, x)$ 升序排序。对于每个 `y` 相同的组，**从前往后**（`x` 从小到大）扫描。
- **'L' (左)**: 将点按 $(y, x)$ 升序排序。对于每个 `y` 相同的组，**从后往前**（`x` 从大到小）扫描。

### 算法流程总结

好啦，现在我们可以整理出最终的算法流程了，喵~

1.  **预处理**:
    -   创建一个据点结构体，包含 `x`, `y` 坐标和它的原始编号 `id`。
    -   创建两个据点数组的副本：`points_by_x` 和 `points_by_y`。
    -   `points_by_x` 按 `x` 为主关键字，`y` 为次关键字升序排序。
    -   `points_by_y` 按 `y` 为主关键字，`x` 为次关键字升序排序。

2.  **动态规划**:
    -   使用一个 `bool` 数组 `is_reachable`，大小为 $N+1$。`is_reachable[i]` 表示据点 `i` 在当前步骤是否可达。
    -   初始时，所有据点都可以是起点，所以 `is_reachable` 全部初始化为 `true`。
    -   我们进行 $M$ 轮迭代，对应 $M$ 个指令。
    -   在每一轮迭代中：
        -   创建一个临时的 `bool` 数组 `next_is_reachable`，全部初始化为 `false`。
        -   根据当前指令（'L', 'R', 'U', 'D'），选择对应的排序数组和扫描方向。
        -   进行线性扫描，维护一个 `flag`（如 `can_reach_from_below`），根据我们之前分析的逻辑更新 `next_is_reachable`。注意，当主关键字（如 `x` 坐标）变化时，要重置 `flag`。
        -   一轮扫描结束后，用 `next_is_reachable` 的内容更新 `is_reachable`。

3.  **最终判断**:
    -   完成 $M$ 轮迭代后，检查 `is_reachable` 数组。只要有**任何一个**元素为 `true`，就说明存在一条满足所有指令的路径。输出 "YES"。
    -   如果所有元素都为 `false`，说明无法完成所有移动，输出 "NO"。

这个算法的复杂度大大降低了，我们来看看~ 预处理排序是 $O(N \log N)$，之后 $M$ 轮 DP，每一轮都只是一次 $O(N)$ 的线性扫描。总时间复杂度就是 $O(N \log N + M \cdot N)$，可以愉快地通过啦！

## 代码实现

这是本猫娘根据上面的思路，精心重构的一份代码，希望能帮助到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// 定义据点结构体，方便存储和排序
struct Point {
    int x, y;
    int id; // 原始编号，用于在dp数组中定位
};

// 按照 x 为主、y 为辅的升序比较函数
bool compareByX(const Point& a, const Point& b) {
    if (a.x != b.x) {
        return a.x < b.x;
    }
    return a.y < b.y;
}

// 按照 y 为主、x 为辅的升序比较函数
bool compareByY(const Point& a, const Point& b) {
    if (a.y != b.y) {
        return a.y < b.y;
    }
    return a.x < b.x;
}

void solve() {
    int n, m;
    std::cin >> n >> m;
    std::string s;
    std::cin >> s;

    std::vector<Point> points_by_x(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> points_by_x[i].x >> points_by_x[i].y;
        points_by_x[i].id = i;
    }

    // 创建另一份副本，用于按y排序
    std::vector<Point> points_by_y = points_by_x;

    // 排序预处理
    std::sort(points_by_x.begin(), points_by_x.end(), compareByX);
    std::sort(points_by_y.begin(), points_by_y.end(), compareByY);

    // dp[i] 表示第 i 个点当前是否可达
    std::vector<bool> is_reachable(n, true);
    
    // 滚动数组，用于计算下一步的可达状态
    std::vector<bool> next_is_reachable(n);

    // M轮移动
    for (char command : s) {
        std::fill(next_is_reachable.begin(), next_is_reachable.end(), false);
        
        if (command == 'U') {
            bool has_reachable_below = false;
            for (int i = 0; i < n; ++i) {
                // 当 x 坐标变化时，进入新的垂直线，重置flag
                if (i > 0 && points_by_x[i].x != points_by_x[i-1].x) {
                    has_reachable_below = false;
                }
                if (has_reachable_below) {
                    next_is_reachable[points_by_x[i].id] = true;
                }
                // 用当前点在"上一步"的可达状态更新flag
                has_reachable_below |= is_reachable[points_by_x[i].id];
            }
        } else if (command == 'D') {
            bool has_reachable_above = false;
            for (int i = n - 1; i >= 0; --i) {
                // 当 x 坐标变化时，重置flag
                if (i < n - 1 && points_by_x[i].x != points_by_x[i+1].x) {
                    has_reachable_above = false;
                }
                if (has_reachable_above) {
                    next_is_reachable[points_by_x[i].id] = true;
                }
                has_reachable_above |= is_reachable[points_by_x[i].id];
            }
        } else if (command == 'R') {
            bool has_reachable_left = false;
            for (int i = 0; i < n; ++i) {
                // 当 y 坐标变化时，进入新的水平线，重置flag
                if (i > 0 && points_by_y[i].y != points_by_y[i-1].y) {
                    has_reachable_left = false;
                }
                if (has_reachable_left) {
                    next_is_reachable[points_by_y[i].id] = true;
                }
                has_reachable_left |= is_reachable[points_by_y[i].id];
            }
        } else { // command == 'L'
            bool has_reachable_right = false;
            for (int i = n - 1; i >= 0; --i) {
                // 当 y 坐标变化时，重置flag
                if (i < n - 1 && points_by_y[i].y != points_by_y[i+1].y) {
                    has_reachable_right = false;
                }
                if (has_reachable_right) {
                    next_is_reachable[points_by_y[i].id] = true;
                }
                has_reachable_right |= is_reachable[points_by_y[i].id];
            }
        }
        // 更新状态，准备下一轮
        is_reachable = next_is_reachable;
    }

    bool possible = false;
    for (int i = 0; i < n; ++i) {
        if (is_reachable[i]) {
            possible = true;
            break;
        }
    }

    if (possible) {
        std::cout << "YES\n";
    } else {
        std::cout << "NO\n";
    }
}

int main() {
    // 加速输入输出，让猫娘跑得更快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \log N + M \cdot N)$
    - 预处理阶段，我们需要对 $N$ 个点进行两次排序，每次排序的时间复杂度是 $O(N \log N)$。
    - DP 阶段，我们有 $M$ 个指令，对于每个指令，我们都需要对 $N$ 个点进行一次线性扫描，所以这部分的复杂度是 $O(M \cdot N)$。
    - 两者相加，总时间复杂度就是 $O(N \log N + M \cdot N)$ 的说。

- **空间复杂度**: $O(N)$
    - 我们需要存储两个据点列表 `points_by_x` 和 `points_by_y`，每个列表大小为 $N$，空间是 $O(N)$。
    - 两个 `bool` 类型的 DP 数组 `is_reachable` 和 `next_is_reachable`，大小也都是 $N$，空间也是 $O(N)$。
    - 所以总的额外空间复杂度是 $O(N)$，喵~

## 知识点总结

这道题真有趣，让我们学会了好多东西呢！

1.  **动态规划 (DP)**: 它是我们解决问题的核心思想，通过一步步构建子问题的解来得到最终答案。
2.  **DP 优化**: 识别问题特性（轴对齐移动）是优化的关键！从 $O(M \cdot N^2)$ 优化到 $O(M \cdot N)$ 是一次巨大的飞跃。
3.  **排序与预处理**: 对于处理坐标或几何关系的问题，排序是一个非常强大的工具。通过预先排序，我们可以将无序的点整理成有序的结构，从而可以在线性时间内处理相关的点。
4.  **滚动数组**: 我们用 `is_reachable` 和 `next_is_reachable` 两个数组交替更新，避免了创建一个 $M \times N$ 的巨大 DP 表，将空间复杂度从 $O(M \cdot N)$ 优化到了 $O(N)$。

希望这篇题解能帮到你，如果还有不明白的地方，随时可以再来问我哦！一起加油，喵~！