# 寻找满足方向约束的点序列 - 题解

### 比赛与标签
> **比赛**: 未提供
> **标签**: 动态规划, 排序
> **难度**: 未提供

## 题目大意喵~
主人，这次的任务是帮助 Little09 在一个点阵中进行一次奇妙的探险！

我们面前有一个二维平面，上面散落着 `n` 个标好号的星星点点，每个点都有自己的 `(x, y)` 坐标。同时，我们还拿到了一张长度为 `m` 的神秘指令卷轴 `s`，上面写满了 'U' (上), 'D' (下), 'L' (左), 'R' (右) 四种移动指令。

我们的目标是，要从这 `n` 个点中，挑选出一条长度为 `m+1` 的点序列 `p_1, p_2, ..., p_{m+1}`。这条路径必须严格遵守卷轴上的指令。也就是说，从第 `i` 个点 `p_i` 移动到第 `i+1` 个点 `p_{i+1}` 时，必须满足第 `i` 个指令 `s[i]` 所规定的方向关系。

举个栗子：
- 如果 `s[i]` 是 'L' (左)，那么 `p_{i+1}` 必须在 `p_i` 的正左方，即 `x` 坐标更小，`y` 坐标完全相同。
- 其他方向也是同理哦！

最后，我们只需要判断是否存在这样一条满足所有条件的路径。如果存在，就开心地喊出 "YES"，如果不存在，就只好遗憾地回答 "NO" 啦。

## 猫娘的解题思路！
这道题要求我们判断一个满足特定条件的路径是否存在，一听到“路径”、“是否存在”，本猫娘的DP雷达就响起来了，叮叮叮~！这很可能是一道动态规划问题哦。

#### 1. DP状态的构想
首先，我们来定义一下DP状态。一个很自然的想法是，`dp[i][j]` 表示我们是否可以走完前 `i` 步（即使用了指令 `s[1]` 到 `s[i]`），并且路径的终点恰好是第 `j` 个点。

- **状态定义**: `dp[i][j]` = `true` / `false`，表示是否存在一条长度为 `i+1` 的合法路径，其终点为点 `j`。
- **初始状态**: 当一步都还没走的时候（`i=0`），任何一个点都可以作为起点 `p_1`。所以 `dp[0][j] = true` 对所有的点 `j` 都成立。
- **状态转移**: `dp[i][j]` 为 `true` 的条件是：存在一个点 `k`，使得 `dp[i-1][k]` 为 `true`，并且从点 `k` 到点 `j` 的移动符合第 `i` 个指令 `s[i]`。

但是，`n` 和 `m` 最大有2000，`dp[m][n]` 这样的二维数组空间上就承受不住了。不过我们发现，计算第 `i` 步的状态，其实只依赖于第 `i-1` 步的结果。所以，我们可以用滚动数组的思想，只用两个一维数组 `dp[]` 和 `tp[]` (临时数组) 来进行状态转移，空间复杂度就从 O(M*N) 降到了 O(N) 啦！

#### 2. 优化的瓶颈——如何快速转移？
解决了空间问题，时间问题又来了。对于每一步 `i`，如果我们都用两层循环去遍历所有的点对 `(j, k)` 来进行转移，那么每一步的时间复杂度是 O(N²)，总时间复杂度就是 O(M*N²)，这对于 `N` 达到10万的级别来说是绝对会超时的。

必须找到更快的方法来找到所有可能的“上一步”的点！

#### 3. 排序大法好！
我们来观察一下移动的条件：'U'/'D' 要求 `x` 坐标相同，'L'/'R' 要求 `y` 坐标相同。这给了我们一个巨大的提示：**把坐标相同的点放在一起处理！**

怎么做呢？排序呀！

我们可以准备两份点的拷贝：
1.  一份按 `x` 坐标为主关键字，`y` 坐标为次关键字排序（记为数组 `f`）。
2.  另一份按 `y` 坐标为主关键字，`x` 坐标为次关键字排序（记为数组 `g`）。

现在，我们以指令 'U' 为例，看看排序如何施展魔法：
- **指令 'U'**: 从点 `k` 到点 `j`，要求 `x_k = x_j` 且 `y_k < y_j`。
- **利用排序**: 我们使用按 `x` 排序的数组 `f`。当我们遍历这个数组时，`x` 坐标相同的点会连续出现，形成一个个“块”。在一个块内，点的 `y` 坐标是递增的。
- **神奇的线性扫描**: 对于一个 `x` 相同的块，我们从头到尾（`y` 从小到大）扫描。对于当前点 `f[i]`，要判断它能否作为终点，我们需要知道在它“下方”（`y`更小）是否存在一个可行的上一步终点。
- 我们可以用一个标志位 `la` (last available) 来记录这件事。当我们处理一个块时：
    1.  `la` 初始化为 `false`。
    2.  处理块中的点 `f[i]`：`tp[f[i].i] = la`。也就是说，当前点能否到达，取决于这个块前面是否已经出现过可行的点。
    3.  更新 `la`：如果 `f[i]` 本身在上一步是可行的 (`dp[f[i].i] == true`)，那么它就可以作为后面点的“下方”点了，于是更新 `la = la | dp[f[i].i]` (这里简化为 `if(dp[f[i].i]) la=true`)。

通过这样一次线性扫描，我们就完成了所有 `x` 相同的点对之间的 'U' 指令转移，时间复杂度是 O(N)！

其他方向的逻辑也是类似的：
- **'D' (Down)**: 同样使用按 `x` 排序的数组 `f`，但这次我们从后往前扫描（`y` 从大到小），这样就能找到“上方”的点啦。
- **'R' (Right)**: 使用按 `y` 排序的数组 `g`，从前往后扫描（`x` 从小到大），寻找“左方”的点。
- **'L' (Left)**: 使用按 `y` 排序的数组 `g`，从后往前扫描（`x` 从大到小），寻找“右方”的点。

这样，每一步的转移都优化到了 O(N)，总时间复杂度就是 O(N log N + M*N)，完美通过！是不是很巧妙呀？喵~

## 代码实现
```cpp
// 附上猫娘的魔法注释！
#include <bits/stdc++.h>

int T, N, M;
// dp[i] 表示是否存在一条合法路径，其终点是点 i
// tp[i] 是一个临时数组，用于存储下一步的 dp 状态
int dp[2009], tp[2009]; 
char s[2009];

struct n_t {
    int a, b, i; // a是主关键字，b是次关键字，i是原始编号
};
n_t f[100009], g[100009];

// 比较函数1：按 x 坐标（记为a）为主，y 坐标（记为b）为辅，升序排序
// 用于处理 U 和 D 指令
bool cmp1(n_t x, n_t y) {
    if (x.a == y.a) return x.b < y.b;
    return x.a < y.a;
}

// 比较函数2：按 y 坐标（记为b）为主，x 坐标（记为a）为辅，升序排序
// 用于处理 L 和 R 指令
bool cmp2(n_t x, n_t y) {
    if (x.b == y.b) return x.a < y.a;
    return x.b < y.b;
}

signed main(void) {
    scanf("%d", &T);
    while (T--) {
        scanf("%d %d", &N, &M);
        scanf("%s", s + 1);
        for (int i = 1; i <= N; i++) {
            scanf("%d %d", &f[i].a, &f[i].b);
            f[i].i = g[i].i = i; // 记录原始编号
            g[i].a = f[i].a;
            g[i].b = f[i].b;
        }

        // 准备两种排序好的点集
        std::sort(f + 1, f + N + 1, cmp1); // f 按 x, y 排序
        std::sort(g + 1, g + N + 1, cmp2); // g 按 y, x 排序

        // 初始状态：任何点都可以是起点
        for (int i = 1; i <= N; i++) {
            dp[i] = 1;
        }

        // 遍历每一个指令
        for (int i = 1; i <= M; i++) {
            if (s[i] == 'U') {
                bool la = 0; // la: last available, 记录同x坐标中，下方是否有可达点
                for (int j = 1; j <= N; j++) {
                    if (j > 1 && f[j].a != f[j - 1].a) la = 0; // 新的x坐标块，重置la
                    tp[f[j].i] = la; // 当前点能否到达，取决于下方是否有可达点
                    if (dp[f[j].i]) la = 1; // 如果当前点在上一步可达，更新la
                }
                for (int j = 1; j <= N; j++) dp[j] = tp[j];
            } else if (s[i] == 'D') {
                bool la = 0; // 记录同x坐标中，上方是否有可达点
                for (int j = N; j >= 1; j--) { // 从后往前遍历
                    if (j < N && f[j].a != f[j + 1].a) la = 0; // 新的x坐标块，重置la
                    tp[f[j].i] = la; // 当前点能否到达，取决于上方是否有可达点
                    if (dp[f[j].i]) la = 1; // 更新la
                }
                for (int j = 1; j <= N; j++) dp[j] = tp[j];
            } else if (s[i] == 'R') {
                bool la = 0; // 记录同y坐标中，左方是否有可达点
                for (int j = 1; j <= N; j++) {
                    if (j > 1 && g[j].b != g[j - 1].b) la = 0; // 新的y坐标块
                    tp[g[j].i] = la;
                    if (dp[g[j].i]) la = 1;
                }
                for (int j = 1; j <= N; j++) dp[j] = tp[j];
            } else { // 'L'
                bool la = 0; // 记录同y坐标中，右方是否有可达点
                for (int j = N; j >= 1; j--) { // 从后往前遍历
                    if (j < N && g[j].b != g[j + 1].b) la = 0; // 新的y坐标块
                    tp[g[j].i] = la;
                    if (dp[g[j].i]) la = 1;
                }
                for (int j = 1; j <= N; j++) dp[j] = tp[j];
            }
        }

        // 检查最终是否有任何一个点是可达的
        int as = 0;
        for (int i = 1; i <= N; i++) if (dp[i]) as = 1; // 注意这里应该是dp[i]而不是tp[i]
        
        // 哎呀，代码里最后一步用的是tp，不过因为每轮循环后dp=tp，所以结果是一样的喵~
        // 但为了逻辑清晰，最后一步结束后，应该是检查最终的dp状态。
        // 不过AC代码是检查tp，我们就按它的逻辑来注释吧~
        as = 0;
        for (int i=1; i<=N; i++) if(tp[i]) as=1;

        if (as) printf("YES\n");
        else printf("NO\n");
    }
}
```

## 复杂度分析
- **时间复杂度**: O(N log N + M * N) 的说。
  - 前期的两次排序需要 O(N log N) 的时间。
  - 之后，我们遍历 `M` 个指令，每个指令都需要对 `N` 个点进行一次线性扫描，这部分是 O(M * N)。
  - 所以总时间就是两者相加啦！
- **空间复杂度**: O(N + M) 的说。
  - `f` 和 `g` 数组需要 O(N) 的空间来存储点的信息。
  - `dp` 和 `tp` 数组需要 O(N) 的空间。
  - 指令字符串 `s` 需要 O(M) 的空间。
  - 合起来就是 O(N + M) 啦。

## 知识点与总结
这次的冒险是不是很有趣呀？我们来总结一下学到了什么吧，喵~

1.  **核心算法**: **动态规划** 是解决这类路径存在性问题的有力武器。关键在于定义好状态和状态转移方程。
2.  **优化技巧**: **排序** 在这里起到了决定性的作用！它能将具有相同属性（`x`或`y`坐标相同）的元素聚集在一起，从而把 O(N²) 的暴力检查优化为 O(N) 的线性扫描。这是一个非常重要的思想，当问题中存在“需要满足某个坐标相同”的约束时，一定要想想排序能不能派上用场！
3.  **DP空间优化**: **滚动数组** 是一个经典的DP空间优化技巧。当 `dp[i]` 只依赖 `dp[i-1]` 时，就可以用两个数组来回滚动，大大降低空间需求。
4.  **编程细节**:
    -   处理坐标相等的“块”时，别忘了在块的边界重置状态（比如代码里的 `la` 标志）。
    -   根据指令的不同（比如'U'和'D'），扫描的方向（从前到后或从后到前）也不同，这决定了你是在寻找“之前”的点还是“之后”的点作为前驱。

希望这次的题解能帮到主人哦！以后遇到类似的题目，也要像猫娘一样，敏锐地发现优化的线索呐！加油！(ฅ'ω'ฅ)