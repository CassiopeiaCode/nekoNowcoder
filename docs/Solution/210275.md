# Apollo - 题解

### 比赛与标签
> **比赛**: 喵~ 这道题的比赛信息好像被淘气的妖精藏起来了，找不到呢！
> **标签**: 图论，拓扑排序，高精度
> **难度**: 喵~ 这道题的难度评分也神秘地消失了，不过感觉是需要耐心和细心的中等偏上题目哦！

## 题目大意喵~

呜喵~！各位工程师，欢迎来到 Apollo 的工厂 *Factorio*！这里有一个复杂的生产网络，我们需要找出它的瓶颈所在！

简单来说，工厂里有各种物品，它们之间的生产关系构成了一个有向无环图（DAG）。从最基础的**自然资源**（只有产出，没有消耗），到各种**中间产品**，最后汇集到**唯一的最终产品**（只被消耗，不用于生产其他东西）。

每个物品（产品或资源）都有一堆机器（装配机或矿机）在生产它，机器的总数是固定的。我们可以调整每台机器的生产速率（0到1之间），来平衡整个生产线。

**我们的任务是**：找出所谓的“**生产瓶颈**”。这是一个物品集合，如果我们同时给这个集合里的每一种物品都增加一台机器，那么工厂的“生产效率”（最终产品的最大产出速率）就会提高。我们需要找到这样一个**最小**的集合。

**输入格式**：
1.  第一行是物品总数 $N$ 和生产配方总数 $M$。
2.  接下来 $N$ 行，每行是一个物品的名字和它的机器数量。
3.  再接下来 $M$ 行，是生产配方，形如 `c1 mat1 + c2 mat2 = c_p prod`。

**输出格式**：
1.  第一行是瓶颈集合的大小。
2.  第二行是瓶颈集合中所有物品的名字，按字典序排序，用空格隔开。

## 解题思路分析

这道题看起来有点复杂，但别怕，让本猫娘带你一步步拆解它，喵~

### 核心问题：什么是生产瓶颈？

题目的核心是理解“生产效率”和“生产瓶颈”。

**生产效率**：就是最终产品（Final Product）的最大产出速度。
**生产瓶颈**：是那些最最限制了最终产品产出速度的物品。

想象一下，为了生产1个最终产品，我们需要消耗多少个不同的中间产品和自然资源呢？这个“需求量”是解决问题的关键，呐！

### 第一步：量化需求

我们可以定义一个值 `demand[i]`，表示**为了生产 1 单位的最终产品，总共需要多少单位的物品 i**。

-   对于最终产品 `FP` 本身，它的需求量当然是1。所以 `demand[FP] = 1`。
-   对于其他物品，它们的需求量取决于它们被用来生产什么。如果物品 `i` 是生产物品 `j` 的原材料，配方是 `... + c_i * i + ... = c_j * j`，那么每生产1单位的 `j`，就需要 `c_i / c_j` 单位的 `i`。
-   所以，物品 `i 的总需求量，是所有需要它的产品对它的需求之和。用公式表达就是：
    $$
    \text{demand}[i] = \sum_{j \text{ 是 } i \text{ 的产物}} \text{demand}[j] \times \frac{\text{配方中 } i \text{ 的数量}}{\text{配方中 } j \text{ 的产量}}
    $$

这个计算过程是不是很眼熟？生产关系是一个 DAG，而 demand[i]` 的计算依赖于它产出的物品的 `demand` 值。这提示我们可以从最终产品开始，**反向拓扑排序**来计算所有物品的 `demand` 值！

### 第二步：找到真正的限制

我们算出了 `demand[i]`，也知道了每种物品 `i` 有 `num_machines[i]` 台机器。每台机器的最大生产速率是1，所以物品 `i` 的最大产出速率就是 `num_machines[i]`。

假设我们想让最终产品的产出速率达到 `E`。那么对于任何一种物品 `i`，我们对它的需求速率就是 `E * demand[i]`。这个需求速率肯定不能超过它的最大产出速率 `num_machines[i]，对吧？

$$
E \times \text{demand}[i] \le \text{num\_machines}[i]
$$

为了让 E 尽可能大，我们需要满足所有物品的这个不等式。把不等式变个形：

$$
E \le \frac{\text{num\_machines}[i]}{\text{demand}[i]}
$$

这个不等式对所有物品 i` 都必须成立。那么 `E` 的最大值，就是所有 `num_machines[i] / demand[i] 中的**最小值**。

$$
E_{\text{max}} = \min_{i} \left( \frac{\text{num\_machines}[i]}{\text{demand}[i]} \right)
$$

看呐！瓶颈就出现在那些让这个比值达到最小的物品 i` 上！这些物品就是我们苦苦寻找的“生产瓶leneck”！因为它们把 `E` “卡”在了最小的位置。

为了方便比较，我们通常会比较它们的倒数，也就是找到使 `demand[i] / num_machines[i]` **最大**的那些物品 `i`。

### 第三步：处理讨厌的小数和超大整数

配方中的系数都是1或2，但经过一连串的乘除，`demand[i]` 很容易变成一个分数。如果用 `double` 计算，精度误差会让我们得到错误的答案，喵~

所以，我们需要用高精度计算！有两种常见的策略：

1.  **分数类**：自己实现一个分数类，或者像 Python 那样直接用 `fractions.Fraction`。
2.  **整数化**：这是个很棒的技巧！注意到配方中，产物的数量（也就是除数）只可能是1或2。我们可以给所有 `demand` 值乘上一个足够大的2的幂（比如 $2^M$，其中 $M$ 是配方数量），把所有计算都转换成整数。这样，我们只需要一个高精度整数（`BigNum`）库就行啦！

我们选择第二种策略，因为它在 C++ 中更高效。我们将 `demand[FinalProduct]` 初始化为一个巨大的 $2$ 的幂，而不是 $1$。然后一路反向拓扑计算下去，遇到的除法都是除以1或2，可以确保结果始终是整数。

### 算法总结喵~

1.  **建图**：将物品名字映射到整数ID。根据配方建立一个**从原料指向产品**的依赖图 `dependency_graph`，并记录每个节点的出度。同时，为了方便计算，也建立一个**从产品指向原料**的配方图 `recipe_graph`。
2.  **拓扑排序**：对 `dependency_graph` 进行拓扑排序，得到一个处理节点的顺序 `topo_order`。
3.  **计算需求**：
    *   找到最终产品 `FP`（在 `dependency_graph` 中出度为0的节点）。
    *   初始化 `demand[FP]` 为一个很大的2的幂（例如 $2^M$），其他 `demand` 为0。
    *   **逆序**遍历 `topo_order`。对于每个节点 `u`（原料），遍历所有它能产出的产品 `v`，根据公式 `demand[u] += demand[v] * ...` 来累加 `demand[u]`。
4.  **寻找瓶颈**：
    *   遍历所有物品 `i`，计算瓶颈度量 `demand[i] / num_machines[i]`。
    *   为了避免高精度除法，我们通过交叉相乘来比较两个物品 `i` 和 `j` 的瓶颈度量：比较 `demand[i] * num_machines[j]` 和 `demand[j] * num_machines[i]` 的大小。
    *   找到所有使这个度量达到最大的物品。
5.  **输出**：将找到的瓶颈物品按字典序排序后输出。

好啦，思路清晰了，让我们看看代码怎么实现吧！

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <algorithm>

// 一个简单的高精度整数类 (BigNum)，只实现本题需要的功能喵~
// 使用 vector<int> 存储，每个 int 存 4 位数（基数为 10000）
struct BigNum {
    static const int BASE = 10000;
    std::vector<int> digits;

    BigNum(long long n = 0) {
        if (n == 0) {
            digits.push_back(0);
        }
        while (n > 0) {
            digits.push_back(n % BASE);
            n /= BASE;
        }
    }

    // 高精度 + 高精度
    BigNum operator+(const BigNum& other) const {
        BigNum result;
        result.digits.clear();
        int carry = 0;
        for (size_t i = 0; i < digits.size() || i < other.digits.size() || carry; ++i) {
            if (i < digits.size()) carry += digits[i];
            if (i < other.digits.size()) carry += other.digits[i];
            result.digits.push_back(carry % BASE);
            carry /= BASE;
        }
        return result;
    }

    // 高精度 * int
    BigNum operator*(int n) const {
        BigNum result;
        result.digits.clear();
        long long carry = 0;
        for (size_t i = 0; i < digits.size() || carry; ++i) {
            if (i < digits.size()) carry += (long long)digits[i] * n;
            result.digits.push_back(carry % BASE);
            carry /= BASE;
        }
        // 去除前导零
        while (result.digits.size() > 1 && result.digits.back() == 0) {
            result.digits.pop_back();
        }
        return result;
    }
    
    // 高精度 / int
    BigNum operator/(int n) const {
        BigNum result;
        result.digits.resize(digits.size());
        long long remainder = 0;
        for (int i = digits.size() - 1; i >= 0; --i) {
            remainder = remainder * BASE + digits[i];
            result.digits[i] = remainder / n;
            remainder %= n;
        }
        // 去除前导零
        while (result.digits.size() > 1 && result.digits.back() == 0) {
            result.digits.pop_back();
        }
        return result;
    }
    
    // 比较两个高精度数的大小
    // 返回 -1 (this < other), 0 (this == other), 1 (this > other)
    int compare(const BigNum& other) const {
        if (digits.size() != other.digits.size()) {
            return digits.size() < other.digits.size() ? -1 : 1;
        }
        for (int i = digits.size() - 1; i >= 0; --i) {
            if (digits[i] != other.digits[i]) {
                return digits[i] < other.digits[i] ? -1 : 1;
            }
        }
        return 0;
    }
};

// 用于存储配方信息的结构体
struct Recipe {
    int product_id;
    int product_yield;
    std::vector<std::pair<int, int>> materials; // {material_id, material_count}
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m;
    while (std::cin >> n >> m) {
        std::map<std::string, int> name_to_id;
        std::vector<std::string> id_to_name(n);
        std::vector<int> num_machines(n);
        
        // 读取物品和机器数量
        for (int i = 0; i < n; ++i) {
            std::string name;
            int count;
            std::cin >> name >> count;
            name_to_id[name] = i;
            id_to_name[i] = name;
            num_machines[i] = count;
        }

        std::vector<std::vector<int>> dep_graph(n); // 原料 -> 产品
        std::vector<int> out_degree(n, 0);
        std::vector<Recipe> recipes(m);

        // 读取配方并建图
        for (int i = 0; i < m; ++i) {
            std::vector<std::pair<int, int>> current_materials;
            int mat_count;
            std::string mat_name;
            char op;

            while (std::cin >> mat_count >> mat_name) {
                current_materials.push_back({name_to_id[mat_name], mat_count});
                // 查看下一个字符是不是 '+'
                std::cin.get(op); // 读取空格
                op = std::cin.peek(); // 偷看一下
                if (op != '+') break;
                std::cin.get(op); // 吃掉 '+'
            }
            // 读取等号和产物
            std::cin >> op; // 吃掉 '='
            int prod_yield;
            std::string prod_name;
            std::cin >> prod_yield >> prod_name;
            
            int prod_id = name_to_id[prod_name];
            recipes[i] = {prod_id, prod_yield, current_materials};
            
            for (const auto& mat_pair : current_materials) {
                dep_graph[mat_pair.first].push_back(prod_id);
                out_degree[mat_pair.first]++;
            }
        }

        // 1. 拓扑排序
        std::vector<int> topo_order;
        std::queue<int> q;
        std::vector<int> in_degree(n, 0);
        std::vector<std::vector<int>> rev_dep_graph(n); // 产品 -> 原料
        for(int u = 0; u < n; ++u) {
            for(int v : dep_graph[u]) {
                in_degree[v]++;
                rev_dep_graph[v].push_back(u);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (in_degree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            topo_order.push_back(u);
            for (int v : dep_graph[u]) {
                in_degree[v]--;
                if (in_degree[v] == 0) {
                    q.push(v);
                }
            }
        }

        // 2. 反向拓扑计算 demand
        std::vector<BigNum> demand(n);
        int final_product_id = -1;
        for (int i = 0; i < n; ++i) {
            if (out_degree[i] == 0) {
                final_product_id = i;
                break;
            }
        }

        // 初始化 demand[FP] 为 2^m，避免小数
        demand[final_product_id] = BigNum(1);
        for(int i = 0; i < m; ++i) {
            demand[final_product_id] = demand[final_product_id] * 2;
        }

        // 创建一个方便查找的配方表
        std::map<int, Recipe> product_recipe_map;
        for(const auto& r : recipes) {
            product_recipe_map[r.product_id] = r;
        }
        
        // 从后往前遍历拓扑序
        for (int i = topo_order.size() - 1; i >= 0; --i) {
            int u = topo_order[i]; // u 是产品
            if(product_recipe_map.count(u)) {
                const auto& r = product_recipe_map[u];
                for (const auto& mat_pair : r.materials) {
                    int v = mat_pair.first; // v 是原料
                    int mat_count = mat_pair.second;
                    BigNum term = demand[u] * mat_count;
                    if (r.product_yield == 2) {
                        term = term / 2;
                    }
                    demand[v] = demand[v] + term;
                }
            }
        }
        
        // 3. 寻找瓶颈
        std::vector<std::string> bottleneck_items;
        int bottleneck_idx = -1;

        for (int i = 0; i < n; ++i) {
            if (bottleneck_idx == -1) {
                bottleneck_idx = i;
                continue;
            }
            // 比较 demand[i]/machines[i] 和 demand[bottleneck_idx]/machines[bottleneck_idx]
            // 通过交叉相乘: demand[i] * machines[bottleneck_idx] vs demand[bottleneck_idx] * machines[i]
            BigNum lhs = demand[i] * num_machines[bottleneck_idx];
            BigNum rhs = demand[bottleneck_idx] * num_machines[i];
            if (lhs.compare(rhs) > 0) { // i 的瓶颈度更高
                bottleneck_idx = i;
            }
        }
        
        // 找到所有与最大瓶颈度相同的物品
        for (int i = 0; i < n; ++i) {
            BigNum lhs = demand[i] * num_machines[bottleneck_idx];
            BigNum rhs = demand[bottleneck_idx] * num_machines[i];
            if (lhs.compare(rhs) == 0) {
                bottleneck_items.push_back(id_to_name[i]);
            }
        }

        std::sort(bottleneck_items.begin(), bottleneck_items.end());

        // 4. 输出结果
        std::cout << bottleneck_items.size() << "\n";
        for (size_t i = 0; i < bottleneck_items.size(); ++i) {
            std::cout << bottleneck_items[i] << (i == bottleneck_items.size() - 1 ? "" : " ");
        }
        std::cout << "\n";
    }
    return 0;
}
``

## 复杂度分析

-   **时间复杂度**: $O((N+K) \cdot L)$，其中 $N$ 是物品数量， $K$ 是所有配方中原料项的总数。$L$ 是高精度运算的复杂度，它取决于数字的长度。在最坏情况下，数字的长度可能与 $N$ 或 $M$ 相关，所以 $L$ 可以看作是 $O(N)$ 或 $O(M)$。建图和拓扑排序是 $O(N+K)$。计算 demand 值需要遍历所有节点和边，每次操作是高精度运算，所以是 $O((N+K) \cdot L)$。最后寻找瓶颈需要 $O(N \cdot L)$。所以总体由计算 demand 的部分主导。
-   **空间复杂度**: $O(N \cdot L + K)$。图的存储需要 $O(N+K)$。demand 数组存储 $N$ 个高精度数，每个数可能长达 $L$，所以是 $O(N \cdot L)$。

## 知识点总结

这道题是一道非常好的图论应用题，融合了多种算法思想，喵~

1.  **问题建模**: 将复杂的生产关系抽象成图论中的有向无环图（DAG）是解题的第一步，也是最重要的一步！
2.  **拓扑排序**: DAG 的问题经常和拓扑排序联系在一起。这里我们用它来确定一个无后效性的计算顺序。
3.  **图上动态规划/反向传播**: 我们从最终产品出发，反向地在图上传播和计算“需求量”，这是一种在图上进行动态规划或信息传播的典型模式。
4.  **高精度计算**: 当题目中的数值计算可能超出标准数据类型（如 long long`）的范围，或者涉及精确的分数运算时，就要果断使用高精度算法（`BigNum`）。整数化的技巧（乘以公分母）是处理分数运算时一个非常实用的小窍门！

希望这篇题解能帮助你理解这道有趣的题目！只要一步步分析，再复杂的问题也能被我们解决的，加油喵~！