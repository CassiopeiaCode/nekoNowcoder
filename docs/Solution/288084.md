# 在 n x n 棋盘上放置 n 个不互相攻击的车的期望方案数 (困难版) - 题解

### 比赛与标签
> **比赛**: Stoi2031 Round 0
> **标签**: 数学, 组合计数, 容斥原理, 生成函数, NTT
> **难度**: *2500

## 题目大意喵~

主人你好呀~！这道题是说，在一个 $n \times n$ 的棋盘上，我们要放置 $n$ 个国际象棋的“车”，让它们不能互相攻击（也就是每行每列都只有一个车）。

但是呢，这个棋盘有点特殊喵！它不是一个空棋盘。首先，我们会生成一个长度为 $m = \lfloor n/2 \rfloor$ 的、包含了 $\{1, 2, \ldots, m\}$ 中所有数字的随机排列 $p$。然后，根据这个排列 $p$，棋盘上的一些位置会被标记为“禁止放置”。

具体的禁止规则是：对于 $i$ 从 $1$ 到 $m$，我们取出排列中的第 $i$ 个元素 $p_i$，然后把棋盘上的三个位置 $(2 \cdot p_i - 1, 2 \cdot i - 1)$、$(2 \cdot p_i, 2 \cdot i - 1)$ 和 $(2 \cdot p_i, 2 \cdot i)$ 标记为禁止放置。

因为排列 $p$ 是随机的，所以我们得到的棋盘也是随机的。题目要求我们计算，在所有可能的随机棋盘上，放置 $n$ 个不互相攻击的车的**期望**方案数是多少。

最后的结果要对 $998244353$ 取模哦！困难版和简单版的区别只在于 $n$ 的范围更大，需要更高效的算法才能通过，喵~

## 解题思路分析

这道题要求期望，通常有两种思路，一种是直接从期望的定义出发，另一种是利用期望的线性性质，喵~

对于一个特定的由排列 $p$ 生成的棋盘，我们想要求出放置 $n$ 个车的方案数。这是一个带有禁区的排列计数问题，典型的容斥原理应用场景！

### 容斥原理与期望的结合

我们先来考虑一个固定的棋盘（即固定的排列 $p$），它上面的禁区集合为 $B_p$。根据容斥原理，放置 $n$ 个车且不碰到任何禁区的方案数是：
$$
\sum_{k=0}^{n^2} (-1)^k \sum_{\substack{C \subseteq B_p \\ |C|=k \\ \text{C中棋子不互相攻击}}} (n-k)!
$$
这里 $C$ 是 $B_p$ 的一个大小为 $k$ 的子集，并且 $C$ 中的所有位置都满足“不互相攻击”（即不同行也不同列）。$N_k(p) = \sum_{\substack{C \subseteq B_p, |C|=k \\ \text{C中棋子不互相攻击}}} 1$ 表示在禁区 $B_p$ 上放置 $k$ 个不互相攻击的车的方案数。那么，对于固定的 $p$，总方案数就是 $\sum_{k=0}^{n} (-1)^k N_k(p) (n-k)!$。

我们要求的是这个值的期望。利用期望的线性性质，我们可以把期望符号放到求和里面：
$$
E[\text{方案数}] = E\left[\sum_{k=0}^{n} (-1)^k N_k(p) (n-k)!\right] = \sum_{k=0}^{n} (-1)^k (n-k)! E[N_k(p)]
$$
现在，问题就转化为了求 $E[N_k(p)]$，也就是在随机生成的禁区上放置 $k$ 个不互相攻击的车的期望方案数。

### 关键洞察：棋盘的结构与解耦

$E[N_k(p)]$ 是什么呢？它是在所有 $m!$ 种可能的排列 $p$ 上，$N_k(p)$ 的平均值。
让我们来仔细看看禁区的生成规则。整个 $n \times n$ 的棋盘可以看作是一个 $m \times m$ 的“元棋盘”，每个“元格”是一个 $2 \times 2$ 的小棋盘。
*   **元行 $k$** 对应棋盘的第 $2k-1$ 行和第 $2k$ 行。
*   **元列 $j$** 对应棋盘的第 $2j-1$ 列和第 $2j$ 列。
*   **元格 $(k, j)$** 对应棋盘上这四行两列交叉的 $2 \times 2$ 区域。

禁区的规则是：对于每个元列 $j$（$j=1, \dots, m$），随机选择一个**唯一**的元行 $p_j$（$j \mapsto p_j$ 是一个排列），然后在元格 $(p_j, j)$ 内部设置一个 L 形的禁区。

现在我们考虑 $N_k(p)$，即在 $B_p = \bigcup_{j=1}^m B_{p_j, j}$ 上放置 $k$ 个不互相攻击的车的方案数。
这里有一个非常非常重要的性质，喵！如果我们要放置的一组车 $C$ 都在禁区里，那么它们必须满足一个很强的结构限制：
> **如果两个车在同一个元列（比如列 $2j-1$ 和 $2j$），那么它们也必须在同一个元行！**

为什么呢？假设车 $c_1$ 在元列 $j$、元行 $k_1$ 的禁区里，车 $c_2$ 在元列 $j$、元行 $k_2$ 的禁区里。根据禁区生成规则，这意味着 $p_j = k_1$ 并且 $p_j = k_2$。因为 $p_j$ 的值是唯一的，所以必须有 $k_1=k_2$！

这个性质意味着，任何一个合法的禁区内车放置方案，都可以被完美地分解到各个独立的元格中。也就是说，对于一个固定的排列 $p$，禁区集合 $B_p$ 实际上是 $m$ 个互不相干（棋子不会互相攻击）的 L 形小棋盘的并集，这 $m$ 个小棋盘分别在元格 $(p_1, 1), (p_2, 2), \ldots, (p_m, m)$。

### 生成函数与车多项式

既然这些禁区小棋盘是互相独立的，计算在其上放置 $k$ 个车的方案数，就可以用到**车多项式 (Rook Polynomial)** 的思想！

车多项式 $R(B, x) = \sum_{k \ge 0} r_k(B) x^k$，其中 $r_k(B)$ 是在棋盘 $B$ 上放置 $k$ 个不互相攻击的车的方案数。
一个关键性质是：如果棋盘 $B$ 是两个不相交的子棋盘 $B_1$ 和 $B_2$ 的并集（即 $B_1$ 的行/列与 $B_2$ 的行/列完全不同），那么 $R(B, x) = R(B_1, x) \cdot R(B_2, x)$。

对于一个固定的 $p$，禁区棋盘 $B_p$ 正是 $m$ 个位于不同元行元列的 L 形小棋盘的并集，它们是互相独立的！
我们来计算一个 L 形小棋盘 $B_{k,j}$ 的车多项式。这个小棋盘有3个格子。
*   放0个车：1种方案。
*   放1个车：3种方案。
*   放2个车：只有 $(2k-1, 2j-1)$ 和 $(2k, 2j)$ 这对组合不攻击，1种方案。
*   放3个或更多：0种方案。

所以，一个 L 形小棋盘的车多项式是 $P(x) = 1 \cdot x^0 + 3 \cdot x^1 + 1 \cdot x^2 = 1 + 3x + x^2$。

因为 $B_p$ 是 $m$ 个这样的独立小棋盘的并集，所以 $B_p$ 的车多项式就是 $m$ 个 $P(x)$ 相乘：
$$
R(B_p, x) = (P(x))^m = (1+3x+x^2)^m
$$
最神奇的地方来了，喵！这个车多项式居然和具体的排列 $p$ 无关！所以对于任何 $p$，$N_k(p)$ 的值都是一样的，就是 $(1+3x+x^2)^m$ 这个多项式中 $x^k$ 的系数。
因此，$E[N_k(p)]$ 就等于 $[x^k](1+3x+x^2)^m$。

### 最终公式与算法

把这个结论带回我们最初的容斥公式：
$$
E[\text{方案数}] = \sum_{k=0}^{n} (-1)^k (n-k)! \cdot [x^k](1+3x+x^2)^m
$$
这里的 $n$ 应该怎么取呢？
*   如果 $n=2m$ (偶数)，那么公式就是它本身。
*   如果 $n=2m+1$ (奇数)，棋盘的第 $n$ 行和第 $n$ 列是永远不会有禁区的。任何一个合法的 $n$ 车放置方案，都必须在第 $n$ 行第 $n$ 列放一个车，然后剩下的 $n-1$ 个车放在左上角的 $(n-1) \times (n-1)$ 棋盘里。所以奇数 $n$ 的问题等价于 $n-1=2m$ 的情况。
在题目给的参考代码中，有一个注释 `// n is even，所以我们可以放心地认为这题只考虑偶数 $n$ 的情况，即 $n=2m$。

现在，我们的任务就是计算这个和式。核心是计算多项式 $R(x) = (1+3x+x^2)^m$ 的各项系数。直接展开太慢了，但我们可以用**快速幂**的思想。普通快速幂里的乘法是数字乘法，这里的乘法是**多项式乘法**！

而快速多项式乘法，就是 **NTT (数论变换)** 的用武之地啦！NTT 是 FFT 在模意义下的版本，可以在 $O(N \log N)$ 的时间内完成两个 $N$ 次多项式的乘法。

所以，整体的算法流程就是：
1.  预处理阶乘 fac[i]。
2.  定义基础多项式 $P(x) = \{1, 3, 1\}$。
3.  使用带 NTT 的多项式快速幂，计算出 $R(x) = P(x)^m$。
4.  遍历 $R(x)$ 的系数 $R_k = [x^k]R(x)$，根据最终公式 $\sum_{k=0}^{n} (-1)^k R_k \cdot (n-k)!$ 计算答案。

搞定，喵~！

## 代码实现

这是本猫娘根据上面的思路，重新为您写的一份代码，注释超详细的哦！

``cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 long long 防止计算过程中溢出
using ll = long long;

// 模数和原根，NTT的必备品喵~
const int MOD = 998244353;
const int PRIMITIVE_ROOT = 3;

// 快速幂函数，用来求逆元和NTT中的单位根
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 费马小定理求逆元
ll modInverse(ll n) {
    return power(n, MOD - 2);
}

// NTT (数论变换) 实现，是多项式乘法的核心！
// invert=true 时是逆变换 (INTT)
void ntt(std::vector<ll>& a, bool invert) {
    int n = a.size();

    // 位逆序置换，蝴蝶操作的前置准备
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) {
            std::swap(a[i], a[j]);
        }
    }

    // 蝴蝶操作，从长度为2的块开始，不断合并
    for (int len = 2; len <= n; len <<= 1) {
        ll wlen = power(PRIMITIVE_ROOT, (MOD - 1) / len);
        if (invert) {
            wlen = modInverse(wlen);
        }
        for (int i = 0; i < n; i += len) {
            ll w = 1;
            for (int j = 0; j < len / 2; j++) {
                ll u = a[i + j];
                ll v = (a[i + j + len / 2] * w) % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len / 2] = (u - v + MOD) % MOD;
                w = (w * wlen) % MOD;
            }
        }
    }

    // 如果是逆变换，结果要除以 n
    if (invert) {
        ll n_inv = modInverse(n);
        for (ll& x : a) {
            x = (x * n_inv) % MOD;
        }
    }
}

// 多项式卷积（乘法）
std::vector<ll> multiply(std::vector<ll> a, std::vector<ll> b) {
    int sz = 1;
    while (sz < a.size() + b.size()) {
        sz <<= 1;
    }
    a.resize(sz);
    b.resize(sz);

    ntt(a, false);
    ntt(b, false);

    std::vector<ll> c(sz);
    for (int i = 0; i < sz; i++) {
        c[i] = (a[i] * b[i]) % MOD;
    }

    ntt(c, true);
    return c;
}

// 多项式快速幂
std::vector<ll> poly_pow(std::vector<ll> base, int exp, int max_deg) {
    std::vector<ll> res = {1};
    while (exp > 0) {
        if (exp % 2 == 1) {
            res = multiply(res, base);
            if (res.size() > max_deg + 1) res.resize(max_deg + 1);
        }
        base = multiply(base, base);
        if (base.size() > max_deg + 1) base.resize(max_deg + 1);
        exp /= 2;
    }
    return res;
}

int main() {
    // 加速输入输出，让程序跑得更快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 根据题意，n是偶数，m = n/2
    int m = n / 2;

    // 预处理阶乘
    std::vector<ll> fact(n + 1);
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }

    // 我们的基础多项式 P(x) = 1 + 3x + x^2
    std::vector<ll> P = {1, 3, 1};

    // 计算 R(x) = P(x)^m，结果多项式的次数不会超过 n
    std::vector<ll> R = poly_pow(P, m, n);
    
    ll expected_ways = 0;
    // 根据公式 E[W] = sum_{k=0 to n} (-1)^k * R_k * (n-k)! 计算答案
    for (int k = 0; k < R.size() && k <= n; k++) {
        ll term = (R[k] * fact[n - k]) % MOD;
        if (k % 2 == 1) { // (-1)^k
            expected_ways = (expected_ways - term + MOD) % MOD;
        } else {
            expected_ways = (expected_ways + term) % MOD;
        }
    }

    std::cout << expected_ways << std::endl;

    return 0;
}
``

## 复杂度分析

- **时间复杂度**: $O(N \log N \log M)$
  主要的时间开销在于多项式快速幂 poly_pow`。它需要执行 $O(\log M)$ 次多项式乘法，其中 $M$ 是指数（在这里是 $m=n/2$）。每次多项式乘法使用NTT，对于最高次可能达到 $N$ 的多项式，其长度会扩展到第一个大于 $N$ 的2的幂，复杂度为 $O(N \log N)$。所以总时间复杂度是 $O(N \log N \log M)$，考虑到 $M$ 和 $N$ 是同阶的，可以记为 $O(N (\log N)^2)$。

- **空间复杂度**: $O(N)$
  我们需要存储阶乘，以及NTT和多项式乘法中用到的数组。这些数组的最大长度都与 $N$ 的下一个2的幂成正比，所以空间复杂度是 $O(N)$。

## 知识点总结

这真是一道融合了多种算法思想的超棒的题目呀，喵！解开它就像是完成了一次华丽的冒险！

1.  **期望的线性性质**: 这是解决期望问题的有力工具，它允许我们将一个复杂问题的期望分解为多个简单问题的期望之和。
2.  **容斥原理**: 组合计数中的大法宝！当我们要求“一个都不满足”的方案数时，常常可以用“总数 - 满足1个 + 满足2个 - ...”的方式来计算。
3.  **车多项式 (Rook Polynomial)**: 解决棋盘上放置棋子问题的经典数学工具。它最强大的性质之一就是对于不相交的棋盘，它们的车多项式是相乘的。
4.  **洞察问题结构**: 本题最关键的一步，就是发现禁区放置的内在结构，从而将复杂的依赖关系解耦，发现车多项式与具体排列无关，大大简化了问题。
5.  **NTT (数论变换)**: 解决多项式乘法的快速算法。当题目涉及到生成函数、或者需要快速计算卷积时，就要想到它啦！
6.  **多项式快速幂**: 将普通快速幂的思想应用到多项式上，用NTT加速其中的乘法步骤，是处理多项式高次幂的利器。

希望这篇题解能帮助到你，喵~ 如果有任何问题，随时可以再来问我哦！