# E. 期望 - 题解

### 比赛与标签
> **比赛**: 猫娘杯算法竞赛 (´｡• ᵕ •｡`) ♡
> **标签**: 数学, 组合数学, NTT, 多项式快速幂, 期望, 容斥原理
> **难度**: *2900

## 题目大意喵~
这道题是说，在一个 `n x n` 的棋盘上（`n` 是偶数哦！），我们要放置 `n` 个“车”，规则和象棋一样，要求它们不能互相攻击。也就是说，每行每列都只能有一个车。

但是呢，棋盘上有一些格子是“禁止通行”的，不能放车。这些禁止格子的生成方式有点特别：
1.  先取一个 `1` 到 `m = n/2` 的随机排列 `p`。
2.  对于 `i` 从 `1` 到 `m`，我们会在三个位置打上禁止标记：`(2*p_i - 1, 2*i - 1)`, `(2*p_i, 2*i - 1)` 和 `(2*p_i, 2*i)`。

我们的任务就是，计算在所有可能的随机排列 `p` 下，放置 `n` 个互不攻击的车的方案数的**期望值**是多少。答案要对 `998244353` 取模哦！

## 解题思路详解的说
看到“期望”两个字，有些同学可能就有点头大了，喵~ 但别慌！期望问题常常可以通过**期望的线性性**来简化。

#### 第一步：期望的魔法变身！
首先，我们来回忆一个关于在有禁区的棋盘上放车的经典组合问题。对于一个确定的棋盘（即禁止区域 `F` 已知），放置 `n` 个互不攻击的车的方案数可以通过**容斥原理**计算。其公式为：
`Ans = Σ_{k=0 to n} (-1)^k * c_k * (n-k)!`
这里的 `c_k` 指的是“在禁止区域 `F` 中，放置 `k` 个互不攻击的车的方案数”。

现在我们的问题是求期望方案数。根据期望的线性性，我们可以把期望算子 `E[...]` 放进求和符号里：
`E[Ans] = E[Σ_{k=0 to n} (-1)^k * c_k * (n-k)!]`
`E[Ans] = Σ_{k=0 to n} (-1)^k * E[c_k] * (n-k)!`

哇！问题瞬间转化成了求解 `E[c_k]`，也就是在随机生成的禁止区域中，放置 `k` 个互不攻击的车的方案数的期望值。只要搞定了 `E[c_k]`，整个问题就迎刃而解啦！

#### 第二步：对称性的奇迹呐！
`E[c_k]` 怎么求呢？`c_k` 的值是依赖于随机排列 `p` 的。我们把它写作 `c_k(p)`。
`E[c_k] = (1 / m!) * Σ_p c_k(p)`，其中 `m = n/2`。

这里的求和看起来还是很吓人。但是，我们来观察一下禁止区域的生成方式。排列 `p` 的作用，是把第 `i` 个“列对”（`2i-1, 2i`）与第 `p_i` 个“行对”（`2p_i-1, 2p_i`）关联起来，并在这之中形成一个 L 形的禁止区域。

改变排列 `p`，本质上只是在对棋盘的“行对”进行置换。比如，原来关联到第 `j` 个行对的禁止规则，现在可能被关联到第 `j'` 个行对。从整个棋盘来看，这相当于对棋盘的行进行了一次置换（当然是成对置换）。

而我们知道，**对棋盘的行或列进行任意的置换，并不会改变其“车多项式”（Rook Polynomial）**，也就是说，放置 `k` 个互不攻击的车的方案数是不会变的！

这意味着，对于任何一个排列 `p`，`c_k(p)` 的值都是相同的！
`c_k(p) = c_k(I)`，其中 `I` 是单位排列（即 `p_i = i`）。

所以，`E[c_k] = (1 / m!) * Σ_p c_k(I) = (1 / m!) * m! * c_k(I) = c_k(I)`。
太棒了！随机问题被我们变成了确定性问题！我们只需要计算当 `p` 为单位排列时的 `c_k` 值就好啦！

#### 第三步：生成函数大法好！
当 `p_i = i` 时，禁止区域 `F` 变成了：
`F_I = ∪_{i=1 to m} {(2i-1, 2i-1), (2i, 2i-1), (2i, 2i)}`

我们发现，这些禁止区域是按照 `2x2` 的小方块组织的，并且不同方块之间的禁止格是完全分离的。第 `i` 个小方块（由行 `2i-1, 2i` 和列 `2i-1, 2i` 组成）的禁止格是 `(2i-1, 2i-1)`, `(2i, 2i-1)`, `(2i, 2i)`。

对于这种互相分离的区域，它们的车多项式是各自车多项式的乘积。我们来分析一个 `2x2` 小方块内的车多项式 `P(x)`：
-   放 **0** 个车：方案数是 `1`。对应 `1 * x^0`。
-   放 **1** 个车：有 `3` 个位置可以选。方案数是 `3`。对应 `3 * x^1`。
-   放 **2** 个车：要互不攻击，只能放在 `(2i-1, 2i-1)` 和 `(2i, 2i)` 这两个位置。方案数是 `1`。对应 `1 * x^2`。
-   放 **3** 个车或更多：不可能。

所以，每个小方块的车多项式都是 `P(x) = 1 + 3x + x^2`。
我们一共有 `m = n/2` 个这样的小方块，所以整个禁止区域 `F_I` 的车多项式就是 `R(x) = (P(x))^m = (1 + 3x + x^2)^m`。
`c_k(I)` 正是 `R(x)` 中 `x^k` 项的系数！我们记作 `R_k`。

#### 第四步：卷起来，然后加起来！
现在我们有了所有材料：
-   `E[c_k] = R_k`，其中 `R_k` 是 `(1 + 3x + x^2)^m` 的 `k` 次项系数。
-   最终期望 `E[Ans] = Σ_{k=0 to n} (-1)^k * R_k * (n-k)!`。

剩下的任务就是计算 `R(x) = (1 + 3x + x^2)^m`。直接展开太慢了，这里就要请出我们的老朋友——**多项式快速幂**和**NTT (快速数论变换)** 啦！

算法流程总结一下：
1.  构建基础多项式 `P(x) = {1, 3, 1}`。
2.  使用多项式快速幂（底层用NTT实现卷积）计算出 `R(x) = P(x)^m`，其中 `m=n/2`。计算过程中，多项式的度数不会超过 `2m = n`，所以NTT的长度开到大于 `n` 的2的幂次即可。
3.  预处理阶乘 `fac[i]`。
4.  根据公式 `Σ_{k=0 to n} (-1)^k * R_k * (n-k)!` 计算最终答案。注意 `(-1)^k` 的符号交替。

就这样，一道复杂的期望组合题，就被我们一步步拆解，最后变成了一个多项式计算问题。是不是很有趣呢？喵~

## 代码实现喵~
```cpp
#include <bits/stdc++.h>
using namespace std;
static const int MOD = 998244353, PRIM_ROOT = 3;

// ———— 1. 快速幂，用来求逆元和次方~ ————
int modexp(int a, int e=MOD-2) {
    long long r=1, x=a%MOD;
    while(e){
        if(e&1) r = (r*x)%MOD;
        x = (x*x)%MOD;
        e >>= 1;
    }
    return int(r);
}

// ———— 2. NTT 核心实现，多项式乘法的加速器！ ————
void ntt(vector<int> & a, bool invert){
    int n = a.size();
    static vector<int> rev;
    static vector<int> roots{0,1};

    // 预计算蝴蝶变换的位置
    if((int)rev.size() != n){
        rev.assign(n,0);
        for(int i=0;i<n;i++)
            rev[i] = (rev[i>>1]>>1) | ((i&1)?(n>>1):0);
    }
    for(int i=0;i<n;i++)
        if(i<rev[i]) swap(a[i], a[rev[i]]);

    // 预计算单位根
    if((int)roots.size() < n){
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while((1<<k) < n){
            int z = modexp(PRIM_ROOT, (MOD-1) >> (k+1)); // 2^(k+1) 次单位根
            for(int i=1<<(k-1); i<(1<<k); i++){
                roots[2*i] = roots[i];
                roots[2*i+1] = int((long long)roots[i] * z % MOD);
            }
            k++;
        }
    }

    // NTT 蝶形运算
    for(int len=1; len<n; len<<=1){
        for(int i=0; i<n; i += 2*len){
            for(int j=0; j<len; j++){
                int u = a[i+j];
                int v = int((long long)a[i+j+len] * roots[len+j] % MOD);
                a[i+j] = u+v < MOD ? u+v : u+v-MOD;
                a[i+j+len] = u-v >= 0 ? u-v : u-v+MOD;
            }
        }
    }
    
    // 如果是逆变换 (INTT)
    if(invert){
        reverse(a.begin()+1, a.end());
        int inv_n = modexp(n);
        for(int & x: a) x = int((long long)x * inv_n % MOD);
    }
}

// 卷积操作的封装
vector<int> convolution(const vector<int> & a, const vector<int> & b){
    int n = 1, tot = a.size() + b.size() - 1;
    while(n < tot) n <<= 1;
    vector<int> A(a.begin(), a.end()), B(b.begin(), b.end());
    A.resize(n); B.resize(n);
    ntt(A,false); ntt(B,false);
    for(int i=0;i<n;i++)
        A[i] = int((long long)A[i] * B[i] % MOD);
    ntt(A,true);
    A.resize(tot);
    return A;
}

// ———— 3. 多项式快速幂，用二分法和卷积实现~ ————
vector<int> poly_pow(vector<int> base, long long e, int max_deg){
    vector<int> res = {1}; // 初始结果是 P(x)^0 = 1
    while(e){
        if(e&1){
            res = convolution(res, base);
            // 及时裁剪，防止多项式度数爆炸
            if((int)res.size() > max_deg+1)
                res.resize(max_deg+1);
        }
        e >>= 1;
        if(e){
            base = convolution(base, base);
            if((int)base.size() > max_deg+1)
                base.resize(max_deg+1);
        }
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    int m = n/2; // n是偶数，m是小方块的数量

    // — 预处理阶乘 —
    vector<int> fac(n+1,1);
    for(int i=1;i<=n;i++)
        fac[i] = int((long long)fac[i-1]*i % MOD);
    
    // (这里不需要逆阶乘 ifac, 所以原代码中的 ifac 部分可以省略)
    // vector<int> ifac(n+1,1);
    // ifac[n] = modexp(fac[n]);
    // for(int i=n;i>0;i--)
    //     ifac[i-1] = int((long long)ifac[i]*i % MOD);

    // — 构建基础多项式 P(x) = 1 + 3x + x^2 —
    vector<int> P = {1, 3, 1};

    // — 计算 R(x) = P(x)^m, 度数不超过 n —
    auto R = poly_pow(P, m, n);

    // — 根据容斥公式 Σ (-1)^k * R_k * (n-k)! 计算最终答案 —
    long long ans = 0;
    for(int k=0; k<(int)R.size(); k++){
        long long term = (long long)R[k] * fac[n-k] % MOD;
        if(k&1) term = MOD - term; // k是奇数时，符号为负
        ans = (ans + term) % MOD;
    }
    cout << ans << "\n";
    return 0;
}
```

## 复杂度分析
- **时间复杂度**: O(n log n log n) 的说
  主要开销在 `poly_pow` 函数。它执行了 `O(log m)` 次多项式乘法，也就是 `O(log n)` 次。每次乘法使用NTT，两个度数最高为 `n` 的多项式相乘，需要 `O(n log n)` 的时间。所以总时间复杂度是 `O(n log n log n)`。
- **空间复杂度**: O(n) 的说
  我们需要存储多项式的系数，以及NTT变换时需要的数组，长度都是 `n` 的线性级别。所以空间复杂度是 `O(n)`。

## 知识点与总结喵~
这道题是一次组合数学与多项式算法的美妙邂逅！(ฅ'ω'ฅ)

1.  **核心思想**:
    *   **期望的线性性**: 将复杂期望问题分解为求 `E[c_k]`。
    *   **对称性/不变量**: 发现 `c_k(p)` 的值与排列 `p` 无关，是解题的突破口，它将随机问题化为确定性问题。
    *   **容斥原理**: 使用车多项式的容斥公式来构建最终答案的框架。

2.  **核心算法**:
    *   **生成函数/车多项式**: 用多项式 `(1+3x+x^2)^m` 来巧妙地表示 `E[c_k]`，展现了组合计数与代数的美。
    *   **多项式快速幂**: 高效计算多项式的高次幂。
    *   **NTT**: 实现多项式快速幂中卷积操作的关键，是算法性能的保证。

通过这道题，我们再次体会到，面对看似棘手的组合和期望问题时，寻找问题中的对称性和不变量，并利用强大的代数工具（如生成函数）来建模，往往能让我们柳暗花明又一村！希望大家都能从中学到东西，继续在算法的世界里快乐探索，喵~！