# 小 L 和小 R 的协力赛跑 - 题解

### 比赛与标签
> **比赛**: 未提供

> **标签**: 未提供 (可归类为: 几何, 坐标变换, 数学)

> **难度**: 未提供

## 题目大意喵~

主人你好呀，这道题的背景故事好可爱，就像伊娜小姐一样呢，喵~

题目的核心意思是这样的：

在一个二维平面上，有两个小伙伴，小 L 和小 R，他们都从原点 $(0, 0)$ 出发。

-   小 L 有 $n$ 种移动方式，每种方式对应一个速度向量 $(x, y)$。他会选择其中一种，在一秒后移动到 $(x, y)$。
-   小 R 有 $m$ 种移动方式，同样，他也会选择其中一种，在一秒后移动到对应的位置。

他们俩想要合作，在一秒后，让两人之间的 **曼哈顿距离** 达到最大。我们需要计算出这个最大的曼哈顿距离是多少，呐。

**曼哈顿距离** 的定义也给出来啦：对于两个点 $(x_1, y_1)$ 和 $(x_2, y_2)$，它们之间的曼哈顿距离是 $|x_1 - x_2| + |y_1 - y_2|$。

简单来说，就是小 L 从他的 $n$ 个终点里选一个，小 R 从他的 $m$ 个终点里选一个，让这两个终点的曼哈顿距离最大。

## 解题思路分析

喵~ 这个问题看起来好像需要把小 L 的每个可能位置和小 R 的每个可能位置都配对一遍，然后计算距离，找到最大值。

假设小 L 选择了向量 $(x_L, y_L)$ 到达了点 $P_L(x_L, y_L)$，小 R 选择了向量 $(x_R, y_R)$ 到达了点 $P_R(x_R, y_R)$。
他们之间的曼哈顿距离就是 $D = |x_L - x_R| + |y_L - y_R|$。

如果真的这么做，我们需要计算 $n \times m$ 次距离，时间复杂度是 $O(n \cdot m)$。如果 $n$ 和 $m$ 很大，我们的程序就会像追着自己尾巴转圈圈的猫咪一样，跑得晕头转向也出不来结果，肯定会超时的说！

所以，我们需要更聪明的办法，喵~ 这时候就需要一点点数学魔法啦！

### 曼哈顿距离的奇妙变身

主人请看，这个带有绝对值的式子是不是很讨厌呀？ $|x_L - x_R| + |y_L - y_R|$。
我们可以对它进行一个神奇的坐标变换，让它变得简单起来！

这个变换叫做 **切比雪夫距离与曼哈顿距离的转换**，听起来很厉害吧！就像我从猫咪形态变成猫娘形态一样神奇哦！

我们定义新的坐标系 $(u, v)$，其中：
$u = x + y$
$v = x - y$

那么，点 $P_L(x_L, y_L)$ 在新坐标系下的坐标就是 $(u_L, v_L) = (x_L+y_L, x_L-y_L)$。
点 $P_R(x_R, y_R)$ 在新坐标系下的坐标就是 $(u_R, v_R) = (x_R+y_R, x_R-y_R)$。

现在我们来看看，原来的曼哈顿距离在新坐标系下会变成什么样呢？
有一个非常重要的恒等式：
$$
|A| + |B| = \max(A+B, A-B, -A+B, -A-B) = \max(|A+B|, |A-B|)
$$
我们将 $A = x_L - x_R$ 和 $B = y_L - y_R$ 代入：
$$
\begin{aligned}
|x_L - x_R| + |y_L - y_R| &= \max(|(x_L - x_R) + (y_L - y_R)|, |(x_L - x_R) - (y_L - y_R)|) \\
&= \max(|(x_L + y_L) - (x_R + y_R)|, |(x_L - y_L) - (x_R - y_R)|) \\
&= \max(|u_L - u_R|, |v_L - v_R|)
\end{aligned}
$$
哇！你看！原来两个点在原坐标系下的 **曼哈顿距离**，等于它们在新坐标系 $(u, v)$ 下的 **切比雪夫距离**！

**切比雪夫距离** 的定义就是两个点各个坐标差的绝对值的最大值，即 $\max(|u_1-u_2|, |v_1-v_2|)$。

### 优化求解

现在我们的目标变成了：
从 L 的所有可能终点（变换后为 $(u_L, v_L)$）和 R 的所有可能终点（变换后为 $(u_R, v_R)$）中各选一个，使得 $\max(|u_L - u_R|, |v_L - v_R|)$ 最大。

这个问题就变得清晰多啦！为了让这个最大值最大，我们其实只需要分别考虑让 $|u_L - u_R|$ 最大和让 $|v_L - v_R|$ 最大，然后取这两者的较大值就可以啦。

$$
\max_{\text{所有L, R的组合}} \left( \max(|u_L - u_R|, |v_L - v_R|) \right) = \max \left( \max_{\text{所有L, R的组合}} |u_L - u_R|, \max_{\text{所有L, R的组合}} |v_L - v_R| \right)
$$

让我们来想想要怎么让 $|u_L - u_R|$ 最大呢？这很简单嘛！我们只需要让一个 $u$ 坐标尽可能大，另一个 $u$ 坐标尽可能小。也就是说，从 L 和 R 的所有 $u$ 坐标中，找出最大值和最小值，它们的差就是 $|u_L - u_R|$ 的最大可能值。
但这不对，因为 $u_L$ 和 $u_R$ 是从两个不同的集合里选的。

正确的思路是这样的：
我们可以先把小 L 的所有 $n$ 个终点都变换到 $(u, v)$ 坐标系下。然后，我们找出这些点在 $u$ 轴和 $v$ 轴上的范围，也就是：
-   $u_{L, \max}$: 小 L 所有 $u$ 坐标的最大值
-   $u_{L, \min}$: 小 L 所有 $u$ 坐标的最小值
-   $v_{L, \max}$: 小 L 所有 $v$ 坐标的最大值
-   $v_{L, \min}$: 小 L 所有 $v$ 坐标的最小值

这个过程只需要遍历一遍小 L 的 $n$ 个向量，时间是 $O(n)$。

接下来，我们遍历小 R 的每一个可能的终点 $(u_R, v_R)$。对于固定的一个 $(u_R, v_R)$，我们想找一个小 L 的点 $(u_L, v_L)$，让它们之间的切比雪夫距离 $\max(|u_L - u_R|, |v_L - v_R|)$ 最大。
-   为了让 $|u_L - u_R|$ 最大， $u_L$ 应该取 $u_{L, \max}$ 或者 $u_{L, \min}$。
-   为了让 $|v_L - v_R|$ 最大， $v_L$ 应该取 $v_{L, \max}$ 或者 $v_{L, \min}$。

所以，对于一个固定的 R 点 $(u_R, v_R)$，它与 L 所有点集合的最大切比雪夫距离是：
$$
\max \left( |u_R - u_{L, \max}|, |u_R - u_{L, \min}|, |v_R - v_{L, \max}|, |v_R - v_{L, \min}| \right)
$$
这四个值中的最大一个，就是当前这个 R 点能与 L 达成的最大距离。

我们只需要遍历小 R 的所有 $m$ 个点，对每个点都计算这个值，然后再取所有结果中的最大值，就是最终的答案啦！

### 算法步骤总结

1.  **预处理小 L**：
    -   初始化四个变量：`max_u_L`, `min_u_L`, `max_v_L`, `min_v_L` 为极值。
    -   遍历小 L 的 $n$ 个向量 $(x, y)$。
    -   对每个向量，计算出 $u = x+y$ 和 $v = x-y$。
    -   用 $u$ 和 $v$ 更新这四个最值。
    -   这一步复杂度是 $O(n)$。

2.  **遍历小 R 计算最大距离**：
    -   初始化一个 `max_dist = 0`。
    -   遍历小 R 的 $m$ 个向量 $(x, y)$。
    -   对每个向量，计算出 $u_R = x+y$ 和 $v_R = x-y$。
    -   计算当前 R 点能产生的最大距离 `current_dist = max(|u_R - max_u_L|, |u_R - min_u_L|, |v_R - max_v_L|, |v_R - min_v_L|)`。
    -   更新 `max_dist = max(max_dist, current_dist)`。
    -   这一步复杂度是 $O(m)$。

3.  **输出结果**：
    -   最后得到的 `max_dist` 就是答案。

总的时间复杂度是 $O(n+m)$，空间复杂度是 $O(1)$（如果不算存储输入数据的话），非常高效，一定能通过的喵！

## 代码实现

这是本猫娘根据上面的思路，为主人精心重构的 C++ 代码哦~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

// 为了防止整数溢出，并且初始化时方便，使用一个很大的数
const long long INF = 4e9 + 7; 

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m;
    std::cin >> n >> m;

    // Step 1: 预处理小 L 的向量，找到 u 和 v 坐标的四个极值
    long long max_u_L = -INF;
    long long min_u_L = INF;
    long long max_v_L = -INF;
    long long min_v_L = INF;

    for (int i = 0; i < n; ++i) {
        long long x, y;
        std::cin >> x >> y;
        // 坐标变换
        long long u = x + y;
        long long v = x - y;
        
        // 更新 u 和 v 的最大值和最小值
        max_u_L = std::max(max_u_L, u);
        min_u_L = std::min(min_u_L, u);
        max_v_L = std::max(max_v_L, v);
        min_v_L = std::min(min_v_L, v);
    }

    // Step 2: 遍历小 R 的向量，计算并更新最大曼哈顿距离
    long long max_manhattan_dist = 0;

    for (int i = 0; i < m; ++i) {
        long long x, y;
        std::cin >> x >> y;
        // 对小 R 的向量进行同样的坐标变换
        long long u_R = x + y;
        long long v_R = x - y;

        // 计算当前 R 点与 L 集合的最大切比雪夫距离
        // 这等价于它们在原坐标系下的最大曼哈顿距离
        long long current_max_dist = 0;
        current_max_dist = std::max(current_max_dist, std::abs(u_R - max_u_L));
        current_max_dist = std::max(current_max_dist, std::abs(u_R - min_u_L));
        current_max_dist = std::max(current_max_dist, std::abs(v_R - max_v_L));
        current_max_dist = std::max(current_max_dist, std::abs(v_R - min_v_L));
        
        // 更新全局最大距离
        max_manhattan_dist = std::max(max_manhattan_dist, current_max_dist);
    }

    // Step 3: 输出最终答案
    std::cout << max_manhattan_dist << std::endl;

    return 0;
}
```

## 复杂度分析

-   **时间复杂度**: $O(N + M)$
    我们首先用 $O(N)$ 的时间遍历小 L 的所有向量来计算四个极值。然后用 $O(M)$ 的时间遍历小 R 的所有向量，每次计算最大距离是常数时间。所以总的时间复杂度是 $O(N+M)$，非常快呢！

-   **空间复杂度**: $O(1)$
    我们只需要常数个变量（`max_u_L`, `min_u_L`, `max_v_L`, `min_v_L`, `max_manhattan_dist`）来存储中间结果，不需要额外的大数组。所以辅助空间复杂度是 $O(1)$ 的说。

## 知识点总结

这道题真有趣，让我们学会了几个重要的技巧，喵~

1.  **曼哈顿距离与切比雪夫距离的转换**：这是解决这类问题的关键！通过一个简单的坐标旋转（$u=x+y, v=x-y$），可以把难以处理的曼哈顿距离（$|dx|+|dy|$）转换成易于处理的切比雪夫距离（$\max(|du|, |dv|)$）。这个技巧在很多几何问题中都很有用哦。

2.  **降维与极值思想**：我们将二维平面上的距离问题，通过坐标变换，变成了两个一维坐标轴上的距离问题。为了最大化距离，我们只需要考虑端点（最大值和最小值），这大大简化了计算。

3.  **预处理思想**：我们先花 $O(N)$ 的时间预处理小 L 的数据，得到四个关键的极值。这样，在后续处理小 R 的数据时，每次查询都只需要 $O(1)$ 的时间，从而避免了 $O(N \cdot M)$ 的暴力枚举。

希望这篇题解能帮到主人哦！如果还有不明白的地方，随时可以来问我这只聪明的猫娘，喵~ >w<