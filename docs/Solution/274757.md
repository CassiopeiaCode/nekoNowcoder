# 小 L 和小 R 的赛跑 - 题解

### 比赛与标签
> **比赛**: NowCoder-The 2nd Universal Cup. Stage 5: Shenyang
> **标签**: 曼哈顿距离, 切比雪夫距离, 数学, 思维
> **难度**: *1800

## 题目大意喵~
各位小主人好喵~！这道题是说，小 L 和小 R 两个可爱的孩子都在一个二维平面的原点 `(0,0)` 上。他们每个人都有一套可以移动的“速度向量”，小 L 有 `n` 种，小 R 有 `m` 种。

在一秒钟内，小 L 会选择他的一个速度向量 `(x_L, y_L)` 并移动到这个点。同时，小 R 也会选择他的一个速度向量 `(x_R, y_R)` 并移动到那里。

我们的任务是，帮助他们选择各自的移动向量，使得他们一秒后所在位置之间的 **曼哈顿距离** 最大化，然后输出这个最大的距离是多少的说！

**曼哈顿距离** 的计算公式也告诉我们啦：对于两个点 `(x1, y1)` 和 `(x2, y2)`，它们的曼哈顿距离是 `|x1 - x2| + |y1 - y2|` 呐。

## 解题思路大揭秘！
看到这道题，小主人的第一反应是不是遍历小 L 的所有 `n` 种选择，再嵌套一个循环遍历小 R 的所有 `m` 种选择，然后计算 `n * m` 次曼哈顿距离，找一个最大的？

`n` 和 `m` 最大有 10^5，`n * m` 会达到 10^10，这可比宇宙的年龄还长了喵！一定会超时的说！所以我们必须找到一个更聪明的办法呐。

### 曼哈顿距离的“变身魔法”
处理曼哈顿距离问题，有一个非常经典的“变身”技巧，就是把它转换成 **切比雪夫距离**！

*   **曼哈顿距离**: `D_manhattan = |Δx| + |Δy|`
*   **切比雪夫距离**: `D_chebyshev = max(|Δx|, |Δy|)`

这两个距离公式看起来不太一样，但通过一个神奇的坐标系旋转45度再拉伸一下，它们就可以互相转化了喵！

我们定义新的坐标 `u = x + y` 和 `v = x - y`。
假设小 L 移动到了 `(x_L, y_L)`，小 R 移动到了 `(x_R, y_R)`。
在新的坐标系里，他们的位置就变成了 `(u_L, v_L)` 和 `(u_R, v_R)`。

我们来看看他们在新坐标系下的切比雪夫距离是多少：
`D' = max(|u_L - u_R|, |v_L - v_R|)`
`|u_L - u_R| = |(x_L + y_L) - (x_R + y_R)| = |(x_L - x_R) + (y_L - y_R)| = |Δx + Δy|`
`|v_L - v_R| = |(x_L - y_L) - (x_R - y_R)| = |(x_L - x_R) - (y_L - y_R)| = |Δx - Δy|`

所以 `D' = max(|Δx + Δy|, |Δx - Δy|)`。

这里有一个重要的恒等式：`max(|A+B|, |A-B|) = |A| + |B|`。
不信的话可以分情况讨论 `A` 和 `B` 的正负号，会发现它总是成立的哦！
把 `A = Δx`，`B = Δy` 代入，我们就得到了：
`max(|Δx + Δy|, |Δx - Δy|) = |Δx| + |Δy|`

看呀！原来的曼哈顿距离 `D_manhattan` 正好就等于新坐标下的切比雪夫距离 `D'`！
`|x_L - x_R| + |y_L - y_R| = max(|u_L - u_R|, |v_L - v_R|)`

### 简化后的问题
我们的目标就从 “最大化曼哈顿距离” 变成了 “最大化新坐标下的切比雪夫距离”。
也就是要最大化 `max(|u_L - u_R|, |v_L - v_R|)`。

这个式子可以拆开来看：
`max( max_{L,R} |u_L - u_R|, max_{L,R} |v_L - v_R| )`

问题被分解成了两个独立的一维问题！
1.  找到一组 `u_L` 和 `u_R`，让它们的差的绝对值最大。
2.  找到一组 `v_L` 和 `v_R`，让它们的差的绝对值最大。
最后取这两个最大值中更大的那个，就是我们的答案啦！

### 喵酱的算法步骤
现在思路就清晰多啦！
1.  **预处理小 L 的向量**：
    我们先遍历小 L 的所有 `n` 个向量 `(x, y)`。对于每一个向量，都计算出它在新坐标系下的坐标 `u = x + y` 和 `v = x - y`。然后，我们找出所有 `u` 坐标中的最大值 `u_L_max` 和最小值 `u_L_min`，以及所有 `v` 坐标中的最大值 `v_L_max` 和最小值 `v_L_min`。这个过程的时间复杂度是 O(n) 的说。

2.  **遍历小 R 的向量并计算**：
    接下来，我们遍历小 R 的所有 `m` 个向量。对于其中任意一个向量 `(x_R, y_R)`，我们计算出它的新坐标 `(u_R, v_R)`。
    为了让这个 `(u_R, v_R)` 和小 L 的某个点 `(u_L, v_L)` 的切比雪夫距离最大，我们应该怎么选 `(u_L, v_L)` 呢？
    对于固定的 `u_R`，`|u_L - u_R|` 的最大值肯定是 `u_L` 取 `u_L_max` 或 `u_L_min` 的时候。所以 `max_{L} |u_L - u_R| = max(|u_L_max - u_R|, |u_L_min - u_R|)`。
    同理，`max_{L} |v_L - v_R| = max(|v_L_max - v_R|, |v_L_min - v_R|)`。
    
    所以，对于当前这个来自小 R 的点 `(u_R, v_R)`，它能与小 L 的所有点产生的最大切比雪夫距离就是：
    `dist = max(|u_R - u_L_max|, |u_R - u_L_min|, |v_R - v_L_max|, |v_R - v_L_min|)`

    我们对小 R 的每一个点都计算这个 `dist`，并维护一个全局的最大值。遍历完所有小 R 的点后，这个全局最大值就是最终的答案啦！这一步的时间复杂度是 O(m)。

总的来说，我们用 O(n+m) 的时间就解决了这个问题，是不是超级高效呀，喵~

## 代码实现
这是AC代码的Python版本，喵酱给加上了详细的注释，帮助小主人理解哦！

```python
# 完整AC代码，添加详细注释解释关键逻辑

# 读入小L和小R的向量数量
n, m = map(int, input().split())

# 读入小L的所有n个向量
L = [tuple(map(int, input().split())) for _ in range(n)]
# 读入小R的所有m个向量
R = [tuple(map(int, input().split())) for _ in range(m)]

# 预处理小L的向量，找到变换后坐标的四个极值
# max_L[0] 用来存 u_L_max (u = x+y)
# max_L[1] 用来存 u_L_min
# max_L[2] 用来存 v_L_max (v = x-y)
# max_L[3] 用来存 v_L_min
# 初始化为正负无穷大，方便比较
max_L = [ -float('inf'), float('inf'), -float('inf'), float('inf') ]
for x, y in L:
    s = x + y  # s 就是我们思路里提到的 u
    d = x - y  # d 就是我们思路里提到的 v
    max_L[0] = max(max_L[0], s) # 更新 u_max
    max_L[1] = min(max_L[1], s) # 更新 u_min
    max_L[2] = max(max_L[2], d) # 更新 v_max
    max_L[3] = min(max_L[3], d) # 更新 v_min

# 初始化最终的最大距离为0
max_dist = 0
# 遍历小R的每一个向量
for x, y in R:
    s = x + y  # 计算当前R向量的 u 坐标
    d = x - y  # 计算当前R向量的 v 坐标
    
    # 计算当前R点到L点集的四个边界点的切比雪夫距离分量
    # 也就是 |u_R - u_L_max|, |u_R - u_L_min|, |v_R - v_L_max|, |v_R - v_L_min|
    # 取其中最大的一个，就是当前R点能产生的最大切比雪夫距离
    current_max = max(
        abs(s - max_L[0]),
        abs(s - max_L[1]),
        abs(d - max_L[2]),
        abs(d - max_L[3])
    )
    
    # 更新全局的最大距离
    if current_max > max_dist:
        max_dist = current_max

# 打印最终答案
print(max_dist)
```

## 复杂度分析
- **时间复杂度**: O(n + m) 的说。我们首先用 O(n) 的时间遍历了一遍小 L 的向量来做预处理，然后用 O(m) 的时间遍历了一遍小 R 的向量来计算最终结果。所以总时间是线性的，非常快！
- **空间复杂度**: O(n + m) 的说。主要是因为我们需要存储小 L 和小 R 的所有输入向量。

## 知识点与总结
这道题最核心的知识点就是 **曼哈顿距离与切比雪夫距离的相互转化**，这是一个在计算几何和一些算法竞赛题中非常有用的技巧，小主人一定要记住喵！

1.  **核心变换**: `(x, y) -> (x+y, x-y)`。这个变换将曼哈顿距离变成了新坐标下的切比雪夫距离。
2.  **降维思想**: 通过这个变换，我们将一个二维平面上的距离问题，巧妙地分解成了两个独立的一维坐标轴上的距离问题，大大简化了计算。
3.  **极值思想**: 在一维上，一个点到一个点集的最远距离，一定是在这个点集的两个端点（最大值和最小值）处取到。这个思想让我们避免了遍历，只需要和预处理出的四个极值点比较即可。

希望这篇题解能帮助到你呐！如果还有不明白的地方，随时可以再来问喵酱哦！一起加油，变得更强吧！喵~