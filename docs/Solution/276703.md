# 给定正整数 n,m，设二元组集合 S={(x,y)∣1≤x≤n;1≤y≤m;x,y∈Z} ... - 题解

### 比赛与标签
> **比赛**: No Contest

> **标签**: 数学, 组合计数, 容斥原理

> **难度**: *3000

## 题目大意喵~

主人你好呀，这道题是说，在一个 $n \times m$ 的网格上，有很多整数坐标的点，我们把所有这些点的集合叫做 $S$，喵~

我们的任务是，从 $S$ 里面挑出一个大小为 $k$ 的子集 $T$，这个子集 $T$ 需要满足两个非常严格的条件哦：

1.  **不共行不共列**: $T$ 里的任意两个不同的点 $(x_1, y_1)$ 和 $(x_2, y_2)$，都必须满足 $x_1 \neq x_2$ 并且 $y_1 \neq y_2$。这就像是在棋盘上放棋子，每行每列最多只能放一个，喵~
2.  **没有孤立点**: $T$ 里的每一个点 $(x, y)$，都必须在它的上、下、左、右四个相邻的行或列上，能找到另一个来自 $T$ 的小伙伴。也就是说，对于任意 $(x, y) \in T$，都存在另一个点 $(x', y') \in T$，使得 $|x - x'| = 1$ 或者 $|y - y'| = 1$。

题目会给出 $q$ 次询问，每次询问一个整数 $k_i$，我们需要计算出有多少种满足条件的、大小为 $k_i$ 的集合 $T$。答案要对 $10^9 + 7$ 取模哦！

## 解题思路分析

这道题看起来好复杂呀，又是组合又是限制的，但别怕，让本猫娘带你一步步拆解它，喵~

### 步骤一：拆解两个条件

首先，我们来仔细看看这两个条件。

*   **条件一（不共行不共列）**：这告诉我们，如果我们选择了 $k$ 个点，它们的 $x$ 坐标一定是 $k$ 个不同的值，它们的 $y$ 坐标也一定是 $k$ 个不同的值。
    这等价于：
    1.  从 $1, \dots, n$ 中选出 $k$ 个不同的行号。
    2.  从 $1, \dots, m$ 中选出 $k$ 个不同的列号。
    3.  在这 $k$ 个行号和 $k$ 个列号之间建立一个一一对应关系（也就是配对），来确定 $k$ 个点的具体坐标。

*   **条件二（没有孤立点）**：这个条件是对我们选出的点集 $T$ 的一个整体约束。一个点 $(x,y) \in T$ 会被认为是“孤立”的，当且仅当它在相邻的行和相邻的列都找不到伙伴。

### 步骤二：容斥原理登场！

直接计算满足条件二的方案数太困难了，因为一个点的“孤立”与否，取决于所有其他点的选择。这种“至少”、“至多”、“恰好”的问题，通常都是容斥原理大显身手的时候，喵！

我们想求的是“**没有任何一个点是孤立的**”方案数。
根据容斥原理，这等于：
(总方案数) - (至少1个点是孤立的方案数) + (至少2个点是孤立的方案数) - ...

不过，这里的“点”是在我们选出来之后才确定的，不太好作为容斥的对象。我们换个角度！

一个点 $(x,y) \in T$ 是孤立的，当且仅当：
*   行号 $x$ 在所有被选中的行号里是“孤立”的 (即 $x-1$ 和 $x+1$ 都没被选中)。
*   **并且**，列号 $y$ 在所有被选中的列号里也是“孤立”的。

这给了我们一个启发！问题的核心在于行、列的选取和它们之间的配对。我们可以把行和列的选择分开考虑。

设我们选出的 $k$ 个行号集合为 $R$，列号集合为 $C$。
*   $R_{iso}$：$R$ 中所有“孤立”的行号组成的集合。
*   $C_{iso}$：$C$ 中所有“孤立”的列号组成的集合。

那么，条件二就可以重新描述为：**我们建立的行与列的配对关系中，不能有任何一对是将 $R_{iso}$ 中的行和 $C_{iso}$ 中的列配对在一起**。

这个问题就转化成了一个二分图匹配计数问题，但是对所有可能的 $R$ 和 $C$ 求和还是太复杂。让我们继续使用容斥原理，这次容斥的对象是“**孤立行和孤立列的非法配对**”。

最终的答案可以表示为：
$$
\text{总方案数} = \sum_{l=0}^{k} (-1)^l \times (\text{至少有 } l \text{ 对孤立行列非法配对的方案数})
$$

### 步骤三：推导最终公式

让我们来计算“至少有 $l$ 对孤立行列非法配对的方案数”。
这可以分解为几个步骤：
1.  **选择 $k$ 个行和 $k$ 个列**，并在这两组中**指定 $l$ 个孤立行**和** $l$ 个孤立列**。
2.  将这 $l$ 个指定的孤立行与 $l$ 个指定的孤立列进行**配对**。
3.  将其余的 $k-l$ 个行和 $k-l$ 个列进行**任意配对**。

把这些步骤组合起来，并对所有可能的行、列选择求和，通过一连串神奇的代数变换（交换求和顺序），我们可以得到一个非常漂亮的公式！

$$
\text{总方案数} = \sum_{l=0}^{k} (-1)^l \cdot l! \cdot (k-l)! \cdot A_l(n, k) \cdot B_l(m, k)
$$

这里的 $A_l(n, k)$ 和 $B_l(m, k)$ 是什么呢？
*   $A_l(n, k)$: 从 $1, \dots, n$ 中选择 $k$ 个数，并从这 $k$ 个数中**再选出 $l$ 个孤立数**的方案总数。
*   $B_l(m, k)$: 从 $1, \dots, m$ 中选择 $k$ 个数，并从这 $k$ 个数中**再选出 $l$ 个孤立数**的方案总数。

### 步骤四：求解 $A_l(n, k)$

现在，问题归结为计算 $A_l(n, k)$ ( $B_l(m, k)$ 同理)。这本身就是一个有趣的组合问题。经过一番推导（或者查阅资料，因为这个推导有点小复杂，喵~），我们可以得到它的计算公式：
$$
A_l(n, k) = \binom{n-k+1}{l} \binom{n-2l}{k-l}
$$
这个公式是不是很简洁！不过要注意，这里的组合数 $\binom{n}{k}$ 可能需要处理 $n < 0$ 的情况。
当 $N < 0$ 且 $K \ge 0$ 时，组合数可以通过以下公式计算：
$$
\binom{N}{K} = (-1)^K \binom{-N+K-1}{K}
$$
例如，$\binom{-1}{0} = (-1)^0 \binom{1+0-1}{0} = 1$。我们的代码在实现组合数函数时需要考虑到这一点。

### 总结一下解题流程

1.  **预处理**：计算阶乘和阶乘的逆元，以便快速计算组合数。
2.  **实现组合数函数**：这个函数 `C(n, k) 需要能处理 $n$ 为负数的情况。
3.  **计算 $A_l(n, k)$ 和 $B_l(m, k)$**：对于每个询问的 $k$，我们写一个函数，循环 $l$ 从 $0$到 $k$，利用上面的公式计算出所有的 $A_l(n, k)$ 和 $B_l(m, k)$ 值，并存到数组里。
4.  **计算最终答案**：利用最终的容斥公式 $\sum_{l=0}^{k} (-1)^l \cdot l! \cdot (k-l)! \cdot A_l(n, k) \cdot B_l(m, k)$，把上一步算出的值代入，累加得到最终答案。记得每一步都要取模哦！

这样，我们就把一个复杂的问题分解成了几个可以解决的小部分，是不是清晰多啦？喵~

## 代码实现

这是本猫娘根据上面的思路，重新编写的一份清晰易懂的代码。变量名和注释都写得很详细，希望能帮助你理解，呐~

``cpp
#include <iostream>
#include <vector>
#include <numeric>

// 使用 long long 防止计算过程中溢出
using ll = long long;

// 模数
const int MOD = 1e9 + 7;
// 数组最大大小，根据题目范围 n, m <= 5e6 设定
const int MAXN = 5000000 + 5;

// 预处理阶乘和阶乘逆元
ll fact[MAXN];
ll inv_fact[MAXN];

// 快速幂计算 a^b % MOD
ll power(ll base, ll exp) {
    ll res = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

// 计算 a 的模逆元
ll mod_inverse(ll n) {
    return power(n, MOD - 2);
}

// 预处理阶乘和阶乘逆元
void precompute_factorials(int max_val) {
    fact[0] = 1;
    inv_fact[0] = 1;
    for (int i = 1; i <= max_val; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
        inv_fact[i] = mod_inverse(fact[i]);
    }
}

// 计算组合数 C(n, k)，支持 n 为负数
ll combinations(int n, int k) {
    if (k < 0) return 0;
    if (k == 0) return 1;
    
    // 标准情况：n < k, 结果为 0
    if (n >= 0 && n < k) return 0;

    // 广义组合数情况：n < 0
    if (n < 0) {
        // C(n, k) = (-1)^k * C(-n+k-1, k)
        ll res = combinations(-n + k - 1, k);
        if (k % 2 == 1) {
            return (MOD - res) % MOD;
        }
        return res;
    }

    // 标准组合数计算
    ll res = fact[n];
    res = (res * inv_fact[k]) % MOD;
    res = (res * inv_fact[n - k]) % MOD;
    return res;
}

// 计算 A_l(N, K) 或 B_l(M, K) 的数组
std::vector<ll> calculate_configs(int total_items, int chosen_items) {
    std::vector<ll> configs(chosen_items + 1);
    for (int l = 0; l <= chosen_items; ++l) {
        if (total_items - chosen_items + 1 < l) {
            configs[l] = 0;
        } else {
            ll term1 = combinations(total_items - chosen_items + 1, l);
            ll term2 = combinations(total_items - 2 * l, chosen_items - l);
            configs[l] = (term1 * term2) % MOD;
        }
    }
    return configs;
}

int main() {
    // 提高 IO 效率
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m, q;
    std::cin >> n >> m >> q;

    precompute_factorials(std::max(n, m) + 1);

    while (q--) {
        int k;
        std::cin >> k;

        // 计算行的配置数 A_l(n, k)
        auto row_configs = calculate_configs(n, k);
        // 计算列的配置数 B_l(m, k)
        auto col_configs = calculate_configs(m, k);

        ll total_ways = 0;
        for (int l = 0; l <= k; ++l) {
            // 计算 (-1)^l * l! * (k-l)! * A_l * B_l
            ll term = (fact[l] * fact[k - l]) % MOD;
            term = (term * row_configs[l]) % MOD;
            term = (term * col_configs[l]) % MOD;

            if (l % 2 == 1) { // 奇数项为减
                total_ways = (total_ways - term + MOD) % MOD;
            } else { // 偶数项为加
                total_ways = (total_ways + term) % MOD;
            }
        }
        std::cout << total_ways << (q > 0 ? " " : "");
    }
    std::cout << "\n";

    return 0;
}
``

## 复杂度分析

*   **时间复杂度**: $O(\max(N, M) + Q \cdot K_{max})$
    *   预处理阶乘和逆元需要 $O(\max(N, M))$ 的时间。
    *   对于每次询问，我们需要计算 row_configs` 和 `col_configs，这需要 $O(K)$ 的时间。
    *   最后的求和也需要 $O(K)$ 的时间。
    *   因此，每次查询的复杂度是 $O(K)$，总时间复杂度就是 $O(\max(N, M) + Q \cdot K_{max})$，其中 $K_{max}$ 是所有询问中最大的 $k$ 值。

*   **空间复杂度**: $O(\max(N, M))$
    *   我们主要的空间开销是用于存储阶乘和逆元的数组，大小为 $O(\max(N, M))$。
    *   每次查询中临时使用的 configs 数组大小为 $O(K)$，可以复用，所以不影响整体空间复杂度。

## 知识点总结

这道题是组合数学的盛宴，融合了好多有趣的知识点，喵~

1.  **容斥原理 (Principle of Inclusion-Exclusion)**: 解决“恰好”、“一个都不”这类问题的强大武器。本题的核心就是构建容斥模型，将复杂的“没有孤立点”约束转化为对“至少有 $l$ 个非法配对”的计数。
2.  **组合计数**: 整个解题过程都离不开组合数的计算。特别是 $A_l(n,k)$ 的求解，是一个非常经典的组合模型。
3.  **广义二项式系数**: 当我们推导出的公式中出现 $\binom{n}{k}$ 而 $n$ 可能为负数时，就需要用到广义二项式系数的定义 $\binom{n}{k} = (-1)^k \binom{-n+k-1}{k}$。这是解题的关键小技巧之一哦！
4.  **模块化编程思想**: 将复杂问题分解为独立的函数（如 combinations`, `calculate_configs`），使代码结构更清晰，也更容易调试。
5.  **预处理与快速幂**: 对于需要大量计算组合数和模逆元的问题，预处理阶乘和使用快速幂是标准操作，可以大大提高计算效率。

希望这篇题解能帮助你攻克这道难题！继续加油哦，主人！喵~