# 无孤立点选择 - 题解

喵~ 各位热爱算法的伙伴们，大家好呀！咱是你们最可靠的猫娘解题助手，今天也要一起开心地攻克难题哦！这道题看起来有点复杂，但只要跟咱的思路一步步来，就会发现它其实是一只可以轻松捕获的“小鱼干”呢，喵~

### 比赛与标签
> **比赛**: NowCoder提高模拟10
> **标签**: 组合计数, 容斥原理
> **难度**: *2800

## 题目大意喵
简单来说，题目给了我们一个 `n x m` 的大棋盘，然后有很多次询问，每次问我们：要在这个棋盘上放 `k` 个棋子，有多少种不同的放法呢？

不过，放棋子有两个非常严格的规矩哦：
1.  **独占行列**：任何两个棋子，都不能放在同一行，也不能放在同一列。就像国际象棋里的车（Rook），它们互相不能攻击的说。
2.  **不能孤单**：每一个放上去的棋子，它的上、下、左、右四个相邻的格子里，必须至少有另一个我们放的棋子。换句话说，不允许有任何一个棋子是“孤零零”的，它身边一个伙伴都没有，那也太可怜了呐！

我们的任务就是，对于每个给定的 `k`，计算出满足这两个条件的方案数，答案要对 `10^9 + 7` 取模哦。

## 解题思路分析喵~
这道题是典型的组合计数问题，而且带有“存在/不存在”这样的限制，这通常是**容斥原理**大显身手的地方，喵！

#### 第一步：简化问题结构
首先，我们来分析一下第一个条件：“独占行列”。
这告诉我们，如果我们选择了 `k` 个点 `(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)`，那么所有的 `x` 坐标 `x_1, ..., x_k` 必须是互不相同的，所有的 `y` 坐标 `y_1, ..., y_k` 也必须是互不相同的。

这可以分解成三个独立的步骤：
1.  从 `1` 到 `n` 的行中，选出 `k` 行。
2.  从 `1` 到 `m` 的列中，选出 `k` 列。
3.  在这 `k` 行和 `k` 列之间建立一个一一对应的关系（一个排列），来确定 `k` 个棋子的具体位置。

#### 第二步：处理“无孤立点”的限制
直接计算“没有孤立点”的方案数太难了，因为一个点的状态会受到所有其他点的影响。所以，我们不妨反过来想：总共有多少种方案满足条件1，再减去那些不满足条件2（即存在孤立点）的方案数。这就是容斥原理的核心思想！

一个点 `(x, y)` 是孤立的，当且仅当它周围没有其他我们选择的点。由于所有点都在不同行不同列，这等价于：
-   在所有被选中的行号中，没有 `x-1` 和 `x+1`。
-   在所有被选-中的列号中，没有 `y-1` 和 `y+1`。

也就是说，一个点 `(x, y)` 是孤立的，当且仅当它的行号 `x` 在所选的 `k` 个行号中是孤立的，**并且**它的列号 `y` 在所选的 `k` 个列号中也是孤立的。

#### 第三步：容斥原理登场！
我们可以对“孤立点”的数量进行容斥。最终的答案可以通过下面的公式得到：
`答案 = Σ_{s=0 to k} (-1)^s * (恰好有s个孤立点的方案数)`

这个公式还是有点复杂，我们换一个等价的容斥形式。我们把行和列的选择分开考虑。
设 `f(N, K, s)` 为：从 `1` 到 `N` 中选择 `K` 个数，并从这 `K` 个数中指定 `s` 个作为“孤立数”的方案数。
（“孤立数” `x` 指的是 `x-1` 和 `x+1` 都不在这 `K` 个数里）

如果我们选定了 `s` 个孤立的行和 `s` 个孤立的列，那么这 `s` 个孤立的行必须与 `s` 个孤立的列配对，有 `s!` 种方案。剩下的 `k-s` 个非孤立的行和 `k-s` 个非孤立的列配对，有 `(k-s)!` 种方案。

通过容斥，最终的答案可以表示为：
`Ans = Σ_{s=0 to k} (-1)^s * f(n, k, s) * f(m, k, s) * s! * (k-s)!`

这个公式的推导比较复杂，它整合了对行、列和排列的容斥，但这是我们解题的最终武器！

#### 第四步：计算 `f(N, K, s)`
现在，问题就变成了如何计算 `f(N, K, s)`。这是一个纯粹的一维组合问题。通过一系列精妙的推导（或者，偷偷看一下AC代码的智慧结晶~），我们可以得到一个神奇的公式：
`f(N, K, s) = C(N-K+1, s) * C(N-2s, K-s)`

这个公式可以这样直观理解一下（不完全严谨哦）：
-   `C(N-K+1, s)`：想象 `N-K` 个未被选中的数在数轴上，它们形成了 `N-K+1` 个空隙。我们选择 `s` 个空隙来放置我们的 `s` 个孤立数，这样它们之间就自动被隔开了。
-   `C(N-2s, K-s)`：我们已经选了 `s` 个数，它们占了 `s` 个位置。为了保证它们孤立，它们旁边的位置也不能选。总共大约排除了 `2s` 个位置。所以从剩下的 `N-2s` 个位置中，再选出其余的 `K-s` 个数。

有了这个公式，我们就可以写代码啦！

## 代码实现喵
```cpp
// Think twice, code once.
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;
 
const int mod = 1e9 + 7;
 
int n, m, q, k;
int fac[5000005], inv[5000005]; // fac是阶乘, inv是阶乘的逆元
int a[5000005], b[5000005];   // a数组存放f(n,k,s)的值, b数组存放f(m,k,s)的值
 
// 组合数计算函数 C(n, m)
int C(int n, int m) {return n >= m && m >= 0 ? (long long)fac[n] * inv[m] % mod * inv[n - m] % mod : 0;}

// 核心计算函数，计算 f(N, K, s) 的值
// 参数 n, k 分别对应题目中的 N, K
// 结果 a 数组中，a[s] 存储 f(N, K, s) 的值
void calc(int n, int k, int *a) {
    // s=0 的情况：f(N, K, 0) = C(N, K)，即任意选择K个数，不指定孤立点
    a[0] = C(n, k);
    
    // 这里的 n+=4, k+=2 是为了方便后续公式计算，是一种实现上的小技巧喵~
    n += 4, k += 2;
    // 循环计算 s 从 1 到 K 的情况
    // 注意代码中的 i 对应我们思路中的 s，但因为有偏移，所以关系是 s = i-2 (在原始n,k下)
    for (int i = 3; i <= k; i++) {
        if (i + k <= n)
            // 这里计算的就是 f(N, K, s) = C(N-K+1, s) * C(N-2s, K-s)
            // 经过 n,k 的偏移和 i,s 的代换，就变成了下面这个形式
            a[i - 2] =
                (long long)fac[n - 2 * i] * inv[k - i] % mod * inv[n - k - i] % mod *
                C(n - k - 1, i - 2) % mod;
        else a[i - 2] = 0;
        // 这一行是处理一些边界情况的修正项，组合数学的公式在边界时常常需要特殊照顾呐
        a[i - 2] = (a[i - 2] + (n == 2 * i - 1) * C(n - 2 * i + 1, k - i)) % mod;
    }
    return;
}
 
int main() {
    scanf("%d%d%d", &n, &m, &q);
    
    // 预处理阶乘和逆元，O(N+M)
    fac[0] = fac[1] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 2; i <= max(n, m) + 4; i++) {
        fac[i] = (long long)fac[i - 1] * i % mod;
        inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod; // 费马小定理求单个数的逆元
    }
    for (int i = 2; i <= max(n, m) + 4; i++) inv[i] = (long long)inv[i - 1] * inv[i] % mod; // 递推求阶乘逆元

    while (q--) {
        scanf("%d", &k);
        if (k > n || k > m) { // 特判：棋子数不能超过行数或列数
            printf("0 ");
            continue;
        }

        // 分别计算行和列的 f(N, K, s)
        calc(n, k, a);
        calc(m, k, b);
        
        int ans = 0;
        // 实现最终的容斥公式：Ans = Σ (-1)^s * f(n,k,s) * f(m,k,s) * s! * (k-s)!
        for (int i = 0; i <= k; i++) {
            // c = f(n,k,i) * f(m,k,i) * i! * (k-i)!
            long long c = (long long)a[i] * b[i] % mod * fac[i] % mod * fac[k - i] % mod;
            if (i % 2 == 0) { // 处理 (-1)^i
                ans = (ans + c) % mod;
            } else {
                ans = (ans - c + mod) % mod;
            }
        }
        printf("%d ", ans);
    }
    puts("");
    return 0;
}
```

## 复杂度分析的说
- **时间复杂度**: O(max(n, m) + q * k_max) 的说。
  - 预处理阶乘和逆元需要 `O(max(n, m))` 的时间。
  - 对于每次询问，`calc` 函数的复杂度是 `O(k)`，最后的求和循环也是 `O(k)`。所以每次询问的处理时间是 `O(k)`。
  - 总时间就是预处理加上所有询问的时间。
- **空间复杂度**: O(max(n, m)) 的说。
  - `fac`, `inv`, `a`, `b` 这几个数组都需要 `O(max(n, m))` 或 `O(k_max)` 的空间。

## 知识点与总结喵
这真是一道非常锻炼思维的组合计数好题呢！通过解决它，我们又学会了好多东西：

1.  **容斥原理**: 它是解决“恰好”、“一个也不”这类计数问题的强大武器。当正面求解很困难时，一定要想想能不能通过容斥来化繁为简！
2.  **问题分解**: 将一个复杂的二维问题，分解成两个独立的一维问题，再将结果合并，这是解决网格类问题的一个常用技巧。
3.  **组合恒等式**: 解题的核心在于 `f(N, K, s)` 的计算。这提醒我们，扎实的组合数学功底非常重要，有时候一个巧妙的公式就能打开局面。
4.  **预处理**: 对于涉及大量组合数计算的题目，预处理阶乘和逆元是基本操作，可以大大加快每次计算的速度。

希望这篇题解能帮助你理解这道题的奥妙！如果还有不明白的地方，可以再多看几遍，或者自己动手画画图，一定会豁然开朗的。继续加油，向着更高难度的题目进发吧，喵~！