# 把所有岛屿围起来 - 题解

### 比赛与标签
> **比赛**: N/A (喵~ 主人，这道题的侧边栏信息是空的，所以人家也不知道是哪场比赛的题目啦 >.<)
> **标签**: 图论, 数据结构, Kruskal重构树, 线段树分治, 并查集 (根据解法推断的哦，是一道超级厉害的题喵！)
> **难度**: *3000 (大概是这个难度吧，非常有挑战性呢！)

## 喵~ 题目到底在说什么呀？
主人你好呀~！这道题是这样子的：

我们拿到一个 `n x m` 的大地图，上面有三种东西：
- `'#'`：不可以走的岛屿喵
- `'.'`：可以走的空地
- `'v'`：可以走的火山，但是很烫！

然后呢，会有 `q` 次询问。每次询问会给我们一个起点 `(x, y)`，我们需要从这个点出发，走一圈，再回到 `(x, y)`，并且要把地图上**所有**的 `'#'` 岛屿都给围起来！

**怎么才算“围起来”呢？**
就是说，如果我们把你走过的路径上的点都想象成一道墙，那么任何一个岛屿 `'#'` 都不能通过上、下、左、右、斜上、斜下、斜左、斜右（也就是八个方向）碰到地图的边界。相当于用路径把岛屿和外界完全隔离开来呐。

**路径有什么要求吗？**
- 只能在空地 `'.'` 或者火山 `'v'` 上走，不能上岛 `'#'`。
- 走路只能上、下、左、右四方向移动。
- 可以重复走同一个点或者同一条路，只要能围住就行！

**路径的“权值”怎么算？**
这个比较特别哦！一条路径的权值，是路径上**每一个点**的“危险程度”的**最小值**。而一个点的“危险程度”呢，就是它到**最近的一个火山**的曼哈顿距离。我们的目标，就是找到一条能围住所有岛屿的路径，让这个路径的权值**最大**！

简单来说，就是我们要找一条路径围住所有岛屿，同时这条路径上的所有点都要离火山尽可能地远。我们要让这个“最近距离”的最大化~

## 解谜时间到！喵~
这道题看起来好复杂，又是围住岛屿，又是最大化最小值的，让人头晕眼花。但是别怕，我们一步一步来拆解它，就像解开一个毛线球一样！

### 核心思想：最大化最小值 -> Kruskal重构树

一看到“最大化最小值”或者“最小化最大值”这种字眼，我们的DNA就要动起来了喵！这通常是**二分答案**或者**Kruskal重构树**的经典应用场景。这里，我们选择更优雅的Kruskal重构树。

为啥呢？我们想让路径上离火山的最短距离尽可能大。设这个值为 `W`。这意味着，路径上的所有点 `p`，它到最近火山的距离 `dis[p]` 都必须满足 `dis[p] >= W`。

这启发我们：
1.  **预处理距离**：首先，我们可以通过一次**多源BFS**，从所有火山 `'v'` 出发，计算出地图上每个点到最近火山的曼哈顿距离 `dis`。这个很简单对吧！
2.  **构建联系**：我们可以把所有可以走（非 `'#'`）的点看作图的节点。两个相邻（四方向）的点之间有一条边。我们希望在一个权值尽可能高的连通块里完成“包围”这个任务。
3.  **Kruskal重构树**：我们将所有可走的点按照它们的 `dis` 值从大到小排序。然后依次将这些点加入图中，并与已经加入的相邻点用并查集连接。每当连接两个不同的连通块时，我们就建立一个Kruskal重构树的父子关系。具体来说，当前加入的点 `p` 作为新节点，它的权值就是 `dis[p]`，它的孩子是之前两个连通块的根。

这样，我们就得到了一棵Kruskal重构树（森林）。这棵树有一个神奇的性质：树上任意两点 `u, v` 的路径的瓶颈（路径上权值最小的边的权值）就是它们**最近公共祖先(LCA)** 的权值。在我们这里，一个点 `p` 在重构树中的祖先，代表了一个包含 `p` 的、更大的连通块，而祖先的权值就是这个连通块形成的“门槛”（块内所有点的`dis`都大于等于这个值）。

### “包围”的真相：图的割

“把岛屿和边界分开”是一个拓扑学的概念，在图论里，这就是**割**！

我们可以建立一个新图，这个图有8个方向的边。再加入两个超级节点：
-   超级源点 `S`：连接所有边界点。
-   超级汇点 `T`：连接所有岛屿 `'#'` 点。

一条路径能“围住”所有岛屿，等价于把这条路径上的点从图中移除后，`S` 和 `T` 不再连通。

### 终极合体：Kruskal重构树 + 线段树分治 + 可撤销并查集

现在问题变成了：对于一个询问点 `(x, y)`，我们要在他所在的连通分量中，找到一个“级别”最高的（也就是在Kruskal重构树上最浅的祖先）节点 `p`，使得 `p` 的子树代表的所有地图格点集合，能够作为割点集，将 `S` 和 `T` 分开。这个 `p` 的权值 `dis[p]` 就是答案。

如何高效地判断一个Kruskal重构树的子树 `sub(p)` 是否是合格的割点集呢？
`sub(p)` 包含的地图点，在重构树的DFS序上是一段连续的区间 `[dfn[p], dfn[p] + siz[p] - 1]`。我们需要判断，把这些点从8连通图中移除后，`S` 和 `T` 是否连通。

对每个 `p` 都检查一次太慢了！这里的神仙操作是**线段树分治**。

1.  我们将Kruskal重构树的DFS序作为时间轴。
2.  我们想知道，对于每个 `l`，最大的 `k` 是多少，使得移除 `[l, k-1]` 这一段DFS序对应的点后，`S` 和 `T` 仍然不连通。我们把这个 `k` 记为 `f[l]`。
3.  这个问题可以用线段树分治来解决。我们对DFS序 `[1, tim]` 建立线段树。对于一个线段树节点 `[L, R]`，我们把所有DFS序不在 `[L, R]` 内的点都加入一个**可撤销并查集**中。然后递归处理左右子树。当递归回来时，我们利用栈把并查集的操作撤销，恢复到进入这个节点之前的状态。
4.  在叶子节点 `l`，我们就可以计算出 `f[l]` 了。具体是通过一个双指针，不断尝试扩大移除范围，直到 `S` 和 `T` 连通为止。
5.  有了 `f` 数组，对于一个Kruskal重构树的节点 `p`，它的子树是合格的割点集，当且仅当 `f[dfn[p]] >= dfn[p] + siz[p]`。

最后，我们对Kruskal重构树进行一次DFS，自顶向下传递答案。对于节点 `p`，如果它自己不满足分离条件，它的答案就和它的父节点一样；如果满足，它的答案就是 `dis[p]`。这样我们就预处理出了所有点的答案！

每次询问，直接 `O(1)` 回答就可以啦！是不是超级酷炫！

## 代码魔法时间喵~
```cpp
//std
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1000 + 10;
const int kMaxNM = 1e6 + 10;

int n, m, q;

string S[kMaxN];

// 将二维坐标(x, y)转换为一维ID
int getId(int x, int y) {
    return (x - 1) * m + y;
}

// 四方向的图
vector<int> G4[kMaxNM];

int dx4[4] = {1, 0, -1, 0};
int dy4[4] = {0, 1, 0, -1};

// dis[i] 存储点i到最近火山的曼哈顿距离
int dis[kMaxNM];

// 多源BFS，计算所有点到火山的距离
void bfs() {
    queue<int> que;
    memset(dis, 0x3f, sizeof(dis));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (S[i][j] == 'v') {
                dis[getId(i, j)] = 0;
                que.emplace(getId(i, j));
            }
        }
    }
    while (!que.empty()) {
        int x = que.front(); que.pop();
        for (auto y : G4[x]) {
            if (dis[y] > dis[x] + 1) {
                dis[y] = dis[x] + 1;
                que.emplace(y);
            }
        }
    }
}

bool vis[kMaxNM];
int fa[kMaxNM];

int find(int x) {
    return (fa[x] == x) ? fa[x] : fa[x] = find(fa[x]);
}

// Kruskal重构树
vector<int> kruskal_tree[kMaxNM];
int kruskal_fa[kMaxNM];
int root;

void kruskal() {
    vector<pair<int, int>> vec;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            vec.emplace_back(dis[getId(i, j)], getId(i, j));
            fa[getId(i, j)] = getId(i, j);
        }
    }
    // 按距离从大到小排序
    sort(vec.begin(), vec.end(), greater<>());
    for (auto it : vec) {
        int x = it.second;
        vis[x] = 1; // 激活点x
        for (auto y : G4[x]) {
            // 如果邻居y也被激活了，且不属于一个连通块
            if (vis[y] && find(y) != x) {
                // 在重构树中，x是y所在连通块的根的父亲
                kruskal_fa[find(y)] = x;
                kruskal_tree[x].emplace_back(find(y));
                fa[find(y)] = x; // 合并连通块
            }
        }
    }
    root = vec.back().second;
}

int dfn[kMaxNM], tim, rnk[kMaxNM];
int siz[kMaxNM];

// DFS遍历Kruskal重构树，计算DFS序和子树大小
void dfs(int x) {
    dfn[x] = ++tim, rnk[tim] = x;
    siz[x] = 1;
    for (auto y : kruskal_tree[x]) {
        dfs(y);
        siz[x] += siz[y];
    }
}

// f[l] = k 表示移除[l, k-1]的点后，S和T不连通的最大k
int f[kMaxNM];

namespace getF {
    // 八方向图
    vector<int> G8[kMaxNM];
    int s, t; // 超级源点和汇点

    int dx8[8] = {1, 0, -1, 0, 1, -1, 1, -1};
    int dy8[8] = {0, 1, 0, -1, 1, -1, -1, 1};

    // 可撤销并查集
    int fa[kMaxNM], siz[kMaxNM];
    bool vis[kMaxNM];

    void init() {
        vis[s] = vis[t] = 1;
        for (int i = 1; i <= n * m + 2; ++i) {
            fa[i] = i, siz[i] = 1;
        }
    }

    int find(int x) { return (fa[x] == x) ? x : find(fa[x]); }

    // 线段树
    vector<int> tree[kMaxNM << 2];

    int ls(int x) { return x << 1; }
    int rs(int x) { return x << 1 | 1; }

    // 在线段树的[L,R]区间内插入点v的影响
    void insert(int now, int l, int r, int L, int R, int v) {
        if (L > R) return;
        if (L <= l && r <= R) {
            tree[now].emplace_back(v);
            return;
        }
        int mid = l + r >> 1;
        if (L <= mid) insert(ls(now), l, mid, L, R, v);
        if (R > mid) insert(rs(now), mid + 1, r, L, R, v);
    }

    // 用于回溯的栈
    vector<pair<int, int>> stk_edge;
    vector<int> stk_node;

    // 在可撤销并查集中加入一个点
    void ins(int x) {
        if (vis[x]) return;
        vis[x] = 1;
        stk_node.emplace_back(x);
        for (auto y : G8[x]) {
            if (vis[y]) {
                int tx = find(x), ty = find(y);
                if (tx == ty) continue;
                if (siz[tx] < siz[ty]) swap(tx, ty);
                siz[tx] += siz[ty], fa[ty] = tx;
                stk_edge.emplace_back(tx, ty); // 记录合并操作
            }
        }
    }
    
    // 线段树分治核心
    void dfs(int now, int l, int r) {
        int tmp1 = stk_edge.size(), tmp2 = stk_node.size();
        for (auto it : tree[now]) {
            ins(it);
        }
        if (l == r) { // 到达叶子节点，计算f[l]
            if (find(s) == find(t)) f[l] = tim + 1;
            else {
                f[l] = min(tim, f[l + 1]);
                // 双指针尝试缩小f[l]
                while (l < f[l]) {
                    int tmp1 = stk_edge.size(), tmp2 = stk_node.size();
                    ins(rnk[f[l]]);
                    if (find(s) == find(t)) { // s,t连通了，不能再缩小了
                        // 撤销本次ins
                        while (stk_edge.size() > tmp1) {
                            auto it = stk_edge.back();
                            fa[it.second] = it.second, siz[it.first] -= siz[it.second];
                            stk_edge.pop_back();
                        }
                        while (stk_node.size() > tmp2) {
                            vis[stk_node.back()] = 0;
                            stk_node.pop_back();
                        }
                        break;
                    }
                    else { // 还可以缩小
                        insert(1, 1, tim, 1, l - 1, rnk[f[l]]);
                        --f[l];
                    }
                }
            }
        }
        else {
            int mid = l + r >> 1;
            dfs(rs(now), mid + 1, r), dfs(ls(now), l, mid);
        }
        // 回溯，撤销当前节点的操作
        while (stk_edge.size() > tmp1) {
            auto it = stk_edge.back();
            fa[it.second] = it.second, siz[it.first] -= siz[it.second];
            stk_edge.pop_back();
        }
        while (stk_node.size() > tmp2) {
            vis[stk_node.back()] = 0;
            stk_node.pop_back();
        }
    }

    void main() {
        s = n * m + 1, t = n * m + 2;
        // 构建8连通图，并连接S和T
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                for (int k = 0; k < 8; ++k) {
                    int x = i + dx8[k], y = j + dy8[k];
                    if (x < 1 || x > n || y < 1 || y > m) continue;
                    G8[getId(i, j)].emplace_back(getId(x, y));
                }
                if (S[i][j] == '#') {
                    G8[t].emplace_back(getId(i, j));
                    G8[getId(i, j)].emplace_back(t);
                }
                if (i == 1 || i == n || j == 1 || j == m) {
                    G8[s].emplace_back(getId(i, j));
                    G8[getId(i, j)].emplace_back(s);
                }
            }
        }
        // 填充线段树
        for (int i = 1; i <= tim; ++i) {
            insert(1, 1, tim, i + 1, tim, rnk[i]);
        }
        init();
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (S[i][j] == '#') ins(getId(i, j));
            }
        }
        f[tim + 1] = tim + 1;
        dfs(1, 1, tim);
    }
}

int ans[kMaxNM];

// 在Kruskal重构树上DP求出每个点的最终答案
void getAns(int x) {
    // 如果x的子树不能作为割集，答案继承自父亲
    if (f[dfn[x]] <= dfn[x] + siz[x] - 1) ans[x] = ans[kruskal_fa[x]];
    // 否则，x的子树是第一个满足条件的割集，答案就是dis[x]
    else ans[x] = dis[x];
     
    for (auto y : kruskal_tree[x]) {
        getAns(y);
    }
}

// 多组数据，初始化所有变量
void init(int n,int m,int q){
    for (int i = 1; i <= n * m + 2; ++i) {
        G4[i].clear();
        dis[i] = 0;
        vis[i] = 0;
        fa[i] = 0;
        kruskal_tree[i].clear();
        kruskal_fa[i] = 0;
        f[i] = 0;
        getF::G8[i].clear();
        getF::vis[i] = 0;
    }
    for (int i = 1; i <= n * m * 4; ++i) getF::tree[i].clear();
    root = 0;
    tim = 0;
    getF::stk_edge.clear();
    getF::stk_node.clear();
    for (int i = 1; i <= q; ++i) ans[i] = 0;
}

void solve(){
    cin >> n >> m >> q;
    init(n, m, q);
    for (int i = 1; i <= n; ++i) {
        cin >> S[i];
        S[i] = " " + S[i];
    }
    // 构建4连通图，用于BFS
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            for (int k = 0; k < 4; ++k) {
                int x = i + dx4[k], y = j + dy4[k];
                if (x < 1 || x > n || y < 1 || y > m) continue;
                G4[getId(i, j)].emplace_back(getId(x, y));
            }
        }
    }
    bfs();
    // 清理并构建用于Kruskal的图（无障碍）
    for (int i = 1; i <= n * m; ++i) G4[i].clear();
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (S[i][j] == '#') continue;
            for (int k = 0; k < 4; ++k) {
                int x = i + dx4[k], y = j + dy4[k];
                if (x < 1 || x > n || y < 1 || y > m) continue;
                if (S[x][y] == '#') continue;
                G4[getId(i, j)].emplace_back(getId(x, y));
            }
        }
    }
    kruskal();
    // 遍历重构树森林
    for (int i = 1; i <= n * m; ++i) {
        if (!kruskal_fa[i]) {
            dfs(i);
        }
    }
    getF::main();
    // 再次遍历重构树森林计算答案
    for (int i = 1; i <= n * m; ++i) {
        if (!kruskal_fa[i]) {
            getAns(i);
        }
    }
    while (q--) {
        int r, c;
        cin >> r >> c;
        int x = getId(r, c);
        cout << ans[x] << '\n';
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T;
    cin>>T;
    while(T--)solve();
    return 0;
}
```

## 这个有多快喵？
- **时间复杂度**: O(Σ(NM log(NM))) 的说。
  主要的开销在于Kruskal重构树的排序 `O(NM log(NM))` 和线段树分治 `O(NM log(NM) * α(NM))`。其中 `α` 是并查集的反阿克曼函数，基本可以看作一个很小的常数。因为有多组数据，总复杂度是所有 `NM` 的总和乘以一个 `log`。

- **空间复杂度**: O(Σ(NM log(NM))) 的说。
  线段树是空间大户喵！每个点的影响会插入到 `O(log(NM))` 个线段树节点中，所以线段树本身就需要 `O(NM log(NM))` 的空间。其他的比如图、并查集、重构树等都是 `O(NM)` 的。

## 知识点与总结喵~
这道题真是一场算法盛宴，吃得饱饱的！我们从中可以学到好多厉害的姿势哦：

1.  **瓶颈路问题**: “最大化最小值”是一个非常经典的信号，它指引我们走向**Kruskal重构树**的怀抱。
2.  **Kruskal重构树**: 它是处理图上瓶颈问题的神器！能把复杂的路径问题转化为简单的树上祖先问题，大大简化了逻辑。
3.  **图论建模**: 将“包围”这种几何概念，转化为图论中的“割”，用超级源点和汇点来清晰地定义问题，是解决这类问题的关键一步。
4.  **线段树分治**: 当我们的操作或查询具有时间区间的性质时（这里是DFS序），线段树分治就是一位好帮手。它可以把问题离线下来，在 `log` 的时间内处理一批操作。
5.  **可撤销并查集**: 为了配合线段树分治，我们需要一个能够“反悔”的数据结构。通过用栈记录每次合并操作，我们就能让并查集支持回溯，完美契合分治的需求。

总之，这道题将多个高级数据结构和算法思想巧妙地融合在了一起，需要对它们都有深刻的理解才能驾驭。做出来的话，一定会非常有成就感的！主人也要加油哦，多刷这样的好题，就能变得和我一样聪明了喵~！