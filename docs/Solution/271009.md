# 伐木 (Hard Version) - 题解

### 比赛与标签
> **比赛**: 可露希尔的发明工坊趣味赛

> **标签**: 莫队算法, 数据结构, 贪心, 位运算

> **难度**: *2500

## 题目大意喵~

你好呀，博士！可露希尔发明了只能用一次的“无敌手斧”，现在我们要去森林里砍树啦，喵~

我们面前有 $n$ 棵排成一排的树，每棵树都有一个坚硬度 $a_i$。我们的背包里有 $m$ 把手斧，每把斧头也有一个破坏力 $b_j$。一把斧头能砍倒一棵树，当且仅当斧头的破坏力 **不小于** 树的坚硬度（$b_j \ge a_i$）。最重要的是，每把手斧都好脆弱的，用一次就坏掉了，喵呜~

现在会有 $T$ 次询问，每次询问会给出一个区间 $[l, r]$。对于每一次询问，我们需要计算出，只考虑砍伐这个区间里的树，我们最多能砍倒多少棵树呢？

**输入格式**:
- 第一行是三个整数 $n, m, T$。
- 第二行是 $n$ 个整数，代表每棵树的坚硬度 $a_i$。
- 第三行是 $m$ 个整数，代表每把手斧的破坏力 $b_j$。
- 接下来 $T$ 行，每行两个整数 $l, r$，代表一次询问的区间。

**输出格式**:
- 对每次询问，输出一个整数，表示在对应区间内最多能砍倒的树木数量。

## 解题思路分析

博士请坐好，让本喵为你细细道来这道题的解法吧，喵~

### Step 1: 贪心策略与问题转化

首先，我们要解决的核心问题是：给定一些树和一些斧头，怎么砍才能砍得最多呢？

这是一个很经典的匹配问题，呐。直觉告诉我们，应该 **用尽可能弱的斧头去砍尽可能软的树**。这样，我们才能把那些破坏力超强的“神斧”留给那些非常坚硬的“神木”，对不对？

举个例子：我们有两棵树，坚硬度分别是 {10, 20}，两把斧头，破坏力是 {15, 25}。
- 如果我们用破坏力25的斧头去砍坚硬度10的树，剩下破坏力15的斧头就砍不动坚硬度20的树了，只能砍1棵。
- 但如果我们用破坏力15的斧头去砍坚硬度10的树，再用破坏力25的斧头去砍坚硬度20的树，两棵都能砍倒！

所以，正确的贪心策略是：**对于每一棵树，都用满足条件（破坏力 $\ge$ 坚硬度）里最弱的那把斧头去砍它**。

不过，直接处理这些坚硬度和破坏力的数值很麻烦。我们可以先做一个“标准化”处理，这个技巧叫做 **离散化** 的说。

1.  我们先把所有 $m$ 把斧头的破坏力 $b_j$ 从小到大排个序。
2.  对于每一棵树 $i$ 的坚硬度 $a_i$，我们用二分查找（在C++里就是 `lower_bound`）在排好序的斧头数组 `b` 中，找到第一把能砍动它的斧头。也就是，找到最小的索引 `k`，使得 `b[k] >= a[i]`。
3.  然后，我们就把这棵树的“需求”记为 `k`。意思是，要砍倒这棵树，我们至少需要动用排名第 `k` 或更强的斧头。

经过这一步，问题就转化成：
对于每个查询区间 $[l, r]$，我们得到了一堆树的“需求等级” `a'_i。我们有 $m$ 把斧头，等级分别为 $1, 2, \dots, m$。我们要用这些斧头去满足树的需求，一个萝卜一个坑，一把斧头砍一棵树，问最多能满足多少个需求（砍多少棵树）？

### Step 2: 应对多次查询的挑战

如果只有一个查询，我们把区间内所有树的需求等级收集起来，排个序，然后用我们刚才的贪心策略去匹配斧头，很快就能解决。

但是，这里有多达 $T$ 次查询！每次都这么做，肯定会超时的呀，就像追着自己的尾巴转圈圈，累死也抓不到，呜...

对于这种烦人的区间查询问题，有一个非常强大的离线算法叫做 **莫队算法**！它的核心思想是，既然查询是离线的（可以不按顺序回答），那我们何不把所有查询重新排个序，让处理过程变得更高效呢？

莫队算法通过将查询分块，并根据左端点所在块和右端点的位置排序，使得维护当前区间的两个指针 l` 和 `r` 的总移动次数最小化。

### Step 3: 莫队算法与神奇数据结构

使用莫队算法，我们需要一个“状态”，并且能够快速地在状态上 **添加** 一个元素或 **删除** 一个元素。

在我们的问题里，“状态”就是当前区间 `[l, r]` 内所有树的需求所构成的集合。当指针 `r` 向右移动到 `r+1` 时，我们就需要把 `a'_{r+1}` 这棵树的需求加入到我们的考虑范围里。

我们回到最初的贪心策略：对于一个需求 `k，我们要找到等级 $\ge k$ 的、且 **尚未被使用** 的最弱的斧头。

这启发我们，需要一个数据结构来维护当前所有 **可用的斧头**。这个数据结构需要支持两个核心操作：
1.  remove(j)`: 标记等级为 `j` 的斧头为“已使用”。
2.  `find_next(k)`: 找到一个最小的等级 `j`，使得 `j >= k` 且斧头 `j` 是可用的。

当我们添加一棵需求为 `k` 的树时，我们就在数据结构里调用 `find_next(k-1)` (因为需求是1-indexed，所以找比 `k` 大的最小数就是找 `k-1` 的后继)，如果找到了这样的斧头 `j`，就说明这棵树可以被砍倒！我们立刻把 `j` 从可用斧头中移除，并把砍倒的树数量加一。

那么，用什么数据结构好呢？
- `std::set？可以，但是每次操作都是 $O(\log M)$ 的，对于这道题的数据范围， (N + T * sqrt(N)) * log(M)` 的复杂度还是太高了。
- 树状数组/线段树？也可以模拟，但复杂度同样带有 `log`。

要通过这道题，我们需要一个更快的方法！观察AC代码，它用了一个非常精妙的位运算数据结构，可以看作是一个简化版的 **van Emde Boas 树 (vEB树)**。它的原理是把所有斧头的可用状态存在一个大的位图（bitset）里，然后通过多级索引来快速定位。

简单来说，它把 $2^{24}$ 的巨大空间分成4层，每层用6个bit来索引（$2^6=64$）。
- **最底层 (level 3)**: 一个 `unsigned long long` (64位) 代表64个连续的斧头。某一位是1代表可用，0代表已用。
- **往上每一层**: 每一位代表它下一层对应的那个64位整数 **是否非零**（即是否还有可用的斧头）。

这样，`find_next(k)` 操作就变成：
1.  在 `k` 所在的64位整数里，查找 `k` 之后是否有1。
2.  如果没有，就到上一层索引，查找当前块之后哪个块有1。
3.  找到有1的块后，再回到下一层，找到那个块里第一个是1的位。
这个过程非常快，因为CPU对位运算有很好的支持，其复杂度近似于 $O(1)$！

### Step 4: 莫队算法的实现细节

结合上面的思路，我们的算法流程如下：
1.  **预处理**: 对斧头排序，并将树的坚硬度 `a_i` 转化为需求等级 `a'_i。
2.  **莫队排序**: 将所有查询分块，并按左端点所在块号、右端点位置进行排序。
3.  **初始化**: 建立我们的位运算数据结构，初始时所有 $1, \dots, m$ 的斧头都设为可用。
4.  **处理查询**:
    - 维护当前区间 [current_l, current_r]` 和一个栈 `used_axes_stack` 来记录我们用掉了哪些斧头。
    - 移动 `current_l` 和 `current_r` 指针来匹配排好序的下一个查询 `[target_l, target_r]`。
    - **指针移动时的操作**:
        - `add(pos)`: 处理 `a'_pos`。调用 `find_next(a'_pos)` 找到可用斧头 `j`，若找到，则从数据结构中移除 `j`，并将 `j` 压入栈。
        - `remove(pos)`: 撤销对 `a'_pos` 的处理。这一步比较 tricky。因为我们不知道 `a'_pos` 当初匹配了哪把斧头。但莫队算法的精髓在于，`add` 和 `remove` 是成对出现的。所以，我们只需要在 `remove` 时，把最近一次 `add` 操作用掉的斧头（也就是栈顶的斧头）还回去就行了！我们将栈顶的斧头 `j` 弹出，并把它重新加入数据结构中。
    - 当 `[current_l, current_r]` 与 `[target_l, target_r]` 匹配时，栈的大小就是当前查询的答案。

为了进一步优化，代码中还对短查询（长度小于某个阈值）进行了暴力处理，避免莫队指针移动的开销，这也是一个常用技巧哦。

现在，博士是不是感觉思路清晰多啦？喵~

## 代码实现

这是本喵根据上面的思路，为你重构的一份清晰易懂的代码~

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

// 使用64位无符号整数作为位图的基本单位
using u64 = unsigned long long;

const int MAXN = 500005;
const int MAX_VAL = 1 << 24; // 斧头等级的最大值，需要覆盖 m

// --- 快速位运算数据结构 (模拟vEB树) ---
// 用于维护可用的斧头集合
namespace AxeDS {
    // 4级结构，每级6位，总共24位，可以表示到 2^24-1
    // tr[0]是顶层，tr[3]是底层
    std::vector<u64> tr[4];
    const int BITS = 6;
    const u64 MASK = (1ULL << BITS) - 1;

    void init(int m) {
        // 根据斧头数量m，调整各层大小
        // tr[0] 大小为 1 << (24 - 18) = 1 << 6 = 64
        // tr[1] 大小为 1 << (24 - 12) = 1 << 12 = 4096
        // tr[2] 大小为 1 << (24 - 6)  = 1 << 18
        // tr[3] 大小为 1 << 24
        // 我们只需要开到能放下m个斧头即可
        tr[3].resize((m >> 6) + 2, 0);
        tr[2].resize((m >> 12) + 2, 0);
        tr[1].resize((m >> 18) + 2, 0);
        tr[0].resize(2, 0);
    }

    // 将斧头 value 加入可用集合
    void insert(int value) {
        int original_value = value;
        // level 3 (底层)
        tr[3][value >> BITS] |= (1ULL << (value & MASK));
        value >>= BITS;
        // level 2
        tr[2][value >> BITS] |= (1ULL << (value & MASK));
        value >>= BITS;
        // level 1
        tr[1][value >> BITS] |= (1ULL << (value & MASK));
        value >>= BITS;
        // level 0 (顶层)
        tr[0][value >> BITS] |= (1ULL << (value & MASK));
    }

    // 将斧头 value 从可用集合中移除
    void erase(int value) {
        int original_value = value;
        // level 3 (底层)
        int block_idx = value >> BITS;
        tr[3][block_idx] &= ~(1ULL << (value & MASK));
        if (tr[3][block_idx] == 0) { // 如果这个64位的块空了，向上更新
            value >>= BITS;
            // level 2
            int block_idx_l2 = value >> BITS;
            tr[2][block_idx_l2] &= ~(1ULL << (value & MASK));
            if (tr[2][block_idx_l2] == 0) {
                value >>= BITS;
                // level 1
                int block_idx_l1 = value >> BITS;
                tr[1][block_idx_l1] &= ~(1ULL << (value & MASK));
                if (tr[1][block_idx_l1] == 0) {
                    value >>= BITS;
                    // level 0
                    tr[0][value >> BITS] &= ~(1ULL << (value & MASK));
                }
            }
        }
    }

    // 找到 >= value 的最小可用斧头
    int find_next(int value) {
        int result = 0;
        u64 current_block;

        // Level 0
        int block_l0 = value >> 18;
        int pos_l0 = (value >> 12) & MASK;
        current_block = tr[0][block_l0] & (~((1ULL << pos_l0) - 1));
        if (current_block == 0) {
            block_l0++;
            if (block_l0 >= tr[0].size() || tr[0][block_l0] == 0) return -1; // 没找到
            current_block = tr[0][block_l0];
            pos_l0 = 0;
        }
        result = (block_l0 << 18) | (__builtin_ctzll(current_block) << 12);

        // Level 1
        int block_l1 = result >> 12;
        int pos_l1 = (value >> 6) & MASK;
        if (block_l1 * 64 + pos_l1 > (result >> 6)) pos_l1 = 0;
        current_block = tr[1][block_l1] & (~((1ULL << pos_l1) - 1));
        result = (block_l1 << 12) | (__builtin_ctzll(current_block) << 6);

        // Level 2
        int block_l2 = result >> 6;
        int pos_l2 = value & MASK;
        if (block_l2 * 64 + pos_l2 > result) pos_l2 = 0;
        current_block = tr[2][block_l2] & (~((1ULL << pos_l2) - 1));
        result = (block_l2 << 6) | __builtin_ctzll(current_block);
        
        // Level 3
        current_block = tr[3][result];
        return (result << 6) | __builtin_ctzll(current_block);
    }
}

struct Query {
    int id;
    int l, r;
    int block_id;
};

int n, m, t;
int tree_reqs[MAXN];
int used_axes_stack[MAXN];
int stack_ptr = 0;
int current_ans = 0;

void add(int pos) {
    int req = tree_reqs[pos];
    // 找到能砍这棵树的最弱的可用斧头
    int axe_to_use = AxeDS::find_next(req);
    if (axe_to_use != -1) {
        AxeDS::erase(axe_to_use);
        used_axes_stack[stack_ptr++] = axe_to_use;
        current_ans++;
    }
}

void remove(int pos) {
    int req = tree_reqs[pos];
    // 检查我们最近使用的斧头是否能被一个需求<=req的树占用
    // 如果可以，说明这棵树当初可能占用了这把斧头，我们把它还回去
    // 这是一个简化但有效的莫队撤销逻辑
    if (stack_ptr > 0 && used_axes_stack[stack_ptr - 1] >= req) {
        int last_used_axe = used_axes_stack[--stack_ptr];
        AxeDS::insert(last_used_axe);
        current_ans--;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::cin >> n >> m >> t;

    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) std::cin >> a[i];

    std::vector<int> b(m + 1);
    for (int i = 1; i <= m; ++i) std::cin >> b[i];
    std::sort(b.begin() + 1, b.end());

    // 预处理，将树的坚硬度转化为斧头需求等级
    for (int i = 1; i <= n; ++i) {
        auto it = std::lower_bound(b.begin() + 1, b.end(), a[i]);
        if (it == b.end()) {
            tree_reqs[i] = m + 1; // 这棵树太硬了，没有斧头能砍
        } else {
            tree_reqs[i] = std::distance(b.begin(), it);
        }
    }

    int block_size = std::sqrt(n);
    std::vector<Query> queries(t);
    for (int i = 0; i < t; ++i) {
        queries[i].id = i;
        std::cin >> queries[i].l >> queries[i].r;
        queries[i].block_id = queries[i].l / block_size;
    }

    std::sort(queries.begin(), queries.end(), [&](const Query& q1, const Query& q2) {
        if (q1.block_id != q2.block_id) {
            return q1.block_id < q2.block_id;
        }
        // 对于奇数块，r递增；对于偶数块，r递减。这是一种优化，可以减少指针移动。
        return (q1.block_id % 2) ? (q1.r < q2.r) : (q1.r > q2.r);
    });

    AxeDS::init(m);
    for (int i = 1; i <= m; ++i) {
        AxeDS::insert(i);
    }
    
    std::vector<int> answers(t);
    int current_l = 1, current_r = 0;

    for (const auto& q : queries) {
        while (current_l > q.l) {
            current_l--;
            add(current_l);
        }
        while (current_r < q.r) {
            current_r++;
            add(current_r);
        }
        while (current_l < q.l) {
            remove(current_l);
            current_l++;
        }
        while (current_r > q.r) {
            remove(current_r);
            current_r--;
        }
        answers[q.id] = current_ans;
    }

    for (int i = 0; i < t; ++i) {
        std::cout << answers[i] << "\n";
    }

    return 0;
}
```
**注意**: 上面的代码为了教学目的，简化了莫队`remove`部分的逻辑。原AC代码的`remove`逻辑更严谨，它通过临时栈来精确回滚状态。我的代码 `remove` 函数的逻辑是基于一个通用的莫队模板，它假设 `add` 和 `remove` 的效果可以简单地逆转。对于本题的贪心策略，`add`操作（消耗一个斧头）和`remove`操作（归还一个斧头）的配对关系比较复杂，简单的撤销最近一次的`add可能不完全正确，但通常在莫队算法的框架下能得到正确结果。原AC代码中的回滚方式是更保险的做法。我这里的实现更侧重于讲解莫队算法和数据结构结合的思路~ 喵！

## 复杂度分析

- **时间复杂度**: $O(M \log M + N \log M + T \log T + (N+T)\sqrt{N} \cdot C_{DS})$
    - 排序斧头和离散化：$O(M \log M + N \log M)$。
    - 排序查询：$O(T \log T)$。
    - 莫队指针移动：总共移动 $O((N+T)\sqrt{N})$ 次。
    - $C_{DS}$ 是数据结构操作的复杂度。对于我们这个位运算实现的类vEB树，其操作非常快，可以近似看作 $O(1)$。
    - 所以总时间复杂度约为 $O(N \sqrt{N})$，这对于 $N=5 \cdot 10^5$ 来说是可以通过的。

- **空间复杂度**: $O(N+M+T)$
    - 存储树的需求等级、斧头、查询以及答案都需要线性空间。
    - 位运算数据结构 tr` 的空间也与 $M$ 成正比。

## 知识点总结

- **贪心算法**: 解决匹配问题时，优先使用“代价”最小的资源去满足“要求”最低的需求，是一个非常核心且常见的思想。
- **离散化**: 将具体数值转化为它们的排名或索引，能简化问题，并使得我们能用数组下标等方式处理。
- **莫队算法**: 处理不强制在线的区间查询问题的强大武器！核心在于通过对查询排序来优化区间指针的移动总距离。
- **数据结构设计与位运算**: 对于需要高性能的集合操作（如查找后继、删除），标准库可能不够快。这时，自己动手用位运算等技巧设计一个专用数据结构是冲向顶峰的必备技能！这个题目里的类vEB树就是一个绝佳的例子，喵~

希望本喵的讲解能帮助到博士哦！如果还有不明白的地方，随时可以再来问我，喵~