# 今天又是无聊的一天... - 题解

### 比赛与标签
> **比赛**: N/A

> **标签**: N/A

> **难度**: N/A

(喵~ 看起来这道题没有被分配到特定的比赛和标签呢，不过没关系，解题的乐趣本身就是最棒的奖励啦！)

## 题目大意喵~

主人，这道题是关于一个超级文本编辑器的说！想象一下，我们有一个只用来写数字的编辑器，还有一个闪烁的光标。小灰灰会进行 $q$ 次操作，小蓝会提出 $m$ 次询问，这些操作和询问是混合在一起的哦。

具体的操作有这几种：

1.  **`I x` (Insert)**: 在光标当前位置插入一个数字字符 `x`，然后光标移动到 `x` 的后面。
2.  **`D` (Delete)**: 删除光标前面的那个数字。题目保证光标前一定有数字，所以不用担心删空啦。
3.  **`F` (Forward/Move Left)**: 光标向前移动一个位置（也就是移动到前一个数字的后面）。题目也保证了光标前面有数字可供移动。
4.  **`B` (Backward/Move Right)**: 光标向后移动一个位置（移动到后一个数字的后面）。同样，保证了光标后面有数字。
5.  **`Q pos len` (Query)**: 这是小蓝的提问！她想知道，从文本的第 `pos` 个数字开始，连续 `len` 个数字组成的那个大整数，对 998244353 取模的结果是多少。

我们的任务就是正确地响应所有的操作和询问，喵~

## 解题思路分析

这道题的核心是在一个动态变化的序列上，频繁地进行插入、删除，并且还要快速地查询一个子区间的“数值”。

一开始，我们可能会想到用一个简单的数组或者 `std::vector` 来模拟这个文本串，对吧？

*   **插入 (Insert)**: `vector.insert()`，时间复杂度是 $O(N)$，因为要移动后面的所有元素。
*   **删除 (Delete)**: `vector.erase()`，时间复杂度也是 $O(N)$，同样需要移动元素。
*   **查询 (Query)**: 遍历指定区间的数字，一边乘10一边加，时间复杂度是 $O(len)$。

当操作次数非常多的时候，$O(N)$ 的插入和删除会让我们的程序慢得像在打瞌睡，肯定会超时的说。所以，我们需要一个更高效的数据结构，喵！

什么数据结构既能快速插入删除，又能快速定位和查询呢？我的猫猫直觉告诉我，这一定是 **平衡二叉搜索树 (Balanced Binary Search Tree, BBST)** 的舞台！

不过，普通的 BBST 是按照节点的值来排序的，比如 `std::set` 或者 `std::map`。但在这里，我们关心的是数字在文本中的 **位置**，而不是它们的大小。所以，我们需要一种特殊的 BBST——**文艺平衡树**，或者说，用平衡树来维护一个序列。Splay Tree (伸展树) 就是实现这个功能的绝佳选择，因为它实现起来相对简单，而且功能强大，喵~

#### 用 Splay Tree 维护序列

我们可以让 Splay Tree 的 **中序遍历** 结果恰好就是我们编辑的数字序列。树中的每个节点代表序列中的一个数字。

为了能够快速找到第 $k$ 个位置，我们需要在每个节点上维护一个额外的信息：`size`，表示以该节点为根的子树中包含的节点总数。

*   **查找第 k 个元素**: 从根节点开始，看它左子树的大小 `left_size`。
    *   如果 $k < left\_size$，就去左子树里找第 $k$ 个。
    *   如果 $k == left\_size$，根节点就是我们要找的！
    *   如果 $k > left\_size$，就去右子树里找第 $k - left\_size - 1$ 个。
    这个过程每次都能把问题规模减半（差不多），所以是 $O(\log N)$ 的。

#### 处理区间查询：哈希大法！

现在最关键的问题来了：如何快速计算一个子序列组成的数字呢？比如查询 `pos=3, len=5`，就是要看第3到第7个数字组成的数。暴力计算太慢了。

这里就要请出我们的好朋友——**字符串哈希** 啦！我们可以用一个基数（比如10，因为我们处理的是数字）和一个模数（题目给了 998244353）来给任意一段序列一个唯一的（几乎啦）哈希值。

一个数字串 $S = d_1d_2...d_k$ 的值可以表示为 $\sum_{i=1}^{k} d_i \cdot 10^{k-i}$。这本身就是一种哈希形式！

我们可以让 Splay Tree 的每个节点，除了维护 `size`，再维护一个 `hash` 值，表示 **以它为根的子树所代表的子序列的哈希值**。

假设一个节点 `p`，它的值为 `p->val`，左孩子是 `L`，右孩子是 `R`。那么 `p` 这棵子树对应的序列就是 `(L的序列) + p->val + (R的序列)`。它的哈希值怎么计算呢？

$$
\text{hash}(p) = (\text{hash}(L) \cdot 10^{\text{size}(R) + 1} + \text{p->val} \cdot 10^{\text{size}(R)} + \text{hash}(R)) \pmod{M}
$$

这里 `size(R)` 是右子树的大小。这个公式的意义是：
1.  把左子树的哈希值 `hash(L)` "抬高" `size(R) + 1` 位（因为它后面跟了 `p` 节点和整个右子树）。
2.  加上 `p` 节点的值 `p->val`，它需要被 "抬高" `size(R)` 位。
3.  最后加上右子树的哈希值 `hash(R)`。

每次对树进行旋转或者更新孩子节点后，我们都用这个公式从下到上更新 `size` 和 `hash` 值。因为树是平衡的，所以每次操作只会影响 $O(\log N)$ 个节点。

#### Splay Tree 的核心操作：Split 和 Merge

Splay Tree 最美妙的地方在于它能轻松实现 `split` (分裂) 和 `merge` (合并) 操作。

*   **`split(k)`**: 将序列在第 $k$ 个位置切开，分成 `[1, k-1]` 和 `[k, N]` 两部分，并得到两棵 Splay Tree。
*   **`merge(T1, T2)`**: 将两棵树 `T1` 和 `T2` 合并成一棵（前提是 `T1` 的所有元素都在 `T2` 之前）。

有了这两个神器，我们的编辑器操作就变得超级简单了，喵~

*   **插入 `x` 到光标 `k`**:
    1.  `split` 树在位置 `k`，得到 `LeftTree` 和 `RightTree`。
    2.  创建一个只包含 `x` 的新节点 `NewNode`。
    3.  `merge(merge(LeftTree, NewNode), RightTree)`。搞定！
*   **删除光标 `k-1` 位置的字符**:
    1.  `split` 树在位置 `k`，得到 `LeftTree` 和 `RightTree`。
    2.  `split` `LeftTree` 在位置 `k-1`，得到 `FinalLeftTree` 和 `NodeToDelete`。
    3.  `merge(FinalLeftTree, RightTree)`。那个被孤立的 `NodeToDelete` 就被丢掉啦。
*   **查询 `pos` 开始长度为 `len` 的子串**:
    1.  `split` 树在位置 `pos + len`，得到 `LeftAndMidTree` 和 `RightTree`。
    2.  `split` `LeftAndMidTree` 在位置 `pos`，得到 `LeftTree` 和 `MidTree`。
    3.  `MidTree` 的根节点的 `hash` 值就是我们想要的答案！
    4.  最后，别忘了把树按 `merge(merge(LeftTree, MidTree), RightTree)` 的顺序合并回去，恢复原状。

好啦！思路就是这样，用一个维护了 `size` 和 `hash` 的 Splay Tree，一切问题都迎刃而解了！接下来就看本喵如何把它实现出来吧，喵呜~

## 代码实现

这是本喵根据上面的思路，精心重构的一份代码哦！注释超详细的，希望能帮到你，喵~

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

const int MOD = 998244353;
const int MAX_OPS = 400005; // q + m 的最大值

// 预处理10的幂，避免重复计算
long long powerOf10[MAX_OPS];

void precompute_powers() {
    powerOf10[0] = 1;
    for (int i = 1; i < MAX_OPS; ++i) {
        powerOf10[i] = (powerOf10[i - 1] * 10) % MOD;
    }
}

// Splay Tree 的节点定义
struct Node {
    Node *parent;
    Node *child[2]; // child[0] 是左孩子, child[1] 是右孩子
    int value;      // 节点存储的数字
    int size;       // 子树大小
    long long hash; // 子树哈希值

    Node(int v, Node* p = nullptr) : parent(p), value(v), size(1), hash(v) {
        child[0] = child[1] = nullptr;
    }
};

class SplayTree {
private:
    Node* root;

    // 更新节点信息（size 和 hash）
    void push_up(Node* x) {
        if (!x) return;
        x->size = 1;
        x->hash = x->value;

        int left_size = 0, right_size = 0;
        long long left_hash = 0, right_hash = 0;

        if (x->child[0]) {
            left_size = x->child[0]->size;
            left_hash = x->child[0]->hash;
            x->size += left_size;
        }
        if (x->child[1]) {
            right_size = x->child[1]->size;
            right_hash = x->child[1]->hash;
            x->size += right_size;
        }
        
        // hash(p) = (hash(L) * 10^(size(R)+1) + val(p) * 10^size(R) + hash(R))
        x->hash = (left_hash * powerOf10[right_size + 1]) % MOD;
        x->hash = (x->hash + (long long)x->value * powerOf10[right_size]) % MOD;
        x->hash = (x->hash + right_hash) % MOD;
    }

    // 旋转操作
    void rotate(Node* x) {
        Node* p = x->parent;
        Node* g = p->parent;
        int d = (x == p->child[1]); // x是p的哪个孩子 (0或1)

        // 更新祖父节点的链接
        if (g) g->child[g->child[1] == p] = x;
        x->parent = g;
        
        // 更新p和x的链接
        p->child[d] = x->child[d ^ 1];
        if (x->child[d ^ 1]) x->child[d ^ 1]->parent = p;
        
        x->child[d ^ 1] = p;
        p->parent = x;
        
        // 先更新p再更新x，因为p在下面
        push_up(p);
        push_up(x);
    }

    // 将节点x伸展到目标节点goal的子节点位置
    void splay(Node* x, Node* goal = nullptr) {
        while (x->parent != goal) {
            Node* p = x->parent;
            Node* g = p->parent;
            if (g != goal) {
                // 如果g, p, x在一条直线上，先转p；否则先转x
                if ((p->child[1] == x) == (g->child[1] == p)) {
                    rotate(p);
                } else {
                    rotate(x);
                }
            }
            rotate(x);
        }
        if (goal == nullptr) {
            root = x;
        }
    }

    // 找到排名为k的节点 (k从0开始)
    Node* find_by_rank(int k) {
        Node* curr = root;
        if (!curr || k < 0 || k >= curr->size) return nullptr;
        
        while (curr) {
            int left_size = (curr->child[0]) ? curr->child[0]->size : 0;
            if (k < left_size) {
                curr = curr->child[0];
            } else if (k == left_size) {
                break;
            } else {
                k -= (left_size + 1);
                curr = curr->child[1];
            }
        }
        splay(curr);
        return curr;
    }
    
public:
    SplayTree() : root(nullptr) {}
    
    int get_size() {
        return root ? root->size : 0;
    }

    void insert(int pos, int val) {
        if (pos > get_size()) pos = get_size(); // 修正光标位置
        
        Node* new_node = new Node(val);
        if (!root) {
            root = new_node;
            return;
        }

        if (pos == get_size()) { // 在末尾插入
            Node* last = find_by_rank(pos - 1);
            last->child[1] = new_node;
            new_node->parent = last;
            splay(new_node);
        } else { // 在中间或开头插入
            Node* curr = find_by_rank(pos);
            Node* prev = curr->child[0];
            curr->child[0] = nullptr;
            
            if (prev) {
                while(prev->child[1]) prev = prev->child[1];
                splay(prev, curr); // 将prev伸展到curr的左孩子位置
                prev->child[1] = new_node;
                new_node->parent = prev;
            } else {
                curr->child[0] = new_node;
                new_node->parent = curr;
            }
            splay(new_node);
        }
    }

    void erase(int pos) {
        Node* to_delete = find_by_rank(pos);
        if (!to_delete) return;
        
        splay(to_delete); // to_delete is now root
        Node* left_tree = to_delete->child[0];
        Node* right_tree = to_delete->child[1];

        if (!left_tree) {
            root = right_tree;
            if (root) root->parent = nullptr;
        } else {
            // 找到左子树的最大节点，把它splay到左子树的根
            while (left_tree->child[1]) {
                left_tree = left_tree->child[1];
            }
            splay(left_tree, to_delete);
            // 合并
            left_tree->child[1] = right_tree;
            if (right_tree) right_tree->parent = left_tree;
            root = left_tree;
            root->parent = nullptr;
            push_up(root);
        }
        delete to_delete;
    }

    long long query(int pos, int len) {
        if (pos + len > get_size()) return 0; // 非法查询
        
        // 1. 找到区间右端点 pos + len - 1，splay到根
        Node* right_end = find_by_rank(pos + len - 1);
        splay(right_end);
        
        // 2. 找到区间左端点的前一个 pos - 1, splay到根的左孩子
        Node* left_prev = nullptr;
        if (pos > 0) {
            left_prev = find_by_rank(pos - 1);
            splay(left_prev, right_end);
        }
        
        // 此时，查询区间的根节点是 right_end->child[0] (如果pos > 0)
        // 或者是 right_end 本身 (如果pos = 0)
        Node* query_root = left_prev ? left_prev->child[1] : right_end->child[0];
        if (pos == 0) query_root = right_end;

        return query_root ? query_root->hash : 0;
    }
};


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    precompute_powers();

    int q, m;
    cin >> q >> m;

    SplayTree splay_tree;
    int cursor_pos = 0;

    int total_events = q + m;
    while (total_events--) {
        char op_type;
        cin >> op_type;
        if (op_type == 'I') {
            int x;
            cin >> x;
            splay_tree.insert(cursor_pos, x);
            cursor_pos++;
        } else if (op_type == 'D') {
            splay_tree.erase(cursor_pos - 1);
            cursor_pos--;
        } else if (op_type == 'F') {
            cursor_pos--;
        } else if (op_type == 'B') {
            cursor_pos++;
        } else if (op_type == 'Q') {
            int pos, len;
            cin >> pos >> len;
            cout << splay_tree.query(pos - 1, len) << "\n";
        }
    }

    return 0;
}
```

## 复杂度分析

*   **时间复杂度**: $O((q+m) \log N)$，喵~
    Splay Tree 的所有核心操作（`insert`, `erase`, `find_by_rank`, `splay`）的均摊时间复杂度都是 $O(\log N)$，其中 $N$ 是序列的当前长度。每次编辑操作或查询都涉及到常数次 Splay Tree 操作。因此，总的时间复杂度就是操作总数乘以对数因子。

*   **空间复杂度**: $O(q)$
    我们主要的空间开销是 Splay Tree 的节点和预计算的 `powerOf10` 数组。Splay Tree 的节点数最多和插入次数一样多，也就是 $O(q)$。`powerOf10` 数组的大小是 $O(q+m)$。所以总的空间复杂度是 $O(q+m)$，考虑到 $q$ 是插入操作，所以更精确地说是 $O(q)$。

## 知识点总结

这道题真是一次愉快的冒险呢！我们用到的知识点有：

1.  **动态序列维护**: 明白了普通数组在频繁插入删除时的局限性。
2.  **Splay Tree (伸展树)**: 学会了使用 Splay Tree 来维护一个序列，它的 `splay` 操作和灵活的 `split/merge` 思想非常强大。
3.  **数据结构增强 (Augmentation)**: 在 Splay Tree 节点上，我们不仅存储了基本信息，还额外维护了 `size` 和 `hash`，这使得我们能高效处理复杂的查询。这是解决很多数据结构问题的关键思想哦！
4.  **字符串哈希**: 利用多项式哈希的思想，将一个子序列的值压缩成一个数字，从而实现 $O(\log N)$ 内的区间查询。
5.  **均摊分析**: 理解 Splay Tree 的操作虽然单次可能很慢，但长期来看，平均每次操作都很快，这就是均摊复杂度的魅力所在。

希望这篇题解能帮到你，如果还有不懂的地方，随时可以来问本喵哦！我们一起变强，喵~！