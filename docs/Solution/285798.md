# 小灰灰的文本编辑器 - 题解

### 比赛与标签
> **比赛**: [信息缺失]
> **标签**: [信息缺失]
> **难度**: [信息缺失]

## 题目大意喵~
喵~ 主人 sama，下午好呀！今天我们来帮小灰灰解决一个有趣的文本编辑器问题！(ฅ'ω'ฅ)

简单来说，我们要模拟一个特殊的文本编辑器，它里面只存放数字字符。我们需要支持这几种操作：
1.  **插入 (Insert)**: 在光标当前位置插入一个数字，光标移动到新数字后面。
2.  **删除 (Delete)**: 删除光标前的一个数字。
3.  **光标左移 (Forward)**: 光标向左移动一个位置。
4.  **光标右移 (Backward)**: 光标向右移动一个位置。

除了这些编辑操作，还有一种查询操作：
*   **查询 (Query)**: 询问从第 `pos` 个位置开始，长度为 `len` 的一段数字串，把它看作一个大整数，它对 998244353 取模的结果是多少。

这些操作和查询是混合在一起的，我们需要高效地处理它们哦！

## 解题思路大揭秘！
看到这种在序列中间频繁进行插入、删除，还要查询区间信息的问题，我们的第一反应可能就是“普通数组或链表肯定不行”！

*   用 `std::vector` 或者普通数组，插入和删除操作的时间复杂度是 O(N) 的，在大量操作下肯定会超时，喵~
*   用链表的话，虽然插入删除很快（O(1)），但是要找到第 k 个元素或者一个区间，又需要 O(N) 的时间，还是太慢了呀！

所以，我们需要一个更强大的数据结构！锵锵~ 这时候就轮到我们的**平衡二叉搜索树 (Balanced Binary Search Tree, BBST)** 登场啦！这道题的AC代码用的是 **Splay Tree (伸展树)**，它是一种非常灵活的BBST，特别适合处理这种动态序列问题。

#### 1. Splay Tree 如何表示序列？
我们可以把文本里的每一个数字都看作是树上的一个节点。通过维护树的形态，我们保证**树的中序遍历结果，就是我们当前文本的完整序列**。这样，序列的第 `k` 个元素，就对应着树里中序遍历排名为 `k` 的那个节点。

#### 2. 如何快速查询区间？—— 区间哈希！
这道题最棘手的部分就是查询了。要我们计算一个区间的数字连起来表示的大数，一个一个乘10再相加肯定来不及。所以我们用到了**字符串哈希**的魔法！

具体的哈希方式是：对于一个数字串 `S = d_1 d_2 ... d_k`，它的哈希值 `hash(S)` 定义为：
`hash(S) = (d_1 * 10^(k-1) + d_2 * 10^(k-2) + ... + d_k * 10^0) % MOD`

为了在Splay Tree上维护这个哈希值，我们在每个节点 `u` 上维护两个关键信息：
*   `size`: 以 `u` 为根的子树的大小（节点数量）。
*   `hash`: 以 `u` 为根的子树，其中序遍历构成的数字串的哈希值。

`size` 很好维护，就是 `左子树size + 右子树size + 1`。那 `hash` 值怎么更新呢？
假设节点 `u` 的值为 `val`，它的左孩子是 `L`，右孩子是 `R`。那么以 `u` 为根的子树对应的序列就是 `(L子树序列) + (u) + (R子树序列)`。
它的哈希值就可以通过 `L` 和 `R` 的哈希值组合起来：
`u->hash = (L->hash * 10^(R->size + 1) + u->val * 10^(R->size) + R->hash) % MOD`
这个公式就是我们 `update` 函数的核心啦！为了快速计算 `10` 的幂，我们可以提前预处理出来。

#### 3. 如何实现各种操作？
有了Splay Tree和区间哈希，所有操作都迎刃而解了！Splay Tree有两大核心操作：`split` (分裂) 和 `merge` (合并)。
*   **`split(k)`**: 将序列从第 `k` 个元素后切开，分成 `[1, k]` 和 `[k+1, N]` 两部分，分别构成两棵Splay Tree。
*   **`merge(L, R)`**: 将两棵Splay Tree `L` 和 `R` 合并成一棵，前提是 `L` 中的所有元素都在 `R` 之前。

基于这两个操作：
*   **插入 (Insert)**: 在 `cursor` 位置插入数字 `x`？我们先 `split(cursor)` 得到 `L` 和 `R`，然后创建一个只包含 `x` 的新节点 `node_x`，最后 `merge(merge(L, node_x), R)` 就好啦！
*   **删除 (Delete)**: 删除 `cursor-1` 位置的数字？我们用 `split` 两次，把这个数字孤立出来，形如 `split(root, cursor-1)` 得到 `L` 和 `tmp`，再 `split(tmp, 1)` 得到 `mid` 和 `R`。`mid` 就是我们要删除的节点，删掉它，然后 `merge(L, R)` 即可。
*   **查询 (Query)**: 查询 `[pos, pos+len-1]` 区间？同样是两次 `split`！先 `split(root, pos-1)` 得到 `L` 和 `tmp`，再 `split(tmp, len)` 得到 `mid` 和 `R`。`mid` 这棵树的根节点的 `hash` 值就是答案！查询完别忘了把树 `merge` 回去哦！

光标的移动只需要维护一个整数 `cursor` 就行，非常简单！这样，所有操作都可以在均摊 `O(log N)` 的时间内完成，是不是很高效呢！

## 可爱捏的代码实现
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
const int MAX_POW = 1 << 24; // 预处理10的幂次，大小要足够
vector<int> pow10(MAX_POW, 1);
 
// Splay Tree 的节点结构体，喵~
struct Node {
    int val, size, hash; // val: 节点存的数字, size: 子树大小, hash: 子树对应的哈希值
    Node *left, *right, *parent; // 左孩子、右孩子、父节点指针
    Node(int v) : val(v), size(1), hash(v), left(nullptr), right(nullptr), parent(nullptr) {}
};
 
// 提前算好10的幂，后面用起来快快的~
void precompute() {
    for (int i = 1; i < MAX_POW; ++i)
        pow10[i] = (pow10[i-1] * 10LL) % MOD;
}
 
// 更新节点信息的核心函数，哈希值和子树大小都在这里计算
void update(Node* node) {
    if (!node) return;
    int l = node->left ? node->left->size : 0;
    int r = node->right ? node->right->size : 0;
    node->size = l + 1 + r;
    int lh = node->left ? node->left->hash : 0;
    int rh = node->right ? node->right->hash : 0;
    // 哈希合并公式: hash(L) * 10^(size(R)+1) + val * 10^(size(R)) + hash(R)
    node->hash = ((1LL * lh * pow10[r + 1]) % MOD + (1LL * node->val * pow10[r]) % MOD + rh) % MOD;
}
 
// Splay Tree 的基本体操动作：旋转！
void rotate(Node* x) {
    Node* p = x->parent;
    if (!p) return;
    Node* g = p->parent;
    if (g) (g->left == p ? g->left : g->right) = x;
    x->parent = g;
    if (p->left == x) { // Zig
        p->left = x->right;
        if (x->right) x->right->parent = p;
        x->right = p;
    } else { // Zag
        p->right = x->left;
        if (x->left) x->left->parent = p;
        x->left = p;
    }
    p->parent = x;
    update(p); // 先更新孩子(p)
    update(x); // 再更新自己(x)
}
 
// 伸展操作：把节点x旋转到根
void splay(Node* x) {
    while (x->parent) {
        Node* p = x->parent;
        Node* g = p->parent;
        if (g) {
            // Zig-Zig 或 Zag-Zag vs Zig-Zag 或 Zag-Zig
            // 如果x,p,g三点一线，先转p；否则先转x
            rotate((g->left == p) == (p->left == x) ? p : x);
        }
        rotate(x);
    }
}
 
// 找到排名为k的节点（从0开始计数）并将其splay到根
Node* find(Node* root, int k) {
    Node* u = root;
    while (u) {
        int l = u->left ? u->left->size : 0;
        if (k < l) u = u->left;
        else if (k == l) break; // 找到了！
        else k -= l + 1, u = u->right;
    }
    if (u) splay(u);
    return u;
}
 
// 分裂操作：将树在第k个元素后分开
pair<Node*, Node*> split(Node* root, int k) {
    if (k == 0) return {nullptr, root};
    Node* left = find(root, k - 1); // 找到第k个元素(k-1排名)
    splay(left); // 将它转到根
    Node* right = left->right; // 它的右子树就是第二部分
    if (right) right->parent = nullptr; // 断开连接
    left->right = nullptr;
    update(left);
    return {left, right};
}
 
// 合并操作：合并两棵树
Node* merge(Node* left, Node* right) {
    if (!left) return right;
    // 找到left树中最大的元素（最右边的）
    while (left->right) left = left->right;
    splay(left); // splay到根
    left->right = right; // 将right树作为它的右孩子
    if (right) right->parent = left;
    update(left);
    return left;
}
 
// 在排名k处插入值v
Node* insert(Node* root, int k, int v) {
    auto [left, right] = split(root, k);
    Node* node = new Node(v);
    return merge(merge(left, node), right);
}
 
// 删除排名为k的节点
Node* erase(Node* root, int k) {
    auto [left, temp] = split(root, k);
    auto [mid, right] = split(temp, 1); // 把要删除的节点分离出来
    delete mid; // 释放内存
    return merge(left, right);
}
 
// 查询从l开始，长度为len的区间的哈希值
int query(Node*& root, int l, int len) {
    auto [left, rest] = split(root, l);
    auto [mid, right] = split(rest, len);
    int res = mid ? mid->hash : 0;
    // 操作完一定要合并回去，恢复树的形态！
    root = merge(merge(left, mid), right);
    return res;
}
 
int main() {
    precompute();
    Node* root = nullptr;
    int q, m, cursor = 0, len = 0; // cursor是光标位置, len是当前序列总长
    scanf("%d%d", &q, &m);
    for (int i = 0; i < q + m; ++i) {
        char op[2];
        scanf("%s", op);
        if (op[0] == 'I') {
            int x; scanf("%d", &x);
            root = insert(root, cursor, x);
            cursor++, len++;
        } else if (op[0] == 'D') {
            root = erase(root, cursor - 1);
            cursor--, len--;
        } else if (op[0] == 'F') {
            if (cursor > 0) cursor--;
        } else if (op[0] == 'B') {
            if (cursor < len) cursor++;
        } else if (op[0] == 'Q') {
            int pos, l; scanf("%d%d", &pos, &l);
            printf("%d\n", query(root, pos - 1, l)); // 题目是1-indexed，我们内部是0-indexed
        }
    }
    return 0;
}

```

## 复杂度分析喵
- **时间复杂度**: Splay Tree 的所有操作（插入、删除、查询、分裂、合并）的均摊时间复杂度都是 O(log N) 的说，其中 N 是序列的当前长度。我们总共有 `q+m` 次操作，所以总的时间复杂度是 **O((q+m) log N)** 啦，非常优秀！
- **空间复杂度**: 我们需要存储 Splay Tree 的所有节点，最坏情况下有 `q` 个节点。另外还需要一个预处理的 `pow10` 数组。所以空间复杂度是 **O(q + MAX_POW)** 的说。

## 知识点与总结
这道题真是一道非常经典的动态序列维护问题，完美地展示了 Splay Tree 的强大之处！

1.  **核心数据结构**: **Splay Tree** (或其它平衡树如Treap) 是解决此类问题的标准武器。它能把一个序列映射到树上，并高效地维护。
2.  **核心思想**: **区间哈希**与树形结构的结合。通过在树的节点上维护子树的哈希值，我们可以将对序列的区间查询转化为对子树根节点信息的查询，大大提高了效率。
3.  **关键操作**: 一定要熟练掌握 Splay Tree 的 **`split`** 和 **`merge`** 操作！它们是处理各种区间问题的利器，能让我们像切蛋糕一样轻松地处理序列的任意子段。
4.  **注意事项**: 在计算哈希值时，乘法可能会超出 `int` 的范围，记得使用 `long long` 来进行中间计算，再对 `MOD` 取模，这是一个写代码的好习惯哦！

希望这篇题解能帮助主人 sama 理解 Splay Tree 的奇妙之处！下次再遇到类似的动态序列问题，就知道该怎么秒杀它啦！加油喵~ (๑•̀ㅂ•́)و✧