# Crying 在面对错误码 404 Not Found - 题解

### 比赛与标签
> **比赛**: (2024) 蓝桥杯省赛 B 组

> **标签**: 数据结构, 主席树

> **难度**: *2500

## 题目大意喵~

主人，你好呀！这道题是说，有一个长度为 $n$ 的数组 $\pi$，它是 $0, 1, \dots, n-1$ 的一个排列，喵~

然后呢，会有 $m$ 次询问。每次询问会给你三个数字 $l, r, k$。你需要找出，在数组的子区间 $\pi_l, \pi_{l+1}, \dots, \pi_r$ 这个集合里，**没有出现**的第 $k$ 小的自然数是多少，的说。

举个例子，如果排列是 `{0, 1, 3, 5, 2, 4}`，询问是 `l=2, r=4, k=2`。
那么子区间的集合就是 `S = {π₂, π₃, π₄} = {1, 3, 5}`。
没有出现在 `S` 里的自然数从小到大是：$0, 2, 4, 6, 7, \dots$
第 1 小的是 $0$。
第 2 小的是 $2$。
所以对于这个询问，答案就是 $2$ 啦，喵~

## 解题思路分析

这道题看起来有点复杂，但别担心，跟着本猫娘的思路一步步来，很快就能抓住它的尾巴啦，喵~

#### 朴素的想法

最直接的想法就是，对于每一次询问 `(l, r, k)`，我们先把区间 `[l, r]` 的所有数都拿出来，放进一个哈希表或者布尔数组里做好标记。然后从自然数 $0$ 开始，一个一个地检查：$0$ 在不在集合里？$1$ 在不在？$2$ 在不在？... 每找到一个不在集合里的数，就把 $k$ 减一。当 $k$ 减到 $0$ 的时候，当前检查的这个数就是我们要的答案啦！

但是，这个方法太慢了，的说。如果 $n$ 和 $m$ 都很大，比如 $5 \times 10^5$，每次询问都这么找一遍，肯定会超时的。我的猫爪都得算麻了！所以我们需要更高效的办法，呐。

#### 聪明的优化：二分答案

当问题的答案具有单调性时，我们通常可以考虑二分答案。让我们来分析一下，这道题的答案有单调性吗？

假设我们猜一个答案 `ans`，我们想知道最终的正确答案是比 `ans` 大还是小。怎么判断呢？
我们可以数一数，在 $[0, ans]$ 这个范围里，有多少个数字是**没有**在给定的区间 $\pi[l \dots r]$ 中出现的。我们把这个数量记为 `missing_count`。

- 如果 `missing_count >= k`，这说明第 $k$ 个没出现的数肯定小于等于 `ans`。所以真正的答案就在 $[0, ans]$ 这个范围里。
- 如果 `missing_count < k`，这说明在 $[0, ans]$ 范围里所有没出现的数加起来也不够 $k$ 个，所以第 $k$ 个没出现的数肯定比 `ans` 大。真正的答案就在 $[ans+1, \infty)$ 这个范围里。

看，单调性这不就有了嘛！喵~

那么现在的问题就变成了：如何快速计算 `missing_count`？
missing_count = ( $[0, ans]$ 中自然数的总个数) - (在 $\pi[l \dots r]$ 中出现且小于等于 ans 的数的个数)。
$[0, ans]$ 中自然数的总个数就是 $ans+1$。
所以关键在于快速求出**“在数组的 `[l, r]` 下标范围内，值在 `[0, ans]` 范围内的元素有多少个”**。

这是一个经典的二维数点问题（一个维度是数组下标，另一个维度是数值大小）。解决这种问题，主席树（也就是可持久化线段树）就是我们的得力猫爪啦！

#### 主席树闪亮登场！

主席树是一种神奇的数据结构，它可以“记住”自己每一个历史版本。

我们可以这样做：
1.  遍历原始排列 $\pi$，从 $\pi_1$ 到 $\pi_n$。
2.  对于每个 $\pi_i$，我们都建立一棵新的权值线段树。第 $i$ 棵树是在第 $i-1$ 棵树的基础上，只更新与 $\pi_i$ 这个值相关的路径而得到的。这棵树记录了前缀 $\pi[1 \dots i]$ 中各个数值的出现次数。
3.  因为每次只修改一条路径，所以新树和旧树可以共享大量节点，空间和时间都非常高效。

建好之后，我们就可以用 `root[r]` 和 `root[l-1]` 这两个历史版本，通过作差来得到任意区间 $\pi[l \dots r]$ 的数值分布信息了！

结合二分答案和主席树，我们可以在 $O(\log N)$ 时间内完成一次 `check`，总时间复杂度是 $O(M \log N \log N)$。这已经很不错了，但本猫娘还有更妙的方法哦！

#### 终极解法：在主席树上直接二分！

我们真的需要外面套一层二分吗？其实，线段树本身就是一种二分结构！我们可以把二分答案的过程和查询主席树的过程合二为一！

想象一下我们正在主席树上从根节点向下走，来寻找第 $k$ 小的**缺失**数字。
- 当前节点代表的值域是 `[v_low, v_high]`。
- 它的左子节点代表 `[v_low, v_mid]`，右子节点代表 `[v_mid+1, v_high]`。
- 我们可以利用 root[r] 和 root[l-1] 轻松算出在 $\pi[l \dots r]$ 中，有多少个数落在了左子节点的值域 [v_low, v_mid] 内。设这个数量为 count_in_left。
- 左子节点值域 `[v_low, v_mid]` 总共有 `v_mid - v_low + 1` 个数。
- 那么，在左子节点值域中，**缺失**的数字个数就是 `missing_in_left = (v_mid - v_low + 1) - count_in_left`。

现在，我们就可以做出判断了：
- 如果 `k <= missing_in_left`，说明我们要找的第 $k$ 小的缺失数，就在左子树对应的 `[v_low, v_mid]` 这个范围里！我们继续往左子树走，继续寻找第 $k$ 小的缺失数。
- 如果 `k > missing_in_left`，说明左子树里所有缺失的数加起来都不够 $k$ 个。我们要找的数肯定在右子树。并且，在进入右子树寻找时，我们已经跨过了左子树里全部 `missing_in_left` 个缺失数，所以我们现在要找的是右子树里第 `k - missing_in_left` 小的缺失数。

这样一路走下去，当我们到达叶子节点时，那个叶子节点代表的数值就是我们的答案啦！这个方法把查询复杂度降到了 $O(M \log N)$，非常优雅，喵~

#### 一个小小的边缘情况

还有一个小细节需要注意。我们找的缺失数可能比 $n-1$ 还要大。
- 在 `[0, n-1]` 这个值域里，总共有 $n$ 个数。
- 区间 $\pi[l \dots r]$ 中有 $r-l+1$ 个数。
- 所以，在 `[0, n-1]` 中，缺失的数的总数是 $n - (r-l+1)$。
- 如果我们要找的 $k$ 大于这个数，即 $k > n - (r-l+1)$，那么答案一定大于等于 $n$。
- 大于等于 $n$ 的数一个都没有在排列 $\pi$ 中出现过。所以，我们只需要找到第 $k - (n - (r-l+1))$ 个大于等于 $n$ 的数就行啦。
- 第 $1$ 个是 $n$, 第 $2$ 个是 $n+1, \dots$
- 经过简单的推导，答案就是 $k + (r-l+1) - n + (n-1) = k + r - l$。
- 我们可以先特判这种情况，这样主席树的值域只需要处理 `[0, n-1]` 就够了。

好啦，思路都理清了，接下来就让我们用代码来实现吧！

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <numeric>

// 为了让代码更清晰，定义一些类型别名，喵~
using ll = long long;

const int MAXN = 500005;

// 主席树的节点信息
struct Node {
    int left_child = 0;  // 左子节点的ID
    int right_child = 0; // 右子节点的ID
    int count = 0;       // 这个节点代表的区间内有多少个数
};

// 全局变量区
int n, m;
int pi[MAXN];          // 存放输入的排列
int roots[MAXN];       // 存放每个历史版本的树根ID
Node tree[MAXN * 22];  // 主席树的节点池，空间要开够哦！
int node_count = 0;    // 当前已使用的节点数量

// 插入操作，构建主席树
// current_root: 新版本的树根
// prev_root:    旧版本的树根
// low, high:    当前节点代表的值域
// value:        要插入的值
void insert(int& current_root, int prev_root, int low, int high, int value) {
    // 创建一个新节点，作为当前版本的新路径上的点
    current_root = ++node_count;
    tree[current_root] = tree[prev_root]; // 复制旧版本节点信息
    tree[current_root].count++;           // 计数值+1

    // 到达叶子节点，结束递归
    if (low == high) {
        return;
    }

    int mid = low + (high - low) / 2;
    if (value <= mid) {
        // 要插入的值在左半边，递归更新左子树
        insert(tree[current_root].left_child, tree[prev_root].left_child, low, mid, value);
    } else {
        // 要插入的值在右半边，递归更新右子树
        insert(tree[current_root].right_child, tree[prev_root].right_child, mid + 1, high, value);
    }
}

// 查询操作，寻找第k小的缺失数
// root_r:       右端点r对应的树根
// root_l_minus_1: 左端点l-1对应的树根
// low, high:    当前节点代表的值域
// k:            要找的是第k小的缺失数
int find_kth_missing(int root_r, int root_l_minus_1, int low, int high, int k) {
    // 到达叶子节点，找到了答案！
    if (low == high) {
        return low;
    }

    int mid = low + (high - low) / 2;
    
    // 计算在区间 pi[l...r] 中，值落在左子树值域 [low, mid] 内的元素个数
    int count_in_left_range = tree[tree[root_r].left_child].count - tree[tree[root_l_minus_1].left_child].count;
    
    // 计算左子树值域 [low, mid] 中，应该有多少个数
    int total_possible_in_left = mid - low + 1;
    
    // 计算左子树值域中，缺失的数的个数
    int missing_in_left = total_possible_in_left - count_in_left_range;

    if (k <= missing_in_left) {
        // 第k小的缺失数在左子树，继续向左找
        return find_kth_missing(tree[root_r].left_child, tree[root_l_minus_1].left_child, low, mid, k);
    } else {
        // 第k小的缺失数在右子树，更新k的值后向右找
        return find_kth_missing(tree[root_r].right_child, tree[root_l_minus_1].right_child, mid + 1, high, k - missing_in_left);
    }
}


int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::cin >> n >> m;

    // roots[0] 是一棵空树，作为所有历史版本的起点
    roots[0] = 0;
    tree[0] = {0, 0, 0};

    for (int i = 1; i <= n; ++i) {
        std::cin >> pi[i];
        // 基于 roots[i-1] 版本，插入 pi[i]，得到新版本 roots[i]
        insert(roots[i], roots[i - 1], 0, n - 1, pi[i]);
    }

    for (int i = 0; i < m; ++i) {
        int l, r;
        ll k;
        std::cin >> l >> r >> k;

        int range_len = r - l + 1;
        // 在 [0, n-1] 中缺失的数的总数
        ll missing_count_le_n = n - range_len;

        if (k > missing_count_le_n) {
            // 特判：要找的数比 n-1 大
            // 答案是 k + (r-l+1) - n + (n-1), 化简得 k + r - l
            std::cout << k + r - l << "\n";
        } else {
            // 在主席树上寻找答案
            int ans = find_kth_missing(roots[r], roots[l - 1], 0, n - 1, k);
            std::cout << ans << "\n";
        }
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(N \log N + M \log N)$
    - 构建主席树需要遍历一次数组，每次插入操作的复杂度是 $O(\log N)$，所以建树总时间是 $O(N \log N)$，呐。
    - 每次查询，我们都在主席树上从根走到叶子，路径长度是 $O(\log N)$。总共有 $M$ 次查询，所以查询总时间是 $O(M \log N)$。
    - 两部分加起来就是 $O((N+M) \log N)$。

- **空间复杂度**: $O(N \log N)$
    - 主席树每次插入会新建 $\log N$ 个节点。总共插入 $N$ 次，所以节点总数是 $O(N \log N)$ 级别的。这就是我们主要的额外空间开销，的说。

## 知识点总结

这道题真是一次愉快的冒险呀！我们用到的主要工具有：

1.  **主席树 (可持久化线段树)**: 解决静态区间查询问题的强大工具，特别适合查询区间第k大/小、区间内值在某范围的元素个数等问题。核心思想是保留历史版本，通过版本作差来获取区间信息。
2.  **二分思想**: 虽然最终解法没有显式地写 `while(left <= right)`，但在线段树上根据子树信息决定向左还是向右走，本质上就是一种二分。这种“树上二分”的技巧非常常用和高效。
3.  **转化与特判**: 将“寻找第k小缺失数”转化为在权值线段树上的查询，并巧妙地处理了答案超出初始值域 `[0, n-1]` 的边界情况。这告诉我们，解题时要全面思考，不能放过任何一种可能性哦，喵~

希望这篇题解能帮到你！如果还有不明白的地方，随时可以再来问本猫娘哦！喵~