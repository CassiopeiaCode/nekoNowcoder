# F - Flower - 题解

### 标签与难度
> **标签**: 数学, 模运算, 博弈论, 构造, 数论

> **难度**: 1200

## 题目大意喵~

你好呀，指挥官！这道题是关于一朵有 $n$ 片花瓣的花，还有一位名叫 Yuki 的朋友，喵~

Yuki 会一轮一轮地摘花瓣：
1.  先摘 $a$ 片。
2.  再摘 $b$ 片。
一轮总共摘 $a+b$ 片。如果某一刻剩下的花瓣不够摘了，她就会把剩下的全部摘走。这个过程会一直持续到没有花瓣为止。

Yuki 有个小小的约定：
- **离开**：如果她摘下的**最后一片**花瓣，是某一轮里**先摘的那 $a$ 片**中的一片。
- **留下**：其他所有情况她都会留下。

我们的任务是，为了让 Yuki 能够**留下**，我们可以在她开始之前先帮她摘掉一些花瓣。我们摘的花瓣数量设为 $k$。但是有个限制，我们**不能把花瓣全摘完**（也就是 $k < n$）。我们需要找到能让她留下的、最小的 $k$ 值。如果无论如何都无法让她留下，就输出 "Sayonara"。

举个栗子：
- 输入: `10 2 3`
- 输出: `0`
- 解释: 花有10瓣，每轮摘 $a=2, b=3$。
  - 第一轮：摘2片，再摘3片。共摘5片，剩5片。
  - 第二轮：剩5片，先摘2片，剩3片。再摘3片，正好摘完。
  - 最后一片是在摘那3片（$b$组）的时候摘的，所以 Yuki 会留下。我们什么都不用做，所以答案是 `0`。

## 解题思路分析

这道题看起来像一个复杂的过程模拟，但其实藏着一个非常简单的数学规律哦，喵~ 让我们一步步把它揪出来！

#### 1. 分析 Yuki 的摘花瓣行为

Yuki 的行为是周期性的。在每一轮完整的操作中，她都会摘掉 $a+b$ 片花瓣。这个 "周期" 就是解题的关键！当花瓣数量足够多时，她会一轮又一轮地摘，每轮减少 $a+b$ 片。这像不像我们在求一个数除以 $a+b$ 的余数呢？Bingo！

#### 2. “留下”与“离开”的本质

决定 Yuki 去留的，是**最后一轮**的情况。我们假设在 Yuki 开始操作时，花瓣还剩下 $n'$ 片（也就是我们摘了 $k$ 片后，$n' = n - k$）。

经过若干轮完整的操作后，剩下的花瓣数量一定是 $n' \pmod{a+b}$。我们令这个余数为 `rem`。
$$
rem = n' \pmod{a+b}
$$
这个 `rem` 就是最后一轮开始时花瓣的数量。

现在我们来分析最后一轮的情况：
*   **情况一：$1 \le rem \le a$**
    Yuki 准备先摘 $a$ 片，但发现只有 `rem` 片了。因为 `rem` 不够 $a$ 片，她会把这 `rem` 片全部摘走。游戏结束！那么最后一片花瓣，显然是她在这第一步（摘 $a$ 片）中摘走的。根据规则，Yuki 会**离开**。这是我们不希望看到的，呜...

*   **情况二：$rem > a$**
    Yuki 先摘走了 $a$ 片，此时还剩下 $rem - a$ 片。然后她准备再摘 $b$ 片，但发现只剩下 $rem - a$ 片了，于是她把这些剩下的也全摘走了。游戏结束！最后一片花瓣是在第二步（摘 $b$ 片）中摘走的。根据规则，Yuki 会**留下**。耶！

*   **情况三：$rem = 0$**
    这说明 $n'$ 正好是 $a+b$ 的整数倍。最后一轮完整地摘走了 $a+b$ 片花瓣。先摘了 $a$ 片，再摘了 $b$ 片。那么最后一片花瓣是在摘 $b$ 片时摘走的。所以 Yuki 也会**留下**，喵~

**总结一下**：
- 如果最后一轮开始时花瓣数 `rem` 满足 $1 \le rem \le a$，Yuki **离开**。
- 如果 `rem` 满足 $rem = 0$ 或 $rem > a$，Yuki **留下**。

#### 3. 我们的策略：寻找最小的 $k$

我们的目标是找到一个最小的非负整数 $k$ ($k < n$)，使得 $n' = n - k$ 满足“留下”的条件。也就是 `(n - k) % (a + b)` 的结果要么是 0，要么大于 $a$。

我们先看看什么都不做（即 $k=0$）会发生什么：
1.  计算初始的余数 $r = n \pmod{a+b}$。
2.  如果 $r=0$ 或者 $r > a$，太棒了！Yuki 本来就会留下，我们什么都不用做。最小的 $k$ 就是 `0`。
3.  如果 $1 \le r \le a$，坏了，Yuki 会离开！我们必须出手相助，摘掉一些花瓣。

当我们必须摘花瓣时（即初始状态是 $1 \le r \le a$），我们希望摘掉最少的 $k$ 片。我们摘掉 $k$ 片后，新的花瓣数是 $n-k$，新的余数是 $(n-k) \pmod{a+b}$。我们希望这个新余数是“留下”状态。

当前余数是 $r$。我们最少需要摘掉多少片，才能让余数变成 0 或者大于 $a$ 呢？
- **目标：让新余数等于 0。**
  当前的余数是 $r$，要让余数变成 0，最直接的方法就是把这多出来的 $r$ 片摘掉。也就是说，我们取 $k=r$。这样新的花瓣数是 $n-r$，它除以 $a+b$ 的余数正好是 0。这是一个“留下”的状态，而且我们只摘了 $r$ 片，这看起来就是最少的代价了，对吧？
- **目标：让新余数大于 a。**
  要从一个小于等于 $a$ 的余数 $r$ 变成一个大于 $a$ 的余数，我们需要摘掉更多的花瓣，让它“绕一圈”回到 $a+b-1, a+b-2, \dots$ 这些值，这需要的 $k$ 肯定比 $r$ 大得多。

所以，当初始状态是“离开”时，我们最少需要摘掉 $r$ 片花瓣，让余数归零，从而使 Yuki 留下。

#### 4. 特殊情况：一开始就没救了

别忘了，题目有个前提：我们不能把花瓣全摘完。还有一个隐含的条件，如果一开始花瓣总数 $n$ 就小于等于 $a$ 呢？
如果 $n \le a$，Yuki 在第一轮的第一步就会把所有 $n$ 片花瓣都摘走。她必然会离开。我们能做的只有摘掉 $k$ 片（$k < n$），剩下 $n-k$ 片。但 $n-k$ 依然小于 $a$，Yuki 还是会一次性摘完并离开。所以，这种情况下我们无能为力，只能伤心地说 "Sayonara"。

#### 最终算法总结

1.  如果 $n \le a$，我们无能为力。输出 "Sayonara"。
2.  否则，计算 $r = n \pmod{a+b}$。
3.  如果 $r=0$ 或者 $r > a$，Yuki 本来就会留下。我们无需操作。输出 `0`。
4.  如果 $1 \le r \le a$，Yuki 本来会离开。我们必须摘掉 $r$ 片花瓣来改变结局。输出 `r`。

这个逻辑非常清晰，而且只需要几次简单的算术运算，效率超高呢，喵~

## 代码实现

这是我根据上面的思路，精心为你准备的代码哦~

```cpp
#include <iostream>

// 为了处理多组测试用例，我们把核心逻辑封装在一个函数里，喵~
void solve() {
    long long n, a, b;
    std::cin >> n >> a >> b;

    // 情况1: 初始花瓣数不足 a，Yuki 必定在第一步就摘完所有花瓣。
    // 此时她一定会离开，我们无能为力，因为不能摘光所有花瓣。
    if (n <= a) {
        std::cout << "Sayonara\n";
        return;
    }

    // 计算一轮操作的总摘花瓣数
    long long cycle_len = a + b;
    
    // 计算如果不干预，最后一轮会剩下多少花瓣
    long long remainder = n % cycle_len;

    // 情况2: 最后一轮的花瓣数会让 Yuki 留下
    // rem = 0: 正好在上一轮的 b 部分摘完
    // rem > a: 在这一轮的 b 部分摘完
    if (remainder == 0 || remainder > a) {
        // 我们什么都不用做，Yuki 就会留下，最小代价是 0
        std::cout << 0 << "\n";
    } else {
        // 情况3: 最后一轮的花瓣数在 [1, a] 之间，会让 Yuki 离开
        // 我们需要摘掉 remainder 片花瓣，使得新的总数是 cycle_len 的倍数，
        // 这样新余数就变成 0，Yuki 就会留下了。这是最小的代价。
        std::cout << remainder << "\n";
    }
}

int main() {
    // 加速输入输出，让程序跑得像猫一样快！
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 复杂度分析

- **时间复杂度**: $O(1)$
  对于每个测试用例，我们只进行了几次基本的算术运算（取模、比较），这些操作的时间消耗是常数级别的。所以，时间复杂度是 $O(1)$ 呀，超级快！

- **空间复杂度**: $O(1)$
  我们只使用了几个变量来存储输入的 $n, a, b$ 和一些中间计算结果，没有使用任何随输入规模增长的额外数据结构。所以空间复杂度也是 $O(1)$ 呢。

## 知识点总结

这道题的核心是**模运算（Modular Arithmetic）** 的巧妙应用。通过分析问题的周期性，我们将一个看似复杂的模拟过程简化为了一个简单的余数判断问题。

关键思想：
1.  **识别周期性**：当一个操作会重复进行，并且每次都减少固定的量时，可以考虑使用模运算来分析最终状态。
2.  **状态划分**：根据余数的值，将所有可能的结果划分为几个明确的状态（“留下”或“离开”）。
3.  **构造解**：在确定了不利状态后，思考如何以最小的代价将其转变为有利状态。在这里，就是通过减去余数本身来达到目标。

希望我的题解对你有帮助哦！如果还有不明白的地方，随时可以再来问我，喵~ >w<