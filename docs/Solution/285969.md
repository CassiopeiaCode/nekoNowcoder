# 团 - 题解

### 比赛与标签
> **比赛**: [比赛信息未提供喵~]
> **标签**: 并查集, 根号分治, 图论 (根据代码和题目分析得出的说~)
> **难度**: *2800 (这是一个很有挑战性的题目呐！)

## 喵喵的题目解读
主人你好喵~ 欢迎来到这道关于图和颜色变化的有趣问题！

是这样的说：我们拿到了一张有 `n` 个点和 `m` 条边的无向图。每个点都有自己的颜色。

题目里定义了一个很关键的概念叫做【团】。如果两个点 `a` 和 `b` 颜色相同，并且能通过一条只经过和它们颜色相同的点的路径互相到达，那它们就属于同一个【团】。简单来说，一个【团】就是一个颜色相同的连通块啦！喵~

接下来会有 `q` 次操作。每次操作会给出一个点 `x` 和一个新颜色 `c`。我们需要做的是：
1.  找到点 `x` 所在的整个【团】。
2.  把这个【团】里所有点的颜色都改成 `c`。
3.  在每次操作之后，都要告诉小蓝，现在图里总共有多少个【团】。

我们的任务就是帮助小蓝完成这个挑战！

## 核心思路大揭秘！
看到“连通块”、“合并”这些字眼，我们的第一反应当然是可爱的**并查集**啦！喵~ 我们可以用并查集来维护每一个【团】，每个集合的根节点代表一个团。初始时有 `n` 个团，每次合并两个团，总数就减一。

但是，这道题的挑战在于**动态的颜色修改**。当一个团的颜色改变后，它可能会和旁边同样颜色的其他团合并。比如，一个红色的团A和一个蓝色的团B挨着，当团A的颜色也变成蓝色后，如果A和B之间有边相连，它们就需要合并成一个更大的蓝色团。

如果我们用最朴素的方法，每次修改一个团的颜色时，就遍历这个团里的所有点，再检查这些点的所有邻居，看看有没有可以合并的新团。但是呀，如果一个团非常非常大，或者一个点的度数非常大，每次都这么暴力遍历一遍，肯定会超时的说！QAQ

为了解决这个瓶颈，我们引入一个超级帅气的技巧——**根号分治**！喵~

这个思想的核心是“区别对待”。我们把图里的点分成两类：
1.  **小点**：邻居数量（度数）小于某个阈值 `M` 的点。
2.  **大点**：邻居数量（度数）大于或等于 `M` 的点。

通常我们取 `M = sqrt(N)` 左右来达到最好的平衡。

然后我们对这两类点采用不同的维护策略：
*   **对于小点**：它们的度数很小，暴力遍历它们的邻居完全没问题，速度很快！
*   **对于大点**：它们的度数太大了，不能暴力。所以我们需要为它们建立一些“VIP”数据结构，用空间换时间，来加速操作。

**具体实现细节 (喵~ 这是最关键的部分哦！):**

1.  **并查集维护**：
    *   我们用并查集 `b[]` 数组来维护团。`finding(x)` 找到 `x` 所在团的根节点。
    *   `color[root]` 表示根节点为 `root` 的团的颜色。
    *   `ans` 记录当前团的总数。

2.  **根号分治的结构**：
    *   `va[x]`：存储点 `x` 的邻居列表。
    *   **小点**：我们认为一个团是“小”的，如果它的根节点所代表的邻居集合 `va[root]` 的大小小于阈值 `M`。
    *   **大点**：当一个团的根节点 `root` 的 `va[root]` 大小超过 `M` 时，我们就把它升级为“大点”。
        *   `id[root] = ++tot;`：给这个大点一个独一无二的ID。
        *   `vb[id[root]][c]`: 这是为大点准备的“快速通道”！它是一个链表，存储了这个大点所有颜色为 `c` 的邻居团。这样，当我们要找颜色为 `c` 的邻居时，直接访问这个链表就好，不用遍历所有邻居了！
        *   `va[root + n]`: 专门用来记录这个大点和其他大点之间的邻接关系。

3.  **合并操作 `work(x, y)`**：
    *   这是启发式合并！总是把小的集合合并到大的集合里，这样可以保证效率。
    *   **小点-小点合并**：把邻居少的点的邻居列表加到邻居多的点的列表里。
    *   **大点-大点合并**：把规模小的大点的数据（`vb`链表和`va[y+n]`）合并到规模大的大点里。
    *   **大点-小点合并**：把小点的邻居信息更新到大点的特殊数据结构中。
    *   每次成功合并，`ans--`。

4.  **修改操作 `(x, c)`**：
    *   找到 `x` 所在团的根 `root_x`。
    *   **如果 `root_x` 是小点**：遍历 `va[root_x]`，找出所有邻居中，颜色即将变成 `c` 的团，准备合并。
    *   **如果 `root_x` 是大点**：利用 `vb[id[root_x]][c]` 快速找到颜色为 `c` 的邻居团，再检查 `va[root_x + n]` 找到相邻的颜色为 `c` 的大点团，准备合并。
    *   将所有待合并的点对记录下来。
    *   更新 `color[root_x] = c`。
    *   执行所有合并操作。

总而言之，我们用并查集来维护【团】，然后用根号分治的思想，对度数大的点和度数小的点（的集合）采用不同的维护策略，从而平衡了整体的复杂度，真是太聪明了喵！

## 代码实现喵~
```cpp
// 完整的AC代码，添加详细注释解释关键逻辑
#include <bits/stdc++.h>
using namespace std;
#define _for(i, a, b) for(int i = a, IM = b; i <= IM; i ++)
#define _rep(i, a, b) for(int i = a, IM = b; i >= IM; i --)
#define endl '\n'
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define _mp(a, b) make_pair(a, b)
using pii = pair<int, int>;
 
const int N = 100009, M = 400;  // M是根号分治的阈值，用来区分大点和小点
 
int vb[100000 / M + 9][N];  // 大点的专属数据结构：vb[大点ID][颜色] = 邻居链表头
int nex[200000 * M], to[200000 * M], ft; // 链表的实现
void add(int id, int c, int x) {    // 向大点id的颜色c链表中，添加一个邻居x
    nex[++ ft] = vb[id][c];
    vb[id][c] = ft, to[ft] = x;
}
 
vector<int> va[N << 1]; // va[1..n]存普通邻接表, va[n+1..2n]存大点与大点的邻接关系
int color[N], b[N], ans;    // color[i]存i为根的团的颜色, b[]是并查集父节点数组, ans是答案
int n;
int funq, vis[N]; // funq和vis配合使用，实现O(1)清空标记数组的技巧
int id[N], tot, sz[N];  // id[i]是大点映射ID, tot是大点总数, sz[i]是大点i的规模
 
// 并查集查找（带路径压缩）
int finding(int x) {
    return b[x] == x ? x : b[x] = finding(b[x]);
}
 
// 对一个vector中的节点去重（按其并查集根节点）
void unq(vector<int> &ve) {
    ++ funq; // 更新标记版本号，避免memset
    int cnt = 0;
    for(int i = 0, p; i < ve.size(); i ++) {
        p = finding(ve[i]); // 找到节点的根
        if(vis[p] == funq) continue; // 如果这个根已经处理过，就跳过
        vis[p] = funq;  // 标记处理过
        ve[cnt ++] = p; // 加入去重后的列表
    }
    ve.resize(cnt); // 调整vector大小
}

// 当一个点的等效度数超过阈值M时，将其“升级”为大点
void build(int x) {
   if(id[x] != 0 || va[x].size() < M) return; // 已经是大点或度数不够，则返回
    id[x] = ++ tot; // 分配大点ID
    unq(va[x]); // 对其邻居列表去重
    for(int c: va[x]) add(tot, color[c], c); // 将邻居按颜色存入vb链表中
    sz[tot] = va[x].size(); // 记录规模
    for(int c: va[x]) if(id[c] != 0) // 如果邻居也是大点
            va[x + n].emplace_back(c), va[c + n].emplace_back(x); // 建立大点间连接
}

// 清理大点x的颜色c链表，移除那些颜色已经改变的邻居
void clear(int x, int c) {
    int now = vb[x][c], pre = 0;
    for(int i = vb[x][c]; i; i = nex[i]) {
        int p = to[i];  p = finding(p); // 找到邻居的最新根节点
        if(color[p] == c) { // 如果颜色仍然是c，保留
            to[now] = p, pre = now, now = nex[now];
        }
    }
    if(pre == 0) vb[x][c] = 0; // 如果链表空了
    else nex[pre] = 0; // 断开后续无效部分
}

// 合并x和y所在的团，启发式合并
void work(int x, int y) {
    x = finding(x);
    y = finding(y);
    if(x == y) return;
 
    bool is_x_big = (id[x] != 0);
    bool is_y_big = (id[y] != 0);

    // 启发式合并：总是将小的/简单的合并到大的/复杂的
    if (!is_x_big && !is_y_big) { // 两个小点
        if (va[x].size() < va[y].size()) swap(x, y);
    } else if (is_x_big && is_y_big) { // 两个大点
        if (sz[id[x]] < sz[id[y]]) swap(x, y);
    } else { // 一大一小
        if (!is_x_big) swap(x, y);
    }

    // 执行合并逻辑
    if (id[y] == 0) { // y是小点
        unq(va[y]); // 对y的邻居去重
        for (int neighbor : va[y]) {
            if (id[x] != 0) { // 如果x是大点
                add(id[x], color[neighbor], neighbor);
                sz[id[x]]++;
                if (id[neighbor] != 0) va[x + n].emplace_back(neighbor);
            } else { // 如果x也是小点
                va[x].emplace_back(neighbor);
            }
        }
        if (id[x] != 0) unq(va[x + n]); else build(x); // x可能因为合并而成为大点
    } else { // y是大点 (那么x也必须是大点)
        _for(i, 1, n) { // 遍历所有可能的颜色
            clear(id[y], i); // 清理y的链表
            for(int j = vb[id[y]][i]; j; j = nex[j]) add(id[x], i, to[j]), sz[id[x]] ++; // 合并链表
        }
        for(int c: va[y + n]) va[x + n].emplace_back(c); // 合并大点邻居
        unq(va[x + n]);
    }

    b[y] = x;   // 核心：将y合并到x
    ans --;     // 团的总数减一
}
void solved() {
    int m, q;   cin >> n >> m >> q;
    _for(i, 1, n) b[i] = i;  // 初始化并查集
    ans = n; // 初始有n个团
 
    _for(i, 1, n) cin >> color[i];
    vector<pii> vc;   // 临时存储需要合并的边
    _for(i, 1, m) {
        int x, y;   cin >> x >> y;
        va[x].emplace_back(y), va[y].emplace_back(x); // 建图
        if(color[x] == color[y]) vc.push_back(_mp(x, y)); // 初始颜色相同的点，准备合并
    }
 
    for(pii pi: vc) work(pi.first, pi.second);  // 执行初始合并
    vc.clear();

    while(q --) {
        int x, c;   cin >> x >> c;  
        x = finding(x); // 找到x所在团的根
        if(color[x] == c) { // 如果颜色没变，啥也不用做
            cout << ans << endl;
            continue;
        }

        // 找出因颜色改变而需要新合并的点对
        if(id[x] == 0) { // 如果x是小点
            unq(va[x]);
            for(int y: va[x]) if(c == color[y]) vc.push_back(_mp(x, y));
            for(int y: va[x]) if(id[y] != 0) add(id[y], c, x); // 通知邻居大点，我的颜色变了
        } else { // 如果x是大点
            clear(id[x], c); // 清理旧链表
            for(int i = vb[id[x]][c]; i; i = nex[i]) vc.push_back(_mp(x, to[i])); // 从新颜色链表找合并对象
            vb[id[x]][c] = 0; // 清空这个链表，因为之后要重新建立
            unq(va[x + n]);
            for(int y: va[x + n]) { // 通知邻居大点
                if(color[y] == c) vc.push_back(_mp(x, y));
                else add(id[y], c, x);
            }
        }
        color[x] = c; // 更新颜色
        for(pii pi: vc) work(pi.first, pi.second);  // 执行合并
        vc.clear();
        cout << ans << endl;
    }
    return ;
}
int main() {
    IOS
    solved();
    return 0;
}
```

## 复杂度分析时间！
- **时间复杂度**: O((m+q) * sqrt(n) * α(n)) 的说
  每次修改，我们或者遍历一个“小点”集合的所有邻居（等效度数最多 `M`），或者操作一个“大点”的特殊数据结构。合并两个集合的复杂度由启发式合并来保证。通过精心选择阈值 `M`（这里是 `400`，大约是 `sqrt(100000)`），我们可以平衡这两种操作的开销。总的时间复杂度大约是 `O((m+q) * sqrt(n) * α(n))`，其中 `α(n)` 是并查集操作的、几乎可以忽略不计的阿克曼反函数开销。这个复杂度足以通过本题的数据范围啦！

- **空间复杂度**: O(n+m) 的说
  我们主要存储了图的邻接表 `va`、并查集数组 `b`、颜色数组 `color` 等，这些都是 `O(n+m)` 级别的。为“大点”准备的额外信息 `vb` 和链表，其总大小也和边数 `m` 相关。所以总的空间开销主要由图的点数 `n` 和边数 `m` 决定，是 `O(n+m)` 的级别哦，喵~

## 喵喵的知识小课堂
这道题真是太棒了，融合了好几个重要的知识点呢！

1.  **核心算法**: **并查集 (Disjoint Set Union)** + **根号分治 (Square Root Decomposition)**。

2.  **并查集**: 看到动态维护连通性问题，并查集永远是我们的好朋友！记得要用上**路径压缩**和**按秩/大小合并（启发式合并）**，这是保证它近乎常数时间效率的关键喵。

3.  **根号分治**: 这是一种非常优雅的暴力思想！当一个问题中，处理不同规模的对象有不同的代价时，就可以尝试用根号分治来平衡它们。我们设定一个阈值（通常是 `sqrt(N)`），对大于和小于阈值的两种情况分别设计不同的算法，从而优化整体的最坏情况复杂度。

4.  **本题应用**: 在这道题里，我们根据一个团的等效“度数”（邻居集合大小）来划分“大团”和“小团”。对小团，我们直接暴力遍历邻居；对大团，我们花费额外空间建立预处理结构（按颜色分类的邻居链表），从而加速查询。这就是根号分治思想的完美体现呐！

5.  **实现技巧**: 代码中用 `funq` 和 `vis` 数组来实现 `O(1)` 复杂度的“清空”标记数组，是一个非常实用的小技巧，避免了每次循环都 `memset` 一个大数组，在处理多组查询时特别有效，值得大家学习喵！

希望这篇题解能帮助主人理解这道有趣的题目！继续加油哦，喵~